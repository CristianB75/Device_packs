# This file is autogenerated
comm_speed=4000000
comm_iface = True
reset_delay = 0
has_reset = True
show_output = False
log_level = 0

def onShowPropsDFP2(t):
    ide.addBooleanProperty(t,"arm.use_vtor" , "*|programoptions|programoptions.eraseb4program","Set PC and SP to VTOR","After reset, force PC and SP to the entries defined by the VTOR", False)
    ide.addTextProperty(t,"arm.vtor_adr" , "*|programoptions|programoptions.eraseb4program","VTOR table or numerical address", "Enter address of vector table", "exception_table")
    ide.addPropCategory(t,"diagnostics" , "*|programoptions", "Diagnostics")
    ide.addBooleanProperty(t,"script.show_output" , "*|diagnostics|*","Output diagnostic logging","Show diagnostic text in the Output window", False)
    ide.addTextProperty(t,"script.log_level" , "*|diagnostics|*","Diagnostic log level","Set diagnostic level (usually 0 1 or 3)", "1")
    ide.addTextProperty(t,"script.reset_delay" , "*|diagnostics|*","Additional delay after reset","Enter additional RST settling delay in msec", "0")
    ide.addBooleanProperty(t,"script.has_reset" , "*|diagnostics|*","Uncheck if RESET line is not wired","Normally checked. Uncheck if the target does not have RST connected to the debugger", True)

def _begin_communication_session():    
    global comm_iface, comm_speed,_stealth_runstate, erase_as_needed 
    global log_level,show_output,reset_delay, target_was_reset, has_reset
    log_level  = settings.getNumeric("script.log_level",log_level)
    show_output= settings.getBool("script.show_output",show_output)
    has_reset  = settings.getBool("script.has_reset",has_reset)
    reset_delay= settings.getNumeric("script.reset_delay",reset_delay)
    comm_iface = settings.getString("communication.interface", "swd") == "swd"
    comm_speed = settings.getNumeric("communication.frequency", comm_speed)
    _stealth_runstate = 2
    erase_as_needed = True    
    
    dev.SetApiLogging(log_level)
    log.setShowOutput(show_output)
    try:
        dev.Connect(comm_iface, comm_speed)
    except:
        dev.api.JLINKARM_OpenEx()
        dev.api.JLINK_TIFSelect(1 if comm_iface else 0)
        
def _end_communication_session(): 
    pass

def _begin_debug_session():
    dev.Connect(comm_iface, comm_speed)
    reset_target()
    
def _debug_read(mem_type, start, length, data):
    _prog_read(mem_type, start, length, data)

def _debug_write(mt, start, length, data):
    dev.Write(start, data, 0, length)

def _get_pc():
    return dev.ReadReg64(arm.PC)

def _get_reg(idx):
    return dev.ReadReg64(idx)

def _set_reg(idx,val):
    return dev.WriteReg64(idx,val)

def _mem_read(start, length, data):
    dev.Read(start, data, 0, length)

def _mem_write(start, length, data):
    dev.Write(start, data, 0, length)

def _run_target():
    dev.GoEx(1, 1)

def _halt_target():
    dev.Halt()

def _step_target():
    dev.Step()

def _set_pc(pc):
    dev.WriteReg64(arm.PC, pc)

def _reset_target():
    reset_and_halt()

def reset_and_halt():
    dev.Reset()

g_stopped = False
def _is_target_running():
    global g_stopped

    stopped = dev.IsHalted()
    if stopped != g_stopped:
        log.info("Debug: target has halted" if stopped else "Debug: target is now running")
        g_stopped = stopped
    return 0  == g_stopped

def _end_debug_session(): 
    run_target()
    dev.Disconnect()

def _release_from_reset():
    global target_was_reset,reset_delay
    global has_reset
    if target_was_reset:
        return
    if not has_reset:
        log.info("Prog: Release from reset (soft reset)")
        dev.Connect(comm_iface, comm_speed)
        reset_and_halt()
        run_target()
        return

    log.info("Prog: Release from reset (float reset line)")
    disconnect_on_exit = False
    # toggle reset line
    try:
        dev.SetInterface(dev.SWD if comm_iface else dev.JTAG)
    except:
        disconnect_on_exit = True
        dev.Connect(comm_iface, comm_speed)
    dev.Pins(0, dev.RESET, 1000)
    dev.Delay(reset_delay)
    dev.Pins(dev.RESET, dev.RESET, 1000)  # now float reset back
    dev.Delay(reset_delay)
    target_was_reset = True
    if disconnect_on_exit:
        dev.Disconnect() #we are done with the part

def alt_hold_in_reset(): 
    # Alternative if RESET pin is not connected to debugger
    log.info("Prog: Hold in reset , no reset line")
    dev.Connect(comm_iface, comm_speed)
    reset_and_halt()

def _hold_in_reset(): 
    global target_was_reset
    global has_reset
    if not has_reset:
        alt_hold_in_reset()
        return
    log.info("Prog: Hold in reset")
    try:
        dev.SetInterface(dev.SWD if comm_iface else dev.JTAG)
    except:
        dev.Connect(comm_iface, comm_speed)
    dev.Pins(0, dev.RESET, 1000)
    target_was_reset = True

    
def write_config(address, len, data):
    dev.Write(address,data,0,len)

def read_config(address, length, data):
    dev.Read(address, data, 0, length)

def _handle_security_flags(address, length, data): 
    pass
def _erase():
    global erase_as_needed
    dev.Halt()
    dev.api.JLINK_EraseChip()
    erase_as_needed = False # tell prog_write not to erase rows prior to write
    dev.Delay(100000)

def _post_erase_hook():
    dev.Disconnect()
    try:
        dev.Connect(comm_iface, comm_speed)
        if "RH71" in device:
            initialize_HEFC()
    except:
        log.error("Failed to connect, chip may be secured")

def _begin_programming_operation():
    pass

def _prog_write(type_of_mem, address, length, data): 
    global erase_as_needed

    if _handle_security_flags(address,length,data):
        return

    if str(type_of_mem) == "Cfg":
        write_config(address, length, data)
        return
    elif str(type_of_mem) != "Pgm":
        dev.Write(address, data, 0, length)
        return

    _flash_write(address, length, data, erase_as_needed)
    erase_as_needed = True

def reconnectAfterExtension():
    JLINK_IF_SWD_Select()
    dev.api.JLINKARM_CORESIGHT_Configure ("")
    dev.WriteReg64(arm.DP_1, 0x50000001) # pwrup ocd


def _flash_write(address, length, data, doerase):
    dev.Write(address, data, 0, length)

def _prog_read(type_of_mem, address, length, data):    
    if str(type_of_mem) == "Cfg":
        read_config(address, length, data)
        return
    dev.Read(address, data, 0, length)

def _end_of_operations():
    dev.Disconnect()

def get_sp():
    return dev.ReadReg64(arm.SP)

def set_sp(sp):
    log.info("Debug: Set sp to 0x%0x" % sp)
    dev.WriteReg64(arm.SP, sp)

def JLINK_IF_SWD_Select():
    aIn  = bytearray([255, 255, 255, 255, 255, 255, 255,0x9e,0xe7, 255, 255, 255, 255, 255, 255, 255,0xb6, 0xeD,255, 255, 255, 255, 255, 255, 255,0,0,0xa5,0, 0, 0, 0, 0]);
    aDir = bytearray([255, 255, 255, 255, 255, 255, 255,255, 255,255, 255, 255, 255, 255, 255, 255,255, 255,255, 255, 255, 255, 255, 255, 255,255, 255,0xFF, 0, 0, 0, 0, 0xF0]);
    BitPos = dev.SWD_StoreRaw(aDir, aIn, 33 * 8)
    log.info("SwdSelect")

target_was_reset = False

def begin_communication_session(): #mplab
    log.info("Begin comm session")
    _begin_communication_session()

def end_communication_session(): #mplab
    log.info("End comm session")
    _end_communication_session()

def begin_programming_operation(): #mplab
    log.info("Begin operations")
    _begin_programming_operation()

def read_device_id():#mplab
    log.info("Read device ID")
    return _read_device_id()

def erase(): #mplab
    log.info("Erase")
    _erase()

def prog_write(type_of_mem, address, length, data): #mplab
    log.info("Writing %08x bytes to address 0x%08x of %s memory" % (length, address, type_of_mem))
    _prog_write(type_of_mem, address, length, data)

def prog_read(type_of_mem, address, length, data): #mplab
    log.info("Reading %08x bytes from address 0x%08x of %s memory" % (length, address, type_of_mem))
    _prog_read(type_of_mem, address, length, data)

def end_of_operations():#mplab
    log.info("End of operations")
    _end_of_operations()

def begin_debug_session():  #mplab
    log.info("Debug: Init debug session")
    _begin_debug_session()

def debug_read(mt, start, length, data):  #mplab
    log.info("Debug: Reading %08x bytes at start address 0x%08x (%s)" % (length, start, mt))
    _debug_read(mt, start, length, data)

def debug_write(mt, start, length, data):  #mplab
    log.info("Debug: Writing %08x bytes at start address 0x%08x (%s)" % (length, start, mt))
    _debug_write(mt, start, length, data)

def set_pc(pc):  #mplab
    log.info("Debug: set pc to 0x%08x" % pc)
    _set_pc(pc)

def get_pc():  #mplab
    pc = _get_pc()
    log.info("Debug: get_pc PC=0x%08x" % pc)
    return pc

def run_target():#mplab
    log.info("Debug: run target")
    _run_target()

_stealth_runstate = 2
def halt_target():  #mplab
    global _stealth_runstate    
    log.info("Debug: halt target")
    _stealth_runstate = 2  # cancels stealth mode
    _halt_target()

def step_target():  #mplab
    log.info("Debug: stepping at pc 0x%08x" % get_pc())
    _step_target()

def reset_target(): #mplab
    log.info("Debug: reset")
    _reset_target()
    on_after_reset() # call autoload hook

def is_target_running():#mplab
    global _stealth_runstate
    if _stealth_runstate == 2:
        return _is_target_running()
    return _stealth_runstate != 0

def on_after_reset(): 
    if not settings.getBool("arm.use_vtor", False):
        return
    vtor_name  = settings.getString("arm.vtor_adr", "0")

    vtor = -1
    try:
        vtor = int(vtor_name,0)
    except:
        try:
            vtor=deb.GetSymbolAddress(vtor_name)
        except:
            log.error("Debug: failed to compute location of VTOR")
            return
    load_vtor(vtor) 
    pass

def load_vtor(adr):
    try:
        pc = dev.Read32(adr + 4)
        sp = dev.Read32(adr)
        set_pc(arm.PC,pc)
        dev.WriteReg64(arm.SP,sp)
        log.info("Setting pc=%08x and sp=%08x" % (pc, sp))
    except:
        log.error("Debug: failed to set PC and SP to contents of exception_table")

def on_program_done():
    on_after_reset()

def end_debug_session():  #mplab
    log.info("Debug: End debug session")
    _end_debug_session()

def verify_transfer(type_of_mem, address, data, length):  #mplab
    log.info("Verifying %08x bytes to address 0x%0x of %s memory" % (length, address, type_of_mem))
    if len(data) != length:
        raise Exception("The given data and length mismatch")
    d = bytearray(length)
    prog_read(type_of_mem, address, length, d)
    for i in range(length):
        if data[i] != d[i]:
            raise Exception("Verify failed, the data mismatch from read")

def blank_check():  #mplab
    log.info("Blank check")

def blank_check_mem(type_of_mem, address, length):  #mplab
    if str(type_of_mem) != "Pgm":
        return
    log.info("Blank check Memory")
    data = bytearray(length)
    prog_read(type_of_mem, address, length, data)
    for x in data:
        if x != 255:
            raise Exception("Blank check memory failed")

def hold_in_reset():  #mplab
    log.info("Hold in reset")
    _hold_in_reset()

def release_from_reset():  #mplab
    log.info("Release from reset")
    _release_from_reset()
    
def onloadDFP(ide):
    ide.addCommandWithArgs("Device actions|Set security bit", "device_action", True)
    ide.addCommandWithArgs("Device actions|Chip erase", "device_action",False)


def device_action(set_bit):
    if deb.Connected():
        r = msg.msg("Debugger is in use. Stop debugging and retry", "Busy")
        return
    deb.Connect()
    try:
        reset_extension()
        if set_bit:
            if "M4" in architecture:
                dev.Write16(0x41004004, 0xA516)
            else:
                dev.Write16(0x41004000, 0xA545)
            msg.msg("The security bit is now set","Set security bit")                
            dev.Disconnect()
        else:
            erase()
            msg.msg("Chip erase done", "Chip erase")
    except Exception, e:
        msg.msg(str(e),"Error")
        raise e
    except :
        msg.msg("Device might be locked. Perform a chip erase to remove the lock.","Error")
    finally:
        deb.Disconnect()



def reset_extension():
    global reset_delay # additional delay for reset line if needed
    global has_reset
    if not has_reset:
        return

    delay=1000  # time to  wait for analog RESET/SWCLK pins to become digitally high/low
    try:
        dev.SetInterface(dev.SWD)
    except:
        dev.Connect(comm_iface, comm_speed)
    dev.Pins(0,dev.RESET,delay)  # 1 msec with reset high 
    if reset_delay > 0:
        dev.Delay(reset_delay)
    dev.Pins(dev.RESET,dev.RESET,delay) # 1 msec with floating reset 
    if reset_delay > 0:
        dev.Delay(reset_delay)
    dev.Pins(0,dev.RESET | dev.SWCLK,delay); # 1 msec with reset and clock low 
    if reset_delay > 0:
        dev.Delay(reset_delay)
    dev.Pins(dev.RESET,dev.RESET,delay); # now float reset back
    if reset_delay > 0:
        dev.Delay(reset_delay)
    dev.Delay(10000)
    reconnectAfterExtension()

