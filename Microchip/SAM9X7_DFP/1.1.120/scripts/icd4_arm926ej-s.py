# This file is autogenerated
comm_speed=2000000
default_iface="jtag"
import math
dbgStatus_IJBIT=             0x20L
dbgStatus_ITBIT=             0x10L
dbgStatus_SYSCOMP=           0x8L
dbgStatus_IFEN=              0x4L
dbgStatus_DBGRQ=             0x2L
dbgStatus_DBGACK=            0x1L
DEVID = 0xFFFFF240

core_state = "arm"
current_pc = -1


def reset_peripherals():
    write_named_register("R8_USR",0xd3)
    dev.Write32(0xffffff84, 0x00001030)


printDebug = False     # set to True to print diagnostic info
logLevel = 0           # set to 1 to print diagnostic info

# The l_ variables are reinitialized at every debug session. They are used locally in this script and should not be overriden in autoload.py
l_use_bootstrap = 0
l_bootstrap_entry = -1
l_app_entry = -1
l_bootstrap_bin = ""
l_bootstrap_load = -1

def mplab_chooseBootstrap(self):
    project_dir = ide.expandProjectMacros("${ProjectName}", "${ProjectDir}")
    pdl = len(project_dir)
    fileChooser = JFileChooser(project_dir)
    retval = fileChooser.showOpenDialog(None)
    if retval == JFileChooser.APPROVE_OPTION:
        f = fileChooser.getSelectedFile().getPath()
        if 0==f.find(project_dir):
            f="${ProjectDir}" + f[pdl:]
        bsOpt.binTxt.text= f
        msg.print("Selected bootstrap binary: %s\n" % f)
        settings.setString("boot.path", f)

from javax.swing import JPanel, JLabel , JTextField, BoxLayout, JCheckBox, JButton,JFileChooser,GroupLayout
from java.awt import BorderLayout
class BootstrapPane():
    
    def __init__(self):
        self.panel = JPanel()
        self.panel.setLayout(BorderLayout())
        
        self.pane = JPanel()
        self.initUI()

    def initUI(self):
    
        layout = GroupLayout(self.pane)
        self.pane.setLayout(layout)
        layout.setAutoCreateGaps(True)
        layout.setAutoCreateContainerGaps(True)

        bc = settings.getBool("boot.use", False)
        self.useBs = JCheckBox("Use bootstrap",bc)
        binLabel = JLabel("Bootstrap file: ")
        self.binTxt = JTextField()
        self.binTxt.text = settings.getString("boot.path", "")
        self.binBtn = JButton("Load", actionPerformed=mplab_chooseBootstrap)

        entryLabel = JLabel("Bootstrap entry address (if bin): ")
        self.entryTxt = JTextField()
        self.entryTxt.text = settings.getString("boot.entry_adr", "")
        
        prjLabel = JLabel("Bootstrap project: ")
        self.prjTxt = JTextField()
        self.prjTxt.text = settings.getString("boot.prj", "")
        
        loadLabel=JLabel("Bootstrap load address (if bin): ")

        self.loadTxt = JTextField()
        self.loadTxt.text = settings.getString("boot.load_adr", "")

        layout.setHorizontalGroup(layout.createSequentialGroup()
            .addGroup(layout.createParallelGroup()
                .addComponent(self.useBs)
                .addComponent(prjLabel)
                .addComponent(binLabel)
                .addComponent(entryLabel)
                .addComponent(loadLabel)
                )
            .addGroup(layout.createParallelGroup()
#                .addComponent(self.useBs)
                .addComponent(self.prjTxt)
                .addComponent(self.binTxt)
                .addComponent(self.entryTxt)
                .addComponent(self.loadTxt)
                )
            .addGroup(layout.createParallelGroup()
                .addComponent(self.binBtn)
            )
        )

        layout.setVerticalGroup(layout.createSequentialGroup()
            .addGroup(layout.createParallelGroup()
                .addComponent(self.useBs)
            )
            .addGroup(layout.createParallelGroup()
                .addComponent(prjLabel)
                .addComponent(self.prjTxt, GroupLayout.PREFERRED_SIZE, GroupLayout.DEFAULT_SIZE,GroupLayout.PREFERRED_SIZE)
            )
            .addGroup(layout.createParallelGroup()
                .addComponent(binLabel)
                .addComponent(self.binTxt, GroupLayout.PREFERRED_SIZE, GroupLayout.DEFAULT_SIZE,GroupLayout.PREFERRED_SIZE)
                .addComponent(self.binBtn)
                )
            .addGroup(layout.createParallelGroup()
                .addComponent(entryLabel)
                .addComponent(self.entryTxt, GroupLayout.PREFERRED_SIZE, GroupLayout.DEFAULT_SIZE,GroupLayout.PREFERRED_SIZE)
            )
            .addGroup(layout.createParallelGroup()
                .addComponent(loadLabel)
                .addComponent(self.loadTxt, GroupLayout.PREFERRED_SIZE, GroupLayout.DEFAULT_SIZE,GroupLayout.PREFERRED_SIZE)
            )
        )
        self.panel.add(self.pane,BorderLayout.CENTER)

    def getPanel(self):
        return self.panel

bsOpt = None
def mplab_configure_Bootstrap(confName):
    global bsOpt
    if bsOpt == None:
        bsOpt=BootstrapPane()
    return bsOpt.getPanel()

def save_mplab_configure_Bootstrap(confName):
    global bsOpt
    if bsOpt == None:
        return

    settings.setString("boot.path", bsOpt.binTxt.getText())
    settings.setString("boot.prj", bsOpt.prjTxt.getText())
    settings.setString("boot.load_adr", bsOpt.loadTxt.getText())
    settings.setString("boot.entry_adr", bsOpt.entryTxt.getText())      
    settings.setString("boot.use",  "true" if bsOpt.useBs.isSelected() else "false")

def onShowPropsDFP2(t):
    ide.addPropCategory(t,"diagnostics" , "*|programoptions", "Diagnostics")
    ide.addBooleanProperty(t,"script.show_output" , "*|diagnostics|*","Output diagnostic logging","Show diagnostic text in the Output window", False)
    ide.addTextProperty(t,"script.log_level" , "*|diagnostics|*","Diagnostic log level","Set diagnostic level (usually 0 1 or 3)", "1")
    ide.addTextProperty(t,"script.reset_delay" , "*|diagnostics|*","Additional delay after reset","Enter additional RST settling delay in msec", "0")
    ide.addBooleanProperty(t,"script.has_reset" , "*|diagnostics|*","Uncheck if RESET line is not wired","Normally checked. Uncheck if the target does not have RST connected to the debugger", True)
    ide.addTextProperty(t,"jlink.override" , "*|diagnostics|*","Segger device name override","Use a device name override for Segger tools. Leave blank for no override", "")
    ide.addTextProperty(t, "loader.board_file", "*|programoptions|**","Board file path","Set the path of board file", "${ProjectDir}/board.xboard")

def icd4_connect(iface,speed):
    dev.Connect(iface, speed)

reset_delay=1000
has_reset=True
program_bootstrap =False

def _begin_communication_session():    
    global comm_speed,comm_iface,has_reset,reset_delay,_stealth_runstate, erase_as_needed
    global logLevel,printDebug,has_reset,program_bootstrap
    logLevel  = settings.getNumeric("script.log_level",logLevel)
    printDebug= settings.getBool("script.show_output",printDebug)
    has_reset  = settings.getBool("script.has_reset",has_reset)
    reset_delay = settings.getNumeric("script.reset_delay",reset_delay)
    comm_iface = settings.getString("communication.interface", default_iface) == "swd"
    comm_speed = settings.getNumeric("communication.frequency", comm_speed)
    _stealth_runstate = 2
    erase_as_needed = True
    if reset_delay < 1:
        reset_delay = 1
    program_bootstrap = False
    dev.SetApiLogging(logLevel)
    log.setShowOutput(printDebug)

    global mem_handlers
    mem_handlers = None
    try:
    	board_file = ide.expandProjectMacros("${ProjectName}", settings.getString("loader.board_file", "${ProjectDir}/board.xboard"))
    except:
        board_file = "./board.xboard"
    if os.path.isfile(board_file):
        mem_handlers = MemHandlers(board_file)
    

def _end_communication_session(): 
    pass

def _erase_internal():
    pass

def _begin_programming_operation():
    global program_bootstrap
    if has_reset and settings.getBool("programoptions.resetafterprogram", False): 
        dev.Pins(0, dev.RESET, 1000)
        dev.Delay(reset_delay)
        dev.Pins(dev.RESET, dev.RESET, 1000)  # now float reset back
        dev.Delay(reset_delay)

    icd4_connect(comm_iface, comm_speed)
    halt_target()
    reset_peripherals()
    
    global l_use_bootstrap, l_app_entry, l_bootstrap_entry, l_bootstrap_bin, l_bootstrap_load
    l_app_entry = -1
    l_use_bootstrap = settings.getBool("boot.use",False)
    l_bootstrap_bin = settings.getString("boot.path","")  
    prj = settings.getString("boot.prj","")
    if prj == "":
        prj="${ProjectName}"
    try:
        if l_use_bootstrap:
            l_bootstrap_bin = ide.expandProjectMacros(prj,l_bootstrap_bin)
    except:
        pass # outside a project setting, "boot.path" is expected to point to a fully qualified file

    # handle legacy way of setting variables
    try:
        l_use_bootstrap = True if g_mpu_config['type'] == 'application'  else False
        l_app_entry = g_mpu_config['entry_addr']
        if l_use_bootstrap:
            l_bootstrap_load = l_bootstrap_entry = g_mpu_config['bootstrap_entry_addr']
            l_bootstrap_bin  = g_mpu_config['bootstrap_bin_path']
    except:
        pass
    
    if l_app_entry == -1:
        l_app_entry = deb.GetSpecialSymbolAddress("__entry_address")
    if l_use_bootstrap != 0 and program_bootstrap == True:
        load_and_run_bootstrap(l_bootstrap_bin)

def _prog_write_internal(type_of_mem, address, length, data): 
    global l_app_entry
    global current_pc

    if l_app_entry == 0x7fffffffffffffffL:
        l_app_entry = address # hack when we dont have a known entry point, use first write
        current_pc = address

    dev.Write(address, data, 0, length)
    verLen = 256  # verify a few bytes
    if verLen > length:
        verLen = length

    rdb = bytearray(verLen)
    dev.Read(address,rdb, 0, verLen)
    for i in range(0,verLen):
        if rdb[i] != data[i]:
            log.error("The programmed bytes do not verify. Please check that your bootloader is working correctly.")
            raise  Exception("Verify error")


def _prog_read_internal(type_of_mem, address, length, data):    
    dev.Read(address, data, 0, length)

def _end_of_operations():
    pass

def set_pc_to_appstart():
    global current_pc
    if l_app_entry != -1:
        write_named_register("R8_USR",0xd3)
        write_named_register("PC",l_app_entry)
        current_pc = l_app_entry
        

def _begin_debug_session():
    global current_pc
    hw_bkpts.clear()
    for i in range(max_number_of_breakpoints):
        clr_hardware_bp(i)
    debug_entry()
    halt_and_reset()
    
def get_pc():
    pc = get_pc_scr()
    log.info("Debug: get_pc PC=0x%08x" % pc)
    return pc


def _run_target():
    global current_pc
    step_target()
    restore_hw_bps()
    run_with_set_pc(current_pc)

def _halt_target():
    dev.runScript("Halt")
    for i in range(10):
        if (get_debug_status() & dbgStatus_DBGACK) != 0:
            return
        dev.Delay(100000)

def _step_target():
    global current_pc
    global core_state
    log.info("Debug: step_target PC=0x%08x" % current_pc)
    dat = bytearray()
    dat.extend(to_bytes(current_pc,4))
    log.info("SingleStep Core State: %s" % core_state)
    if core_state == "thumb":
        dev.runScriptWithDownload("thumbSingleStep", dat)
    else:
        dev.runScriptWithDownload("SingleStep", dat)
    run_with_set_pc(current_pc)
    for i in range(10):
        if (get_debug_status() & dbgStatus_DBGACK) != 0:
            return
        dev.Delay(100000)



def _set_pc(pc):
    global current_pc
    current_pc = pc
    set_pc_scr(pc)

def _reset_target():
    halt_and_reset()

def on_ui_reset():
    return msg.dlgYesNo("The reset button will only set PC to application start. For a full reset, please press the Reset button on the kit and restart the debug session. Continue reset?", "Reset")

def halt_and_reset():
    if (get_debug_status() & dbgStatus_DBGACK) == 0:
        _halt_target
    set_pc_to_appstart()
    get_debug_status()


g_is_running = True

def _is_target_running():
    global g_is_running
    if (get_debug_status() & dbgStatus_DBGACK) == 0:
        state = True
    else:
        state = False
        log.info("Debug:: is_running %s" % state)
        debug_entry()
    if state != g_is_running:
        log.info("Debug:: is_running %s" % state)
        g_is_running = state
    return g_is_running

def _end_debug_session(): 
    dev.Disconnect()

def load_binary_file(f, a):
    with open(f, "rb") as fb:
        bootstrap_data = bytearray(fb.read())
    dev.Write(a, bootstrap_data, 0, len(bootstrap_data))

def writeBlock(adr,bytes,name):
    log.info("Section %s at %08x %d" % (name, adr, len(bytes)))
    dev.Write(adr,bytes,0,len(bytes))

def load_file_and_pc(binary_path):
    global l_bootstrap_entry, l_bootstrap_load
    bsLoad = l_bootstrap_load
    bsEntry = l_bootstrap_entry
    filetype = deb.PeekFileType(binary_path)
    if "hex" == filetype or "elf" == filetype:
        msg.print("Debug: Loading %s\n" % binary_path)
        deb.EnumCodeBlocks(binary_path, "writeBlock")
        bsEntry = deb.PeekSymbolAddress(binary_path,"__entry_address",True)
    else:
        try:
            l = settings.getString("boot.load_adr","").strip()
            if l != "":
                bsLoad = int(l,0)
            l = settings.getString("boot.entry_adr","").strip()
            if l != "":
                bsEntry = int(l,0)
        except:
            raise Exception("You need to specify a numeric load address and entry point address for bootstrap %s" % binary_path)
        msg.print("Debug: Loading %s as a binary file at address 0x%08x entry point 0x%08x\n" % (binary_path, bsLoad, bsEntry))
        if bsLoad == -1 or bsEntry == -1:
            raise Exception("You need to specify a numeric load and entry address for %s" % binary_path)
        load_binary_file(binary_path,  bsLoad)
    set_pc(bsEntry)

def load_and_run_bootstrap(l_bootstrap_bin):
    global current_pc
    global core_state
    # Default state to arm, since the tool debugs in arm state
    core_state ="arm"
    try:
        f = open(l_bootstrap_bin, "rb")
        f.close()
    except:
        msg.msg("Failed to open bootstrap file %s" % l_bootstrap_bin, "Error")
        raise Exception("Failed to open bootstrap file")
    load_file_and_pc(l_bootstrap_bin)
    clr_hardware_bp(0)
    clr_hardware_bp(1)
    
    run_with_set_pc(current_pc)
    dev.Delay(100000)
    for i in range(10):
        if (get_debug_status() & dbgStatus_DBGACK) != 0:
            msg.print("Debug: boostrap has halted. Will load application.\n")
            dev.Delay(1000000)
            return
        dev.Delay(100000)
    log.error("Debug: boostrap timed out")

def get_debug_status():
    global core_state
    dbgstatus = dev.runScriptWithUpload("GetDbgStatus",4);
    result = (dbgstatus[0] | dbgstatus[1] << 8 | dbgstatus[2] << 16 | dbgstatus[3] << 24)
    log.info("dbgstatus %08x " % (result))
    
    if (result & dbgStatus_ITBIT == dbgStatus_ITBIT):
        log.info("Core State: Thumb\n")
    elif (result & dbgStatus_IJBIT == dbgStatus_IJBIT):
        log.info("Core State: Jazelle - unsupported\n")
    else:
        log.info("Core State: Arm\n")     
    
    return result

def _debug_read(mt, start, length, data):
    try:
        dev.Read(start, data, 0, length)
    except:
        for i in range(len(data)):
            try:
                dev.Read(start + i, data, i, 1)
            except:
                data[i] = b'?'
                dev.Delay(reset_delay)
        log.info("Debug: an error occurred while reading address 0x%x length 0x%0x" % (start, length))

def _debug_write(mt, start, length, data):
    try:
        dev.Write(start, data, 0, length)
    except:
        for i in range(len(data)):
            try:
                dev.Write(start + i, data, i, 1)
            except:
                dev.Delay(reset_delay)
        log.info("Debug: an error occurred while writing address 0x%x length 0x%0x" % (start, length))

def _get_pc():
    return read_named_register("PC")


def _hold_in_reset():
    pass

def _release_from_reset():
    halt_and_reset()
    run_target()
    pass

target_was_reset = False
debug_session  = True

def begin_communication_session(): #mplab
    log.info("Begin comm session")
    _begin_communication_session()

def end_communication_session(): #mplab
    log.info("End comm session")
    _end_communication_session()

def begin_programming_operation(): #mplab
    global debug_session
    log.info("Begin operations")
    debug_session = False
    _begin_programming_operation()

def erase(): #mplab
    log.info("Erase")
    _erase()

def prog_write(type_of_mem, address, length, data): #mplab
    log.info("Writing %08x bytes to address 0x%08x of %s memory" % (length, address, type_of_mem))
    _prog_write(type_of_mem, address, length, data)

def prog_read(type_of_mem, address, length, data): #mplab
    log.info("Reading %08x bytes from address 0x%08x of %s memory" % (length, address, type_of_mem))
    _prog_read(type_of_mem, address, length, data)

def end_of_operations():#mplab
    log.info("End of operations")
    _end_of_operations()

def begin_debug_session():  #mplab
    log.info("Debug: Init debug session")
    global debug_session
    debug_session = True
    _begin_debug_session()

def debug_read(mt, start, length, data):  #mplab
    log.info("Debug: Reading %08x bytes at start address 0x%08x (%s)" % (length, start, mt))
    _debug_read(mt, start, length, data)

def debug_write(mt, start, length, data):  #mplab
    log.info("Debug: Writing %08x bytes at start address 0x%08x (%s)" % (length, start, mt))
    _debug_write(mt, start, length, data)

def set_pc(pc):  #mplab
    log.info("Debug: set pc to 0x%08x" % pc)
    _set_pc(pc)

def get_pc():  #mplab
    pc = _get_pc()
    log.info("Debug: get_pc PC=0x%08x" % pc)
    return pc

def run_target():#mplab
    log.info("Debug: run target")
    _run_target()

_stealth_runstate = 2
def halt_target():  #mplab
    global _stealth_runstate    
    log.info("Debug: halt target")
    _stealth_runstate = 2  # cancels stealth mode
    _halt_target()

def step_target():  #mplab
    log.info("Debug: stepping at pc")
    get_debug_status()
    write_registers()
    _step_target()
    debug_entry()

def reset_target(): #mplab
    log.info("Debug: reset")
    _reset_target()
    on_after_reset() # call autoload hook

def is_target_running():#mplab
    global _stealth_runstate
    if _stealth_runstate == 2:
        return _is_target_running()
    return _stealth_runstate != 0

def on_after_reset(): 
    if not debug_session:
        return
    if not settings.getBool("arm.use_vtor", False):
        return
    vtor_name  = settings.getString("arm.vtor_adr", "0")

    vtor = -1
    try:
        vtor = int(vtor_name,0)
    except:
        try:
            vtor=deb.GetSymbolAddress(vtor_name)
        except:
            log.error("Debug: failed to compute location of VTOR")
            return
    load_vtor(vtor) 
    pass

def load_vtor(adr):
    try:
        pc = dev.Read32(adr + 4)
        sp = dev.Read32(adr)
        set_pc(pc)
        write_named_register("SP",sp)
        log.info("Setting pc=%08x and sp=%08x" % (pc, sp))
    except:
        log.error("Debug: failed to set PC and SP to contents of exception_table")

def on_program_done():
    on_after_reset()

def end_debug_session():  #mplab
    log.info("Debug: End debug session")
    _end_debug_session()

def verify_transfer(type_of_mem, address, data, length):  #mplab
    log.info("Verifying %08x bytes to address 0x%0x of %s memory" % (length, address, type_of_mem))
    _verify_transfer(type_of_mem, address, data, length)

    

def _verify_transfer(type_of_mem, address, data, length):
    if len(data) != length:
        raise Exception("The given data and length mismatch")
    d = bytearray(length)
    prog_read(type_of_mem, address, length, d)
    if str(type_of_mem) == "Cfg":
        verify_config(address, data, d, "verify")
    else:
        for i in range(length):
            if data[i] != d[i]:
                raise Exception("Verify failed for mem type {}, at address 0x{:X}".format(str(type_of_mem), address + i))

global dev_cfg_masks_bytearray
dev_cfg_masks_bytearray = None

def init_masks_as_bytearray():
    global dev_cfg_masks_bytearray
    if dev_cfg_masks_bytearray:
        return
    dev_cfg_masks_bytearray = {}
    for address, val in dev_cfg_masks.items():
        dev_cfg_masks_bytearray[address    ] = int(val      ) & 0xFF
        dev_cfg_masks_bytearray[address + 1] = int(val >> 8 ) & 0xFF
        dev_cfg_masks_bytearray[address + 2] = int(val >> 16) & 0xFF
        dev_cfg_masks_bytearray[address + 3] = int(val >> 24) & 0xFF

def verify_config(address, expected, actual, error_string_prefix):
    try:
        # older versions of MPLAB X (<=v5.45) did not pass dev_cfg_masks
        # so very_config cannot be executed
        dev_cfg_masks 
    except:
        raise Exception("{} config is not implemented".format(error_string_prefix))
    init_masks_as_bytearray()

    for index, actual_val in enumerate(actual):
        current_address = address + index
        if current_address in dev_cfg_masks_bytearray:
            mask = dev_cfg_masks_bytearray[current_address]
            expected_val = expected[index] & mask
            actual_val &= mask
            if actual_val != expected_val:
                error_string = "{} failed at address 0x{:0X}, expected 0x{:0X}, got 0x{:0X}".format(error_string_prefix, current_address, expected_val, actual_val)
                raise Exception(error_string)

def is_memory_blank_all_ffs(type_of_mem):
    return str(type_of_mem) == "Pgm" or str(type_of_mem) == "UserID"
        
def blank_check():  #mplab
    log.info("Blank check")

def blank_check_mem(type_of_mem, address, length):  #mplab
    msg.print("Blank checking %08x bytes to address 0x%0x of %s memory" % (length, address, type_of_mem))
    _blank_check_mem(type_of_mem, address, length)

def _blank_check_mem(type_of_mem, address, length):
    data = bytearray(length)
    prog_read(type_of_mem, address, length, data)
    if str(type_of_mem) == "Cfg":
        prog_read(type_of_mem, address, length, data)
        verify_config(address, data, data, "blank check")
    elif is_memory_blank_all_ffs(type_of_mem):
        for index, x in enumerate(data):
            if x != 255:
                raise Exception("Blank failed for mem type {}, at address 0x{:X}".format(str(type_of_mem), address + index))
    else:
        log.error("Blank check, ignoring {}".format(str(type_of_mem)))

def hold_in_reset():  #mplab
    log.info("Hold in reset")
    _hold_in_reset()

def release_from_reset():  #mplab
    log.info("Release from reset")
    _release_from_reset()
    
def read_device_id():#mplab
    log.info("Read device ID")
    return _read_device_id()

import os
has_samba = os.path.isfile(os.path.join("samba.py"))
if has_samba:
    import samba
from xml.dom import minidom


class MemHandlers():
    def __init__(self, board_file):
        if has_samba:
            samba.log = log
            samba.msg = msg
            samba.dev = dev
            samba.is_target_running = is_target_running
            samba.run_target = run_target
            samba.architecture = architecture
            samba.arm = arm
        self.parse_board_file(board_file)

    def parse_board_file(self, board_file):
        self.handlers = []
        xmldoc = minidom.parse(board_file)
        rangeNodes = xmldoc.getElementsByTagName("range")
        for rangeNode in rangeNodes:
            start = int(rangeNode.getAttribute("start"), 0)
            end = int(rangeNode.getAttribute("end"), 0)
            type = rangeNode.getAttribute("type")
            config = {}
            for configNode in rangeNode.childNodes:
                if configNode.nodeType == configNode.ELEMENT_NODE:
                    try:
                        config[configNode.tagName] = int(configNode.firstChild.nodeValue, 0)
                    except:
                        config[configNode.tagName] = ide.expandProjectMacros("${ProjectName}", configNode.firstChild.nodeValue).replace("\\", os.path.sep)
            if type == "samba" and has_samba:
                self.handlers.append(samba.Samba(start, end, config))
            elif type == "user":
                self.handlers.append(UserHandler(start, end, config))

    def prog_write(self, type_of_mem, address, length, data):
        log.info("Prog: Writing %d bytes to address 0x%0x of %s memory" % (length, address, type_of_mem))
        _prog_write_internal(type_of_mem, address, length, data)

    def prog_read(self, type_of_mem, address, length, data):
        log.info("Prog: Reading %d bytes to address 0x%0x of %s memory" % (length, address, type_of_mem))
        remainings = [[address, address + length]]
        for handler in self.handlers:
            read_start = max(address, handler.range_start)
            read_end = min(address + length, handler.range_end)
            if read_start < read_end:
                # chop the data buffer and pass it to handler and run
                buffer = bytearray(read_end - read_start)
                handler.read(read_start - handler.range_start, buffer)
                data[read_start - address: read_end - address] = buffer
            new_remainings = []
            for remaining in remainings:
                read_start = max(remaining[0], handler.range_start)
                read_end = min(remaining[1], handler.range_end)
                if remaining[0] < read_start < remaining[1]:
                    new_remainings.append([remaining[0], read_start])
                if remaining[0] < read_end < remaining[1]:
                    new_remainings.append([read_end, remaining[1]])
                elif read_start < read_end < remaining[0] or remaining[1] < read_start < read_end or read_start > read_end:
                    new_remainings.append(remaining)
            remainings = new_remainings
        # now write to memory ranges that are not covered by handlers
        for remaining in remainings:
            _prog_read_internal(type_of_mem, remaining[0], remaining[1] - remaining[0], data[remaining[0] - address: remaining[1] - address])

    def erase(self):
        log.info("Prog: Erasing memory")
        for handler in self.handlers:
            if handler.range_start < handler.range_end:
                handler.erase(0, handler.range_end - handler.range_start)


class UserHandler():
    def __init__(self, range_start, range_end, config):
        self.range_start = range_start
        self.range_end = range_end
        self.config = config

    def call(self, address=0, data=None):
        if "handler_name" in self.config.keys():
            eval(self.config["handler_name"])()
        else:
            log.info("The name of handler function is missing")


def _prog_write(type_of_mem, address, length, data):
    global mem_handlers
    if mem_handlers is None:
        _prog_write_internal(type_of_mem, address, length, data)
    else:
        mem_handlers.prog_write(type_of_mem, address, length, data)


def _prog_read(type_of_mem, address, length, data):
    global mem_handlers
    if mem_handlers is None:
        _prog_read_internal(type_of_mem, address, length, data)
    else:
        mem_handlers.prog_read(type_of_mem, address, length, data)


def _erase():
    global mem_handlers, erase_as_needed
    if mem_handlers is not None:
        mem_handlers.erase()
    _erase_internal()
    erase_as_needed = False  # tell prog_write not to erase rows prior to write


def init_mem_handlers():
    global mem_handlers
    mem_handlers = None
    try:
        board_file = ide.expandProjectMacros("${ProjectName}", settings.getString("loader.board_file", "${ProjectDir}/board.xboard"))
    except:
        board_file = "./board.xboard"
    if os.path.isfile(board_file):
        mem_handlers = MemHandlers(board_file)

def read_device_id():#mplab
    global program_bootstrap
    log.info("Read device ID")
    result = read_memory32(DEVID)
    program_bootstrap = True
    return result

names_order = ["R0","R1","R2","R3","R4","R5","R6","R7","R8","R9","R10","R11","R12","SP","LR","PC","CPSR","R8_FIQ","R9_FIQ","R10_FIQ","R11_FIQ","R12_FIQ","SP_FIQ","LR_FIQ","SPSR_FIQ","SP_IRQ","LR_IRQ","SPSR_IRQ","SP_SVC","LR_SVC","SPSR_SVC","SP_ABT","LR_ABT","SPSR_ABT","SP_UND","LR_UND","SPSR_UND"]
reg_val = [0]*len(names_order)
def read_registers():
    global reg_val
    global core_state
    log.info("GetCoreRegsRange Core State: %s" % core_state)
    res = dev.runScriptWithUpload("GetCoreRegsRange",4*(len(names_order)))
    c = 0
    for i in range(len(names_order)):
        if names_order[i] != "PC":
            reg_val[i] = (res[c] | res[c+1] << 8 | res[c+2] << 16 | res[c+3] << 24)
        c = c+4
        log.info("Register %s value 0x%0x " % (names_order[i], reg_val[i]))

def read_named_register(n):
    global reg_val
    log.info("rnn " + n)
    if n in names_order:
        return reg_val[names_order.index(n)] 
    log.info("Register %s not found " % (n))
    return 0

def to_bytes(n, length):
    bytes = bytearray(length)
    for i in range(length):
        bytes[i] = (n >> i*8) & 0xff
    return bytes

def print_byte_array(text, array, index, size):
    string = text
    for i in range(size):
        string += " 0x%x ," % array[i+index]
        if (i+1) % 4 == 0:
            string += " \n"
    print(string)

def write_registers():
    global reg_val
    dat = bytearray()
    for i in range(len(names_order)):
        val = reg_val[i]
        dat.extend(to_bytes(val,4))
    dev.runScriptWithDownload("SetCoreRegsRange",dat)


def write_named_register(n,v):
    global reg_val
    log.info("wnn %s val: 0x%x" % (n,v))
    if n in names_order:
        reg_val[names_order.index(n)] = v
    write_registers()
        
def read_memory32(m):
    res = dev.runScriptWithUpload("ReadEmu32",4,m);
    result = (res[0] | res[1] << 8 | res[2] << 16 | res[3] << 24)
    log.info("read_memory32 0x%x val: 0x%x" % (m,result))
    return result

def read_memory(m,length):
    log.info("read_memory 0x%x " % (m))
    res = dev.runScriptWithUpload("ReadEmu",length,m,length)
    return res

def debug_entry():
    global core_state
    global current_pc
    result = get_debug_status()
    if (result & dbgStatus_ITBIT == dbgStatus_ITBIT):
        core_state = "thumb"
        log.info("Core State: Thumb\n")
    elif (result & dbgStatus_IJBIT == dbgStatus_IJBIT):
        core_state = "jazelle"
        log.info("Core State: Jazelle - unsupported\n")
    else:
        core_state = "arm"
        log.info("Core State: Arm\n")
    current_pc = get_pc_scr()
    read_registers()

def set_pc_scr(val):
    global core_state
    log.info("set_pc 0x%x " % (val))
    dev.runScript("SetPC", val)
    reg_val[names_order.index("PC")] = val

def get_pc_scr():
    res = dev.runScriptWithUpload("GetPC",4);
    result = (res[0] | res[1] << 8 | res[2] << 16 | res[3] << 24)
    reg_val[names_order.index("PC")] = result
    log.info("GetPC 0x%x " % (result))
    return result

def run_with_set_pc(val):
    global core_state
    log.info("run_with_set_pc 0x%x " % (val))

    get_debug_status()

    if core_state == "arm":
        log.info("Run Core State: %s" % core_state)
        dev.runScript("Run", val)
    elif core_state == "thumb":
        log.info("thumbRun Core State: %s" % core_state)
        dev.runScript("thumbRun", val)
    else:
        log.info("Core State: Jazelle - unsupported\n")

    reg_val[names_order.index("PC")] = val
    for i in range(10):
        if (get_debug_status() & dbgStatus_SYSCOMP) != 0:
            return
        dev.Delay(100000)
    
    
hw_bkpts = {}
max_number_of_breakpoints = 2

def restore_hw_bps():
    for i in range(max_number_of_breakpoints):
        if hw_bkpts.get(i) != None:
            set_hardware_bp(i,list(hw_bkpts.get(i).values())[0])
        else:
            clr_hardware_bp(i)

def set_hw_bp(num,addr):
    log.info("break: set_hw_bp num %d addr: %x\n" % (num,addr))
    global hw_bkpts
    global max_number_of_breakpoints

    for i in range(max_number_of_breakpoints):
        if i in hw_bkpts:
            if num in hw_bkpts[i]:
                log.info("debug : duplicate hwbp at %d addr 0x%x\n" % (num,addr))
                return 0

    for i in range(max_number_of_breakpoints):
        if i not in hw_bkpts:
            hw_bkpts.update({i : {num : addr}})
            set_hardware_bp(i,addr)
            return 0

    raise Exception("Insufficient number of hardware breakpoints : use software breakpoints")

def set_hardware_bp(bp,addr):
    if bp == 0:
        log.info("Debug: HWBP_Set_0 addr: %x\n" % (addr))
        dev.runScript("HWBP_Set_0",addr)

    elif bp == 1:
        log.info("Debug: HWBP_Set_1 addr: %x\n" % (addr))
        dev.runScript("HWBP_Set_1",addr)

    else:
        raise Exception("Insufficient number of hardware breakpoints : use software breakpoints")

def clear_hw_bp(num):
    log.info("Debug: clr_hw_bp num %d \n" % (num))
    global hw_bkpts
    global max_number_of_breakpoints

    for i in range(0,max_number_of_breakpoints):
        if i in hw_bkpts:
            if num in hw_bkpts[i]:
                hw_bkpts.pop(i)
                clr_hardware_bp(i)
                return 0

    raise Exception("Illegal clear of breakpoint")

def clr_hardware_bp(bp):
    if bp == 0:
        log.info("Debug: hwbp0 cleared\n")
        dev.runScript("HWBP_Clear_0")

    elif bp == 1:
        log.info("Debug: hwbp1 cleared\n")
        # Disable the breakpoint
        dev.runScript("HWBP_Clear_1")

    else:
        raise Exception("Illegal clear of breakpoint")

def invalidate_cache():
    dev.runScript("invalidateCache")

def set_sw_bp(address, instruction, flags):
    log.info("swbp at %x instn :%x flags: %x\n" % (address,instruction,flags))
    data_read = dev.Read32(address)
    dev.Write32(address, instruction)
    invalidate_cache()
    data_read2 = dev.Read32(address)
    return data_read

