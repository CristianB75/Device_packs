# This file is autogenerated
comm_speed=2000000
default_iface="jtag"

def reset_peripherals():
    dev.Reset()
    dev.WriteReg64(8, 0xd3)
    dev.Write32(0xffffff84, 0x00001030)


printDebug = False     # set to True to print diagnostic info
logLevel = 0           # set to 1 to print diagnostic info

# The l_ variables are reinitialized at every debug session. They are used locally in this script and should not be overriden in autoload.py
l_use_bootstrap = 0
l_bootstrap_entry = -1
l_app_entry = -1
l_bootstrap_bin = ""
l_bootstrap_load = -1

def mplab_chooseBootstrap(self):
    project_dir = ide.expandProjectMacros("${ProjectName}", "${ProjectDir}")
    pdl = len(project_dir)
    fileChooser = JFileChooser(project_dir)
    retval = fileChooser.showOpenDialog(None)
    if retval == JFileChooser.APPROVE_OPTION:
        f = fileChooser.getSelectedFile().getPath()
        if 0==f.find(project_dir):
            f="${ProjectDir}" + f[pdl:]
        bsOpt.binTxt.text= f
        msg.print("Selected bootstrap binary: %s\n" % f)
        settings.setString("boot.path", f)

from javax.swing import JPanel, JLabel , JTextField, BoxLayout, JCheckBox, JButton,JFileChooser,GroupLayout
from java.awt import BorderLayout
class BootstrapPane():
    
    def __init__(self):
        self.panel = JPanel()
        self.panel.setLayout(BorderLayout())
        
        self.pane = JPanel()
        self.initUI()

    def initUI(self):
    
        layout = GroupLayout(self.pane)
        self.pane.setLayout(layout)
        layout.setAutoCreateGaps(True)
        layout.setAutoCreateContainerGaps(True)

        bc = settings.getBool("boot.use", False)
        self.useBs = JCheckBox("Use bootstrap",bc)
        binLabel = JLabel("Bootstrap file: ")
        self.binTxt = JTextField()
        self.binTxt.text = settings.getString("boot.path", "")
        self.binBtn = JButton("Load", actionPerformed=mplab_chooseBootstrap)

        entryLabel = JLabel("Bootstrap entry address (if bin): ")
        self.entryTxt = JTextField()
        self.entryTxt.text = settings.getString("boot.entry_adr", "")
        
        prjLabel = JLabel("Bootstrap project: ")
        self.prjTxt = JTextField()
        self.prjTxt.text = settings.getString("boot.prj", "")
        
        loadLabel=JLabel("Bootstrap load address (if bin): ")

        self.loadTxt = JTextField()
        self.loadTxt.text = settings.getString("boot.load_adr", "")

        layout.setHorizontalGroup(layout.createSequentialGroup()
            .addGroup(layout.createParallelGroup()
                .addComponent(self.useBs)
                .addComponent(prjLabel)
                .addComponent(binLabel)
                .addComponent(entryLabel)
                .addComponent(loadLabel)
                )
            .addGroup(layout.createParallelGroup()
#                .addComponent(self.useBs)
                .addComponent(self.prjTxt)
                .addComponent(self.binTxt)
                .addComponent(self.entryTxt)
                .addComponent(self.loadTxt)
                )
            .addGroup(layout.createParallelGroup()
                .addComponent(self.binBtn)
            )
        )

        layout.setVerticalGroup(layout.createSequentialGroup()
            .addGroup(layout.createParallelGroup()
                .addComponent(self.useBs)
            )
            .addGroup(layout.createParallelGroup()
                .addComponent(prjLabel)
                .addComponent(self.prjTxt, GroupLayout.PREFERRED_SIZE, GroupLayout.DEFAULT_SIZE,GroupLayout.PREFERRED_SIZE)
            )
            .addGroup(layout.createParallelGroup()
                .addComponent(binLabel)
                .addComponent(self.binTxt, GroupLayout.PREFERRED_SIZE, GroupLayout.DEFAULT_SIZE,GroupLayout.PREFERRED_SIZE)
                .addComponent(self.binBtn)
                )
            .addGroup(layout.createParallelGroup()
                .addComponent(entryLabel)
                .addComponent(self.entryTxt, GroupLayout.PREFERRED_SIZE, GroupLayout.DEFAULT_SIZE,GroupLayout.PREFERRED_SIZE)
            )
            .addGroup(layout.createParallelGroup()
                .addComponent(loadLabel)
                .addComponent(self.loadTxt, GroupLayout.PREFERRED_SIZE, GroupLayout.DEFAULT_SIZE,GroupLayout.PREFERRED_SIZE)
            )
        )
        self.panel.add(self.pane,BorderLayout.CENTER)

    def getPanel(self):
        return self.panel

bsOpt = None
def mplab_configure_Bootstrap(confName):
    global bsOpt
    if bsOpt == None:
        bsOpt=BootstrapPane()
    return bsOpt.getPanel()

def save_mplab_configure_Bootstrap(confName):
    global bsOpt
    if bsOpt == None:
        return

    settings.setString("boot.path", bsOpt.binTxt.getText())
    settings.setString("boot.prj", bsOpt.prjTxt.getText())
    settings.setString("boot.load_adr", bsOpt.loadTxt.getText())
    settings.setString("boot.entry_adr", bsOpt.entryTxt.getText())      
    settings.setString("boot.use",  "true" if bsOpt.useBs.isSelected() else "false")

def onShowPropsDFP2(t):
    ide.addPropCategory(t,"diagnostics" , "*|programoptions", "Diagnostics")
    ide.addBooleanProperty(t,"script.show_output" , "*|diagnostics|*","Output diagnostic logging","Show diagnostic text in the Output window", False)
    ide.addTextProperty(t,"script.log_level" , "*|diagnostics|*","Diagnostic log level","Set diagnostic level (usually 0 1 or 3)", "1")
    ide.addTextProperty(t,"script.reset_delay" , "*|diagnostics|*","Additional delay after reset","Enter additional RST settling delay in msec", "0")
    ide.addBooleanProperty(t,"script.has_reset" , "*|diagnostics|*","Uncheck if RESET line is not wired","Normally checked. Uncheck if the target does not have RST connected to the debugger", True)
    ide.addTextProperty(t,"jlink.override" , "*|diagnostics|*","Segger device name override","Use a device name override for Segger tools. Leave blank for no override", "")
    ide.addTextProperty(t, "loader.board_file", "*|programoptions|**","Board file path","Set the path of board file", "${ProjectDir}/board.xboard")

def select_jlink():
    t = dev.api.GetDescriptor(-2,0,0)
    kvs = t.content.split(":=")
    sn = 0 
    for str in kvs:
        if str.startswith("<sn>"):
            sn = int(str[4:])
            break
    dev.api.JLINKARM_EMU_SelectByUSBSN(sn)

    
def jlink_connect(iface,speed):
    try:
        try:
            dev.SelectConfiguredJlinkTool()
        except:
            select_jlink()
            dev.Connect(iface, speed)
            return
        dev.api.JLINKARM_OpenEx()
        dev.ExecCommand( "ProjectFile = " + dev.api.cSettingsFile)
        d = settings.getString("jlink.override", "")
        if len(d.strip()) == 0:
            d = device
        dev.ExecCommand("Device = " + d)
        dev.api.JLINK_TIFSelect( 1 if iface else 0)
        dev.api.JLINK_SetSpeed(get_jlink_speed())
        dev.api.JLINKARM_SetCoreIndex(0)
        dev.api.JLINKARM_Connect(True)
    except:
        dev.Connect(iface, speed)

def get_jlink_speed():
    comm_speed_is_auto = settings.getBool("communication.autoselectspeed",False)
    comm_speed_is_adaptive = settings.getBool("communication.adaptivespeed",False)
    if comm_speed_is_auto:
        return 0
    elif comm_speed_is_adaptive:
        return 0xFFFF
    return comm_speed/1000

reset_delay=1000
has_reset=True

def _begin_communication_session():    
    global comm_speed,comm_iface,has_reset,reset_delay,_stealth_runstate, erase_as_needed
    global logLevel,printDebug,has_reset
    logLevel  = settings.getNumeric("script.log_level",logLevel)
    printDebug= settings.getBool("script.show_output",printDebug)
    has_reset  = settings.getBool("script.has_reset",has_reset)
    reset_delay = settings.getNumeric("script.reset_delay",reset_delay)
    comm_iface = settings.getString("communication.interface", default_iface) == "swd"
    comm_speed = settings.getNumeric("communication.frequency", comm_speed)
    _stealth_runstate = 2
    erase_as_needed = True
    if reset_delay < 1:
        reset_delay = 1

    dev.SetApiLogging(logLevel)
    log.setShowOutput(printDebug)

    jlink_connect(comm_iface, comm_speed)

    global mem_handlers
    mem_handlers = None
    try:
    	board_file = ide.expandProjectMacros("${ProjectName}", settings.getString("loader.board_file", "${ProjectDir}/board.xboard"))
    except:
        board_file = "./board.xboard"
    if os.path.isfile(board_file):
        mem_handlers = MemHandlers(board_file)
    

def _end_communication_session(): 
    pass

def _erase_internal():
    pass

def _begin_programming_operation():
    if has_reset and settings.getBool("programoptions.resetafterprogram", False):
        dev.Pins(0, dev.RESET, 1000)
        dev.Delay(reset_delay)
        dev.Pins(dev.RESET, dev.RESET, 1000)  # now float reset back
        dev.Delay(500000) #delays added to accomodate a7g5 and 9x7 that did not come back from reset by the time jlink_connect is issued on windows
        dev.Disconnect()
        dev.Delay(500000) #see above
        jlink_connect(comm_iface, comm_speed)

    halt_target()
    reset_peripherals()

    global l_use_bootstrap, l_app_entry, l_bootstrap_entry, l_bootstrap_bin, l_bootstrap_load
    l_app_entry = -1
    l_use_bootstrap = settings.getBool("boot.use",False)
    l_bootstrap_bin = settings.getString("boot.path","")  
    prj = settings.getString("boot.prj","")
    if prj == "":
        prj="${ProjectName}"
    try:
        if l_use_bootstrap:
            l_bootstrap_bin = ide.expandProjectMacros(prj,l_bootstrap_bin)
    except:
        pass # outside a project setting, "boot.path" is expected to point to a fully qualified file

    # handle legacy way of setting variables
    try:
        l_use_bootstrap = True if g_mpu_config['type'] == 'application'  else False
        l_app_entry = g_mpu_config['entry_addr']
        if l_use_bootstrap:
            l_bootstrap_load = l_bootstrap_entry = g_mpu_config['bootstrap_entry_addr']
            l_bootstrap_bin  = g_mpu_config['bootstrap_bin_path']
    except:
        pass
    
    if l_app_entry == -1:
        l_app_entry = deb.GetSpecialSymbolAddress("__entry_address")
    if l_use_bootstrap != 0:
        load_and_run_bootstrap(l_bootstrap_bin)

def _prog_write_internal(type_of_mem, address, length, data): 
    global l_app_entry

    if l_app_entry == 0x7fffffffffffffffL:
        l_app_entry = address # hack when we dont have a known entry point, use first write
    
    dev.Write(address, data, 0, length)
    verLen = 256  # verify a few bytes
    if verLen > length:
        verLen = length

    rdb = bytearray(verLen)
    dev.Read(address,rdb, 0, verLen)
    for i in range(0,verLen):
        if rdb[i] != data[i]:
            log.error("The programmed bytes do not verify. Please check that your bootloader is working correctly.")
            raise  Exception("Verify error")


def _prog_read_internal(type_of_mem, address, length, data):    
    dev.Read(address, data, 0, length)

def _end_of_operations():
    halt_and_reset()

def set_pc_to_appstart():
    if l_app_entry != -1:
        dev.WriteReg64(8, 0xd3) # Disable all interrupts and go to supervisor mode
        dev.WriteReg64(arm.PC, l_app_entry)

def _begin_debug_session():
    halt_and_reset()

def get_pc():
    pc = dev.ReadReg64(arm.PC)
    log.info("Debug: get_pc PC=0x%08x" % pc)
    return pc


def _run_target():
    dev.GoEx(1, 1)

def _halt_target():
    dev.Halt()

def _step_target():
    dev.Step()

def _set_pc(pc):
    dev.WriteReg64(arm.PC, pc)

def _reset_target():
    halt_and_reset()

def on_ui_reset():
    return msg.dlgYesNo("The reset button will only set PC to application start. For a full reset, please press the Reset button on the kit and restart the debug session. Continue reset?", "Reset")

def halt_and_reset():
    if not dev.IsHalted():
        halt_target()
    set_pc_to_appstart()


g_is_running = True

def _is_target_running():
    global g_is_running

    state = dev.IsHalted()
    if state != g_is_running:
        log.info("Debug:: is_running %s" % state)
        g_is_running = state
    return 0 == g_is_running

def _end_debug_session(): 
    pass

def load_binary_file(f, a):
    with open(f, "rb") as fb:
        bootstrap_data = bytearray(fb.read())
    dev.Write(a, bootstrap_data, 0, len(bootstrap_data))

def writeBlock(adr,bytes,name):
    log.info("Section %s at %08x %d" % (name, adr,len(bytes)))
    dev.Write(adr,bytes,0,len(bytes))

def load_file_and_pc(binary_path):
    global l_bootstrap_entry, l_bootstrap_load
    bsLoad = l_bootstrap_load
    bsEntry = l_bootstrap_entry
    filetype = deb.PeekFileType(binary_path)
    if "hex" == filetype or "elf" == filetype:
        msg.print("Debug: Loading %s\n" % binary_path)
        deb.EnumCodeBlocks(binary_path, "writeBlock")
        bsEntry = deb.PeekSymbolAddress(binary_path,"__entry_address",True)
    else:
        try:
            l = settings.getString("boot.load_adr","").strip()
            if l != "":
                bsLoad = int(l,0)
            l = settings.getString("boot.entry_adr","").strip()
            if l != "":
                bsEntry = int(l,0)
        except:
            raise Exception("You need to specify a numeric load address and entry point address for bootstrap %s" % binary_path)
        msg.print("Debug: Loading %s as a binary file at address 0x%08x entry point 0x%08x\n" % (binary_path, bsLoad, bsEntry))
        if bsLoad == -1 or bsEntry == -1:
            raise Exception("You need to specify a numeric load and entry address for %s" % binary_path)
        load_binary_file(binary_path,  bsLoad)
    set_pc(bsEntry)

def load_and_run_bootstrap(l_bootstrap_bin):
    try:
        f = open(l_bootstrap_bin, "rb")
        f.close()
    except:
        msg.msg("Failed to open bootstrap file %s" % l_bootstrap_bin, "Error")
        raise Exception("Failed to open bootstrap file")
    load_file_and_pc(l_bootstrap_bin)
    dev.GoEx(1, 1)
    dev.Delay(1000000)
    for i in range(10):
        if dev.IsHalted():
            msg.print("Debug: boostrap has halted. Will load application.\n")
            return
        dev.Delay(100000)
    log.error("Debug: boostrap timed out")
    msg.showDialog(35, "Bootstrap timed out", "", "The specified bootstrap failed to configure the board. Please make sure you are using a bootstrap configured for your board.")
    raise Exception("bootstrap program did not halt")

def _debug_read(mt, start, length, data):
    try:
        dev.Read(start, data, 0, length)
    except:
        for i in range(len(data)):
            try:
                dev.Read(start + i, data, i, 1)
            except:
                data[i] = b'?'
                dev.Delay(reset_delay)
        log.info("Debug: an error occurred while reading address 0x%x length 0x%0x" % (start, length))

def _debug_write(mt, start, length, data):
    try:
        dev.Write(start, data, 0, length)
    except:
        for i in range(len(data)):
            try:
                dev.Write(start + i, data, i, 1)
            except:
                dev.Delay(reset_delay)
        log.info("Debug: an error occurred while writing address 0x%x length 0x%0x" % (start, length))

def _get_pc():
    return dev.ReadReg64(arm.PC)

def _hold_in_reset():
    pass

def _release_from_reset():
    pass

target_was_reset = False
debug_session  = True

def begin_communication_session(): #mplab
    log.info("Begin comm session")
    _begin_communication_session()

def end_communication_session(): #mplab
    log.info("End comm session")
    _end_communication_session()

def begin_programming_operation(): #mplab
    global debug_session
    log.info("Begin operations")
    debug_session = False
    _begin_programming_operation()

def erase(): #mplab
    log.info("Erase")
    _erase()

def prog_write(type_of_mem, address, length, data): #mplab
    log.info("Writing %08x bytes to address 0x%08x of %s memory" % (length, address, type_of_mem))
    _prog_write(type_of_mem, address, length, data)

def prog_read(type_of_mem, address, length, data): #mplab
    log.info("Reading %08x bytes from address 0x%08x of %s memory" % (length, address, type_of_mem))
    _prog_read(type_of_mem, address, length, data)

def end_of_operations():#mplab
    log.info("End of operations")
    _end_of_operations()

def begin_debug_session():  #mplab
    log.info("Debug: Init debug session")
    global debug_session
    debug_session = True
    _begin_debug_session()

def debug_read(mt, start, length, data):  #mplab
    log.info("Debug: Reading %08x bytes at start address 0x%08x (%s)" % (length, start, mt))
    _debug_read(mt, start, length, data)

def debug_write(mt, start, length, data):  #mplab
    log.info("Debug: Writing %08x bytes at start address 0x%08x (%s)" % (length, start, mt))
    _debug_write(mt, start, length, data)

def set_pc(pc):  #mplab
    log.info("Debug: set pc to 0x%08x" % pc)
    _set_pc(pc)

def get_pc():  #mplab
    pc = _get_pc()
    log.info("Debug: get_pc PC=0x%08x" % pc)
    return pc

def run_target():#mplab
    log.info("Debug: run target")
    _run_target()

_stealth_runstate = 2
def halt_target():  #mplab
    global _stealth_runstate    
    log.info("Debug: halt target")
    _stealth_runstate = 2  # cancels stealth mode
    _halt_target()

def step_target():  #mplab
    log.info("Debug: stepping at pc 0x%08x" % get_pc())
    _step_target()

def reset_target(): #mplab
    log.info("Debug: reset")
    _reset_target()
    on_after_reset() # call autoload hook

def is_target_running():#mplab
    global _stealth_runstate
    if _stealth_runstate == 2:
        return _is_target_running()
    return _stealth_runstate != 0

def on_after_reset(): 
    if not debug_session:
        return
    if not settings.getBool("arm.use_vtor", False):
        return
    vtor_name  = settings.getString("arm.vtor_adr", "0")

    vtor = -1
    try:
        vtor = int(vtor_name,0)
    except:
        try:
            vtor=deb.GetSymbolAddress(vtor_name)
        except:
            log.error("Debug: failed to compute location of VTOR")
            return
    load_vtor(vtor) 
    pass

def load_vtor(adr):
    try:
        pc = dev.Read32(adr + 4)
        sp = dev.Read32(adr)
        set_pc(pc)
        dev.WriteReg64(arm.SP,sp)
        log.info("Setting pc=%08x and sp=%08x" % (pc, sp))
    except:
        log.error("Debug: failed to set PC and SP to contents of exception_table")

def on_program_done():
    on_after_reset()

def end_debug_session():  #mplab
    log.info("Debug: End debug session")
    _end_debug_session()

def verify_transfer(type_of_mem, address, data, length):  #mplab
    log.info("Verifying %08x bytes to address 0x%0x of %s memory" % (length, address, type_of_mem))
    _verify_transfer(type_of_mem, address, data, length)

    

def _verify_transfer(type_of_mem, address, data, length):
    if len(data) != length:
        raise Exception("The given data and length mismatch")
    d = bytearray(length)
    prog_read(type_of_mem, address, length, d)
    if str(type_of_mem) == "Cfg":
        verify_config(address, data, d, "verify")
    else:
        for i in range(length):
            if data[i] != d[i]:
                raise Exception("Verify failed for mem type {}, at address 0x{:X}".format(str(type_of_mem), address + i))

global dev_cfg_masks_bytearray
dev_cfg_masks_bytearray = None

def init_masks_as_bytearray():
    global dev_cfg_masks_bytearray
    if dev_cfg_masks_bytearray:
        return
    dev_cfg_masks_bytearray = {}
    for address, val in dev_cfg_masks.items():
        dev_cfg_masks_bytearray[address    ] = int(val      ) & 0xFF
        dev_cfg_masks_bytearray[address + 1] = int(val >> 8 ) & 0xFF
        dev_cfg_masks_bytearray[address + 2] = int(val >> 16) & 0xFF
        dev_cfg_masks_bytearray[address + 3] = int(val >> 24) & 0xFF

def verify_config(address, expected, actual, error_string_prefix):
    try:
        # older versions of MPLAB X (<=v5.45) did not pass dev_cfg_masks
        # so very_config cannot be executed
        dev_cfg_masks 
    except:
        raise Exception("{} config is not implemented".format(error_string_prefix))
    init_masks_as_bytearray()

    for index, actual_val in enumerate(actual):
        current_address = address + index
        if current_address in dev_cfg_masks_bytearray:
            mask = dev_cfg_masks_bytearray[current_address]
            expected_val = expected[index] & mask
            actual_val &= mask
            if actual_val != expected_val:
                error_string = "{} failed at address 0x{:0X}, expected 0x{:0X}, got 0x{:0X}".format(error_string_prefix, current_address, expected_val, actual_val)
                raise Exception(error_string)

def is_memory_blank_all_ffs(type_of_mem):
    return str(type_of_mem) == "Pgm" or str(type_of_mem) == "UserID"
        
def blank_check():  #mplab
    log.info("Blank check")

def blank_check_mem(type_of_mem, address, length):  #mplab
    msg.print("Blank checking %08x bytes to address 0x%0x of %s memory" % (length, address, type_of_mem))
    _blank_check_mem(type_of_mem, address, length)

def _blank_check_mem(type_of_mem, address, length):
    data = bytearray(length)
    prog_read(type_of_mem, address, length, data)
    if str(type_of_mem) == "Cfg":
        prog_read(type_of_mem, address, length, data)
        verify_config(address, data, data, "blank check")
    elif is_memory_blank_all_ffs(type_of_mem):
        for index, x in enumerate(data):
            if x != 255:
                raise Exception("Blank failed for mem type {}, at address 0x{:X}".format(str(type_of_mem), address + index))
    else:
        log.error("Blank check, ignoring {}".format(str(type_of_mem)))

def hold_in_reset():  #mplab
    log.info("Hold in reset")
    _hold_in_reset()

def release_from_reset():  #mplab
    log.info("Release from reset")
    _release_from_reset()
    
def read_device_id():#mplab
    log.info("Read device ID")
    return _read_device_id()

import os
has_samba = os.path.isfile(os.path.join("samba.py"))
if has_samba:
    import samba
from xml.dom import minidom


class MemHandlers():
    def __init__(self, board_file):
        if has_samba:
            samba.log = log
            samba.msg = msg
            samba.dev = dev
            samba.is_target_running = is_target_running
            samba.run_target = run_target
            samba.architecture = architecture
            samba.arm = arm
        self.parse_board_file(board_file)

    def parse_board_file(self, board_file):
        self.handlers = []
        xmldoc = minidom.parse(board_file)
        rangeNodes = xmldoc.getElementsByTagName("range")
        for rangeNode in rangeNodes:
            start = int(rangeNode.getAttribute("start"), 0)
            end = int(rangeNode.getAttribute("end"), 0)
            type = rangeNode.getAttribute("type")
            config = {}
            for configNode in rangeNode.childNodes:
                if configNode.nodeType == configNode.ELEMENT_NODE:
                    try:
                        config[configNode.tagName] = int(configNode.firstChild.nodeValue, 0)
                    except:
                        config[configNode.tagName] = ide.expandProjectMacros("${ProjectName}", configNode.firstChild.nodeValue).replace("\\", os.path.sep)
            if type == "samba" and has_samba:
                self.handlers.append(samba.Samba(start, end, config))
            elif type == "user":
                self.handlers.append(UserHandler(start, end, config))

    def prog_write(self, type_of_mem, address, length, data):
        log.info("Prog: Writing %d bytes to address 0x%0x of %s memory" % (length, address, type_of_mem))
        global erase_as_needed
        remainings = [[address, address + length]]
        for handler in self.handlers:
            write_start = max(address, handler.range_start)
            write_end = min(address + length, handler.range_end)
            if write_start < write_end:
                # chop the data buffer and pass it to handler and run
                if erase_as_needed:
                    handler.erase(write_start - handler.range_start, write_end - write_start)
                handler.write(write_start - handler.range_start, data[write_start - address: write_end - address])
            new_remainings = []
            for remaining in remainings:
                write_start = max(remaining[0], handler.range_start)
                write_end = min(remaining[1], handler.range_end)
                if remaining[0] < write_start < remaining[1]:
                    new_remainings.append([remaining[0], write_start])
                if remaining[0] < write_end < remaining[1]:
                    new_remainings.append([write_end, remaining[1]])
                elif write_start < write_end < remaining[0] or remaining[1] < write_start < write_end or write_start > write_end:
                    new_remainings.append(remaining)
            remainings = new_remainings
        # now write to memory ranges that are not covered by handlers
        for remaining in remainings:
            _prog_write_internal(type_of_mem, remaining[0], remaining[1] - remaining[0], data[remaining[0] - address: remaining[1] - address])

    def prog_read(self, type_of_mem, address, length, data):
        log.info("Prog: Reading %d bytes to address 0x%0x of %s memory" % (length, address, type_of_mem))
        remainings = [[address, address + length]]
        for handler in self.handlers:
            read_start = max(address, handler.range_start)
            read_end = min(address + length, handler.range_end)
            if read_start < read_end:
                # chop the data buffer and pass it to handler and run
                buffer = bytearray(read_end - read_start)
                handler.read(read_start - handler.range_start, buffer)
                data[read_start - address: read_end - address] = buffer
            new_remainings = []
            for remaining in remainings:
                read_start = max(remaining[0], handler.range_start)
                read_end = min(remaining[1], handler.range_end)
                if remaining[0] < read_start < remaining[1]:
                    new_remainings.append([remaining[0], read_start])
                if remaining[0] < read_end < remaining[1]:
                    new_remainings.append([read_end, remaining[1]])
                elif read_start < read_end < remaining[0] or remaining[1] < read_start < read_end or read_start > read_end:
                    new_remainings.append(remaining)
            remainings = new_remainings
        # now write to memory ranges that are not covered by handlers
        for remaining in remainings:
            _prog_read_internal(type_of_mem, remaining[0], remaining[1] - remaining[0], data[remaining[0] - address: remaining[1] - address])

    def erase(self):
        log.info("Prog: Erasing memory")
        for handler in self.handlers:
            if handler.range_start < handler.range_end:
                handler.erase(0, handler.range_end - handler.range_start)


class UserHandler():
    def __init__(self, range_start, range_end, config):
        self.range_start = range_start
        self.range_end = range_end
        self.config = config

    def call(self, address=0, data=None):
        if "handler_name" in self.config.keys():
            eval(self.config["handler_name"])()
        else:
            log.info("The name of handler function is missing")


def _prog_write(type_of_mem, address, length, data):
    global mem_handlers
    if mem_handlers is None:
        _prog_write_internal(type_of_mem, address, length, data)
    else:
        mem_handlers.prog_write(type_of_mem, address, length, data)


def _prog_read(type_of_mem, address, length, data):
    global mem_handlers
    if mem_handlers is None:
        _prog_read_internal(type_of_mem, address, length, data)
    else:
        mem_handlers.prog_read(type_of_mem, address, length, data)


def _erase():
    global mem_handlers, erase_as_needed
    if mem_handlers is not None:
        mem_handlers.erase()
    _erase_internal()
    erase_as_needed = False  # tell prog_write not to erase rows prior to write


def init_mem_handlers():
    global mem_handlers
    mem_handlers = None
    try:
        board_file = ide.expandProjectMacros("${ProjectName}", settings.getString("loader.board_file", "${ProjectDir}/board.xboard"))
    except:
        board_file = "./board.xboard"
    if os.path.isfile(board_file):
        mem_handlers = MemHandlers(board_file)
