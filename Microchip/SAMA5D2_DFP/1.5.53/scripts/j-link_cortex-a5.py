# This file is autogenerated
comm_speed=2000000

def reset_peripherals():
    dev.WriteReg64(8, 0xd3)              # Disable all interrupts and go to supervisor mode
    dev.Write32(0xF8048000, 0xA5000004)  # Reset peripherals (using RSTC_CR)
    dev.Write32(0x00A00100, 0x0)         # Reset L2 Cache controller
    dev.Write32(0xF8048044, 0x00008000)  # Disable Watchdog (using WDT_MR)


printDebug = False     # set to True to print diagnostic info
logLevel = 0           # set to 1 to print diagnostic info

# The l_ variables are reinitialized at every debug session. They are used locally in this script and should not be overriden in autoload.py
l_use_bootstrap = 0
l_bootstrap_entry = -1
l_app_entry = -1
l_bootstrap_bin = ""
l_bootstrap_load = -1

def mplab_chooseBootstrap(self):
    project_dir = ide.expandProjectMacros("${ProjectName}", "${ProjectDir}")
    pdl = len(project_dir)
    fileChooser = JFileChooser(project_dir)
    retval = fileChooser.showOpenDialog(None)
    if retval == JFileChooser.APPROVE_OPTION:
        f = fileChooser.getSelectedFile().getPath()
        if 0==f.find(project_dir):
            f="${ProjectDir}" + f[pdl:]
        bsOpt.binTxt.text= f
        msg.print("Selected bootstrap binary: %s\n" % f)
        settings.setString("boot.path", f)

from javax.swing import JPanel, JLabel , JTextField, BoxLayout, JCheckBox, JButton,JFileChooser,GroupLayout
from java.awt import BorderLayout
class BootstrapPane():
    
    def __init__(self):
        self.panel = JPanel()
        self.panel.setLayout(BorderLayout())
        
        self.pane = JPanel()
        self.initUI()

    def initUI(self):
    
        layout = GroupLayout(self.pane)
        self.pane.setLayout(layout)
        layout.setAutoCreateGaps(True)
        layout.setAutoCreateContainerGaps(True)

        bc = settings.getBool("boot.use", False)
        self.useBs = JCheckBox("Use bootstrap",bc)
        binLabel = JLabel("Bootstrap file: ")
        self.binTxt = JTextField()
        self.binTxt.text = settings.getString("boot.path", "")
        self.binBtn = JButton("Load", actionPerformed=mplab_chooseBootstrap)

        entryLabel = JLabel("Bootstrap entry address (if bin): ")
        self.entryTxt = JTextField()
        self.entryTxt.text = settings.getString("boot.entry_adr", "")
        
        prjLabel = JLabel("Bootstrap project: ")
        self.prjTxt = JTextField()
        self.prjTxt.text = settings.getString("boot.prj", "")
        
        loadLabel=JLabel("Bootstrap load address (if bin): ")

        self.loadTxt = JTextField()
        self.loadTxt.text = settings.getString("boot.load_adr", "")

        layout.setHorizontalGroup(layout.createSequentialGroup()
            .addGroup(layout.createParallelGroup()
                .addComponent(self.useBs)
                .addComponent(prjLabel)
                .addComponent(binLabel)
                .addComponent(entryLabel)
                .addComponent(loadLabel)
                )
            .addGroup(layout.createParallelGroup()
#                .addComponent(self.useBs)
                .addComponent(self.prjTxt)
                .addComponent(self.binTxt)
                .addComponent(self.entryTxt)
                .addComponent(self.loadTxt)
                )
            .addGroup(layout.createParallelGroup()
                .addComponent(self.binBtn)
            )
        )

        layout.setVerticalGroup(layout.createSequentialGroup()
            .addGroup(layout.createParallelGroup()
                .addComponent(self.useBs)
            )
            .addGroup(layout.createParallelGroup()
                .addComponent(prjLabel)
                .addComponent(self.prjTxt, GroupLayout.PREFERRED_SIZE, GroupLayout.DEFAULT_SIZE,GroupLayout.PREFERRED_SIZE)
            )
            .addGroup(layout.createParallelGroup()
                .addComponent(binLabel)
                .addComponent(self.binTxt, GroupLayout.PREFERRED_SIZE, GroupLayout.DEFAULT_SIZE,GroupLayout.PREFERRED_SIZE)
                .addComponent(self.binBtn)
                )
            .addGroup(layout.createParallelGroup()
                .addComponent(entryLabel)
                .addComponent(self.entryTxt, GroupLayout.PREFERRED_SIZE, GroupLayout.DEFAULT_SIZE,GroupLayout.PREFERRED_SIZE)
            )
            .addGroup(layout.createParallelGroup()
                .addComponent(loadLabel)
                .addComponent(self.loadTxt, GroupLayout.PREFERRED_SIZE, GroupLayout.DEFAULT_SIZE,GroupLayout.PREFERRED_SIZE)
            )
        )
        self.panel.add(self.pane,BorderLayout.CENTER)

    def getPanel(self):
        return self.panel

bsOpt = None
def mplab_configure_Bootstrap(confName):
    global bsOpt
    if bsOpt == None:
        bsOpt=BootstrapPane()
    return bsOpt.getPanel()

def save_mplab_configure_Bootstrap(confName):
    global bsOpt
    if bsOpt == None:
        return

    settings.setString("boot.path", bsOpt.binTxt.getText())
    settings.setString("boot.prj", bsOpt.prjTxt.getText())
    settings.setString("boot.load_adr", bsOpt.loadTxt.getText())
    settings.setString("boot.entry_adr", bsOpt.entryTxt.getText())      
    settings.setString("boot.use",  "true" if bsOpt.useBs.isSelected() else "false")

def onShowPropsDFP2(t):
    ide.addPropCategory(t,"diagnostics" , "*|programoptions", "Diagnostics")
    ide.addBooleanProperty(t,"script.show_output" , "*|diagnostics|*","Output diagnostic logging","Show diagnostic text in the Output window", False)
    ide.addTextProperty(t,"script.log_level" , "*|diagnostics|*","Diagnostic log level","Set diagnostic level (usually 0 1 or 3)", "1")
    ide.addTextProperty(t,"script.reset_delay" , "*|diagnostics|*","Additional delay after reset","Enter additional RST settling delay in msec", "0")
    ide.addBooleanProperty(t,"script.has_reset" , "*|diagnostics|*","Uncheck if RESET line is not wired","Normally checked. Uncheck if the target does not have RST connected to the debugger", True)


def connect():
    global comm_speed,comm_iface
    comm_iface = settings.getString("communication.interface", "swd") == "swd"
    comm_speed = settings.getNumeric("communication.frequency", comm_speed)
    dev.Connect(comm_iface, comm_speed)

reset_delay=1000
has_reset=True

def _begin_communication_session():    
    global comm_speed,comm_iface,has_reset,reset_delay,_stealth_runstate
    global logLevel,printDebug,has_reset
    logLevel  = settings.getNumeric("script.log_level",logLevel)
    printDebug= settings.getBool("script.show_output",printDebug)
    has_reset  = settings.getBool("script.has_reset",has_reset)
    reset_delay = settings.getNumeric("script.reset_delay",reset_delay)
    _stealth_runstate = 2
    if reset_delay < 1:
        reset_delay = 1

    dev.SetApiLogging(logLevel)
    log.setShowOutput(printDebug)

    if has_reset and settings.getBool("programoptions.resetafterprogram", False): 
        dev.Pins(0, dev.RESET, 1000)
        dev.Delay(reset_delay)
        dev.Pins(dev.RESET, dev.RESET, 1000)  # now float reset back
        dev.Delay(reset_delay)
    
    connect()
    halt_target()
    reset_peripherals()

    global l_use_bootstrap, l_app_entry, l_bootstrap_entry, l_bootstrap_bin, l_bootstrap_load
    l_app_entry = -1
    l_use_bootstrap = settings.getBool("boot.use",False)
    l_bootstrap_bin = settings.getString("boot.path","")  
    prj = settings.getString("boot.prj","")
    if prj == "":
        prj="${ProjectName}"
    if l_use_bootstrap:
        l_bootstrap_bin = ide.expandProjectMacros(prj,l_bootstrap_bin)

    # handle legacy way of setting variables
    try:
        l_use_bootstrap = True if g_mpu_config['type'] == 'application'  else False
        l_app_entry = g_mpu_config['entry_addr']
        if l_use_bootstrap:
            l_bootstrap_load = l_bootstrap_entry = g_mpu_config['bootstrap_entry_addr']
            l_bootstrap_bin  = g_mpu_config['bootstrap_bin_path']
    except:
        pass
    
    if l_app_entry == -1:
        l_app_entry = deb.GetSpecialSymbolAddress("__entry_address")
    if l_use_bootstrap != 0:
        load_and_run_bootstrap(l_bootstrap_bin)
    

def _end_communication_session(): 
    pass

def _erase(): 
    pass

def _begin_programming_operation():
    pass

def _prog_write(type_of_mem, address, length, data): 
    global l_app_entry

    if l_app_entry == 0x7fffffffffffffffL:
        l_app_entry = address # hack when we dont have a known entry point, use first write
    
    dev.Write(address, data, 0, length)
    verLen = 256  # verify a few bytes
    if verLen > length:
        verLen = length

    rdb = bytearray(verLen)
    dev.Read(address,rdb, 0, verLen)
    for i in range(0,verLen):
        if rdb[i] != data[i]:
            log.error("The programmed bytes do not verify. Please check that your bootloader is working correctly.")
            raise  Exception("Verify error")


def _prog_read(type_of_mem, address, length, data):    
    dev.Read(address, data, 0, length)

def _end_of_operations():
    set_pc_to_appstart()

def set_pc_to_appstart():
    if l_app_entry != -1:
        dev.WriteReg64(arm.PC, l_app_entry)

def _begin_debug_session():
    halt_and_reset()

def get_pc():
    pc = dev.ReadReg64(arm.PC)
    log.info("Debug: get_pc PC=0x%08x" % pc)
    return pc


def _run_target():
    dev.GoEx(1, 1)

def _halt_target():
    dev.Halt()

def _step_target():
    dev.Step()

def _set_pc(pc):
    dev.WriteReg64(arm.PC, pc)

def _reset_target():
    msg.msg("The reset button will only set PC to application start. For a full reset, please press the Reset button and restart the debug session.", "Reset")
    halt_and_reset()

def halt_and_reset():
    if not dev.IsHalted():
        halt_target()
    set_pc_to_appstart()


g_is_running = True

def _is_target_running():
    global g_is_running

    state = dev.IsHalted()
    if state != g_is_running:
        log.info("Debug:: is_running %s" % state)
        g_is_running = state
    return 0 == g_is_running

def _end_debug_session(): 
    dev.Disconnect()

def load_binary_file(f, a):
    with open(f, "rb") as fb:
        bootstrap_data = bytearray(fb.read())
    dev.Write(a, bootstrap_data, 0, len(bootstrap_data))

def writeBlock(adr,bytes,name):
    log.info("Section %s at %08x %d" % (name, adr,len(bytes)))
    dev.Write(adr,bytes,0,len(bytes))

def load_file_and_pc(binary_path):
    global l_bootstrap_entry, l_bootstrap_load
    bsLoad = l_bootstrap_load
    bsEntry = l_bootstrap_entry
    filetype = deb.PeekFileType(binary_path)
    if "hex" == filetype or "elf" == filetype:
        msg.print("Debug: Loading %s\n" % binary_path)
        deb.EnumCodeBlocks(binary_path, "writeBlock")
        bsEntry = deb.PeekSymbolAddress(binary_path,"__entry_address",True)
    else:
        try:
            l = settings.getString("boot.load_adr","").strip()
            if l != "":
                bsLoad = int(l,0)
            l = settings.getString("boot.entry_adr","").strip()
            if l != "":
                bsEntry = int(l,0)
        except:
            raise Exception("You need to specify a numeric load address and entry point address for bootstrap %s" % binary_path)
        msg.print("Debug: Loading %s as a binary file at address 0x%08x entry point 0x%08x\n" % (binary_path, bsLoad, bsEntry))
        if bsLoad == -1 or bsEntry == -1:
            raise Exception("You need to specify a numeric load and entry address for %s" % binary_path)
        load_binary_file(binary_path,  bsLoad)
    set_pc(bsEntry)

def load_and_run_bootstrap(l_bootstrap_bin):
    try:
        f = open(l_bootstrap_bin, "rb")
        f.close()
    except:
        msg.msg("Failed to open bootstrap file %s" % l_bootstrap_bin, "Error")
        raise Exception("Failed to open bootstrap file")
    load_file_and_pc(l_bootstrap_bin)
    dev.GoEx(1, 1)
    dev.Delay(1000000)
    for i in range(10):
        if dev.IsHalted():
            msg.print("Debug: boostrap has halted. Will load application.\n")
            return
        dev.Delay(100000)
    log.error("Debug: boostrap timed out")
    #raise Exception("bootstrap program did not halt ")


def _debug_read(mem_type, start, length, data):
    dev.Read(start, data, 0, length)

def _debug_write(mt, start, length, data):
    dev.Write(start, data, 0, length)

def _get_pc():
    return dev.ReadReg64(arm.PC)

def _hold_in_reset():
    pass

def _release_from_reset():
    pass

def _read_device_id():
    pass

def begin_communication_session(): #mplab
    log.info("Begin comm session")
    _begin_communication_session()

def end_communication_session(): #mplab
    log.info("End comm session")
    _end_communication_session()

def begin_programming_operation(): #mplab
    log.info("Begin operations")
    _begin_programming_operation()

def read_device_id():#mplab
    log.info("Read device ID")
    return _read_device_id()

def erase(): #mplab
    log.info("Erase")
    _erase()

def prog_write(type_of_mem, address, length, data): #mplab
    log.info("Writing %08x bytes to address 0x%08x of %s memory" % (length, address, type_of_mem))
    _prog_write(type_of_mem, address, length, data)

def prog_read(type_of_mem, address, length, data): #mplab
    log.info("Reading %08x bytes from address 0x%08x of %s memory" % (length, address, type_of_mem))
    _prog_read(type_of_mem, address, length, data)

def end_of_operations():#mplab
    log.info("End of operations")
    _end_of_operations()

def begin_debug_session():  #mplab
    log.info("Debug: Init debug session")
    _begin_debug_session()

def debug_read(mt, start, length, data):  #mplab
    log.info("Debug: Reading %08x bytes at start address 0x%08x (%s)" % (length, start, mt))
    _debug_read(mt, start, length, data)

def debug_write(mt, start, length, data):  #mplab
    log.info("Debug: Writing %08x bytes at start address 0x%08x (%s)" % (length, start, mt))
    _debug_write(mt, start, length, data)

def set_pc(pc):  #mplab
    log.info("Debug: set pc to 0x%08x" % pc)
    _set_pc(pc)

def get_pc():  #mplab
    pc = _get_pc()
    log.info("Debug: get_pc PC=0x%08x" % pc)
    return pc

def run_target():#mplab
    log.info("Debug: run target")
    _run_target()

_stealth_runstate = 2
def halt_target():  #mplab
    global _stealth_runstate    
    log.info("Debug: halt target")
    _stealth_runstate = 2  # cancels stealth mode
    _halt_target()

def step_target():  #mplab
    log.info("Debug: stepping at pc 0x%08x" % get_pc())
    _step_target()

def reset_target(): #mplab
    log.info("Debug: reset")
    _reset_target()
    on_after_reset() # call autoload hook

def is_target_running():#mplab
    global _stealth_runstate
    if _stealth_runstate == 2:
        return _is_target_running()
    return _stealth_runstate != 0

def on_after_reset(): 
    if not settings.getBool("arm.use_vtor", False):
        return
    vtor_name  = settings.getString("arm.vtor_adr", "0")

    vtor = -1
    try:
        vtor = int(vtor_name,0)
    except:
        try:
            vtor=deb.GetSymbolAddress(vtor_name)
        except:
            log.error("Debug: failed to compute location of VTOR")
            return
    load_vtor(vtor) 
    pass

def load_vtor(adr):
    try:
        pc = dev.Read32(adr + 4)
        sp = dev.Read32(adr)
        set_pc(arm.PC,pc)
        dev.WriteReg64(arm.SP,sp)
        log.info("Setting pc=%08x and sp=%08x" % (pc, sp))
    except:
        log.error("Debug: failed to set PC and SP to contents of exception_table")

def on_program_done():
    on_after_reset()

def end_debug_session():  #mplab
    log.info("Debug: End debug session")
    _end_debug_session()

def verify_transfer(type_of_mem, address, data, length):  #mplab
    log.error("Not-implemented Verifying %08x bytes to address 0x%0x of %s memory" % (length, address, type_of_mem))
    return True

def blank_check():  #mplab
    log.info("Blank check")

def hold_in_reset():  #mplab
    log.info("Hold in reset")
    _hold_in_reset()

def release_from_reset():  #mplab
    log.info("Release from reset")
    _release_from_reset()
    
