<?xml version="1.0" encoding="UTF-8"?>
<avr-tools-device-file xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" schema-version="4.3" xsi:noNamespaceSchemaLocation="../../schema/avr_tools_device_file.xsd">
  <file timestamp="2021-05-26T17:25:30Z"/>
  <variants>
    <variant ordercode="CEC1736-S0-I/2ZW" package="WFBGA84" pinout="CEC1736_S0_2ZW" speedmax="96000000" tempmax="+85" tempmin="-40" vccmax="3.63" vccmin="3.135"/>
  </variants>
  <devices>
    <device name="CEC1736_S0_2ZW" architecture="CORTEX-M4" family="CEC173X" series="CEC">
      <address-spaces>
        <address-space id="base" name="base" start="0" size="0x100000000" endianness="little">
          <memory-segment name="CODE_SRAM" start="0x000C8000" size="0x50000" type="ram" rw="RW" exec="true"/>
          <memory-segment name="DATA_SRAM" start="0x00118000" size="0x10000" type="ram" rw="RW"/>
          <memory-segment name="DATA_SRAM2" start="0x00128000" size="0x10000" type="ram" rw="RW"/>
          <memory-segment name="DATA_SRAM3" start="0x00138000" size="0x10000" type="ram" rw="RW"/>
          <memory-segment name="DATA_SRAM_ALIAS" start="0x20000000" size="0x8000" type="ram" rw="RW"/>
          <memory-segment name="EC_DEVICE_REGISTERS" start="0x40000000" size="0x80000" type="io" rw="RW"/>
          <memory-segment name="GPIO_REGISTERS" start="0x40080000" size="0x10000" type="io" rw="RW"/>
          <memory-segment name="HOST_DEVICE_REGISTERS" start="0x400F0000" size="0x100000" type="io" rw="RW"/>
          <memory-segment name="CRYPTO_RAM" start="0x40100000" size="0x6000" type="ram" rw="R"/>
          <memory-segment name="SCS" start="0xE000E000" size="0x00001000" type="io" rw="RW"/>
          <memory-segment name="EXTERNAL_FLASH" start="0x50000000" size="0x8000000" type="flash" rw="RW" external="true" exec="true"/>
        </address-space>
      </address-spaces>
      <parameters>
        <param name="__FPU_PRESENT" value="1" caption="FPU present"/>
        <param name="__MPU_PRESENT" value="1" caption="MPU present"/>
        <param name="__CM4_REV" value="0x0100" caption="CM4 Core Revision"/>
        <param name="__NVIC_PRIO_BITS" value="3" caption="Number of Bits used for Priority Levels"/>
        <param name="__Vendor_SysTickConfig" value="0" caption="Set to 1 if different SysTick Config is used"/>
        <param name="__VTOR_PRESENT" value="1" caption="Vector Table Offset Regisrer present or not"/>
        <param name="__ARCH_ARM" value="1"/>
        <param name="__ARCH_ARM_CORTEX_M" value="1"/>
        <param name="LITTLE_ENDIAN" value="1"/>
        <param name="EXTERNAL_APPLICATION_FLASH" value="1"/>
        <param name="__REVID" value="1"/>
      </parameters>
      <peripherals>
        <module name="PCR" id="100" version="1.0">
          <instance name="PCR">
            <register-group name="PCR" name-in-module="PCR" address-space="base" offset="0x40080100"/>
            <signals>
              <signal group="nRESET_IN" function="A" pad="nRESET_IN"/>
              <signal group="VCC_PWRGD" function="B" pad="GPIO057"/>
              <signal group="CLK32KHZ_IN" function="B" pad="GPIO130"/>
              <signal group="CLK32KHZ_OUT" function="B" pad="GPIO201"/>
              <signal group="TST_CLK_OUT" function="B" pad="GPIO253"/>
            </signals>
          </instance>
        </module>
        <module name="DMA_MAIN" id="85a" version="1.0">
          <instance name="DMA_MAIN">
            <register-group name="DMA_MAIN" name-in-module="DMA_MAIN" address-space="base" offset="0x40002400"/>
          </instance>
        </module>
        <module name="DMA_CHAN00" id="85b" version="1.0">
          <instance name="DMA_CHAN00">
            <register-group name="DMA_CHAN00" name-in-module="DMA_CHAN00" address-space="base" offset="0x40002440"/>
          </instance>
        </module>
        <module name="DMA_CHAN01" id="85c" version="1.0">
          <instance name="DMA_CHAN01">
            <register-group name="DMA_CHAN01" name-in-module="DMA_CHAN01" address-space="base" offset="0x40002480"/>
          </instance>
        </module>
        <module name="DMA_CHAN02" id="85d" version="1.0">
          <instance name="DMA_CHAN02">
            <register-group name="DMA_CHAN02" name-in-module="DMA_CHAN02" address-space="base" offset="0x400024C0"/>
          </instance>
          <instance name="DMA_CHAN03">
            <register-group name="DMA_CHAN03" name-in-module="DMA_CHAN02" address-space="base" offset="0x40002500"/>
          </instance>
          <instance name="DMA_CHAN04">
            <register-group name="DMA_CHAN04" name-in-module="DMA_CHAN02" address-space="base" offset="0x40002540"/>
          </instance>
          <instance name="DMA_CHAN05">
            <register-group name="DMA_CHAN05" name-in-module="DMA_CHAN02" address-space="base" offset="0x40002580"/>
          </instance>
          <instance name="DMA_CHAN06">
            <register-group name="DMA_CHAN06" name-in-module="DMA_CHAN02" address-space="base" offset="0x400025C0"/>
          </instance>
          <instance name="DMA_CHAN07">
            <register-group name="DMA_CHAN07" name-in-module="DMA_CHAN02" address-space="base" offset="0x40002600"/>
          </instance>
          <instance name="DMA_CHAN08">
            <register-group name="DMA_CHAN08" name-in-module="DMA_CHAN02" address-space="base" offset="0x40002640"/>
          </instance>
          <instance name="DMA_CHAN09">
            <register-group name="DMA_CHAN09" name-in-module="DMA_CHAN02" address-space="base" offset="0x40002680"/>
          </instance>
        </module>
        <module name="ECIA" id="200" version="1.0">
          <instance name="ECIA">
            <register-group name="ECIA" name-in-module="ECIA" address-space="base" offset="0x4000E000"/>
          </instance>
        </module>
        <module name="GCR" id="101" version="1.0">
          <instance name="GCR">
            <register-group name="GCR" name-in-module="GCR" address-space="base" offset="0x400FFF00"/>
          </instance>
        </module>
        <module name="UART" id="39" version="1.0">
          <instance name="UART0">
            <register-group name="UART0" name-in-module="UART" address-space="base" offset="0x4000C400"/>
            <signals>
              <signal group="UART0_TX" function="B" pad="GPIO104"/>
              <signal group="UART0_RX" function="B" pad="GPIO105"/>
            </signals>
          </instance>
        </module>
        <module name="GPIO" id="26" version="1.0">
          <instance name="GPIO">
            <register-group name="GPIO" name-in-module="GPIO" address-space="base" offset="0x40081000"/>
            <signals>
              <signal group="GPIO000" function="default" pad="GPIO000"/>
              <signal group="GPIO002" function="default" pad="GPIO002"/>
              <signal group="GPIO003" function="default" pad="GPIO003"/>
              <signal group="GPIO004" function="default" pad="GPIO004"/>
              <signal group="GPIO012" function="default" pad="GPIO012"/>
              <signal group="GPIO013" function="default" pad="GPIO013"/>
              <signal group="GPIO015" function="default" pad="GPIO015"/>
              <signal group="GPIO016" function="default" pad="GPIO016"/>
              <signal group="GPIO020" function="default" pad="GPIO020"/>
              <signal group="GPIO021" function="default" pad="GPIO021"/>
              <signal group="GPIO022" function="default" pad="GPIO022"/>
              <signal group="GPIO023" function="default" pad="GPIO023"/>
              <signal group="GPIO024" function="default" pad="GPIO024"/>
              <signal group="GPIO026" function="default" pad="GPIO026"/>
              <signal group="GPIO027" function="default" pad="GPIO027"/>
              <signal group="GPIO030" function="default" pad="GPIO030"/>
              <signal group="GPIO031" function="default" pad="GPIO031"/>
              <signal group="GPIO032" function="default" pad="GPIO032"/>
              <signal group="GPIO033" function="default" pad="GPIO033"/>
              <signal group="GPIO034" function="default" pad="GPIO034"/>
              <signal group="GPIO045" function="default" pad="GPIO045"/>
              <signal group="GPIO046" function="default" pad="GPIO046"/>
              <signal group="GPIO047" function="default" pad="GPIO047"/>
              <signal group="GPIO050" function="default" pad="GPIO050"/>
              <signal group="GPIO053" function="default" pad="GPIO053"/>
              <signal group="GPIO055" function="default" pad="GPIO055"/>
              <signal group="GPIO056" function="default" pad="GPIO056"/>
              <signal group="GPIO057" function="default" pad="GPIO057"/>
              <signal group="GPIO063" function="default" pad="GPIO063"/>
              <signal group="GPIO070" function="default" pad="GPIO070"/>
              <signal group="GPIO071" function="default" pad="GPIO071"/>
              <signal group="GPIO104" function="default" pad="GPIO104"/>
              <signal group="GPIO105" function="default" pad="GPIO105"/>
              <signal group="GPIO106" function="default" pad="GPIO106"/>
              <signal group="GPIO107" function="default" pad="GPIO107"/>
              <signal group="GPIO112" function="default" pad="GPIO112"/>
              <signal group="GPIO113" function="default" pad="GPIO113"/>
              <signal group="GPIO120" function="default" pad="GPIO120"/>
              <signal group="GPIO121" function="default" pad="GPIO121"/>
              <signal group="GPIO122" function="default" pad="GPIO122"/>
              <signal group="GPIO123" function="default" pad="GPIO123"/>
              <signal group="GPIO124" function="default" pad="GPIO124"/>
              <signal group="GPIO125" function="default" pad="GPIO125"/>
              <signal group="GPIO126" function="default" pad="GPIO126"/>
              <signal group="GPIO127" function="default" pad="GPIO127"/>
              <signal group="GPIO130" function="default" pad="GPIO130"/>
              <signal group="GPIO131" function="default" pad="GPIO131"/>
              <signal group="GPIO132" function="default" pad="GPIO132"/>
              <signal group="GPIO140" function="default" pad="GPIO140"/>
              <signal group="GPIO143" function="default" pad="GPIO143"/>
              <signal group="GPIO144" function="default" pad="GPIO144"/>
              <signal group="GPIO145" function="default" pad="GPIO145"/>
              <signal group="GPIO146" function="default" pad="GPIO146"/>
              <signal group="GPIO147" function="default" pad="GPIO147"/>
              <signal group="GPIO150" function="default" pad="GPIO150"/>
              <signal group="GPIO156" function="default" pad="GPIO156"/>
              <signal group="GPIO157" function="default" pad="GPIO157"/>
              <signal group="GPIO163" function="default" pad="GPIO163"/>
              <signal group="GPIO165" function="default" pad="GPIO165"/>
              <signal group="GPIO170" function="default" pad="GPIO170"/>
              <signal group="GPIO171" function="default" pad="GPIO171"/>
              <signal group="GPIO200" function="default" pad="GPIO200"/>
              <signal group="GPIO201" function="default" pad="GPIO201"/>
              <signal group="GPIO202" function="default" pad="GPIO202"/>
              <signal group="GPIO203" function="default" pad="GPIO203"/>
              <signal group="GPIO204" function="default" pad="GPIO204"/>
              <signal group="GPIO223" function="default" pad="GPIO223"/>
              <signal group="GPIO224" function="default" pad="GPIO224"/>
              <signal group="GPIO227" function="default" pad="GPIO227"/>
              <signal group="GPIO250" function="default" pad="GPIO250"/>
              <signal group="GPIO253" function="default" pad="GPIO253"/>
            </signals>
          </instance>
        </module>
        <module name="WDT" id="88" version="1.0">
          <instance name="WDT">
            <register-group name="WDT" name-in-module="WDT" address-space="base" offset="0x40000400"/>
          </instance>
        </module>
        <module name="TIMER32" id="108b" version="1.0">
          <instance name="TIMER32_0">
            <register-group name="TIMER32_0" name-in-module="TIMER32" address-space="base" offset="0x40000C80"/>
          </instance>
          <instance name="TIMER32_1">
            <register-group name="TIMER32_1" name-in-module="TIMER32" address-space="base" offset="0x40000CA0"/>
          </instance>
        </module>
        <module name="CCT" id="12" version="1.0">
          <instance name="CCT">
            <register-group name="CCT" name-in-module="CCT" address-space="base" offset="0x40001000"/>
            <signals>
              <signal group="ICT10" function="C" pad="GPIO015"/>
              <signal group="ICT0" function="B" pad="GPIO050"/>
              <signal group="ICT9" function="B" pad="GPIO113"/>
            </signals>
          </instance>
        </module>
        <module name="HTM" id="29" version="1.0">
          <instance name="HTM0">
            <register-group name="HTM0" name-in-module="HTM" address-space="base" offset="0x40009800"/>
          </instance>
          <instance name="HTM1">
            <register-group name="HTM1" name-in-module="HTM" address-space="base" offset="0x40009820"/>
          </instance>
        </module>
        <module name="RTOS" id="140" version="1.0">
          <instance name="RTOS">
            <register-group name="RTOS" name-in-module="RTOS" address-space="base" offset="0x40007400"/>
          </instance>
        </module>
        <module name="PWM" id="54" version="1.0">
          <instance name="PWM0">
            <register-group name="PWM0" name-in-module="PWM" address-space="base" offset="0x40005800"/>
            <signals>
              <signal group="PWM0" function="B" pad="GPIO053"/>
            </signals>
          </instance>
        </module>
        <module name="LED" id="111" version="1.0">
          <instance name="LED0">
            <register-group name="LED0" name-in-module="LED" address-space="base" offset="0x4000B800"/>
            <signals>
              <signal group="LED0" function="B" pad="GPIO156"/>
            </signals>
          </instance>
          <instance name="LED1">
            <register-group name="LED1" name-in-module="LED" address-space="base" offset="0x4000B900"/>
            <signals>
              <signal group="LED1" function="B" pad="GPIO157"/>
            </signals>
          </instance>
        </module>
        <module name="SMB" id="31" version="1.0">
          <instance name="SMB0">
            <register-group name="SMB0" name-in-module="SMB" address-space="base" offset="0x40004000"/>
            <signals>
              <signal group="SDA" index="0" function="B" pad="GPIO003"/>
              <signal group="SCL" index="0" function="B" pad="GPIO004"/>
              <signal group="SDA" index="4" function="B" pad="GPIO143"/>
              <signal group="SCL" index="4" function="B" pad="GPIO144"/>
              <signal group="SDA" index="6" function="B" pad="GPIO132"/>
              <signal group="SCL" index="6" function="B" pad="GPIO140"/>
              <signal group="SDA" index="9" function="B" pad="GPIO145"/>
              <signal group="SCL" index="9" function="B" pad="GPIO146"/>
              <signal group="SDA" index="10" function="B" pad="GPIO030"/>
              <signal group="SCL" index="10" function="B" pad="GPIO107"/>
              <signal group="SDA" index="15" function="B" pad="GPIO147"/>
              <signal group="SCL" index="15" function="B" pad="GPIO150"/>
            </signals>
          </instance>
          <instance name="SMB1">
            <register-group name="SMB1" name-in-module="SMB" address-space="base" offset="0x40004400"/>
            <signals>
              <signal group="SDA" index="0" function="B" pad="GPIO003"/>
              <signal group="SCL" index="0" function="B" pad="GPIO004"/>
              <signal group="SDA" index="4" function="B" pad="GPIO143"/>
              <signal group="SCL" index="4" function="B" pad="GPIO144"/>
              <signal group="SDA" index="6" function="B" pad="GPIO132"/>
              <signal group="SCL" index="6" function="B" pad="GPIO140"/>
              <signal group="SDA" index="9" function="B" pad="GPIO145"/>
              <signal group="SCL" index="9" function="B" pad="GPIO146"/>
              <signal group="SDA" index="10" function="B" pad="GPIO030"/>
              <signal group="SCL" index="10" function="B" pad="GPIO107"/>
              <signal group="SDA" index="15" function="B" pad="GPIO147"/>
              <signal group="SCL" index="15" function="B" pad="GPIO150"/>
            </signals>
          </instance>
          <instance name="SMB2">
            <register-group name="SMB2" name-in-module="SMB" address-space="base" offset="0x40004800"/>
            <signals>
              <signal group="SDA" index="0" function="B" pad="GPIO003"/>
              <signal group="SCL" index="0" function="B" pad="GPIO004"/>
              <signal group="SDA" index="4" function="B" pad="GPIO143"/>
              <signal group="SCL" index="4" function="B" pad="GPIO144"/>
              <signal group="SDA" index="6" function="B" pad="GPIO132"/>
              <signal group="SCL" index="6" function="B" pad="GPIO140"/>
              <signal group="SDA" index="9" function="B" pad="GPIO145"/>
              <signal group="SCL" index="9" function="B" pad="GPIO146"/>
              <signal group="SDA" index="10" function="B" pad="GPIO030"/>
              <signal group="SCL" index="10" function="B" pad="GPIO107"/>
              <signal group="SDA" index="15" function="B" pad="GPIO147"/>
              <signal group="SCL" index="15" function="B" pad="GPIO150"/>
            </signals>
          </instance>
          <instance name="SMB3">
            <register-group name="SMB3" name-in-module="SMB" address-space="base" offset="0x40004C00"/>
            <signals>
              <signal group="SDA" index="0" function="B" pad="GPIO003"/>
              <signal group="SCL" index="0" function="B" pad="GPIO004"/>
              <signal group="SDA" index="4" function="B" pad="GPIO143"/>
              <signal group="SCL" index="4" function="B" pad="GPIO144"/>
              <signal group="SDA" index="6" function="B" pad="GPIO132"/>
              <signal group="SCL" index="6" function="B" pad="GPIO140"/>
              <signal group="SDA" index="9" function="B" pad="GPIO145"/>
              <signal group="SCL" index="9" function="B" pad="GPIO146"/>
              <signal group="SDA" index="10" function="B" pad="GPIO030"/>
              <signal group="SCL" index="10" function="B" pad="GPIO107"/>
              <signal group="SDA" index="15" function="B" pad="GPIO147"/>
              <signal group="SCL" index="15" function="B" pad="GPIO150"/>
            </signals>
          </instance>
          <instance name="SMB4">
            <register-group name="SMB4" name-in-module="SMB" address-space="base" offset="0x40005000"/>
            <signals>
              <signal group="SDA" index="0" function="B" pad="GPIO003"/>
              <signal group="SCL" index="0" function="B" pad="GPIO004"/>
              <signal group="SDA" index="4" function="B" pad="GPIO143"/>
              <signal group="SCL" index="4" function="B" pad="GPIO144"/>
              <signal group="SDA" index="6" function="B" pad="GPIO132"/>
              <signal group="SCL" index="6" function="B" pad="GPIO140"/>
              <signal group="SDA" index="9" function="B" pad="GPIO145"/>
              <signal group="SCL" index="9" function="B" pad="GPIO146"/>
              <signal group="SDA" index="10" function="B" pad="GPIO030"/>
              <signal group="SCL" index="10" function="B" pad="GPIO107"/>
              <signal group="SDA" index="15" function="B" pad="GPIO147"/>
              <signal group="SCL" index="15" function="B" pad="GPIO150"/>
            </signals>
          </instance>
        </module>
        <module name="QMSPI" id="147" version="1.0">
          <instance name="QMSPI0">
            <register-group name="QMSPI0" name-in-module="QMSPI" address-space="base" offset="0x40070000"/>
            <signals>
              <signal group="QSPI0_CLK" function="B" pad="GPIO056"/>
              <signal group="QSPI0_CS0_n" function="B" pad="GPIO055"/>
              <signal group="QSPI0_CS1_n" function="B" pad="GPIO002"/>
              <signal group="QSPI0_IO0" function="B" pad="GPIO223"/>
              <signal group="QSPI0_IO1" function="B" pad="GPIO224"/>
              <signal group="QSPI0_IO2" function="B" pad="GPIO227"/>
              <signal group="QSPI0_IO3" function="B" pad="GPIO016"/>
              <signal group="QSPI0_IN_CLK" function="B" pad="GPIO204"/>
              <signal group="QSPI0_IN_CS0_n" function="B" pad="GPIO020"/>
              <signal group="QSPI0_IN_CS1_n" function="B" pad="GPIO021"/>
              <signal group="QSPI0_IN_IO1" function="B" pad="GPIO022"/>
              <signal group="QSPI0_IN_IO0" function="B" pad="GPIO023"/>
              <signal group="QSPI0_IN_IO2" function="B" pad="GPIO202"/>
              <signal group="QSPI0_IN_IO3" function="B" pad="GPIO203"/>
            </signals>
          </instance>
          <instance name="QMSPI1">
            <register-group name="QMSPI1" name-in-module="QMSPI" address-space="base" offset="0x40070200"/>
            <signals>
              <signal group="QSPI1_CS0_n" function="B" pad="GPIO124"/>
              <signal group="QSPI1_CS1_n" function="B" pad="GPIO120"/>
              <signal group="QSPI1_CLK" function="B" pad="GPIO125"/>
              <signal group="QSPI1_IO0" function="B" pad="GPIO121"/>
              <signal group="QSPI1_IO1" function="B" pad="GPIO122"/>
              <signal group="QSPI1_IO2" function="B" pad="GPIO123"/>
              <signal group="QSPI1_IO3" function="B" pad="GPIO126"/>
              <signal group="QSPI1_IN_CLK" function="B" pad="GPIO200"/>
              <signal group="QSPI1_IN_CS0_n" function="B" pad="GPIO071"/>
              <signal group="QSPI1_IN_IO0" function="B" pad="GPIO070"/>
              <signal group="QSPI1_IN_CS1_n" function="B" pad="GPIO045"/>
              <signal group="QSPI1_IN_IO1" function="B" pad="GPIO032"/>
              <signal group="QSPI1_IN_IO2" function="B" pad="GPIO165"/>
              <signal group="QSPI1_IN_IO3" function="B" pad="GPIO171"/>
            </signals>
          </instance>
        </module>
        <module name="TFDP" id="68" version="1.0">
          <instance name="TFDP">
            <register-group name="TFDP" name-in-module="TFDP" address-space="base" offset="0x40008C00"/>
            <signals>
              <signal group="TFDP_CLK" function="C" pad="GPIO104"/>
              <signal group="TFDP_DATA" function="C" pad="GPIO105"/>
              <signal group="TFDP_CLK" function="C" pad="GPIO170"/>
              <signal group="TFDP_DATA" function="C" pad="GPIO171"/>
              <signal group="ALT_TFDP_CLK" function="B" pad="GPIO027"/>
              <signal group="ALT_TFDP_DATA" function="C" pad="GPIO112"/>
            </signals>
          </instance>
        </module>
        <module name="VTR_REG_BANK" id="213" version="1.0">
          <instance name="VTR_REG_BANK">
            <register-group name="VTR_REG_BANK" name-in-module="VTR_REG_BANK" address-space="base" offset="0x4000A400"/>
          </instance>
        </module>
        <module name="EC_REG_BANK" id="95" version="1.0">
          <instance name="EC_REG_BANK">
            <register-group name="EC_REG_BANK" name-in-module="EC_REG_BANK" address-space="base" offset="0x4000FC00"/>
          </instance>
        </module>
        <module name="OTP" id="96" version="1.0">
          <instance name="OTP">
            <register-group name="OTP" name-in-module="OTP" address-space="base" offset="0x40082000"/>
          </instance>
        </module>
        <module name="SPT" id="170" version="1.0">
          <instance name="SPT0">
            <register-group name="SPT0" name-in-module="SPT" address-space="base" offset="0x40007000"/>
            <signals>
              <signal group="QSPI0_IN_CLK" function="B" pad="GPIO204"/>
              <signal group="SPI0PER_CS_n" function="B" pad="GPIO131"/>
              <signal group="QSPI0_IN_IO1" function="B" pad="GPIO022"/>
              <signal group="QSPI0_IN_IO0" function="B" pad="GPIO023"/>
              <signal group="QSPI0_IN_IO2" function="B" pad="GPIO202"/>
              <signal group="QSPI0_IN_IO3" function="B" pad="GPIO203"/>
              <signal group="SP0_AP_INTR" function="B" pad="GPIO053"/>
            </signals>
          </instance>
          <instance name="SPT1">
            <register-group name="SPT1" name-in-module="SPT" address-space="base" offset="0x40006C00"/>
            <signals>
              <signal group="QSPI1_IN_CLK" function="B" pad="GPIO200"/>
              <signal group="SPI1PER_CS_n" function="B" pad="GPIO024"/>
              <signal group="QSPI1_IN_IO0" function="B" pad="GPIO070"/>
              <signal group="QSPI1_IN_IO1" function="B" pad="GPIO032"/>
              <signal group="QSPI1_IN_IO2" function="B" pad="GPIO165"/>
              <signal group="QSPI1_IN_IO3" function="B" pad="GPIO171"/>
              <signal group="SP1_AP_INTR" function="B" pad="GPIO034"/>
            </signals>
          </instance>
        </module>
        <module name="FPU" version="1.0.0">
          <instance name="FPU">
            <register-group name="FPU" name-in-module="FPU" address-space="base" offset="0xE000EF30"/>
          </instance>
        </module>
        <module name="IMSPI" id="173" version="1.0">
          <instance name="IMSPI">
            <register-group name="IMSPI" name-in-module="IMSPI" address-space="base" offset="0x40220000"/>
          </instance>
        </module>
        <module name="NVIC" version="1.0.0">
          <instance name="NVIC">
            <register-group name="NVIC" name-in-module="NVIC" address-space="base" offset="0xE000E100"/>
            <parameters>
              <param name="NUM_IRQ" value="32" caption="Number of interrupt requests"/>
              <param name="__NVIC_PRIO_BITS" value="3" caption="Number of NVIC interrupt priority bits"/>
            </parameters>
          </instance>
        </module>
        <module name="SysTick" version="1.0.0">
          <instance name="SysTick">
            <register-group name="SysTick" name-in-module="SysTick" address-space="base" offset="0xE000E010"/>
          </instance>
        </module>
        <module name="SystemControl" version="1.0.0">
          <instance name="SystemControl">
            <register-group name="SystemControl" name-in-module="SystemControl" address-space="base" offset="0xE000E000"/>
          </instance>
        </module>
        <module name="CRYPTO" id="203" version="1.0.0">
          <instance name="PKE_ERR">
          </instance>
          <instance name="PKE_END">
          </instance>
          <instance name="RNG">
          </instance>
          <instance name="AES">
          </instance>
          <instance name="HASH">
          </instance>
        </module>
        <module name="ENV_MON" id="205" version="1.0.0">
          <instance name="ENV_MON">
            <register-group name="ENV_MON" name-in-module="ENV_MON" address-space="base" offset="0x40200600"/>
          </instance>
        </module>
        <module name="SPI_MON" id="206" version="1.0.0">
          <instance name="SPI_MON0">
            <register-group name="SPI_MON0" name-in-module="SPI_MON" address-space="base" offset="0x40010000"/>
            <signals>
              <signal group="ALT_VIOL_0" function="C" pad="GPIO107"/>
              <signal group="SPI0_KILL" function="B" pad="GPIO000"/>
              <signal group="SPI0_RESET_n" function="C" pad="GPIO000"/>
              <signal group="SPI0PER_CS_n" function="B" pad="GPIO250"/>
              <signal group="AP0_RESET_n" function="B" pad="GPIO106"/>
              <signal group="SP0_AP_INTR" function="B" pad="GPIO026"/>
              <signal group="SPIMON_QSPI0_CS1_n" function="C" pad="GPIO002"/>
              <signal group="SPIMON_QSPI0_CS0_n" function="C" pad="GPIO055"/>
              <signal group="QSPI0_CLK_CLAMP" function="C" pad="GPIO056"/>
              <signal group="QSPI0_IO0_CLAMP" function="C" pad="GPIO223"/>
              <signal group="QSPI0_IO1_CLAMP" function="C" pad="GPIO224"/>
              <signal group="QSPI0_IO2_CLAMP" function="C" pad="GPIO227"/>
              <signal group="QSPI0_IO3_CLAMP" function="C" pad="GPIO016"/>
            </signals>
          </instance>
          <instance name="SPI_MON1">
            <register-group name="SPI_MON1" name-in-module="SPI_MON" address-space="base" offset="0x40010400"/>
            <signals>
              <signal group="ALT_VIOL_1" function="B" pad="GPIO112"/>
              <signal group="SPI1_KILL" function="B" pad="GPIO163"/>
              <signal group="SPI_RESET_n" function="C" pad="GPIO163"/>
              <signal group="SPI1PER_CS_n" function="B" pad="GPIO024"/>
              <signal group="SPIMON_QSPI1_CS1_n" function="C" pad="GPIO120"/>
              <signal group="SPIMON_QSPI1_CS0_n" function="C" pad="GPIO124"/>
              <signal group="QSPI1_CLK_CLAMP" function="C" pad="GPIO125"/>
              <signal group="QSPI1_IO0_CLAMP" function="C" pad="GPIO121"/>
              <signal group="QSPI1_IO1_CLAMP" function="C" pad="GPIO122"/>
              <signal group="QSPI1_IO2_CLAMP" function="C" pad="GPIO123"/>
              <signal group="QSPI1_IO3_CLAMP" function="C" pad="GPIO126"/>
              <signal group="SP1_AP_INTR" function="B" pad="GPIO034"/>
              <signal group="SP1_ALT_CLK" function="B" pad="GPIO063"/>
              <signal group="SP1_ALT_CS_n" function="B" pad="GPIO046"/>
              <signal group="SP1_ALT_IO0" function="B" pad="GPIO031"/>
              <signal group="SP1_ALT_IO1" function="B" pad="GPIO047"/>
              <signal group="SP1_ALT_IO2" function="B" pad="GPIO127"/>
              <signal group="SP1_ALT_IO3" function="B" pad="GPIO013"/>
              <signal group="AP1_RESET_n" function="B" pad="GPIO131"/>
            </signals>
          </instance>
        </module>
      </peripherals>
      <interrupts>
        <interrupt name="Reset" index="-15" caption="Reset Vector, invoked on Power up and warm reset"/>
        <interrupt name="NonMaskableInt" index="-14" caption="Non maskable Interrupt, cannot be stopped or preempted"/>
        <interrupt name="HardFault" index="-13" caption="Hard Fault, all classes of Fault"/>
        <interrupt name="BusFault" index="-11" caption="Bus Fault, Pre-Fetch-, Memory Access Fault, other address/memory related Fault"/>
        <interrupt name="UsageFault" index="-10" caption="Usage Fault, i.e. Undef Instruction, Illegal State Transition"/>
        <interrupt name="SVCall" index="-5" caption="System Service Call via SVC instruction"/>
        <interrupt name="DebugMonitor" index="-4" caption="Debug Monitor"/>
        <interrupt name="PendSV" index="-2" caption="Pendable request for system service"/>
        <interrupt name="SysTick" index="-1" caption="System Tick Timer"/>
        <interrupt name="GIRQ08" index="0" module-instance="ECIA" caption="GIRQ08"/>
        <interrupt name="GIRQ09" index="1" module-instance="ECIA" caption="GIRQ09"/>
        <interrupt name="GIRQ10" index="2" module-instance="ECIA" caption="GIRQ10"/>
        <interrupt name="GIRQ11" index="3" module-instance="ECIA" caption="GIRQ11"/>
        <interrupt name="GIRQ12" index="4" module-instance="ECIA" caption="GIRQ12"/>
        <interrupt name="GIRQ13" index="5" module-instance="ECIA" caption="GIRQ13"/>
        <interrupt name="GIRQ14" index="6" module-instance="ECIA" caption="GIRQ14"/>
        <interrupt name="GIRQ15" index="7" module-instance="ECIA" caption="GIRQ15"/>
        <interrupt name="GIRQ16" index="8" module-instance="ECIA" caption="GIRQ16"/>
        <interrupt name="GIRQ17" index="9" module-instance="ECIA" caption="GIRQ17"/>
        <interrupt name="GIRQ18" index="10" module-instance="ECIA" caption="GIRQ18"/>
        <interrupt name="GIRQ20" index="12" module-instance="ECIA" caption="GIRQ20"/>
        <interrupt name="GIRQ21" index="13" module-instance="ECIA" caption="GIRQ21"/>
        <interrupt name="GIRQ23" index="14" module-instance="ECIA" caption="GIRQ23"/>
        <interrupt name="GIRQ24" index="15" module-instance="ECIA" caption="GIRQ24"/>
        <interrupt name="GIRQ26" index="17" module-instance="ECIA" caption="GIRQ26"/>
        <interrupt name="I2CSMB0" index="20" module-instance="SMB0" caption="I2CSMB0"/>
        <interrupt name="I2CSMB1" index="21" module-instance="SMB1" caption="I2CSMB1"/>
        <interrupt name="I2CSMB2" index="22" module-instance="SMB2" caption="I2CSMB2"/>
        <interrupt name="I2CSMB3" index="23" module-instance="SMB3" caption="I2CSMB3"/>
        <interrupt name="DMA_CH00" index="24" module-instance="DMA_CHAN00" caption="DMA_CH00"/>
        <interrupt name="DMA_CH01" index="25" module-instance="DMA_CHAN01" caption="DMA_CH01"/>
        <interrupt name="DMA_CH02" index="26" module-instance="DMA_CHAN02" caption="DMA_CH02"/>
        <interrupt name="DMA_CH03" index="27" module-instance="DMA_CHAN03" caption="DMA_CH03"/>
        <interrupt name="DMA_CH04" index="28" module-instance="DMA_CHAN04" caption="DMA_CH04"/>
        <interrupt name="DMA_CH05" index="29" module-instance="DMA_CHAN05" caption="DMA_CH05"/>
        <interrupt name="DMA_CH06" index="30" module-instance="DMA_CHAN06" caption="DMA_CH06"/>
        <interrupt name="DMA_CH07" index="31" module-instance="DMA_CHAN07" caption="DMA_CH07"/>
        <interrupt name="DMA_CH08" index="32" module-instance="DMA_CHAN08" caption="DMA_CH08"/>
        <interrupt name="DMA_CH09" index="33" module-instance="DMA_CHAN09" caption="DMA_CH09"/>
        <interrupt name="UART0" index="40" module-instance="UART0" caption="UART0"/>
        <interrupt name="PKE_ERR" index="65" module-instance="PKE_ERR" caption="PKE_ERR"/>
        <interrupt name="PKE_END" index="66" module-instance="PKE_END" caption="PKE_END"/>
        <interrupt name="RNG" index="67" module-instance="RNG" caption="RNG"/>
        <interrupt name="AES" index="68" module-instance="AES" caption="AES"/>
        <interrupt name="HASH" index="69" module-instance="HASH" caption="HASH"/>
        <interrupt name="LED0" index="83" module-instance="LED0" caption="LED0"/>
        <interrupt name="LED1" index="84" module-instance="LED1" caption="LED1"/>
        <interrupt name="SPT0" index="90" module-instance="SPT0" caption="SPT0"/>
        <interrupt name="QMSPI0" index="91" module-instance="QMSPI0" caption="QMSPI0"/>
        <interrupt name="QMSPI1" index="92" module-instance="QMSPI1" caption="QMSPI1"/>
        <interrupt name="RTMR" index="111" module-instance="RTOS" caption="RTMR"/>
        <interrupt name="HTMR0" index="112" module-instance="HTM0" caption="HTMR0"/>
        <interrupt name="HTMR1" index="113" module-instance="HTM1" caption="HTMR1"/>
        <interrupt name="EMC" index="134" module-instance="ENV_MON" caption="EMC"/>
        <interrupt name="TIMER32_0" index="140" module-instance="TIMER32_0" caption="TIMER32_0"/>
        <interrupt name="TIMER32_1" index="141" module-instance="TIMER32_1" caption="TIMER32_1"/>
        <interrupt name="CCT" index="146" module-instance="CCT" caption="CCT"/>
        <interrupt name="CCT_CAP0" index="147" module-instance="CCT" caption="CCT_CAP0"/>
        <interrupt name="CCT_CAP1" index="148" module-instance="CCT" caption="CCT_CAP1"/>
        <interrupt name="CCT_CAP2" index="149" module-instance="CCT" caption="CCT_CAP2"/>
        <interrupt name="CCT_CAP3" index="150" module-instance="CCT" caption="CCT_CAP3"/>
        <interrupt name="CCT_CAP4" index="151" module-instance="CCT" caption="CCT_CAP4"/>
        <interrupt name="CCT_CAP5" index="152" module-instance="CCT" caption="CCT_CAP5"/>
        <interrupt name="CCT_CMP0" index="153" module-instance="CCT" caption="CCT_CMP0"/>
        <interrupt name="CCT_CMP1" index="154" module-instance="CCT" caption="CCT_CMP1"/>
        <interrupt name="I2CSMB4" index="158" module-instance="SMB4" caption="I2CSMB4"/>
        <interrupt name="WDT" index="171" module-instance="WDT" caption="WDT"/>
        <interrupt name="CLK_MON" index="174" module-instance="PCR" caption="CLK_MON"/>
        <interrupt name="SWI0" index="181" module-instance="RTOS" caption="SWI0"/>
        <interrupt name="SWI1" index="182" module-instance="RTOS" caption="SWI1"/>
        <interrupt name="SWI2" index="183" module-instance="RTOS" caption="SWI2"/>
        <interrupt name="SWI3" index="184" module-instance="RTOS" caption="SWI3"/>
        <interrupt name="IMSPI" index="185" module-instance="IMSPI" caption="IMSPI"/>
        <interrupt name="SPT1" index="187" module-instance="SPT1" caption="SPT1"/>
        <interrupt name="SPIMON0_VLTN" index="188" module-instance="SPI_MON0" caption="SPIMON0_VLTN"/>
        <interrupt name="SPIMON0_MTMON" index="189" module-instance="SPI_MON0" caption="SPIMON0_MTMON"/>
        <interrupt name="SPIMON0_LTMON" index="190" module-instance="SPI_MON0" caption="SPIMON0_LTMON"/>
        <interrupt name="SPIMON1_VLTN" index="191" module-instance="SPI_MON1" caption="SPIMON1_VLTN"/>
        <interrupt name="SPIMON1_MTMON" index="192" module-instance="SPI_MON1" caption="SPIMON1_MTMON"/>
        <interrupt name="SPIMON1_LTMON" index="193" module-instance="SPI_MON1" caption="SPIMON1_LTMON"/>
        <interrupt name="VTR1_PAD_MON" index="194" module-instance="EC_REG_BANK" caption="VTR1_PAD_MON"/>
        <interrupt name="VTR2_PAD_MON" index="195" module-instance="EC_REG_BANK" caption="VTR2_PAD_MON"/>
      </interrupts>
      <interfaces>
        <interface type="swd" name="SWD"/>
      </interfaces>
    </device>
  </devices>
  <modules>
    <module name="PCR" id="100" version="1.0" caption="The Power, Clocks, and Resets (PCR) Section identifies clock sources, and reset inputs to the chip.">
      <register-group name="PCR" caption="The Power, Clocks, and Resets (PCR) Section identifies clock sources, and reset inputs to the chip.">
        <register name="PROC_CLK_CTRL" offset="0x4" rw="RW" size="4" access-size="4" initval="0x00000004" caption="Processor Clock Control Register [7:0] Processor Clock Divide Value (PROC_DIV)">
          <bitfield name="DIV" caption="Selects the EC clock rate" mask="0xFF" values="PCR_PROC_CLK_CTRL__DIV"/>
        </register>
        <register name="SLOW_CLK_CTRL" offset="0x8" rw="RW" size="4" access-size="4" initval="0x000001E0" caption="Configures the EC_CLK clock domain">
          <bitfield name="DIV" caption="SLOW_CLOCK_DIVIDE. n=Divide by n; 0=Clock off" mask="0x3FF"/>
        </register>
        <register name="OSC_ID" offset="0xC" rw="RW" size="4" access-size="4" initval="0x00000000" caption="Oscillator ID Register">
          <bitfield name="TEST" caption="Test bits" mask="0xFF"/>
          <bitfield name="PLL_LOCK" caption="PLL Lock Status" mask="0x100"/>
        </register>
        <register name="PWR_RST_STS" offset="0x10" rw="RW" size="4" access-size="4" initval="0x00000050" caption="PCR Power Reset Status Register">
          <bitfield name="VCC_PWRGD_STS" caption="Indicates the status of VCC_PWRGD. 0 = PWRGD not asserted. 1 = PWRGD asserte." mask="0x4"/>
          <bitfield name="RST_H_STS" caption="Indicates the status of RESET_VCC. 0 = reset active. 1 = reset not active." mask="0x8"/>
          <bitfield name="RST_VTR_STS" caption="Indicates the status of RESET_VTR. 0 = reset active. 1 = reset not active.(R/W1C)" mask="0x10"/>
          <bitfield name="VBAT_RST_STS" caption="VBAT reset status 0 = No reset occurred while VTR was off or since the last time this bit was cleared. 1 = A reset occurred.(R/WC)" mask="0x20"/>
          <bitfield name="RST_SYS_STS" caption="Indicates the status of RESET_SYS.(R/W1C)                0 = No reset occurred since the last time this bit was cleared.                1 = A reset occurred." mask="0x40"/>
          <bitfield name="JTAG_RST_STS" caption="Indicates status of JTAG_TRST# pin.                0 = No JTAG reset occurred since the last time this bit was cleared.                1 = A reset occurred because of a JTAG command." mask="0x80"/>
          <bitfield name="WDT_EVENT" caption="Indicates that a WDT_EVENT happened. (R/W1C)                0 = Not active.                1 = A WDT_EVENT occured." mask="0x100"/>
          <bitfield name="ACTIVE_32K" caption="32K ACTIVE (ACTIVE_32K)" mask="0x400"/>
          <bitfield name="PCICLK_ACTIVE" caption="PCICLK_ACTIVE (PCICLK_ACTIVE)" mask="0x800"/>
        </register>
        <register name="SYS_RST" offset="0x18" rw="RW" size="4" access-size="4" initval="0x00000000" caption="System Reset Register">
          <bitfield name="SOFT_SYS_RST" caption="A write of a 1 forces an assertion of the RESET_SYS reset signal, resetting the device. A write of 0 has no effect." mask="0x100"/>
        </register>
        <register name="PRIV_EN_LOCK" offset="0x24" rw="RW" size="4" access-size="4" initval="0x00000000" caption="Peripheral Privilege Register">
          <bitfield name="LOCK_EN" caption="Peripheral Privilege Lock Register. 1=Locked, 0=Unlocked. Locks Itself and CHIP_PRIV_EN, EC_PRIV_EN,           EC_PRIV_EN2, EC_PRIV_EN3, HOST_PRIV_EN registers" mask="0x1"/>
        </register>
        <register name="SLP_EN_0" offset="0x30" rw="RW" size="4" access-size="4" initval="0x00000000" caption="Sleep Enable 0 Register">
          <bitfield name="STAP_SLP_EN" caption="STAP Sleep Enable" mask="0x1"/>
          <bitfield name="OTP_SLP_EN" caption="OTP Sleep Enable" mask="0x2"/>
          <bitfield name="IMSPI_SLP_EN" caption="IMSPI Sleep Enable" mask="0x4"/>
          <bitfield name="CHPTST_SLP_EN" caption="Chip Test Sleep Enable" mask="0x8"/>
          <bitfield name="HRBNK_SLP_EN" caption="Host Register Bank Sleep Enable" mask="0x10"/>
          <bitfield name="TSTSPI_SLP_EN" caption="Test SPI Sleep Enable" mask="0x20"/>
          <bitfield name="GPIO_SLP_EN" caption="GPIO Sleep Enable" mask="0x40"/>
          <bitfield name="PCR_SLP_EN" caption="PCR Sleep Enable" mask="0x80"/>
        </register>
        <register name="SLP_EN_1" offset="0x34" rw="RW" size="4" access-size="4" initval="0x00000000" caption="Sleep Enable 1 Register">
          <bitfield name="INT_SLP_EN" caption="Interrupt Sleep Enable" mask="0x1"/>
          <bitfield name="PWM0_SLP_EN" caption="PWM0 Sleep Enable (PWM0_SLP_EN)" mask="0x10"/>
          <bitfield name="PMC_SLP_EN" caption="PMC Sleep Enable (PMC_SLP_EN)" mask="0x20"/>
          <bitfield name="DMA_SLP_EN" caption="DMA Sleep Enable (DMA_SLP_EN)" mask="0x40"/>
          <bitfield name="TFDP_SLP_EN" caption="TFDP Sleep Enable (TFDP_SLP_EN)" mask="0x80"/>
          <bitfield name="PROC_SLP_EN" caption="PROCESSOR Sleep Enable (PROCESSOR_SLP_EN)" mask="0x100"/>
          <bitfield name="WDT_SLP_EN" caption="Watch Dog Sleep Enable (WDT_SLP_EN)" mask="0x200"/>
          <bitfield name="SMB0_SLP_EN" caption="SMB0 Sleep Enable (SMB0_SLP_EN)" mask="0x400"/>
          <bitfield name="EC_REG_BANK_SLP_EN" caption="EC Register Bank Sleep Enable (EC_REG_BANK_SLP_EN)" mask="0x20000000"/>
          <bitfield name="TMR32_0_SLP_EN" caption="TIMER32_0 Sleep Enable (TIMER32_0_SLP_EN)" mask="0x40000000"/>
          <bitfield name="TMR32_1_SLP_EN" caption="TIMER32_1 Sleep Enable (TIMER32_1_SLP_EN)" mask="0x80000000"/>
        </register>
        <register name="SLP_EN_3" offset="0x3C" rw="RW" size="4" access-size="4" initval="0x00000000" caption="Sleep Enable 3 Register">
          <bitfield name="HTM_0_SLP_EN" caption="Hibernation Timer 0 Sleep Enable (HTM_0_SLP_EN)" mask="0x400"/>
          <bitfield name="SMB1_SLP_EN" caption="SMB1 Sleep Enable (SMB1_SLP_EN)" mask="0x2000"/>
          <bitfield name="SMB2_SLP_EN" caption="SMB2 Sleep Enable (SMB2_SLP_EN)" mask="0x4000"/>
          <bitfield name="SMB3_SLP_EN" caption="SMB3 Sleep Enable (SMB3_SLP_EN)" mask="0x8000"/>
          <bitfield name="LED0_SLP_EN" caption="LED0 Sleep Enable (LED0_SLP_EN)" mask="0x10000"/>
          <bitfield name="LED1_SLP_EN" caption="LED1 Sleep Enable (LED1_SLP_EN)" mask="0x20000"/>
          <bitfield name="SMB4_SLP_EN" caption="SMB4 Sleep Enable (SMB4_SLP_EN)" mask="0x100000"/>
          <bitfield name="CRYPTO_SLP_EN" caption="CRYPTO Sleep Enable" mask="0x4000000"/>
          <bitfield name="HTM_1_SLP_EN" caption="Hibernation TIMER 1 Sleep Enable (HTM_1_SLP_EN)" mask="0x20000000"/>
          <bitfield name="CCT_SLP_EN" caption="Capture Compare Timer Sleep Enable (CCTIMER_SLP_EN)" mask="0x40000000"/>
        </register>
        <register name="SLP_EN_4" offset="0x40" rw="RW" size="4" access-size="4" initval="0x00000000" caption="Sleep Enable 4 Register">
          <bitfield name="SECMON0_SLP_EN" caption="SPI Monitor 0 Sleep Enable (SECMON0_SLP_EN)" mask="0x1"/>
          <bitfield name="SECMON1_SLP_EN" caption="SPI Monitor 1 Sleep Enable (SECMON1_SLP_EN)" mask="0x2"/>
          <bitfield name="RTOS_SLP_EN" caption="RTOS Sleep Enable (RTOS_SLP_EN)" mask="0x40"/>
          <bitfield name="QMSPI0_SLP_EN" caption="Quad Master SPI 0 Sleep Enable (QMSPI_1_SLP_EN)" mask="0x100"/>
          <bitfield name="UART0_SLP_EN" caption="UART0 Sleep Enable (UART_1_SLP_EN)" mask="0x200"/>
          <bitfield name="SPIPER0_SLP_EN" caption="SPI Peropheral 0 Sleep Enable (SPIPER0_SLP_EN)" mask="0x10000"/>
          <bitfield name="SPIPER1_SLP_EN" caption="SPI Peropheral 1 Sleep Enable (SPIPER1_SLP_EN)" mask="0x200000"/>
          <bitfield name="QMSPI_1_SLP_EN" caption="QMSPI 1 Sleep Enable (QMSPI_1_SLP_EN)" mask="0x400000"/>
          <bitfield name="VBAT_REG_SLP_EN" caption="VBAT REG Sleep Enable (VBAT_REG_SLP_EN)" mask="0x800000"/>
        </register>
        <register name="RST_EN_0" offset="0x70" rw="RW" size="4" access-size="4" initval="0x00000000" caption="Reset Enable 0 Register">
          <bitfield name="JTAG_STAP_CLK_REQ" caption="JTAG STAP Enable" mask="0x1"/>
          <bitfield name="OTP_RST_EN" caption="OTP Reset Enable" mask="0x2"/>
          <bitfield name="CHPTST_RST_EN" caption="Chip Test Reset Enable" mask="0x8"/>
          <bitfield name="TSTSPI_RST_EN" caption="Test SPI Reset Enable" mask="0x20"/>
          <bitfield name="GPIO_RST_EN" caption="GPIO Reset Enable" mask="0x40"/>
          <bitfield name="PCR_RST_EN" caption="PCR Reset Enable" mask="0x80"/>
        </register>
        <register name="RST_EN_1" offset="0x74" rw="RW" size="4" access-size="4" initval="0x00000000" caption="Reset Enable 1 Register">
          <bitfield name="INT_RST_EN" caption="Interrupt Reset Enable" mask="0x1"/>
          <bitfield name="PWM0_RST_EN" caption="PWM0 Reset Enable (PWM0_RST_EN)" mask="0x10"/>
          <bitfield name="DMA_RST_EN" caption="DMA Reset Enable (DMA_RST_EN)" mask="0x40"/>
          <bitfield name="TFDP_RST_EN" caption="TFDP Reset Enable (TFDP_RST_EN)" mask="0x80"/>
          <bitfield name="WDT_RST_EN" caption="WDT Reset Enable (WDT_RST_EN)" mask="0x200"/>
          <bitfield name="SMB0_RST_EN" caption="SMB0 Reset Enable (SMB0_RST_EN)" mask="0x400"/>
          <bitfield name="TMR32_0_RST_EN" caption="TIMER32_0 Reset Enable (TIMER32_0_RST_EN)" mask="0x40000000"/>
          <bitfield name="TMR32_1_RST_EN" caption="TIMER32_1 Reset Enable (TIMER32_1_RST_EN)" mask="0x80000000"/>
        </register>
        <register name="RST_EN_3" offset="0x7C" rw="RW" size="4" access-size="4" initval="0x00000000" caption="Reset Enable 3 Register">
          <bitfield name="HTM_0_RST_EN" caption="Hibernation TIMER 0 Reset Enable (HTM_0_RST_EN)" mask="0x400"/>
          <bitfield name="SMB1_RST_EN" caption="SMB1 Reset Enable (SMB1_RST_EN)" mask="0x2000"/>
          <bitfield name="SMB2_RST_EN" caption="SMB2 Reset Enable (SMB2_RST_EN)" mask="0x4000"/>
          <bitfield name="SMB3_RST_EN" caption="SMB3 Reset Enable (SMB3_RST_EN)" mask="0x8000"/>
          <bitfield name="LED0_RST_EN" caption="LED0 Reset Enable (LED0_RST_EN)" mask="0x10000"/>
          <bitfield name="LED1_RST_EN" caption="LED1 Reset Enable (LED1_RST_EN)" mask="0x20000"/>
          <bitfield name="SMB_4_RST_EN" caption="SMB 4 Reset Enable (SMB_4_RST_EN)" mask="0x100000"/>
          <bitfield name="CRYPTO_RST_EN" caption="CRYPTO Reset Enable" mask="0x4000000"/>
          <bitfield name="HTM_1_RST_EN" caption="Hibernation TIMER 1 Reset Enable (HTM_1_RST_EN)" mask="0x20000000"/>
          <bitfield name="CCTIMER_RST_EN" caption="Capture Compare Timer Reset Enable (CCTIMER_RST_EN)" mask="0x40000000"/>
        </register>
        <register name="RST_EN_4" offset="0x80" rw="RW" size="4" access-size="4" initval="0x00000000" caption="Reset Enable 4 Register">
          <bitfield name="SECMON0_RST_EN" caption="SPI Monitor 0 Reset Enable (SECMON0_RST_EN)" mask="0x1"/>
          <bitfield name="SECMON1_RST_EN" caption="SPI Monitor 1 Reset Enable (SECMON1_RST_EN)" mask="0x2"/>
          <bitfield name="RTOS_RST_EN" caption="RTOS Reset Enable (RTOS_RST_EN)" mask="0x40"/>
          <bitfield name="QMSPI0_RST_EN" caption="Quad Master SPI 0 Reset Enable (QMSPI_1_RST_EN)" mask="0x100"/>
          <bitfield name="UART0_RST_EN" caption="UART0 Reset Enable (UART_0_RST_EN)" mask="0x200"/>
          <bitfield name="SPIPER0_RST_EN" caption="SPI Peropheral 0 Reset Enable (SPIPER0_RST_EN)" mask="0x10000"/>
          <bitfield name="SPIPER1_RST_EN" caption="SPI Peropheral 1 Reset Enable (SPIPER1_RST_EN)" mask="0x200000"/>
          <bitfield name="QMSPI_1_RST_EN" caption="QMSPI 1 Reset Enable (QMSPI_1_RST_EN)" mask="0x400000"/>
          <bitfield name="VBAT_REG_RST_EN" caption="VBAT REG Reset Enable (VBAT_REG_RST_EN)" mask="0x800000"/>
        </register>
        <register name="PERIPH_RST_EN_LOCK" offset="0x84" rw="RW" size="4" access-size="4" initval="0xA6382D4D" caption="Peripheral Reset Lock Register">
          <bitfield name="EN" caption="PCR Reset Enable Lock Register." mask="0xFFFFFFFF"/>
        </register>
        <register name="EC_PRIV_EN0" offset="0xF0" rw="RW" size="4" access-size="4" initval="0x00000000" caption="EC Priviliges 0 Register">
          <bitfield name="OTP" caption="OTP Privilege Enable." mask="0x2"/>
          <bitfield name="HOST_REG" caption="Host Register Bank Privilege Enable." mask="0x10"/>
          <bitfield name="TST_SPI" caption="Test SPI Privilege Enable." mask="0x20"/>
          <bitfield name="GPIO" caption="GPIO Privilege Enable." mask="0x40"/>
          <bitfield name="PCR" caption="PCR Privilege Enable." mask="0x80"/>
        </register>
        <register name="EC_PRIV_EN1" offset="0xF4" rw="RW" size="4" access-size="4" initval="0x00000000" caption="EC Priviliges 1 Register">
          <bitfield name="INTR" caption="Interrupt Privilege Enable." mask="0x1"/>
          <bitfield name="PWM0" caption="PWM 0 Privilege Enable." mask="0x10"/>
          <bitfield name="PMC" caption="PMC Privilege Enable." mask="0x20"/>
          <bitfield name="DMA" caption="DMA Privilege Enable." mask="0x40"/>
          <bitfield name="TFDP" caption="TFDP Privilege Enable." mask="0x80"/>
          <bitfield name="WDT" caption="WDT Privilege Enable." mask="0x200"/>
          <bitfield name="SMB_I2C0" caption="SMB I2C 0 Privilege Enable." mask="0x400"/>
          <bitfield name="EC_REGS" caption="EC Registers Privilege Enable." mask="0x20000000"/>
          <bitfield name="BASIC_TMR0" caption="Basic Timer 0 Privilege Enable." mask="0x40000000"/>
          <bitfield name="BASIC_TMR1" caption="Basic Timer 1 Privilege Enable." mask="0x80000000"/>
        </register>
        <register name="EC_PRIV_EN3" offset="0xF8" rw="RW" size="4" access-size="4" initval="0x00000000" caption="EC Priviliges 3 Register">
          <bitfield name="HIB_TIM0" caption="Hibernation TIMER 0 Privilege Enable." mask="0x400"/>
          <bitfield name="SMB_I2C1" caption="SMB I2C 1 Privilege Enable." mask="0x2000"/>
          <bitfield name="SMB_I2C2" caption="SMB I2C 2 Privilege Enable." mask="0x4000"/>
          <bitfield name="SMB_I2C3" caption="SMB I2C 3 Privilege Enable." mask="0x8000"/>
          <bitfield name="LED0" caption="LED 0 Privilege Enable." mask="0x10000"/>
          <bitfield name="LED1" caption="LED 1 Privilege Enable." mask="0x20000"/>
          <bitfield name="SMB_I2C4" caption="SMB I2C 4 Privilege Enable." mask="0x100000"/>
          <bitfield name="CRYPTO" caption="Crypto Privilege Enable." mask="0x4000000"/>
          <bitfield name="HIB_TIM1" caption="Hibernation Timer 1 Privilege Enable." mask="0x20000000"/>
          <bitfield name="CCT0" caption="Capture Compare Timer Privilege Enable." mask="0x40000000"/>
        </register>
        <register name="EC_PRIV_EN4" offset="0xFC" rw="RW" size="4" access-size="4" initval="0x00000000" caption="EC Priviliges 4 Register">
          <bitfield name="SPIMON0" caption="SPI Monitor 0 Privilege Enable." mask="0x1"/>
          <bitfield name="SPIMON1" caption="SPI Monitor 1 Privilege Enable." mask="0x2"/>
          <bitfield name="RTOS_TIM" caption="RTOS Timer Privilege Enable." mask="0x40"/>
          <bitfield name="QMSPI0" caption="QMSPI 0 Privilege Enable." mask="0x100"/>
          <bitfield name="UART0" caption="UART 0 Privilege Enable." mask="0x200"/>
          <bitfield name="SPISLV0" caption="SPISLV 0 Privilege Enable." mask="0x10000"/>
          <bitfield name="SPISLV1" caption="SPISLV 1 Privilege Enable." mask="0x200000"/>
          <bitfield name="QMSPI1" caption="QMSPI 1 Privilege Enable." mask="0x400000"/>
          <bitfield name="VBAT_REG" caption="VBAT Register Privilege Enable." mask="0x800000"/>
        </register>
      </register-group>
      <value-group caption="" name="PCR_PROC_CLK_CTRL__DIV">
        <value caption="Divide 96 MHz clock by 1 (96 MHz Processor Clock)" name="DIVIDE_BY_1" value="0x1"/>
        <value caption="Divide 96 MHz clock by 2 (48 MHz Processor Clock)" name="DIVIDE_BY_2" value="0x2"/>
        <value caption="Divide 96 MHz clock by 4 (24 MHz Processor Clock)" name="DIVIDE_BY_4" value="0x4"/>
        <value caption="Divide 96 MHz clock by 16 (6 MHz Processor Clock)" name="DIVIDE_BY_16" value="0x10"/>
        <value caption="Divide 96 MHz clock by 48 (2 MHz Processor Clock)" name="DIVIDE_BY_48" value="0x30"/>
      </value-group>
      <value-group caption="" name="PCR_PLL_REF__PLL_REF_SRC">
        <value caption="Internal Silicon Oscillator" name="INTERNAL_SILICON_OSC" value="0x0"/>
        <value caption="VTR Pin 32KHZ In" name="VTR_PIN_32KHz_IN" value="0x2"/>
        <value caption="None (Off)" name="NONE_OFF" value="0x3"/>
      </value-group>
    </module>
    <module name="DMA_MAIN" id="85a" version="1.0" caption="DMA Main Registers">
      <register-group name="DMA_MAIN" caption="DMA Main Registers">
        <register name="ACTRST" offset="0x0" rw="RW" size="1" access-size="1" initval="0x00" caption="Soft reset the entire module. Enable the blocks operation.">
          <bitfield name="ACT" caption="Enable the blocks operation. (R/WS)                1=Enable block. Each individual channel must be enabled separately.                0=Disable all channels." mask="0x1"/>
          <bitfield name="SOFT_RST" caption="Soft reset the entire module. This bit is self-clearing." mask="0x2"/>
        </register>
        <register name="DATA_PKT" offset="0x4" rw="R" size="4" access-size="4" initval="0x00000000" caption="Debug register that has the data that is stored in the Data Packet. This data is read data from the currently active transfer source.">
        </register>
      </register-group>
    </module>
    <module name="DMA_CHAN00" id="85b" version="1.0" caption="DMA Channel 00 Registers">
      <register-group name="DMA_CHAN00" caption="DMA Channel 00 Registers">
        <register name="ACTIVATE" offset="0x0" rw="RW" size="1" access-size="1" initval="0x00" caption="Enable this channel for operation. The DMA Main Control: Activate must also be enabled for this channel to be operational.">
          <bitfield name="CHN" caption="Enable this channel for operation. The DMA Main Control:Activate must also be enabled for this channel to be operational.                  1=Enable channel(block). Each individual channel must be enabled separately.                  0=Disable channel(block)." mask="0x1"/>
        </register>
        <register name="MSTART" offset="0x4" rw="RW" size="4" access-size="4" initval="0x00000000" caption="This is the starting address for the Memory device.">
        </register>
        <register name="MEND" offset="0x8" rw="RW" size="4" access-size="4" initval="0x00000000" caption="This is the ending address for the Memory device.">
        </register>
        <register name="DSTART" offset="0xC" rw="RW" size="4" access-size="4" initval="0x00000000" caption="This is the Master Device address.">
        </register>
        <register name="CTRL" offset="0x10" rw="RW" size="4" access-size="4" initval="0x00000000" caption="DMA Channel N Control">
          <bitfield name="RUN" caption="This is a control field. Note: This bit only applies to Hardware Flow Control mode.                  1= This channel is enabled and will service transfer requests                  0=This channel is disabled. All transfer requests are ignored." mask="0x1"/>
          <bitfield name="REQ" caption="This is a status field.                  1= There is a transfer request from the Master Device                  0= There is no transfer request from the Master Device" mask="0x2"/>
          <bitfield name="DONE" caption="This is a status signal. It is only valid while DMA Channel Control: Run is Enabled.                   This is the inverse of the DMA Channel Control: Busy field, except this is qualified with the DMA Channel Control:Run field.                  1=Channel is done                  0=Channel is not done or it is OFF" mask="0x4"/>
          <bitfield name="STS" caption="This is a status signal. The status decode is listed in priority order with the highest priority first.                  3: Error detected by the DMA                  2: The DMA Channel is externally done, in that the Device has terminated the transfer over the Hardware Flow Control through the Port dma_term                  1: The DMA Channel is locally done, in that Memory Start Address equals Memory End Address                  0: DMA Channel Control:Run is Disabled (0x0)" mask="0x18" values="DMA_CHAN00_CTRL__STS"/>
          <bitfield name="BUSY" caption="This is a status signal.                  1=The DMA Channel is busy (FSM is not IDLE)                  0=The DMA Channel is not busy (FSM is IDLE)" mask="0x20"/>
          <bitfield name="TX_DIR" caption="This determines the direction of the DMA Transfer.                  1=Data Packet Read from Memory Start Address followed by Data Packet Write to Device Address                  0=Data Packet Read from Device Address followed by Data Packet Write to Memory Start Address" mask="0x100"/>
          <bitfield name="HW_FLOW_CTRL_DEV" caption="This is the device that is connected to this channel as its Hardware Flow Control master.                  The Flow Control Interface is a bus with each master concatenated onto it.                  This selects which bus index of the concatenated Flow Control Interface bus is targeted towards this channel.                  The Flow Control Interface Port list is dma_req, dma_term, and dma_done." mask="0xFE00"/>
          <bitfield name="INC_MEM_ADDR" caption="This will enable an auto-increment to the DMA Channel Memory Address.                  1=Increment the DMA Channel Memory Address by DMA Channel Control:Transfer Size after every Data Packet transfer                  0=Do nothing" mask="0x10000"/>
          <bitfield name="INC_DEV_ADDR" caption="This will enable an auto-increment to the DMA Channel Device Address.                  1: Increment the DMA Channel Device Address by DMA Channel Control:Transfer Size after every Data Packet transfer                  0: Do nothing" mask="0x20000"/>
          <bitfield name="LOCK" caption="This is used to lock the arbitration of the Channel Arbiter on this channel once this channel is granted. Once this is locked, it will remain on the arbiter until it has completed it transfer (either the Transfer Aborted, Transfer Done or Transfer Terminated conditions)." mask="0x40000"/>
          <bitfield name="DIS_HW_FLOW_CTRL" caption="This will Disable the Hardware Flow Control. When disabled, any DMA Master device attempting to communicate to the DMA over the DMA Flow Control Interface (Ports: dma_req, dma_term, and dma_done) will be ignored. This should be set before using the DMA channel in Firmware Flow Control mode." mask="0x80000"/>
          <bitfield name="TRANS_SIZE" caption="This is the transfer size in Bytes of each Data Packet transfer.                  Note: The transfer size must be a legal AMBA transfer size. Valid sizes are 1, 2 and 4 Bytes." mask="0x700000"/>
          <bitfield name="TRANS_GO" caption="This is used for the Firmware Flow Control DMA transfer." mask="0x1000000"/>
          <bitfield name="TRANS_ABORT" caption="This is used to abort the current transfer on this DMA Channel. The aborted transfer will be forced to terminate immediately." mask="0x2000000"/>
        </register>
        <register name="ISTS" offset="0x14" rw="RW" size="1" access-size="1" initval="0x00" caption="DMA Channel N Interrupt Status">
          <bitfield name="BUS_ERR" caption="This is an interrupt source register. This flags when there is an Error detected over the internal 32-bit Bus.                  1: Error detected. (R/WC)" mask="0x1"/>
          <bitfield name="FLOW_CTRL" caption="This is an interrupt source register. This flags when the DMA Channel has encountered a Hardware Flow Control Request     after the DMA Channel has completed the transfer. This means the Master Device is attempting to overflow the DMA.                  1=Hardware Flow Control is requesting after the transfer has completed                  0=No Hardware Flow Control event" mask="0x2"/>
          <bitfield name="DONE" caption="This is an interrupt source register. This flags when the DMA Channel has completed a transfer successfully on its side.     A completed transfer is defined as when the DMA Channel reaches its limit; Memory Start Address equals Memory End Address.     A completion due to a Hardware Flow Control Terminate will not flag this interrupt.                  1=Memory Start Address equals Memory End Address                  0=Memory Start Address does not equal Memory End Address" mask="0x4"/>
        </register>
        <register name="IEN" offset="0x18" rw="RW" size="1" access-size="1" initval="0x00" caption="DMA CHANNEL N INTERRUPT ENABLE">
          <bitfield name="STS_EN_BUS_ERR" caption="This is an interrupt enable for DMA Channel Interrupt:Status Bus Error.                  1=Enable Interrupt                  0=Disable Interrupt" mask="0x1"/>
          <bitfield name="STS_EN_FLOW_CTRL" caption="This is an interrupt enable for DMA Channel Interrupt:Status Flow Control Error.                  1=Enable Interrupt                  0=Disable Interrupt" mask="0x2"/>
          <bitfield name="STS_EN_DONE" caption="This is an interrupt enable for DMA Channel Interrupt:Status Done.                  1=Enable Interrupt                  0=Disable Interrupt" mask="0x4"/>
        </register>
        <register name="CRC_EN" offset="0x20" rw="RW" size="4" access-size="4" initval="0x00000000" caption="DMA CHANNEL N CRC ENABLE">
          <bitfield name="MODE" caption="1=Enable the calculation of CRC-32 for DMA Channel N     0=Disable the calculation of CRC-32 for DMA Channel N" mask="0x1"/>
          <bitfield name="POST_TRANS" caption="The bit enables the transfer of the calculated CRC-32 after the completion of the DMA transaction.     If the DMA transaction is aborted by either firmware or an internal bus error, the transfer will not occur.     If the target of the DMA transfer is a device and the device signaled the termination of the DMA transaction,     the CRC post transfer will not occur.     1=Enable the transfer of CRC-32 for DMA Channel N after the DMA transaction completes     0=Disable the automatic transfer of the CRC" mask="0x2"/>
        </register>
        <register name="CRC_DATA" offset="0x24" rw="RW" size="4" access-size="4" initval="0x00000000" caption="DMA CHANNEL N CRC DATA">
          <bitfield name="CRC" caption="Writes to this register initialize the CRC generator. Reads from this register return the output of the     CRC that is calculated from the data transferred by DMA Channel N. The output of the CRC generator is bit-reversed     and inverted on reads, as required by the CRC-32-IEEE definition. A CRC can be accumulated across multiple DMA transactions     on Channel N. If it is necessary to save the intermediate CRC value, the result of the read of this register must be     bit-reversed and inverted before being written back to this register." mask="0xFFFFFFFF"/>
        </register>
        <register name="CRC_POST_STS" offset="0x28" rw="RW" size="4" access-size="4" initval="0x00000000" caption="DMA CHANNEL N CRC POST STATUS">
          <bitfield name="CRC_DONE" caption="This bit is set to '1b' when the CRC calculation has completed from either normal or forced termination.     It is cleared to '0b' when the DMA controller starts a new transfer on the channel." mask="0x1"/>
          <bitfield name="CRC_RUNNING" caption="This bit is set to '1b' when the DMA controller starts the post-transfer transmission of the CRC.     It is only set when the post-transfer is enabled by the CRC_POST_TRANSFER_ENABLE field. This bit is cleared     to '0b' when the post-transfer completes." mask="0x2"/>
          <bitfield name="CRC_DATA_DONE" caption="This bit is set to '1b' when the DMA controller has completed the post-transfer of the CRC data.     This bit is cleared to '0b' when the a new DMA transfer starts." mask="0x4"/>
          <bitfield name="CRC_DATA_READY" caption="This bit is set to '1b' when the DMA controller is processing the post-transfer of the CRC data.     This bit is cleared to '0b' when the post-transfer completes." mask="0x8"/>
        </register>
      </register-group>
      <value-group caption="" name="DMA_CHAN00_CTRL__STS">
        <value caption="3: Error detected by the DMA" name="ERROR" value="0x3"/>
        <value caption="2: The DMA Channel is externally done, in that the Device has terminated the transfer over the Hardware Flow Control through the Port dma_term" name="EXT_DONE" value="0x2"/>
        <value caption="1: The DMA Channel is locally done, in that Memory Start Address equals Memory End Address" name="LOC_DONE" value="0x1"/>
        <value caption="0: DMA Channel Control:Run is Disabled (0x0)" name="DIS" value="0x0"/>
      </value-group>
    </module>
    <module name="DMA_CHAN01" id="85c" version="1.0" caption="DMA Channel 01 Registers">
      <register-group name="DMA_CHAN01" caption="DMA Channel 01 Registers">
        <register name="ACTIVATE" offset="0x0" rw="RW" size="1" access-size="1" initval="0x00" caption="Enable this channel for operation. The DMA Main Control: Activate must also be enabled for this channel to be operational.">
          <bitfield name="CHN" caption="Enable this channel for operation. The DMA Main Control:Activate must also be enabled for this channel to be operational.                  1=Enable channel(block). Each individual channel must be enabled separately.                  0=Disable channel(block)." mask="0x1"/>
        </register>
        <register name="MSTART" offset="0x4" rw="RW" size="4" access-size="4" initval="0x00000000" caption="This is the starting address for the Memory device.">
        </register>
        <register name="MEND" offset="0x8" rw="RW" size="4" access-size="4" initval="0x00000000" caption="This is the ending address for the Memory device.">
        </register>
        <register name="DSTART" offset="0xC" rw="RW" size="4" access-size="4" initval="0x00000000" caption="This is the Master Device address.">
        </register>
        <register name="CTRL" offset="0x10" rw="RW" size="4" access-size="4" initval="0x00000000" caption="DMA Channel N Control">
          <bitfield name="RUN" caption="This is a control field. Note: This bit only applies to Hardware Flow Control mode.                  1= This channel is enabled and will service transfer requests                  0=This channel is disabled. All transfer requests are ignored." mask="0x1"/>
          <bitfield name="REQ" caption="This is a status field.                  1= There is a transfer request from the Master Device                  0= There is no transfer request from the Master Device" mask="0x2"/>
          <bitfield name="DONE" caption="This is a status signal. It is only valid while DMA Channel Control: Run is Enabled.                   This is the inverse of the DMA Channel Control: Busy field, except this is qualified with the DMA Channel Control:Run field.                  1=Channel is done                  0=Channel is not done or it is OFF" mask="0x4"/>
          <bitfield name="STS" caption="This is a status signal. The status decode is listed in priority order with the highest priority first.                  3: Error detected by the DMA                  2: The DMA Channel is externally done, in that the Device has terminated the transfer over the Hardware Flow Control through the Port dma_term                  1: The DMA Channel is locally done, in that Memory Start Address equals Memory End Address                  0: DMA Channel Control:Run is Disabled (0x0)" mask="0x18" values="DMA_CHAN01_CTRL__STS"/>
          <bitfield name="BUSY" caption="This is a status signal.                  1=The DMA Channel is busy (FSM is not IDLE)                  0=The DMA Channel is not busy (FSM is IDLE)" mask="0x20"/>
          <bitfield name="TX_DIR" caption="This determines the direction of the DMA Transfer.                  1=Data Packet Read from Memory Start Address followed by Data Packet Write to Device Address                  0=Data Packet Read from Device Address followed by Data Packet Write to Memory Start Address" mask="0x100"/>
          <bitfield name="HW_FLOW_CTRL_DEV" caption="This is the device that is connected to this channel as its Hardware Flow Control master.                  The Flow Control Interface is a bus with each master concatenated onto it.                  This selects which bus index of the concatenated Flow Control Interface bus is targeted towards this channel.                  The Flow Control Interface Port list is dma_req, dma_term, and dma_done." mask="0xFE00"/>
          <bitfield name="INC_MEM_ADDR" caption="This will enable an auto-increment to the DMA Channel Memory Address.                  1=Increment the DMA Channel Memory Address by DMA Channel Control:Transfer Size after every Data Packet transfer                  0=Do nothing" mask="0x10000"/>
          <bitfield name="INC_DEV_ADDR" caption="This will enable an auto-increment to the DMA Channel Device Address.                  1: Increment the DMA Channel Device Address by DMA Channel Control:Transfer Size after every Data Packet transfer                  0: Do nothing" mask="0x20000"/>
          <bitfield name="LOCK" caption="This is used to lock the arbitration of the Channel Arbiter on this channel once this channel is granted. Once this is locked, it will remain on the arbiter until it has completed it transfer (either the Transfer Aborted, Transfer Done or Transfer Terminated conditions)." mask="0x40000"/>
          <bitfield name="DIS_HW_FLOW_CTRL" caption="This will Disable the Hardware Flow Control. When disabled, any DMA Master device attempting to communicate to the DMA over the DMA Flow Control Interface (Ports: dma_req, dma_term, and dma_done) will be ignored. This should be set before using the DMA channel in Firmware Flow Control mode." mask="0x80000"/>
          <bitfield name="TRANS_SIZE" caption="This is the transfer size in Bytes of each Data Packet transfer.                  Note: The transfer size must be a legal AMBA transfer size. Valid sizes are 1, 2 and 4 Bytes." mask="0x700000"/>
          <bitfield name="TRANS_GO" caption="This is used for the Firmware Flow Control DMA transfer." mask="0x1000000"/>
          <bitfield name="TRANS_ABORT" caption="This is used to abort the current transfer on this DMA Channel. The aborted transfer will be forced to terminate immediately." mask="0x2000000"/>
        </register>
        <register name="ISTS" offset="0x14" rw="RW" size="1" access-size="1" initval="0x00" caption="DMA Channel N Interrupt Status">
          <bitfield name="BUS_ERROR" caption="This is an interrupt source register. This flags when there is an Error detected over the internal 32-bit Bus.                  1: Error detected. (R/WC)" mask="0x1"/>
          <bitfield name="FLOW_CTRL" caption="This is an interrupt source register. This flags when the DMA Channel has encountered a Hardware Flow Control Request     after the DMA Channel has completed the transfer. This means the Master Device is attempting to overflow the DMA.                  1=Hardware Flow Control is requesting after the transfer has completed                  0=No Hardware Flow Control event" mask="0x2"/>
          <bitfield name="DONE" caption="This is an interrupt source register. This flags when the DMA Channel has completed a transfer successfully on its side.     A completed transfer is defined as when the DMA Channel reaches its limit; Memory Start Address equals Memory End Address.     A completion due to a Hardware Flow Control Terminate will not flag this interrupt.                  1=Memory Start Address equals Memory End Address                  0=Memory Start Address does not equal Memory End Address" mask="0x4"/>
        </register>
        <register name="IEN" offset="0x18" rw="RW" size="1" access-size="1" initval="0x00" caption="DMA CHANNEL N INTERRUPT ENABLE">
          <bitfield name="STS_EN_BUS_ERR" caption="This is an interrupt enable for DMA Channel Interrupt:Status Bus Error.                  1=Enable Interrupt                  0=Disable Interrupt" mask="0x1"/>
          <bitfield name="STS_EN_FLOW_CTRL" caption="This is an interrupt enable for DMA Channel Interrupt:Status Flow Control Error.                  1=Enable Interrupt                  0=Disable Interrupt" mask="0x2"/>
          <bitfield name="STS_EN_DONE" caption="This is an interrupt enable for DMA Channel Interrupt:Status Done.                  1=Enable Interrupt                  0=Disable Interrupt" mask="0x4"/>
        </register>
        <register name="FILL_EN" offset="0x20" rw="RW" size="4" access-size="4" initval="0x00000000" caption="DMA CHANNEL N FILL ENABLE">
          <bitfield name="MODE" caption="1=Enable the DMA Channel Fill Engine N     0=Disable the DMA Channel Fill Engine" mask="0x1"/>
        </register>
        <register name="FILL_DATA" offset="0x24" rw="RW" size="4" access-size="4" initval="0x00000000" caption="DMA CHANNEL N FILL DATA">
          <bitfield name="DATA" caption="This is the data pattern used to fill memory." mask="0xFFFFFFFF"/>
        </register>
        <register name="FILL_STS" offset="0x28" rw="RW" size="4" access-size="4" initval="0x00000000" caption="DMA CHANNEL N FILL STATUS">
          <bitfield name="DONE" caption="This bit is set to '1b' when the CRC calculation has completed from either normal or forced termination.     It is cleared to '0b' when the DMA controller starts a new transfer on the channel." mask="0x1"/>
          <bitfield name="RUNNING" caption="This bit is set to '1b' when the DMA controller starts the post-transfer transmission of the CRC.     It is only set when the post-transfer is enabled by the CRC_POST_TRANSFER_ENABLE field. This bit is cleared     to '0b' when the post-transfer completes." mask="0x2"/>
        </register>
      </register-group>
      <value-group caption="" name="DMA_CHAN01_CTRL__STS">
        <value caption="3: Error detected by the DMA" name="ERROR" value="0x3"/>
        <value caption="2: The DMA Channel is externally done, in that the Device has terminated the transfer over the Hardware Flow Control through the Port dma_term" name="EXT_DONE" value="0x2"/>
        <value caption="1: The DMA Channel is locally done, in that Memory Start Address equals Memory End Address" name="LOC_DONE" value="0x1"/>
        <value caption="0: DMA Channel Control:Run is Disabled (0x0)" name="DIS" value="0x0"/>
      </value-group>
    </module>
    <module name="DMA_CHAN02" id="85d" version="1.0" caption="DMA Channel 02 Registers">
      <register-group name="DMA_CHAN02" caption="DMA Channel 02 Registers">
        <register name="ACTIVATE" offset="0x0" rw="RW" size="1" access-size="1" initval="0x00" caption="Enable this channel for operation. The DMA Main Control: Activate must also be enabled for this channel to be operational.">
          <bitfield name="CHN" caption="Enable this channel for operation. The DMA Main Control:Activate must also be enabled for this channel to be operational.                  1=Enable channel(block). Each individual channel must be enabled separately.                  0=Disable channel(block)." mask="0x1"/>
        </register>
        <register name="MSTART" offset="0x4" rw="RW" size="4" access-size="4" initval="0x00000000" caption="This is the starting address for the Memory device.">
        </register>
        <register name="MEND" offset="0x8" rw="RW" size="4" access-size="4" initval="0x00000000" caption="This is the ending address for the Memory device.">
	</register>
        <register name="DSTART" offset="0xC" rw="RW" size="4" access-size="4" initval="0x00000000" caption="This is the Master Device address.">
        </register>
        <register name="CTRL" offset="0x10" rw="RW" size="4" access-size="4" initval="0x00000000" caption="DMA Channel N Control">
          <bitfield name="RUN" caption="This is a control field. Note: This bit only applies to Hardware Flow Control mode.                  1= This channel is enabled and will service transfer requests                  0=This channel is disabled. All transfer requests are ignored." mask="0x1"/>
          <bitfield name="REQ" caption="This is a status field.                  1= There is a transfer request from the Master Device                  0= There is no transfer request from the Master Device" mask="0x2"/>
          <bitfield name="DONE" caption="This is a status signal. It is only valid while DMA Channel Control: Run is Enabled.                   This is the inverse of the DMA Channel Control: Busy field, except this is qualified with the DMA Channel Control:Run field.                  1=Channel is done                  0=Channel is not done or it is OFF" mask="0x4"/>
          <bitfield name="STS" caption="This is a status signal. The status decode is listed in priority order with the highest priority first.                  3: Error detected by the DMA                  2: The DMA Channel is externally done, in that the Device has terminated the transfer over the Hardware Flow Control through the Port dma_term                  1: The DMA Channel is locally done, in that Memory Start Address equals Memory End Address                  0: DMA Channel Control:Run is Disabled (0x0)" mask="0x18" values="DMA_CHAN02_CTRL__STS"/>
          <bitfield name="BUSY" caption="This is a status signal.                  1=The DMA Channel is busy (FSM is not IDLE)                  0=The DMA Channel is not busy (FSM is IDLE)" mask="0x20"/>
          <bitfield name="TX_DIR" caption="This determines the direction of the DMA Transfer.                  1=Data Packet Read from Memory Start Address followed by Data Packet Write to Device Address                  0=Data Packet Read from Device Address followed by Data Packet Write to Memory Start Address" mask="0x100"/>
          <bitfield name="HW_FLOW_CTRL_DEV" caption="This is the device that is connected to this channel as its Hardware Flow Control master.                  The Flow Control Interface is a bus with each master concatenated onto it.                  This selects which bus index of the concatenated Flow Control Interface bus is targeted towards this channel.                  The Flow Control Interface Port list is dma_req, dma_term, and dma_done." mask="0xFE00"/>
          <bitfield name="INC_MEM_ADDR" caption="This will enable an auto-increment to the DMA Channel Memory Address.                  1=Increment the DMA Channel Memory Address by DMA Channel Control:Transfer Size after every Data Packet transfer                  0=Do nothing" mask="0x10000"/>
          <bitfield name="INC_DEV_ADDR" caption="This will enable an auto-increment to the DMA Channel Device Address.                  1: Increment the DMA Channel Device Address by DMA Channel Control:Transfer Size after every Data Packet transfer                  0: Do nothing" mask="0x20000"/>
          <bitfield name="LOCK" caption="This is used to lock the arbitration of the Channel Arbiter on this channel once this channel is granted. Once this is locked, it will remain on the arbiter until it has completed it transfer (either the Transfer Aborted, Transfer Done or Transfer Terminated conditions)." mask="0x40000"/>
          <bitfield name="DIS_HW_FLOW_CTRL" caption="This will Disable the Hardware Flow Control. When disabled, any DMA Master device attempting to communicate to the DMA over the DMA Flow Control Interface (Ports: dma_req, dma_term, and dma_done) will be ignored. This should be set before using the DMA channel in Firmware Flow Control mode." mask="0x80000"/>
          <bitfield name="TRANS_SIZE" caption="This is the transfer size in Bytes of each Data Packet transfer.                  Note: The transfer size must be a legal AMBA transfer size. Valid sizes are 1, 2 and 4 Bytes." mask="0x700000"/>
          <bitfield name="TRANS_GO" caption="This is used for the Firmware Flow Control DMA transfer." mask="0x1000000"/>
          <bitfield name="TRANS_ABORT" caption="This is used to abort the current transfer on this DMA Channel. The aborted transfer will be forced to terminate immediately." mask="0x2000000"/>
        </register>
        <register name="ISTS" offset="0x14" rw="RW" size="1" access-size="1" initval="0x00" caption="DMA Channel N Interrupt Status">
          <bitfield name="BUS_ERR" caption="This is an interrupt source register. This flags when there is an Error detected over the internal 32-bit Bus.                  1: Error detected. (R/WC)" mask="0x1"/>
          <bitfield name="FLOW_CTRL" caption="This is an interrupt source register. This flags when the DMA Channel has encountered a Hardware Flow Control Request     after the DMA Channel has completed the transfer. This means the Master Device is attempting to overflow the DMA.                  1=Hardware Flow Control is requesting after the transfer has completed                  0=No Hardware Flow Control event" mask="0x2"/>
          <bitfield name="DONE" caption="This is an interrupt source register. This flags when the DMA Channel has completed a transfer successfully on its side.     A completed transfer is defined as when the DMA Channel reaches its limit; Memory Start Address equals Memory End Address.     A completion due to a Hardware Flow Control Terminate will not flag this interrupt.                  1=Memory Start Address equals Memory End Address                  0=Memory Start Address does not equal Memory End Address" mask="0x4"/>
        </register>
        <register name="IEN" offset="0x18" rw="RW" size="1" access-size="1" initval="0x00" caption="DMA CHANNEL N INTERRUPT ENABLE">
          <bitfield name="STS_EN_BUS_ERR" caption="This is an interrupt enable for DMA Channel Interrupt:Status Bus Error.                  1=Enable Interrupt                  0=Disable Interrupt" mask="0x1"/>
          <bitfield name="STS_EN_FLOW_CTRL" caption="This is an interrupt enable for DMA Channel Interrupt:Status Flow Control Error.                  1=Enable Interrupt                  0=Disable Interrupt" mask="0x2"/>
          <bitfield name="STS_EN_DONE" caption="This is an interrupt enable for DMA Channel Interrupt:Status Done.                  1=Enable Interrupt                  0=Disable Interrupt" mask="0x4"/>
        </register>
      </register-group>
      <value-group caption="" name="DMA_CHAN02_CTRL__STS">
        <value caption="3: Error detected by the DMA" name="ERROR" value="0x3"/>
        <value caption="2: The DMA Channel is externally done, in that the Device has terminated the transfer over the Hardware Flow Control through the Port dma_term" name="EXT_DONE" value="0x2"/>
        <value caption="1: The DMA Channel is locally done, in that Memory Start Address equals Memory End Address" name="LOC_DONE" value="0x1"/>
        <value caption="0: DMA Channel Control:Run is Disabled (0x0)" name="DIS" value="0x0"/>
      </value-group>
    </module>
    <module name="ECIA" id="200" version="1.0" caption="The ECIA works in conjunction with the processor interrupt interface to handle hardware interrupts andd exceptions.">
      <register-group name="ECIA" caption="The ECIA works in conjunction with the processor interrupt interface to handle hardware interrupts andd exceptions.">
        <register name="SRC8" offset="0x0" rw="RW" size="4" access-size="4" initval="0x00000000" caption="GIRQ8 SOURCE">
          <bitfield name="GPIO140" caption="GPIO 140" mask="0x00000001"/>
          <bitfield name="GPIO143" caption="GPIO 143" mask="0x00000008"/>
          <bitfield name="GPIO144" caption="GPIO 144" mask="0x00000010"/>
          <bitfield name="GPIO145" caption="GPIO 145" mask="0x00000020"/>
          <bitfield name="GPIO146" caption="GPIO 146" mask="0x00000040"/>
          <bitfield name="GPIO147" caption="GPIO 147" mask="0x00000080"/>
          <bitfield name="GPIO150" caption="GPIO 150" mask="0x00000100"/>
          <bitfield name="GPIO156" caption="GPIO 156" mask="0x00004000"/>
          <bitfield name="GPIO157" caption="GPIO 157" mask="0x00008000"/>
          <bitfield name="GPIO163" caption="GPIO 163" mask="0x00080000"/>
          <bitfield name="GPIO165" caption="GPIO 165" mask="0x00200000"/>
          <bitfield name="GPIO166" caption="GPIO 166" mask="0x00400000"/>
          <bitfield name="GPIO170" caption="GPIO 170" mask="0x01000000"/>
          <bitfield name="GPIO171" caption="GPIO 171" mask="0x02000000"/>
        </register>
        <register name="EN_SET8" offset="0x4" rw="RW" size="4" access-size="4" atomic-op="set:EN_SET" initval="0x00000000" caption="GIRQ8 ENABLE SET">
          <bitfield name="GPIO140" caption="GPIO 140" mask="0x00000001"/>
          <bitfield name="GPIO143" caption="GPIO 143" mask="0x00000008"/>
          <bitfield name="GPIO144" caption="GPIO 144" mask="0x00000010"/>
          <bitfield name="GPIO145" caption="GPIO 145" mask="0x00000020"/>
          <bitfield name="GPIO146" caption="GPIO 146" mask="0x00000040"/>
          <bitfield name="GPIO147" caption="GPIO 147" mask="0x00000080"/>
          <bitfield name="GPIO150" caption="GPIO 150" mask="0x00000100"/>
          <bitfield name="GPIO156" caption="GPIO 156" mask="0x00004000"/>
          <bitfield name="GPIO157" caption="GPIO 157" mask="0x00008000"/>
          <bitfield name="GPIO163" caption="GPIO 163" mask="0x00080000"/>
          <bitfield name="GPIO165" caption="GPIO 165" mask="0x00200000"/>
          <bitfield name="GPIO166" caption="GPIO 166" mask="0x00400000"/>
          <bitfield name="GPIO170" caption="GPIO 170" mask="0x01000000"/>
          <bitfield name="GPIO171" caption="GPIO 171" mask="0x02000000"/>
        </register>
        <register name="RESULT8" offset="0x8" rw="R" size="4" access-size="4" initval="0x00000000" caption="GIRQ8 RESULT">
          <bitfield name="GPIO140" caption="GPIO 140" mask="0x00000001"/>
          <bitfield name="GPIO143" caption="GPIO 143" mask="0x00000008"/>
          <bitfield name="GPIO144" caption="GPIO 144" mask="0x00000010"/>
          <bitfield name="GPIO145" caption="GPIO 145" mask="0x00000020"/>
          <bitfield name="GPIO146" caption="GPIO 146" mask="0x00000040"/>
          <bitfield name="GPIO147" caption="GPIO 147" mask="0x00000080"/>
          <bitfield name="GPIO150" caption="GPIO 150" mask="0x00000100"/>
          <bitfield name="GPIO156" caption="GPIO 156" mask="0x00004000"/>
          <bitfield name="GPIO157" caption="GPIO 157" mask="0x00008000"/>
          <bitfield name="GPIO163" caption="GPIO 163" mask="0x00080000"/>
          <bitfield name="GPIO165" caption="GPIO 165" mask="0x00200000"/>
          <bitfield name="GPIO166" caption="GPIO 166" mask="0x00400000"/>
          <bitfield name="GPIO170" caption="GPIO 170" mask="0x01000000"/>
          <bitfield name="GPIO171" caption="GPIO 171" mask="0x02000000"/>
        </register>
        <register name="EN_CLR8" offset="0xc" rw="RW" size="4" access-size="4" atomic-op="clear:EN_CLR" initval="0x00000000" caption="GIRQ8 ENABLE CLEAR">
          <bitfield name="GPIO140" caption="GPIO 140" mask="0x00000001"/>
          <bitfield name="GPIO143" caption="GPIO 143" mask="0x00000008"/>
          <bitfield name="GPIO144" caption="GPIO 144" mask="0x00000010"/>
          <bitfield name="GPIO145" caption="GPIO 145" mask="0x00000020"/>
          <bitfield name="GPIO146" caption="GPIO 146" mask="0x00000040"/>
          <bitfield name="GPIO147" caption="GPIO 147" mask="0x00000080"/>
          <bitfield name="GPIO150" caption="GPIO 150" mask="0x00000100"/>
          <bitfield name="GPIO156" caption="GPIO 156" mask="0x00004000"/>
          <bitfield name="GPIO157" caption="GPIO 157" mask="0x00008000"/>
          <bitfield name="GPIO163" caption="GPIO 163" mask="0x00080000"/>
          <bitfield name="GPIO165" caption="GPIO 165" mask="0x00200000"/>
          <bitfield name="GPIO166" caption="GPIO 166" mask="0x00400000"/>
          <bitfield name="GPIO170" caption="GPIO 170" mask="0x01000000"/>
          <bitfield name="GPIO171" caption="GPIO 171" mask="0x02000000"/>
        </register>
        <register name="SRC9" offset="0x14" rw="RW" size="4" access-size="4" initval="0x00000000" caption="GIRQ9 SOURCE">
          <bitfield name="GPIO104" caption="GPIO 104" mask="0x00000010"/>
          <bitfield name="GPIO105" caption="GPIO 105" mask="0x00000020"/>
          <bitfield name="GPIO106" caption="GPIO 106" mask="0x00000040"/>
          <bitfield name="GPIO107" caption="GPIO 107" mask="0x00000080"/>
          <bitfield name="GPIO112" caption="GPIO 112" mask="0x00000400"/>
          <bitfield name="GPIO113" caption="GPIO 113" mask="0x00000800"/>
          <bitfield name="GPIO120" caption="GPIO 120" mask="0x00010000"/>
          <bitfield name="GPIO121" caption="GPIO 121" mask="0x00020000"/>
          <bitfield name="GPIO122" caption="GPIO 122" mask="0x00040000"/>
          <bitfield name="GPIO123" caption="GPIO 123" mask="0x00080000"/>
          <bitfield name="GPIO124" caption="GPIO 124" mask="0x00100000"/>
          <bitfield name="GPIO125" caption="GPIO 125" mask="0x00200000"/>
          <bitfield name="GPIO126" caption="GPIO 126" mask="0x00400000"/>
          <bitfield name="GPIO127" caption="GPIO 127" mask="0x00800000"/>
          <bitfield name="GPIO130" caption="GPIO 130" mask="0x01000000"/>
          <bitfield name="GPIO131" caption="GPIO 131" mask="0x02000000"/>
          <bitfield name="GPIO132" caption="GPIO 132" mask="0x04000000"/>
        </register>
        <register name="EN_SET9" offset="0x18" rw="RW" size="4" access-size="4" atomic-op="set:EN_SET" initval="0x00000000" caption="GIRQ9 ENABLE SET">
          <bitfield name="GPIO104" caption="GPIO 104" mask="0x00000010"/>
          <bitfield name="GPIO105" caption="GPIO 105" mask="0x00000020"/>
          <bitfield name="GPIO106" caption="GPIO 106" mask="0x00000040"/>
          <bitfield name="GPIO107" caption="GPIO 107" mask="0x00000080"/>
          <bitfield name="GPIO112" caption="GPIO 112" mask="0x00000400"/>
          <bitfield name="GPIO113" caption="GPIO 113" mask="0x00000800"/>
          <bitfield name="GPIO120" caption="GPIO 120" mask="0x00010000"/>
          <bitfield name="GPIO121" caption="GPIO 121" mask="0x00020000"/>
          <bitfield name="GPIO122" caption="GPIO 122" mask="0x00040000"/>
          <bitfield name="GPIO123" caption="GPIO 123" mask="0x00080000"/>
          <bitfield name="GPIO124" caption="GPIO 124" mask="0x00100000"/>
          <bitfield name="GPIO125" caption="GPIO 125" mask="0x00200000"/>
          <bitfield name="GPIO126" caption="GPIO 126" mask="0x00400000"/>
          <bitfield name="GPIO127" caption="GPIO 127" mask="0x00800000"/>
          <bitfield name="GPIO130" caption="GPIO 130" mask="0x01000000"/>
          <bitfield name="GPIO131" caption="GPIO 131" mask="0x02000000"/>
          <bitfield name="GPIO132" caption="GPIO 132" mask="0x04000000"/>
        </register>
        <register name="RESULT9" offset="0x1c" rw="R" size="4" access-size="4" initval="0x00000000" caption="GIRQ9 RESULT">
          <bitfield name="GPIO104" caption="GPIO 104" mask="0x00000010"/>
          <bitfield name="GPIO105" caption="GPIO 105" mask="0x00000020"/>
          <bitfield name="GPIO106" caption="GPIO 106" mask="0x00000040"/>
          <bitfield name="GPIO107" caption="GPIO 107" mask="0x00000080"/>
          <bitfield name="GPIO112" caption="GPIO 112" mask="0x00000400"/>
          <bitfield name="GPIO113" caption="GPIO 113" mask="0x00000800"/>
          <bitfield name="GPIO120" caption="GPIO 120" mask="0x00010000"/>
          <bitfield name="GPIO121" caption="GPIO 121" mask="0x00020000"/>
          <bitfield name="GPIO122" caption="GPIO 122" mask="0x00040000"/>
          <bitfield name="GPIO123" caption="GPIO 123" mask="0x00080000"/>
          <bitfield name="GPIO124" caption="GPIO 124" mask="0x00100000"/>
          <bitfield name="GPIO125" caption="GPIO 125" mask="0x00200000"/>
          <bitfield name="GPIO126" caption="GPIO 126" mask="0x00400000"/>
          <bitfield name="GPIO127" caption="GPIO 127" mask="0x00800000"/>
          <bitfield name="GPIO130" caption="GPIO 130" mask="0x01000000"/>
          <bitfield name="GPIO131" caption="GPIO 131" mask="0x02000000"/>
          <bitfield name="GPIO132" caption="GPIO 132" mask="0x04000000"/>
        </register>
        <register name="EN_CLR9" offset="0x20" rw="RW" size="4" access-size="4" atomic-op="clear:EN_CLR" initval="0x00000000" caption="GIRQ9 ENABLE CLEAR">
          <bitfield name="GPIO104" caption="GPIO 104" mask="0x00000010"/>
          <bitfield name="GPIO105" caption="GPIO 105" mask="0x00000020"/>
          <bitfield name="GPIO106" caption="GPIO 106" mask="0x00000040"/>
          <bitfield name="GPIO107" caption="GPIO 107" mask="0x00000080"/>
          <bitfield name="GPIO112" caption="GPIO 112" mask="0x00000400"/>
          <bitfield name="GPIO113" caption="GPIO 113" mask="0x00000800"/>
          <bitfield name="GPIO120" caption="GPIO 120" mask="0x00010000"/>
          <bitfield name="GPIO121" caption="GPIO 121" mask="0x00020000"/>
          <bitfield name="GPIO122" caption="GPIO 122" mask="0x00040000"/>
          <bitfield name="GPIO123" caption="GPIO 123" mask="0x00080000"/>
          <bitfield name="GPIO124" caption="GPIO 124" mask="0x00100000"/>
          <bitfield name="GPIO125" caption="GPIO 125" mask="0x00200000"/>
          <bitfield name="GPIO126" caption="GPIO 126" mask="0x00400000"/>
          <bitfield name="GPIO127" caption="GPIO 127" mask="0x00800000"/>
          <bitfield name="GPIO130" caption="GPIO 130" mask="0x01000000"/>
          <bitfield name="GPIO131" caption="GPIO 131" mask="0x02000000"/>
          <bitfield name="GPIO132" caption="GPIO 132" mask="0x04000000"/>
        </register>
        <register name="SRC10" offset="0x28" rw="RW" size="4" access-size="4" initval="0x00000000" caption="GIRQ10 SOURCE">
          <bitfield name="GPIO045" caption="GPIO 045" mask="0x00000020"/>
          <bitfield name="GPIO046" caption="GPIO 046" mask="0x00000040"/>
          <bitfield name="GPIO047" caption="GPIO 047" mask="0x00000080"/>
          <bitfield name="GPIO050" caption="GPIO 050" mask="0x00000100"/>
          <bitfield name="GPIO053" caption="GPIO 053" mask="0x00000800"/>
          <bitfield name="GPIO055" caption="GPIO 055" mask="0x00002000"/>
          <bitfield name="GPIO056" caption="GPIO 056" mask="0x00004000"/>
          <bitfield name="GPIO057" caption="GPIO 057" mask="0x00008000"/>
          <bitfield name="GPIO063" caption="GPIO 060" mask="0x00080000"/>
          <bitfield name="GPIO070" caption="GPIO 070" mask="0x01000000"/>
          <bitfield name="GPIO071" caption="GPIO 071" mask="0x02000000"/>
        </register>
        <register name="EN_SET10" offset="0x2c" rw="RW" size="4" access-size="4" atomic-op="set:EN_SET" initval="0x00000000" caption="GIRQ10 ENABLE SET">
          <bitfield name="GPIO045" caption="GPIO 045" mask="0x00000020"/>
          <bitfield name="GPIO046" caption="GPIO 046" mask="0x00000040"/>
          <bitfield name="GPIO047" caption="GPIO 047" mask="0x00000080"/>
          <bitfield name="GPIO050" caption="GPIO 050" mask="0x00000100"/>
          <bitfield name="GPIO053" caption="GPIO 053" mask="0x00000800"/>
          <bitfield name="GPIO055" caption="GPIO 055" mask="0x00002000"/>
          <bitfield name="GPIO056" caption="GPIO 056" mask="0x00004000"/>
          <bitfield name="GPIO057" caption="GPIO 057" mask="0x00008000"/>
          <bitfield name="GPIO063" caption="GPIO 060" mask="0x00080000"/>
          <bitfield name="GPIO070" caption="GPIO 070" mask="0x01000000"/>
          <bitfield name="GPIO071" caption="GPIO 071" mask="0x02000000"/>
        </register>
        <register name="RESULT10" offset="0x30" rw="R" size="4" access-size="4" initval="0x00000000" caption="GIRQ10 RESULT">
          <bitfield name="GPIO045" caption="GPIO 045" mask="0x00000020"/>
          <bitfield name="GPIO046" caption="GPIO 046" mask="0x00000040"/>
          <bitfield name="GPIO047" caption="GPIO 047" mask="0x00000080"/>
          <bitfield name="GPIO050" caption="GPIO 050" mask="0x00000100"/>
          <bitfield name="GPIO053" caption="GPIO 053" mask="0x00000800"/>
          <bitfield name="GPIO055" caption="GPIO 055" mask="0x00002000"/>
          <bitfield name="GPIO056" caption="GPIO 056" mask="0x00004000"/>
          <bitfield name="GPIO057" caption="GPIO 057" mask="0x00008000"/>
          <bitfield name="GPIO063" caption="GPIO 060" mask="0x00080000"/>
          <bitfield name="GPIO070" caption="GPIO 070" mask="0x01000000"/>
          <bitfield name="GPIO071" caption="GPIO 071" mask="0x02000000"/>
        </register>
        <register name="EN_CLR10" offset="0x34" rw="RW" size="4" access-size="4" atomic-op="clear:EN_CLR" initval="0x00000000" caption="GIRQ10 ENABLE CLEAR">
          <bitfield name="GPIO045" caption="GPIO 045" mask="0x00000020"/>
          <bitfield name="GPIO046" caption="GPIO 046" mask="0x00000040"/>
          <bitfield name="GPIO047" caption="GPIO 047" mask="0x00000080"/>
          <bitfield name="GPIO050" caption="GPIO 050" mask="0x00000100"/>
          <bitfield name="GPIO053" caption="GPIO 053" mask="0x00000800"/>
          <bitfield name="GPIO055" caption="GPIO 055" mask="0x00002000"/>
          <bitfield name="GPIO056" caption="GPIO 056" mask="0x00004000"/>
          <bitfield name="GPIO057" caption="GPIO 057" mask="0x00008000"/>
          <bitfield name="GPIO063" caption="GPIO 060" mask="0x00080000"/>
          <bitfield name="GPIO070" caption="GPIO 070" mask="0x01000000"/>
          <bitfield name="GPIO071" caption="GPIO 071" mask="0x02000000"/>
        </register>
        <register name="SRC11" offset="0x3c" rw="RW" size="4" access-size="4" initval="0x00000000" caption="GIRQ11 SOURCE">
          <bitfield name="GPIO000" caption="GPIO 000" mask="0x00000001"/>
          <bitfield name="GPIO002" caption="GPIO 002" mask="0x00000004"/>
          <bitfield name="GPIO003" caption="GPIO 003" mask="0x00000008"/>
          <bitfield name="GPIO004" caption="GPIO 004" mask="0x00000010"/>
          <bitfield name="GPIO012" caption="GPIO 012" mask="0x00000400"/>
          <bitfield name="GPIO013" caption="GPIO 013" mask="0x00000800"/>
          <bitfield name="GPIO015" caption="GPIO 015" mask="0x00002000"/>
          <bitfield name="GPIO016" caption="GPIO 016" mask="0x00004000"/>
          <bitfield name="GPIO020" caption="GPIO 020" mask="0x00010000"/>
          <bitfield name="GPIO021" caption="GPIO 021" mask="0x00020000"/>
          <bitfield name="GPIO022" caption="GPIO 022" mask="0x00040000"/>
          <bitfield name="GPIO023" caption="GPIO 023" mask="0x00080000"/>
          <bitfield name="GPIO024" caption="GPIO 024" mask="0x00100000"/>
          <bitfield name="GPIO026" caption="GPIO 026" mask="0x00400000"/>
          <bitfield name="GPIO027" caption="GPIO 027" mask="0x00800000"/>
          <bitfield name="GPIO030" caption="GPIO 030" mask="0x01000000"/>
          <bitfield name="GPIO031" caption="GPIO 031" mask="0x02000000"/>
          <bitfield name="GPIO032" caption="GPIO 032" mask="0x04000000"/>
          <bitfield name="GPIO033" caption="GPIO 033" mask="0x08000000"/>
          <bitfield name="GPIO034" caption="GPIO 034" mask="0x10000000"/>
        </register>
        <register name="EN_SET11" offset="0x40" rw="RW" size="4" access-size="4" atomic-op="set:EN_SET" initval="0x00000000" caption="GIRQ11 ENABLE SET">
          <bitfield name="GPIO000" caption="GPIO 000" mask="0x00000001"/>
          <bitfield name="GPIO002" caption="GPIO 002" mask="0x00000004"/>
          <bitfield name="GPIO003" caption="GPIO 003" mask="0x00000008"/>
          <bitfield name="GPIO004" caption="GPIO 004" mask="0x00000010"/>
          <bitfield name="GPIO012" caption="GPIO 012" mask="0x00000400"/>
          <bitfield name="GPIO013" caption="GPIO 013" mask="0x00000800"/>
          <bitfield name="GPIO015" caption="GPIO 015" mask="0x00002000"/>
          <bitfield name="GPIO016" caption="GPIO 016" mask="0x00004000"/>
          <bitfield name="GPIO020" caption="GPIO 020" mask="0x00010000"/>
          <bitfield name="GPIO021" caption="GPIO 021" mask="0x00020000"/>
          <bitfield name="GPIO022" caption="GPIO 022" mask="0x00040000"/>
          <bitfield name="GPIO023" caption="GPIO 023" mask="0x00080000"/>
          <bitfield name="GPIO024" caption="GPIO 024" mask="0x00100000"/>
          <bitfield name="GPIO026" caption="GPIO 026" mask="0x00400000"/>
          <bitfield name="GPIO027" caption="GPIO 027" mask="0x00800000"/>
          <bitfield name="GPIO030" caption="GPIO 030" mask="0x01000000"/>
          <bitfield name="GPIO031" caption="GPIO 031" mask="0x02000000"/>
          <bitfield name="GPIO032" caption="GPIO 032" mask="0x04000000"/>
          <bitfield name="GPIO033" caption="GPIO 033" mask="0x08000000"/>
          <bitfield name="GPIO034" caption="GPIO 034" mask="0x10000000"/>
        </register>
        <register name="RESULT11" offset="0x44" rw="R" size="4" access-size="4" initval="0x00000000" caption="GIRQ11 RESULT">
          <bitfield name="GPIO000" caption="GPIO 000" mask="0x00000001"/>
          <bitfield name="GPIO002" caption="GPIO 002" mask="0x00000004"/>
          <bitfield name="GPIO003" caption="GPIO 003" mask="0x00000008"/>
          <bitfield name="GPIO004" caption="GPIO 004" mask="0x00000010"/>
          <bitfield name="GPIO012" caption="GPIO 012" mask="0x00000400"/>
          <bitfield name="GPIO013" caption="GPIO 013" mask="0x00000800"/>
          <bitfield name="GPIO015" caption="GPIO 015" mask="0x00002000"/>
          <bitfield name="GPIO016" caption="GPIO 016" mask="0x00004000"/>
          <bitfield name="GPIO020" caption="GPIO 020" mask="0x00010000"/>
          <bitfield name="GPIO021" caption="GPIO 021" mask="0x00020000"/>
          <bitfield name="GPIO022" caption="GPIO 022" mask="0x00040000"/>
          <bitfield name="GPIO023" caption="GPIO 023" mask="0x00080000"/>
          <bitfield name="GPIO024" caption="GPIO 024" mask="0x00100000"/>
          <bitfield name="GPIO026" caption="GPIO 026" mask="0x00400000"/>
          <bitfield name="GPIO027" caption="GPIO 027" mask="0x00800000"/>
          <bitfield name="GPIO030" caption="GPIO 030" mask="0x01000000"/>
          <bitfield name="GPIO031" caption="GPIO 031" mask="0x02000000"/>
          <bitfield name="GPIO032" caption="GPIO 032" mask="0x04000000"/>
          <bitfield name="GPIO033" caption="GPIO 033" mask="0x08000000"/>
          <bitfield name="GPIO034" caption="GPIO 034" mask="0x10000000"/>
        </register>
        <register name="EN_CLR11" offset="0x48" rw="RW" size="4" access-size="4" atomic-op="clear:EN_CLR" initval="0x00000000" caption="GIRQ11 ENABLE CLEAR">
          <bitfield name="GPIO000" caption="GPIO 000" mask="0x00000001"/>
          <bitfield name="GPIO002" caption="GPIO 002" mask="0x00000004"/>
          <bitfield name="GPIO003" caption="GPIO 003" mask="0x00000008"/>
          <bitfield name="GPIO004" caption="GPIO 004" mask="0x00000010"/>
          <bitfield name="GPIO012" caption="GPIO 012" mask="0x00000400"/>
          <bitfield name="GPIO013" caption="GPIO 013" mask="0x00000800"/>
          <bitfield name="GPIO015" caption="GPIO 015" mask="0x00002000"/>
          <bitfield name="GPIO016" caption="GPIO 016" mask="0x00004000"/>
          <bitfield name="GPIO020" caption="GPIO 020" mask="0x00010000"/>
          <bitfield name="GPIO021" caption="GPIO 021" mask="0x00020000"/>
          <bitfield name="GPIO022" caption="GPIO 022" mask="0x00040000"/>
          <bitfield name="GPIO023" caption="GPIO 023" mask="0x00080000"/>
          <bitfield name="GPIO024" caption="GPIO 024" mask="0x00100000"/>
          <bitfield name="GPIO026" caption="GPIO 026" mask="0x00400000"/>
          <bitfield name="GPIO027" caption="GPIO 027" mask="0x00800000"/>
          <bitfield name="GPIO030" caption="GPIO 030" mask="0x01000000"/>
          <bitfield name="GPIO031" caption="GPIO 031" mask="0x02000000"/>
          <bitfield name="GPIO032" caption="GPIO 032" mask="0x04000000"/>
          <bitfield name="GPIO033" caption="GPIO 033" mask="0x08000000"/>
          <bitfield name="GPIO034" caption="GPIO 034" mask="0x10000000"/>
        </register>
        <register name="SRC12" offset="0x50" rw="RW" size="4" access-size="4" initval="0x00000000" caption="GIRQ12 SOURCE">
          <bitfield name="GPIO200" caption="GPIO 200" mask="0x00000001"/>
          <bitfield name="GPIO201" caption="GPIO 201" mask="0x00000002"/>
          <bitfield name="GPIO202" caption="GPIO 202" mask="0x00000004"/>
          <bitfield name="GPIO203" caption="GPIO 203" mask="0x00000008"/>
          <bitfield name="GPIO204" caption="GPIO 204" mask="0x00000010"/>
          <bitfield name="GPIO223" caption="GPIO 223" mask="0x00080000"/>
          <bitfield name="GPIO224" caption="GPIO 224" mask="0x00100000"/>
          <bitfield name="GPIO227" caption="GPIO 227" mask="0x00800000"/>
        </register>
        <register name="EN_SET12" offset="0x54" rw="RW" size="4" access-size="4" atomic-op="set:EN_SET" initval="0x00000000" caption="GIRQ12 ENABLE SET">
          <bitfield name="GPIO200" caption="GPIO 200" mask="0x00000001"/>
          <bitfield name="GPIO201" caption="GPIO 201" mask="0x00000002"/>
          <bitfield name="GPIO202" caption="GPIO 202" mask="0x00000004"/>
          <bitfield name="GPIO203" caption="GPIO 203" mask="0x00000008"/>
          <bitfield name="GPIO204" caption="GPIO 204" mask="0x00000010"/>
          <bitfield name="GPIO223" caption="GPIO 223" mask="0x00080000"/>
          <bitfield name="GPIO224" caption="GPIO 224" mask="0x00100000"/>
          <bitfield name="GPIO227" caption="GPIO 227" mask="0x00800000"/>
        </register>
        <register name="RESULT12" offset="0x58" rw="R" size="4" access-size="4" initval="0x00000000" caption="GIRQ12 RESULT">
          <bitfield name="GPIO200" caption="GPIO 200" mask="0x00000001"/>
          <bitfield name="GPIO201" caption="GPIO 201" mask="0x00000002"/>
          <bitfield name="GPIO202" caption="GPIO 202" mask="0x00000004"/>
          <bitfield name="GPIO203" caption="GPIO 203" mask="0x00000008"/>
          <bitfield name="GPIO204" caption="GPIO 204" mask="0x00000010"/>
          <bitfield name="GPIO223" caption="GPIO 223" mask="0x00080000"/>
          <bitfield name="GPIO224" caption="GPIO 224" mask="0x00100000"/>
          <bitfield name="GPIO227" caption="GPIO 227" mask="0x00800000"/>
        </register>
        <register name="EN_CLR12" offset="0x5c" rw="RW" size="4" access-size="4" atomic-op="clear:EN_CLR" initval="0x00000000" caption="GIRQ12 ENABLE CLEAR">
          <bitfield name="GPIO200" caption="GPIO 200" mask="0x00000001"/>
          <bitfield name="GPIO201" caption="GPIO 201" mask="0x00000002"/>
          <bitfield name="GPIO202" caption="GPIO 202" mask="0x00000004"/>
          <bitfield name="GPIO203" caption="GPIO 203" mask="0x00000008"/>
          <bitfield name="GPIO204" caption="GPIO 204" mask="0x00000010"/>
          <bitfield name="GPIO223" caption="GPIO 223" mask="0x00080000"/>
          <bitfield name="GPIO224" caption="GPIO 224" mask="0x00100000"/>
          <bitfield name="GPIO227" caption="GPIO 227" mask="0x00800000"/>
        </register>
        <register name="SRC13" offset="0x64" rw="RW" size="4" access-size="4" initval="0x00000000" caption="GIRQ13 SOURCE">
          <bitfield name="I2CSMB0" caption="I2CSMB0" mask="0x00000001"/>
          <bitfield name="I2CSMB1" caption="I2CSMB1" mask="0x00000002"/>
          <bitfield name="I2CSMB2" caption="I2CSMB2" mask="0x00000004"/>
          <bitfield name="I2CSMB3" caption="I2CSMB3" mask="0x00000008"/>
          <bitfield name="I2CSMB4" caption="I2CSMB4" mask="0x00000010"/>
        </register>
        <register name="EN_SET13" offset="0x68" rw="RW" size="4" access-size="4" atomic-op="set:EN_SET" initval="0x00000000" caption="GIRQ13 ENABLE SET">
          <bitfield name="I2CSMB0" caption="I2CSMB0" mask="0x00000001"/>
          <bitfield name="I2CSMB1" caption="I2CSMB1" mask="0x00000002"/>
          <bitfield name="I2CSMB2" caption="I2CSMB2" mask="0x00000004"/>
          <bitfield name="I2CSMB3" caption="I2CSMB3" mask="0x00000008"/>
          <bitfield name="I2CSMB4" caption="I2CSMB4" mask="0x00000010"/>
        </register>
        <register name="RESULT13" offset="0x6c" rw="R" size="4" access-size="4" initval="0x00000000" caption="GIRQ13 RESULT">
          <bitfield name="I2CSMB0" caption="I2CSMB0" mask="0x00000001"/>
          <bitfield name="I2CSMB1" caption="I2CSMB1" mask="0x00000002"/>
          <bitfield name="I2CSMB2" caption="I2CSMB2" mask="0x00000004"/>
          <bitfield name="I2CSMB3" caption="I2CSMB3" mask="0x00000008"/>
          <bitfield name="I2CSMB4" caption="I2CSMB4" mask="0x00000010"/>
        </register>
        <register name="EN_CLR13" offset="0x70" rw="RW" size="4" access-size="4" atomic-op="clear:EN_CLR" initval="0x00000000" caption="GIRQ13 ENABLE CLEAR">
          <bitfield name="I2CSMB0" caption="I2CSMB0" mask="0x00000001"/>
          <bitfield name="I2CSMB1" caption="I2CSMB1" mask="0x00000002"/>
          <bitfield name="I2CSMB2" caption="I2CSMB2" mask="0x00000004"/>
          <bitfield name="I2CSMB3" caption="I2CSMB3" mask="0x00000008"/>
          <bitfield name="I2CSMB4" caption="I2CSMB4" mask="0x00000010"/>
        </register>
        <register name="SRC14" offset="0x78" rw="RW" size="4" access-size="4" initval="0x00000000" caption="GIRQ14 SOURCE">
          <bitfield name="DMA_CH00" caption="DMA CH00" mask="0x00000001"/>
          <bitfield name="DMA_CH01" caption="DMA CH01" mask="0x00000002"/>
          <bitfield name="DMA_CH02" caption="DMA CH02" mask="0x00000004"/>
          <bitfield name="DMA_CH03" caption="DMA CH03" mask="0x00000008"/>
          <bitfield name="DMA_CH04" caption="DMA CH04" mask="0x00000010"/>
          <bitfield name="DMA_CH05" caption="DMA CH05" mask="0x00000020"/>
          <bitfield name="DMA_CH06" caption="DMA CH06" mask="0x00000040"/>
          <bitfield name="DMA_CH07" caption="DMA CH07" mask="0x00000080"/>
          <bitfield name="DMA_CH08" caption="DMA CH08" mask="0x00000100"/>
          <bitfield name="DMA_CH09" caption="DMA CH09" mask="0x00000200"/>
        </register>
        <register name="EN_SET14" offset="0x7c" rw="RW" size="4" access-size="4" atomic-op="set:EN_SET" initval="0x00000000" caption="GIRQ14 ENABLE SET">
          <bitfield name="DMA_CH00" caption="DMA CH00" mask="0x00000001"/>
          <bitfield name="DMA_CH01" caption="DMA CH01" mask="0x00000002"/>
          <bitfield name="DMA_CH02" caption="DMA CH02" mask="0x00000004"/>
          <bitfield name="DMA_CH03" caption="DMA CH03" mask="0x00000008"/>
          <bitfield name="DMA_CH04" caption="DMA CH04" mask="0x00000010"/>
          <bitfield name="DMA_CH05" caption="DMA CH05" mask="0x00000020"/>
          <bitfield name="DMA_CH06" caption="DMA CH06" mask="0x00000040"/>
          <bitfield name="DMA_CH07" caption="DMA CH07" mask="0x00000080"/>
          <bitfield name="DMA_CH08" caption="DMA CH08" mask="0x00000100"/>
          <bitfield name="DMA_CH09" caption="DMA CH09" mask="0x00000200"/>
        </register>
        <register name="RESULT14" offset="0x80" rw="R" size="4" access-size="4" initval="0x00000000" caption="GIRQ14 RESULT">
          <bitfield name="DMA_CH00" caption="DMA CH00" mask="0x00000001"/>
          <bitfield name="DMA_CH01" caption="DMA CH01" mask="0x00000002"/>
          <bitfield name="DMA_CH02" caption="DMA CH02" mask="0x00000004"/>
          <bitfield name="DMA_CH03" caption="DMA CH03" mask="0x00000008"/>
          <bitfield name="DMA_CH04" caption="DMA CH04" mask="0x00000010"/>
          <bitfield name="DMA_CH05" caption="DMA CH05" mask="0x00000020"/>
          <bitfield name="DMA_CH06" caption="DMA CH06" mask="0x00000040"/>
          <bitfield name="DMA_CH07" caption="DMA CH07" mask="0x00000080"/>
          <bitfield name="DMA_CH08" caption="DMA CH08" mask="0x00000100"/>
          <bitfield name="DMA_CH09" caption="DMA CH09" mask="0x00000200"/>
        </register>
        <register name="EN_CLR14" offset="0x84" rw="RW" size="4" access-size="4" atomic-op="clear:EN_CLR" initval="0x00000000" caption="GIRQ14 ENABLE CLEAR">
          <bitfield name="DMA_CH00" caption="DMA CH00" mask="0x00000001"/>
          <bitfield name="DMA_CH01" caption="DMA CH01" mask="0x00000002"/>
          <bitfield name="DMA_CH02" caption="DMA CH02" mask="0x00000004"/>
          <bitfield name="DMA_CH03" caption="DMA CH03" mask="0x00000008"/>
          <bitfield name="DMA_CH04" caption="DMA CH04" mask="0x00000010"/>
          <bitfield name="DMA_CH05" caption="DMA CH05" mask="0x00000020"/>
          <bitfield name="DMA_CH06" caption="DMA CH06" mask="0x00000040"/>
          <bitfield name="DMA_CH07" caption="DMA CH07" mask="0x00000080"/>
          <bitfield name="DMA_CH08" caption="DMA CH08" mask="0x00000100"/>
          <bitfield name="DMA_CH09" caption="DMA CH09" mask="0x00000200"/>
        </register>
        <register name="SRC15" offset="0x8c" rw="RW" size="4" access-size="4" initval="0x00000000" caption="GIRQ15 SOURCE">
          <bitfield name="UART0" caption="UART0" mask="0x00000001"/>
        </register>
        <register name="EN_SET15" offset="0x90" rw="RW" size="4" access-size="4" atomic-op="set:EN_SET" initval="0x00000000" caption="GIRQ15 ENABLE SET">
          <bitfield name="UART0" caption="UART0" mask="0x00000001"/>
        </register>
        <register name="RESULT15" offset="0x94" rw="R" size="4" access-size="4" initval="0x00000000" caption="GIRQ15 RESULT">
          <bitfield name="UART0" caption="UART0" mask="0x00000001"/>
        </register>
        <register name="EN_CLR15" offset="0x98" rw="RW" size="4" access-size="4" atomic-op="clear:EN_CLR" initval="0x00000000" caption="GIRQ15 ENABLE CLEAR">
          <bitfield name="UART0" caption="UART0" mask="0x00000001"/>
        </register>
        <register name="SRC16" offset="0xa0" rw="RW" size="4" access-size="4" initval="0x00000000" caption="GIRQ16 SOURCE">
          <bitfield name="PKE_ERR" caption="PKE ERR" mask="0x00000001"/>
          <bitfield name="PKE_END" caption="PKE END" mask="0x00000002"/>
          <bitfield name="RNG" caption="RNG" mask="0x00000004"/>
          <bitfield name="AES" caption="AES" mask="0x00000008"/>
          <bitfield name="HASH" caption="HASH" mask="0x00000010"/>
        </register>
        <register name="EN_SET16" offset="0xa4" rw="RW" size="4" access-size="4" atomic-op="set:EN_SET" initval="0x00000000" caption="GIRQ16 ENABLE SET">
          <bitfield name="PKE_ERR" caption="PKE ERR" mask="0x00000001"/>
          <bitfield name="PKE_END" caption="PKE END" mask="0x00000002"/>
          <bitfield name="RNG" caption="RNG" mask="0x00000004"/>
          <bitfield name="AES" caption="AES" mask="0x00000008"/>
          <bitfield name="HASH" caption="HASH" mask="0x00000010"/>
        </register>
        <register name="RESULT16" offset="0xa8" rw="R" size="4" access-size="4" initval="0x00000000" caption="GIRQ16 RESULT">
          <bitfield name="PKE_ERR" caption="PKE ERR" mask="0x00000001"/>
          <bitfield name="PKE_END" caption="PKE END" mask="0x00000002"/>
          <bitfield name="RNG" caption="RNG" mask="0x00000004"/>
          <bitfield name="AES" caption="AES" mask="0x00000008"/>
          <bitfield name="HASH" caption="HASH" mask="0x00000010"/>
        </register>
        <register name="EN_CLR16" offset="0xac" rw="RW" size="4" access-size="4" atomic-op="clear:EN_CLR" initval="0x00000000" caption="GIRQ16 ENABLE CLEAR">
          <bitfield name="PKE_ERR" caption="PKE ERR" mask="0x00000001"/>
          <bitfield name="PKE_END" caption="PKE END" mask="0x00000002"/>
          <bitfield name="RNG" caption="RNG" mask="0x00000004"/>
          <bitfield name="AES" caption="AES" mask="0x00000008"/>
          <bitfield name="HASH" caption="HASH" mask="0x00000010"/>
        </register>
        <register name="SRC17" offset="0xb4" rw="RW" size="4" access-size="4" initval="0x00000000" caption="GIRQ17 SOURCE">
          <bitfield name="LED0" caption="Breating LED0" mask="0x00002000"/>
          <bitfield name="LED1" caption="Breating LED1" mask="0x00004000"/>
        </register>
        <register name="EN_SET17" offset="0xb8" rw="RW" size="4" access-size="4" atomic-op="set:EN_SET" initval="0x00000000" caption="GIRQ17 ENABLE SET">
          <bitfield name="LED0" caption="Breating LED0" mask="0x00002000"/>
          <bitfield name="LED1" caption="Breating LED1" mask="0x00004000"/>
        </register>
        <register name="RESULT17" offset="0xbc" rw="R" size="4" access-size="4" initval="0x00000000" caption="GIRQ17 RESULT">
          <bitfield name="LED0" caption="Breating LED0" mask="0x00002000"/>
          <bitfield name="LED1" caption="Breating LED1" mask="0x00004000"/>
        </register>
        <register name="EN_CLR17" offset="0xc0" rw="RW" size="4" access-size="4" atomic-op="clear:EN_CLR" initval="0x00000000" caption="GIRQ17 ENABLE CLEAR">
          <bitfield name="LED0" caption="Breating LED0" mask="0x00002000"/>
          <bitfield name="LED1" caption="Breating LED1" mask="0x00004000"/>
        </register>
        <register name="SRC18" offset="0xc8" rw="RW" size="4" access-size="4" initval="0x00000000" caption="GIRQ18 SOURCE">
          <bitfield name="SPT0" caption="SPT0" mask="0x00000001"/>
          <bitfield name="QMSPI0" caption="QMSPI0" mask="0x00000002"/>
          <bitfield name="QMSPI1" caption="QMSPI1" mask="0x00000004"/>
          <bitfield name="SPT1" caption="SPT1" mask="0x00040000"/>
          <bitfield name="CCT" caption="CCT" mask="0x00100000"/>
          <bitfield name="CCT_CAP0" caption="CCT_CAP0" mask="0x00200000"/>
          <bitfield name="CCT_CAP1" caption="CCT_CAP1" mask="0x00400000"/>
          <bitfield name="CCT_CAP2" caption="CCT_CAP2" mask="0x00800000"/>
          <bitfield name="CCT_CAP3" caption="CCT_CAP3" mask="0x01000000"/>
          <bitfield name="CCT_CAP4" caption="CCT_CAP4" mask="0x02000000"/>
          <bitfield name="CCT_CAP5" caption="CCT_CAP5" mask="0x04000000"/>
          <bitfield name="CCT_CMP0" caption="CCT_CMP0" mask="0x08000000"/>
          <bitfield name="CCT_CMP1" caption="CCT_CMP1" mask="0x10000000"/>
        </register>
        <register name="EN_SET18" offset="0xcc" rw="RW" size="4" access-size="4" atomic-op="set:EN_SET" initval="0x00000000" caption="GIRQ18 ENABLE SET">
          <bitfield name="SPT0" caption="SPT0" mask="0x00000001"/>
          <bitfield name="QMSPI0" caption="QMSPI0" mask="0x00000002"/>
          <bitfield name="QMSPI1" caption="QMSPI1" mask="0x00000004"/>
          <bitfield name="SPT1" caption="SPT1" mask="0x00040000"/>
          <bitfield name="CCT" caption="CCT" mask="0x00100000"/>
          <bitfield name="CCT_CAP0" caption="CCT_CAP0" mask="0x00200000"/>
          <bitfield name="CCT_CAP1" caption="CCT_CAP1" mask="0x00400000"/>
          <bitfield name="CCT_CAP2" caption="CCT_CAP2" mask="0x00800000"/>
          <bitfield name="CCT_CAP3" caption="CCT_CAP3" mask="0x01000000"/>
          <bitfield name="CCT_CAP4" caption="CCT_CAP4" mask="0x02000000"/>
          <bitfield name="CCT_CAP5" caption="CCT_CAP5" mask="0x04000000"/>
          <bitfield name="CCT_CMP0" caption="CCT_CMP0" mask="0x08000000"/>
          <bitfield name="CCT_CMP1" caption="CCT_CMP1" mask="0x10000000"/>
        </register>
        <register name="RESULT18" offset="0xd0" rw="R" size="4" access-size="4" initval="0x00000000" caption="GIRQ18 RESULT">
          <bitfield name="SPT0" caption="SPT0" mask="0x00000001"/>
          <bitfield name="QMSPI0" caption="QMSPI0" mask="0x00000002"/>
          <bitfield name="QMSPI1" caption="QMSPI1" mask="0x00000004"/>
          <bitfield name="SPT1" caption="SPT1" mask="0x00040000"/>
          <bitfield name="CCT" caption="CCT" mask="0x00100000"/>
          <bitfield name="CCT_CAP0" caption="CCT_CAP0" mask="0x00200000"/>
          <bitfield name="CCT_CAP1" caption="CCT_CAP1" mask="0x00400000"/>
          <bitfield name="CCT_CAP2" caption="CCT_CAP2" mask="0x00800000"/>
          <bitfield name="CCT_CAP3" caption="CCT_CAP3" mask="0x01000000"/>
          <bitfield name="CCT_CAP4" caption="CCT_CAP4" mask="0x02000000"/>
          <bitfield name="CCT_CAP5" caption="CCT_CAP5" mask="0x04000000"/>
          <bitfield name="CCT_CMP0" caption="CCT_CMP0" mask="0x08000000"/>
          <bitfield name="CCT_CMP1" caption="CCT_CMP1" mask="0x10000000"/>
        </register>
        <register name="EN_CLR18" offset="0xd4" rw="RW" size="4" access-size="4" atomic-op="clear:EN_CLR" initval="0x00000000" caption="GIRQ18 ENABLE CLEAR">
          <bitfield name="SPT0" caption="SPT0" mask="0x00000001"/>
          <bitfield name="QMSPI0" caption="QMSPI0" mask="0x00000002"/>
          <bitfield name="QMSPI1" caption="QMSPI1" mask="0x00000004"/>
          <bitfield name="SPT1" caption="SPT1" mask="0x00040000"/>
          <bitfield name="CCT" caption="CCT" mask="0x00100000"/>
          <bitfield name="CCT_CAP0" caption="CCT_CAP0" mask="0x00200000"/>
          <bitfield name="CCT_CAP1" caption="CCT_CAP1" mask="0x00400000"/>
          <bitfield name="CCT_CAP2" caption="CCT_CAP2" mask="0x00800000"/>
          <bitfield name="CCT_CAP3" caption="CCT_CAP3" mask="0x01000000"/>
          <bitfield name="CCT_CAP4" caption="CCT_CAP4" mask="0x02000000"/>
          <bitfield name="CCT_CAP5" caption="CCT_CAP5" mask="0x04000000"/>
          <bitfield name="CCT_CMP0" caption="CCT_CMP0" mask="0x08000000"/>
          <bitfield name="CCT_CMP1" caption="CCT_CMP1" mask="0x10000000"/>
        </register>
        <register name="SRC19" offset="0xdc" rw="RW" size="4" access-size="4" initval="0x00000000" caption="GIRQ19 SOURCE">
        </register>
        <register name="EN_SET19" offset="0xe0" rw="RW" size="4" access-size="4" atomic-op="set:EN_SET" initval="0x00000000" caption="GIRQ19 ENABLE SET">
        </register>
        <register name="RESULT19" offset="0xe4" rw="R" size="4" access-size="4" initval="0x00000000" caption="GIRQ19 RESULT">
        </register>
        <register name="EN_CLR19" offset="0xe8" rw="RW" size="4" access-size="4" atomic-op="clear:EN_CLR" initval="0x00000000" caption="GIRQ19 ENABLE CLEAR">
        </register>
        <register name="SRC20" offset="0xf0" rw="RW" size="4" access-size="4" initval="0x00000000" caption="GIRQ20 SOURCE">
          <bitfield name="IMSPI" caption="IMSPI" mask="0x00000100"/>
          <bitfield name="CLK_MON" caption="CLK_MON" mask="0x00000200"/>
          <bitfield name="VTR1_PAD_MON" caption="VTR1_PAD_MON" mask="0x00000400"/>
          <bitfield name="VTR2_PAD_MON" caption="VTR2_PAD_MON" mask="0x00000800"/>
        </register>
        <register name="EN_SET20" offset="0xf4" rw="RW" size="4" access-size="4" atomic-op="set:EN_SET" initval="0x00000000" caption="GIRQ20 ENABLE SET">
          <bitfield name="IMSPI" caption="IMSPI" mask="0x00000100"/>
          <bitfield name="CLK_MON" caption="CLK_MON" mask="0x00000200"/>
          <bitfield name="VTR1_PAD_MON" caption="VTR1_PAD_MON" mask="0x00000400"/>
          <bitfield name="VTR2_PAD_MON" caption="VTR2_PAD_MON" mask="0x00000800"/>
        </register>
        <register name="RESULT20" offset="0xf8" rw="R" size="4" access-size="4" initval="0x00000000" caption="GIRQ20 RESULT">
          <bitfield name="IMSPI" caption="IMSPI" mask="0x00000100"/>
          <bitfield name="CLK_MON" caption="CLK_MON" mask="0x00000200"/>
          <bitfield name="VTR1_PAD_MON" caption="VTR1_PAD_MON" mask="0x00000400"/>
          <bitfield name="VTR2_PAD_MON" caption="VTR2_PAD_MON" mask="0x00000800"/>
        </register>
        <register name="EN_CLR20" offset="0xfc" rw="RW" size="4" access-size="4" atomic-op="clear:EN_CLR" initval="0x00000000" caption="GIRQ20 ENABLE CLEAR">
          <bitfield name="IMSPI" caption="IMSPI" mask="0x00000100"/>
          <bitfield name="CLK_MON" caption="CLK_MON" mask="0x00000200"/>
          <bitfield name="VTR1_PAD_MON" caption="VTR1_PAD_MON" mask="0x00000400"/>
          <bitfield name="VTR2_PAD_MON" caption="VTR2_PAD_MON" mask="0x00000800"/>
        </register>
        <register name="SRC21" offset="0x104" rw="RW" size="4" access-size="4" initval="0x00000000" caption="GIRQ21 SOURCE">
          <bitfield name="WDT" caption="WDT" mask="0x00000004"/>
          <bitfield name="EMC" caption="EMC" mask="0x01000000"/>
        </register>
        <register name="EN_SET21" offset="0x108" rw="RW" size="4" access-size="4" atomic-op="set:EN_SET" initval="0x00000000" caption="GIRQ21 ENABLE SET">
          <bitfield name="WDT" caption="WDT" mask="0x00000004"/>
          <bitfield name="EMC" caption="EMC" mask="0x01000000"/>
        </register>
        <register name="RESULT21" offset="0x10c" rw="R" size="4" access-size="4" initval="0x00000000" caption="GIRQ21 RESULT">
          <bitfield name="WDT" caption="WDT" mask="0x00000004"/>
          <bitfield name="EMC" caption="EMC" mask="0x01000000"/>
        </register>
        <register name="EN_CLR21" offset="0x110" rw="RW" size="4" access-size="4" atomic-op="clear:EN_CLR" initval="0x00000000" caption="GIRQ21 ENABLE CLEAR">
          <bitfield name="WDT" caption="WDT" mask="0x00000004"/>
          <bitfield name="EMC" caption="EMC" mask="0x01000000"/>
        </register>
        <register name="SRC22" offset="0x118" rw="RW" size="4" access-size="4" initval="0x00000000" caption="GIRQ22 SOURCE">
        </register>
        <register name="EN_SET22" offset="0x11c" rw="RW" size="4" access-size="4" atomic-op="set:EN_SET" initval="0x00000000" caption="GIRQ22 ENABLE SET">
        </register>
        <register name="RESULT22" offset="0x120" rw="R" size="4" access-size="4" initval="0x00000000" caption="GIRQ22 RESULT">
        </register>
        <register name="EN_CLR22" offset="0x124" rw="RW" size="4" access-size="4" atomic-op="clear:EN_CLR" initval="0x00000000" caption="GIRQ22 ENABLE CLEAR">
        </register>
        <register name="SRC23" offset="0x12c" rw="RW" size="4" access-size="4" initval="0x00000000" caption="GIRQ23 SOURCE">
          <bitfield name="TIMER32_0" caption="TIMER32_0" mask="0x00000010"/>
          <bitfield name="TIMER32_1" caption="TIMER32_1" mask="0x00000020"/>
          <bitfield name="RTMR" caption="RTMR" mask="0x00000400"/>
          <bitfield name="SWI0" caption="SWI0" mask="0x00000800"/>
          <bitfield name="SWI1" caption="SWI1" mask="0x00001000"/>
          <bitfield name="SWI2" caption="SWI2" mask="0x00002000"/>
          <bitfield name="SWI3" caption="SWI3" mask="0x00004000"/>
          <bitfield name="HTMR0" caption="HTMR0" mask="0x00010000"/>
          <bitfield name="HTMR1" caption="HTMR1" mask="0x00020000"/>
        </register>
        <register name="EN_SET23" offset="0x130" rw="RW" size="4" access-size="4" atomic-op="set:EN_SET" initval="0x00000000" caption="GIRQ23 ENABLE SET">
          <bitfield name="TIMER32_0" caption="TIMER32_0" mask="0x00000010"/>
          <bitfield name="TIMER32_1" caption="TIMER32_1" mask="0x00000020"/>
          <bitfield name="RTMR" caption="RTMR" mask="0x00000400"/>
          <bitfield name="SWI0" caption="SWI0" mask="0x00000800"/>
          <bitfield name="SWI1" caption="SWI1" mask="0x00001000"/>
          <bitfield name="SWI2" caption="SWI2" mask="0x00002000"/>
          <bitfield name="SWI3" caption="SWI3" mask="0x00004000"/>
          <bitfield name="HTMR0" caption="HTMR0" mask="0x00010000"/>
          <bitfield name="HTMR1" caption="HTMR1" mask="0x00020000"/>
        </register>
        <register name="RESULT23" offset="0x134" rw="R" size="4" access-size="4" initval="0x00000000" caption="GIRQ23 RESULT">
          <bitfield name="TIMER32_0" caption="TIMER32_0" mask="0x00000010"/>
          <bitfield name="TIMER32_1" caption="TIMER32_1" mask="0x00000020"/>
          <bitfield name="RTMR" caption="RTMR" mask="0x00000400"/>
          <bitfield name="SWI0" caption="SWI0" mask="0x00000800"/>
          <bitfield name="SWI1" caption="SWI1" mask="0x00001000"/>
          <bitfield name="SWI2" caption="SWI2" mask="0x00002000"/>
          <bitfield name="SWI3" caption="SWI3" mask="0x00004000"/>
          <bitfield name="HTMR0" caption="HTMR0" mask="0x00010000"/>
          <bitfield name="HTMR1" caption="HTMR1" mask="0x00020000"/>
        </register>
        <register name="EN_CLR23" offset="0x138" rw="RW" size="4" access-size="4" atomic-op="clear:EN_CLR" initval="0x00000000" caption="GIRQ23 ENABLE CLEAR">
          <bitfield name="TIMER32_0" caption="TIMER32_0" mask="0x00000010"/>
          <bitfield name="TIMER32_1" caption="TIMER32_1" mask="0x00000020"/>
          <bitfield name="RTMR" caption="RTMR" mask="0x00000400"/>
          <bitfield name="SWI0" caption="SWI0" mask="0x00000800"/>
          <bitfield name="SWI1" caption="SWI1" mask="0x00001000"/>
          <bitfield name="SWI2" caption="SWI2" mask="0x00002000"/>
          <bitfield name="SWI3" caption="SWI3" mask="0x00004000"/>
          <bitfield name="HTMR0" caption="HTMR0" mask="0x00010000"/>
          <bitfield name="HTMR1" caption="HTMR1" mask="0x00020000"/>
        </register>
        <register name="SRC24" offset="0x140" rw="RW" size="4" access-size="4" initval="0x00000000" caption="GIRQ24 SOURCE">
          <bitfield name="SPIMON0_VLTN" caption="SPIMON0_VLTN" mask="0x00000001"/>
          <bitfield name="SPIMON0_MTMON" caption="SPIMON0_MTMON" mask="0x00000002"/>
          <bitfield name="SPIMON0_LTMON" caption="SPIMON0_LTMON" mask="0x00000004"/>
          <bitfield name="SPIMON1_VLTN" caption="SPIMON1_VLTN" mask="0x00000008"/>
          <bitfield name="SPIMON1_MTMON" caption="SPIMON1_MTMON" mask="0x00000010"/>
          <bitfield name="SPIMON1_LTMON" caption="SPIMON1_LTMON" mask="0x00000020"/>
        </register>
        <register name="EN_SET24" offset="0x144" rw="RW" size="4" access-size="4" atomic-op="set:EN_SET" initval="0x00000000" caption="GIRQ24 ENABLE SET">
          <bitfield name="SPIMON0_VLTN" caption="SPIMON0_VLTN" mask="0x00000001"/>
          <bitfield name="SPIMON0_MTMON" caption="SPIMON0_MTMON" mask="0x00000002"/>
          <bitfield name="SPIMON0_LTMON" caption="SPIMON0_LTMON" mask="0x00000004"/>
          <bitfield name="SPIMON1_VLTN" caption="SPIMON1_VLTN" mask="0x00000008"/>
          <bitfield name="SPIMON1_MTMON" caption="SPIMON1_MTMON" mask="0x00000010"/>
          <bitfield name="SPIMON1_LTMON" caption="SPIMON1_LTMON" mask="0x00000020"/>
        </register>
        <register name="RESULT24" offset="0x148" rw="R" size="4" access-size="4" initval="0x00000000" caption="GIRQ24 RESULT">
          <bitfield name="SPIMON0_VLTN" caption="SPIMON0_VLTN" mask="0x00000001"/>
          <bitfield name="SPIMON0_MTMON" caption="SPIMON0_MTMON" mask="0x00000002"/>
          <bitfield name="SPIMON0_LTMON" caption="SPIMON0_LTMON" mask="0x00000004"/>
          <bitfield name="SPIMON1_VLTN" caption="SPIMON1_VLTN" mask="0x00000008"/>
          <bitfield name="SPIMON1_MTMON" caption="SPIMON1_MTMON" mask="0x00000010"/>
          <bitfield name="SPIMON1_LTMON" caption="SPIMON1_LTMON" mask="0x00000020"/>
        </register>
        <register name="EN_CLR24" offset="0x14c" rw="RW" size="4" access-size="4" atomic-op="clear:EN_CLR" initval="0x00000000" caption="GIRQ24 ENABLE CLEAR">
          <bitfield name="SPIMON0_VLTN" caption="SPIMON0_VLTN" mask="0x00000001"/>
          <bitfield name="SPIMON0_MTMON" caption="SPIMON0_MTMON" mask="0x00000002"/>
          <bitfield name="SPIMON0_LTMON" caption="SPIMON0_LTMON" mask="0x00000004"/>
          <bitfield name="SPIMON1_VLTN" caption="SPIMON1_VLTN" mask="0x00000008"/>
          <bitfield name="SPIMON1_MTMON" caption="SPIMON1_MTMON" mask="0x00000010"/>
          <bitfield name="SPIMON1_LTMON" caption="SPIMON1_LTMON" mask="0x00000020"/>
        </register>
        <register name="SRC25" offset="0x154" rw="RW" size="4" access-size="4" initval="0x00000000" caption="GIRQ25 SOURCE">
        </register>
        <register name="EN_SET25" offset="0x158" rw="RW" size="4" access-size="4" atomic-op="set:EN_SET" initval="0x00000000" caption="GIRQ25 ENABLE SET">
        </register>
        <register name="RESULT25" offset="0x15c" rw="R" size="4" access-size="4" initval="0x00000000" caption="GIRQ25 RESULT">
        </register>
        <register name="EN_CLR25" offset="0x160" rw="RW" size="4" access-size="4" atomic-op="clear:EN_CLR" initval="0x00000000" caption="GIRQ25 ENABLE CLEAR">
        </register>
        <register name="SRC26" offset="0x168" rw="RW" size="4" access-size="4" initval="0x00000000" caption="GIRQ26 SOURCE">
          <bitfield name="GPIO250" caption="GPIO250" mask="0x00000100"/>
          <bitfield name="GPIO253" caption="GPIO253" mask="0x00000800"/>
        </register>
        <register name="EN_SET26" offset="0x16c" rw="RW" size="4" access-size="4" atomic-op="set:EN_SET" initval="0x00000000" caption="GIRQ26 ENABLE SET">
          <bitfield name="GPIO250" caption="GPIO250" mask="0x00000100"/>
          <bitfield name="GPIO260" caption="GPIO260" mask="0x00000800"/>
        </register>
        <register name="RESULT26" offset="0x170" rw="R" size="4" access-size="4" initval="0x00000000" caption="GIRQ26 RESULT">
          <bitfield name="GPIO250" caption="GPIO250" mask="0x00000100"/>
          <bitfield name="GPIO260" caption="GPIO260" mask="0x00000800"/>
        </register>
        <register name="EN_CLR26" offset="0x174" rw="RW" size="4" access-size="4" atomic-op="clear:EN_CLR" initval="0x00000000" caption="GIRQ26 ENABLE CLEAR">
          <bitfield name="GPIO250" caption="GPIO250" mask="0x00000100"/>
          <bitfield name="GPIO260" caption="GPIO260" mask="0x00000800"/>
        </register>
        <register name="BLK_EN_SET" offset="0x200" rw="RW" size="4" access-size="4" atomic-op="set:BLOCK_ENABLE_SET" initval="0x00000000" caption="Block Enable Set Register">
          <bitfield name="VTOR_EN_SET" caption="Each GIRQx bit can be individually enabled to assert an interrupt event.      Reads always return the current value of the internal GIRQX_ENABLE bit. The state of the GIRQX_ENABLE bit is determined by      the corresponding GIRQX_ENABLE_SET bit and the GIRQX_ENABLE_CLEAR bit. (0=disabled, 1=enabled) (R/WS)      1=Interrupts in the GIRQx Source Register may be enabled      0=No effect." mask="0x7FFFFFFF"/>
        </register>
        <register name="BLK_EN_CLR" offset="0x204" rw="RW" size="4" access-size="4" initval="0x00000000" caption="Block Enable Clear Register.">
          <bitfield name="VTOR_EN_CLR" caption="Each GIRQx bit can be individually disabled to inhibit an interrupt event.      Reads always return the current value of the internal GIRQX_ENABLE bit. The state of the GIRQX_ENABLE bit is determined by      the corresponding GIRQX_ENABLE_SET bit and the GIRQX_ENABLE_CLEAR bit. (0=disabled, 1=enabled) (R/WC)      1=All interrupts in the GIRQx Source Register are disabled      0=No effect." mask="0x7FFFFFFF"/>
        </register>
        <register name="BLK_IRQ_VTOR" offset="0x208" rw="R" size="4" access-size="4" initval="0x00000000" caption="Block IRQ Vector Register">
          <bitfield name="VTOR" caption="Each bit in this field reports the status of the group GIRQ interrupt assertion to the NVIC. If the GIRQx interrupt      is disabled as a group, by the Block Enable Clear Register, then the corresponding bit will be '0'b and no interrupt will be asserted." mask="0x1FFFFFF"/>
        </register>
      </register-group>
    </module>
    <module name="GCR" id="101" version="1.0" caption="The Logical Device Configuration registers support motherboard designs in which the resources required by their components are known and assigned by the BIOS at POST.">
      <register-group name="GCR" caption="The Logical Device Configuration registers support motherboard designs in which the resources required by their components are known and assigned by the BIOS at POST.">
        <register name="LDN" offset="0x7" rw="RW" size="1" access-size="1" initval="0x00" caption="A write to this register selects the current logical device. This allows access to the control and configuration registers for each logical device. Note: The Activate command operates only on the selected logical device.">
        </register>
        <register name="DEV_REV" offset="0x1C" rw="R" size="1" access-size="1" initval="0xA0" caption="A read-only register which provides device revision information.">
        </register>
        <register name="DEV_SUBID" offset="0x1D" rw="R" size="1" access-size="1" initval="0x41" caption="A read-only register which provides device sub ID information.">
        </register>
        <register name="DEV_ID" offset="0x1E" rw="R" size="2" access-size="2" initval="0x0023" caption="A read-only register which provides device identification LSB.">
        </register>
        <register name="LEG_DEV_ID" offset="0x20" rw="R" size="1" access-size="1" initval="0xFE" caption="A read-only register which provides legacy device identification.">
        </register>
        <register name="LEG_DEV_REV" offset="0x21" rw="R" size="1" access-size="1" initval="0xA0" caption="A read-only register which provides legacy device revision information.">
        </register>
        <register name="OTP_ID" offset="0x24" rw="R" size="1" access-size="1" initval="0x00" caption="A read-only register which provides OTP ID information.">
        </register>
        <register name="VLD_ID" offset="0x25" rw="R" size="1" access-size="1" initval="0x00" caption="A read-only register which provides Validation ID information.">
        </register>
        <register name="BR_REV_ID" offset="0x26" rw="R" size="1" access-size="1" initval="0x00" caption="A read-only register which provides Boot ROM Revision ID information.">
        </register>
      </register-group>
    </module>
    <module name="UART" id="39" version="1.0" caption="The 16550 UART is a full-function Two Pin Serial Port that supports the standard RS-232 Interface.">
      <register-group name="UART" caption="The 16550 UART is a full-function Two Pin Serial Port that supports the standard RS-232 Interface.">
        <mode name="DATA" qualifier="UART.LINE_CR.DLAB" mask="0x80" value="0x00" caption="UART when DLAB=0"/>
        <mode name="DLAB" qualifier="UART.LINE_CR.DLAB" mask="0x80" value="0x80" caption="UART when DLAB=1"/>
        <register modes="DATA" name="RX_DAT" offset="0x0" rw="R" size="1" access-size="1" initval="0x00" caption="UART Receive (Read) Buffer Register (DLAB=0)">
        </register>
        <register modes="DATA" name="TX_DAT" offset="0x0" rw="W" size="1" access-size="1" initval="0x00" caption="UART Transmit (Write) Buffer Register (DLAB=0)">
        </register>
        <register modes="DLAB" name="BAUDRT_LSB" offset="0x0" rw="RW" size="1" access-size="1" initval="0x00" caption="UART Programmable BAUD Rate Generator (LSB) Register (DLAB=1)">
        </register>
        <register modes="DLAB" name="BAUDRT_MSB" offset="0x1" rw="RW" size="1" access-size="1" initval="0x00" caption="UART Programmable BAUD Rate Generator (MSB) Register (DLAB=1). [6:0] BAUD_RATE_DIVISOR_MSB, [7:7] BAUD_CLK_SEL             1=If CLK_SRC is '0', the baud clock is derived from the 1.8432MHz_Clk. If CLK_SRC is '1', this bit has no effect            0=If CLK_SRC is '0', the baud clock is derived from the 24MHz_Clk. If CLK_SRC is '1', this bit has no effect">
          <bitfield name="BAUDRT_DIV_MSB" caption="Baud Rate divisor (MSB)." mask="0x7F"/>
          <bitfield name="BAUD_CLK_SEL" caption="Baud Clock Selection" mask="0x80" values="UART_BAUDRT_MSB__BAUD_CLK_SEL"/>
        </register>
        <register modes="DATA" name="IEN" offset="0x1" rw="RW" size="1" access-size="1" initval="0x00" caption="UART Interrupt Enable Register (DLAB=0)">
          <bitfield name="ERDAI" caption="ERDAI This bit enables the Received Data Available Interrupt (and timeout interrupts in the FIFO mode) when set to logic '1'." mask="0x1"/>
          <bitfield name="ETHREI" caption="ETHREI This bit enables the Transmitter Holding Register Empty Interrupt when set to logic '1'." mask="0x2"/>
          <bitfield name="ELSI" caption="ELSI This bit enables the Received Line Status Interrupt when set to logic '1'." mask="0x4"/>
          <bitfield name="EMSI" caption="EMSI  This bit enables the MODEM Status Interrupt when set to logic '1'." mask="0x8"/>
        </register>
        <register modes="DLAB DATA" name="FIFO_CR" offset="0x2" rw="W" size="1" access-size="1" initval="0x00" caption="UART FIFO Control Register">
          <bitfield name="EXRF" caption="EXRF Enable XMIT and RECV FIFO." mask="0x1"/>
          <bitfield name="CLR_RECV_FIFO" caption="CLEAR_RECV_FIFO  Setting this bit to a logic '1' clears all bytes in the RCVR FIFO and resets its counter logic to '0'." mask="0x2"/>
          <bitfield name="CLR_XMIT_FIFO" caption="CLEAR_XMIT_FIFO  Setting this bit to a logic '1' clears all bytes in the XMIT FIFO and resets its counter logic to '0' . The shift register is not cleared. This bit is self-clearing." mask="0x4"/>
          <bitfield name="DMA_MODE_SEL" caption="DMA_MODE_SELECT  Writing to this bit has no effect on the operation of the UART. The RXRDY and TXRDY pins are not available on this chip." mask="0x8"/>
          <bitfield name="RECV_FIFO_TRIG_LVL" caption="RECV_FIFO_TRIGGER_LEVEL These bits are used to set the trigger level for the RCVR FIFO interrupt." mask="0xC0"/>
        </register>
        <register modes="DLAB DATA" name="INT_ID" offset="0x2" rw="R" size="1" access-size="1" initval="0x00" caption="UART Interrupt Identification Register">
          <bitfield name="IPEND" caption="IPEND  This bit can be used in either a hardwired prioritized or polled environment to indicate whether an interrupt is pending." mask="0x1"/>
          <bitfield name="INTID" caption="INTID  These bits identify the highest priority interrupt pending" mask="0xE"/>
          <bitfield name="FIFO_EN" caption="These two bits are set when the FIFO CONTROL Register bit 0 equals 1." mask="0xC0"/>
        </register>
        <register modes="DLAB DATA" name="LCR" offset="0x3" rw="RW" size="1" access-size="1" initval="0x00" caption="UART Line Control Register">
          <bitfield name="WORD_LEN" caption="WORD_LENGTH These two bits specify the number of bits in each transmitted or received serial character." mask="0x3" values="UART_LCR__WORD_LEN"/>
          <bitfield name="STOP_BITS" caption="STOP_BITS  This bit specifies the number of stop bits in each transmitted or received serial character." mask="0x4" values="UART_LCR__STOP_BITS"/>
          <bitfield name="EN_PAR" caption="ENABLE_PARITY  Parity Enable bit." mask="0x8"/>
          <bitfield name="PAR_SEL" caption="PARITY_SELECT Even Parity Select bit." mask="0x10" values="UART_LCR__PAR_SEL"/>
          <bitfield name="STICK_PAR" caption="STICK_PARITY  Stick Parity bit." mask="0x20"/>
          <bitfield name="BRK_CTRL" caption="BREAK_CONTROL Set Break Control bit" mask="0x40"/>
          <bitfield name="DLAB" caption="DLAB Divisor Latch Access Bit (DLAB)." mask="0x80"/>
        </register>
        <register modes="DLAB DATA" name="MCR" offset="0x4" rw="RW" size="1" access-size="1" initval="0x00" caption="UART Modem Control Register">
          <bitfield name="DTR" caption="DTR  This bit controls the Data Terminal Ready (nDTR) output." mask="0x1"/>
          <bitfield name="RTS" caption="RTS  This bit controls the Request To Send (nRTS) output." mask="0x2"/>
          <bitfield name="OUT1" caption="OUT1 This bit controls the Output 1 (OUT1) bit." mask="0x4"/>
          <bitfield name="OUT2" caption="OUT2  This bit is used to enable an UART interrupt." mask="0x8"/>
          <bitfield name="LOOPBACK" caption="LOOPBACK  This bit provides the loopback feature for diagnostic testing of the Serial Port." mask="0x10"/>
        </register>
        <register modes="DLAB DATA" name="LSR" offset="0x5" rw="R" size="1" access-size="1" initval="0x00" caption="UART Line Status Register">
          <bitfield name="DATA_READY" caption="DATA_READY  Data Ready. It is set to a logic '1' whenever a complete incoming character has been received and transferred into the Receiver Buffer Register or the FIFO" mask="0x1"/>
          <bitfield name="OVERRUN" caption="OVERRUN  Overrun Error." mask="0x2"/>
          <bitfield name="PE" caption="PARITY ERROR  Parity Error." mask="0x4"/>
          <bitfield name="FRAME_ERR" caption="FRAME_ERROR Framing Error." mask="0x8"/>
          <bitfield name="BRK_INTR" caption="BREAK_INTERRUPT   Break Interrupt." mask="0x10"/>
          <bitfield name="TRANS_EMPTY" caption="TRANSMIT_EMPTY  Transmitter Holding Register Empty Bit 5 indicates that the Serial Port is ready to accept a new character for transmission." mask="0x20"/>
          <bitfield name="TRANS_ERR" caption="Transmitter Empty. Bit 6 is set to a logic '1' whenever the Transmitter Holding Register (THR) and Transmitter Shift Register (TSR) are both empty." mask="0x40"/>
          <bitfield name="FIFO_ERR" caption="FIFO_ERROR" mask="0x80"/>
        </register>
        <register modes="DLAB DATA" name="MSR" offset="0x6" rw="R" size="1" access-size="1" initval="0x00" caption="UART Modem Status Register">
          <bitfield name="CTS" caption="CTS  Delta Clear To Send (DCTS)." mask="0x1"/>
          <bitfield name="DSR" caption="DSR  Delta Data Set Ready (DDSR)." mask="0x2"/>
          <bitfield name="RI" caption="RI  Trailing Edge of Ring Indicator (TERI)." mask="0x4"/>
          <bitfield name="DCD" caption="DCD  Delta Data Carrier Detect (DDCD)." mask="0x8"/>
          <bitfield name="nCTS" caption="nCTS  This bit is the complement of the Clear To Send (nCTS) input." mask="0x10"/>
          <bitfield name="nDSR" caption="This bit is the complement of the Data Set Ready (nDSR) input." mask="0x20"/>
          <bitfield name="nRI" caption="nRI This bit is the complement of the Ring Indicator (nRI) input." mask="0x40"/>
          <bitfield name="nDCD" caption="nDCD   This bit is the complement of the Data Carrier Detect (nDCD) input." mask="0x80"/>
        </register>
        <register modes="DLAB DATA" name="SCR" offset="0x7" rw="RW" size="1" access-size="1" initval="0x00" caption="UART Scratchpad Register    This 8 bit read/write register has no effect on the operation of the Serial Port. It is intended as a scratchpad register to be used by the programmer to hold data temporarily.">
        </register>
        <register modes="DLAB DATA" name="ACTIVATE" offset="0x330" rw="RW" size="1" access-size="1" initval="0x00" caption="UART Activate Register. [0:0] ACTIVATE When this bit is 1, the UART logical device is powered and functional. When this bit is 0, the UART logical device is powered down and inactive.">
        </register>
        <register modes="DLAB DATA" name="CFG_SEL" offset="0x3F0" rw="RW" size="1" access-size="1" initval="0x00" caption="UART Config Select Register">
          <bitfield name="CLK_SRC" caption="CLK_SRC  1=The UART Baud Clock is derived from an external clock source, 0=The UART Baud Clock is derived from one of the two internal clock sources" mask="0x1" values="UART_CFG_SEL__CLK_SRC"/>
          <bitfield name="PWR" caption="POWER  1=The RESET reset signal is derived from nSIO_RESET, 0=The RESET reset signal is derived from VCC1_RESET" mask="0x2"/>
          <bitfield name="POLAR" caption="POLARITY  1=The UART_TX and UART_RX pins functions are inverted, 0=The UART_TX and UART_RX pins functions are not inverted" mask="0x4"/>
        </register>
      </register-group>
      <value-group name="UART_LCR__STOP_BITS">
        <value name="ONE_STOP_BIT" caption="1 Stop bit" value="0x0"/>
        <value name="ONE_FIVE_TWO_STOP_BITS" caption="1.5 or 2 Stop bits" value="0x1"/>
      </value-group>
      <value-group name="UART_LCR__WORD_LEN">
        <value name="5_BIT" caption="5 Bits" value="0x0"/>
        <value name="6_BIT" caption="6 Bits" value="0x1"/>
        <value name="7_BIT" caption="7 Bits" value="0x2"/>
        <value name="8_BIT" caption="8 Bits" value="0x3"/>
      </value-group>
      <value-group name="UART_LCR__PAR_SEL">
        <value name="ODD" caption="Odd Parity" value="0x0"/>
        <value name="EVEN" caption="Even Parity" value="0x1"/>
      </value-group>
      <value-group name="UART_CFG_SEL__CLK_SRC">
        <value name="INTERNAL" caption="Baud Clock is derived from one of the two internal clock sources" value="0x0"/>
        <value name="EXTERNAL" caption="Baud Clock is derived from an external clock source" value="0x1"/>
      </value-group>
      <value-group name="UART_BAUDRT_MSB__BAUD_CLK_SEL">
        <value name="1843200_Hz" caption="Baud clock is derived from the 1.8432MHz Clk" value="0x0"/>
        <value name="48000000_HZ" caption="baud clock is derived from the 48MHz Clk" value="0x1"/>
      </value-group>
    </module>
    <module name="GPIO" id="26" version="1.0" caption="GPIO Pin Control Registers">
      <register-group name="GPIO" caption="GPIO Pin Control Registers">
        <register name="CTRL0" offset="0x0" rw="RW" size="4" access-size="4" initval="0x00008040" count="8" caption="GPIO Pin Control Register">
          <bitfield name="PU_PD" caption="These bits are used to enable an internal pull-up or pull-down resistor." mask="0x3" values="GPIO_CTRL__PU_PD"/>
          <bitfield name="PWR_GATING" caption="The GPIO pin will be tristated when the selected power well is off." mask="0xC"/>
          <bitfield name="INTR_DET" caption="Determines the interrupt capability of the GPIO input." mask="0x70"/>
          <bitfield name="EDGE_EN" caption="Determines the interrupt capability of the GPIO input." mask="0x80"/>
          <bitfield name="OUT_BUFF_TYPE" caption="0 = Push-Pull, 1 = Open Drain" mask="0x100"/>
          <bitfield name="GPIO_DIR" caption="Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output" mask="0x200"/>
          <bitfield name="GPIO_OUT_SEL" caption="GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register." mask="0x400"/>
          <bitfield name="POL" caption="1=Inverted; 0=Non-inverted" mask="0x800"/>
          <bitfield name="MUX_CTRL" caption="00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3." mask="0x7000" values="GPIO_CTRL__MUX_CTRL"/>
          <bitfield name="INP_DIS" caption="GPIO input disable" mask="0x8000"/>
          <bitfield name="ALT_GPIO_DATA" caption="GPIO Alternate Data Register." mask="0x10000"/>
          <bitfield name="GPIO_INP" caption="GPIO input from pin, independent of the Mux selection for the pin or the Direction." mask="0x1000000"/>
        </register>
        <register name="CTRL1" offset="0x20" rw="RW" size="4" access-size="4" initval="0x00008040" count="8" caption="GPIO Pin Control Register">
          <bitfield name="PU_PD" caption="These bits are used to enable an internal pull-up or pull-down resistor." mask="0x3" values="GPIO_CTRL__PU_PD"/>
          <bitfield name="PWR_GATING" caption="The GPIO pin will be tristated when the selected power well is off." mask="0xC"/>
          <bitfield name="INTR_DET" caption="Determines the interrupt capability of the GPIO input." mask="0x70"/>
          <bitfield name="EDGE_EN" caption="Determines the interrupt capability of the GPIO input." mask="0x80"/>
          <bitfield name="OUT_BUFF_TYPE" caption="0 = Push-Pull, 1 = Open Drain" mask="0x100"/>
          <bitfield name="GPIO_DIR" caption="Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output" mask="0x200"/>
          <bitfield name="GPIO_OUT_SEL" caption="GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register." mask="0x400"/>
          <bitfield name="POL" caption="1=Inverted; 0=Non-inverted" mask="0x800"/>
          <bitfield name="MUX_CTRL" caption="00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3." mask="0x7000" values="GPIO_CTRL__MUX_CTRL"/>
          <bitfield name="INP_DIS" caption="GPIO input disable" mask="0x8000"/>
          <bitfield name="ALT_GPIO_DATA" caption="GPIO Alternate Data Register." mask="0x10000"/>
          <bitfield name="GPIO_INP" caption="GPIO input from pin, independent of the Mux selection for the pin or the Direction." mask="0x1000000"/>
        </register>
        <register name="CTRL2" offset="0x40" rw="RW" size="4" access-size="4" initval="0x00008040" count="8" caption="GPIO Pin Control Register">
          <bitfield name="PU_PD" caption="These bits are used to enable an internal pull-up or pull-down resistor." mask="0x3" values="GPIO_CTRL__PU_PD"/>
          <bitfield name="PWR_GATING" caption="The GPIO pin will be tristated when the selected power well is off." mask="0xC"/>
          <bitfield name="INTR_DET" caption="Determines the interrupt capability of the GPIO input." mask="0x70"/>
          <bitfield name="EDGE_EN" caption="Determines the interrupt capability of the GPIO input." mask="0x80"/>
          <bitfield name="OUT_BUFF_TYPE" caption="0 = Push-Pull, 1 = Open Drain" mask="0x100"/>
          <bitfield name="GPIO_DIR" caption="Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output" mask="0x200"/>
          <bitfield name="GPIO_OUT_SEL" caption="GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register." mask="0x400"/>
          <bitfield name="POL" caption="1=Inverted; 0=Non-inverted" mask="0x800"/>
          <bitfield name="MUX_CTRL" caption="00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3." mask="0x7000" values="GPIO_CTRL__MUX_CTRL"/>
          <bitfield name="INP_DIS" caption="GPIO input disable" mask="0x8000"/>
          <bitfield name="ALT_GPIO_DATA" caption="GPIO Alternate Data Register." mask="0x10000"/>
          <bitfield name="GPIO_INP" caption="GPIO input from pin, independent of the Mux selection for the pin or the Direction." mask="0x1000000"/>
        </register>
        <register name="CTRL3" offset="0x60" rw="RW" size="4" access-size="4" initval="0x00008040" count="8" caption="GPIO Pin Control Register">
          <bitfield name="PU_PD" caption="These bits are used to enable an internal pull-up or pull-down resistor." mask="0x3" values="GPIO_CTRL__PU_PD"/>
          <bitfield name="PWR_GATING" caption="The GPIO pin will be tristated when the selected power well is off." mask="0xC"/>
          <bitfield name="INTR_DET" caption="Determines the interrupt capability of the GPIO input." mask="0x70"/>
          <bitfield name="EDGE_EN" caption="Determines the interrupt capability of the GPIO input." mask="0x80"/>
          <bitfield name="OUT_BUFF_TYPE" caption="0 = Push-Pull, 1 = Open Drain" mask="0x100"/>
          <bitfield name="GPIO_DIR" caption="Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output" mask="0x200"/>
          <bitfield name="GPIO_OUT_SEL" caption="GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register." mask="0x400"/>
          <bitfield name="POL" caption="1=Inverted; 0=Non-inverted" mask="0x800"/>
          <bitfield name="MUX_CTRL" caption="00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3." mask="0x7000" values="GPIO_CTRL__MUX_CTRL"/>
          <bitfield name="INP_DIS" caption="GPIO input disable" mask="0x8000"/>
          <bitfield name="ALT_GPIO_DATA" caption="GPIO Alternate Data Register." mask="0x10000"/>
          <bitfield name="GPIO_INP" caption="GPIO input from pin, independent of the Mux selection for the pin or the Direction." mask="0x1000000"/>
        </register>
        <register name="CTRL4" offset="0x80" rw="RW" size="4" access-size="4" initval="0x00008040" count="8" caption="GPIO Pin Control Register">
          <bitfield name="PU_PD" caption="These bits are used to enable an internal pull-up or pull-down resistor." mask="0x3" values="GPIO_CTRL__PU_PD"/>
          <bitfield name="PWR_GATING" caption="The GPIO pin will be tristated when the selected power well is off." mask="0xC"/>
          <bitfield name="INTR_DET" caption="Determines the interrupt capability of the GPIO input." mask="0x70"/>
          <bitfield name="EDGE_EN" caption="Determines the interrupt capability of the GPIO input." mask="0x80"/>
          <bitfield name="OUT_BUFF_TYPE" caption="0 = Push-Pull, 1 = Open Drain" mask="0x100"/>
          <bitfield name="GPIO_DIR" caption="Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output" mask="0x200"/>
          <bitfield name="GPIO_OUT_SEL" caption="GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register." mask="0x400"/>
          <bitfield name="POL" caption="1=Inverted; 0=Non-inverted" mask="0x800"/>
          <bitfield name="MUX_CTRL" caption="00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3." mask="0x7000" values="GPIO_CTRL__MUX_CTRL"/>
          <bitfield name="INP_DIS" caption="GPIO input disable" mask="0x8000"/>
          <bitfield name="ALT_GPIO_DATA" caption="GPIO Alternate Data Register." mask="0x10000"/>
          <bitfield name="GPIO_INP" caption="GPIO input from pin, independent of the Mux selection for the pin or the Direction." mask="0x1000000"/>
        </register>
        <register name="CTRL5" offset="0xa0" rw="RW" size="4" access-size="4" initval="0x00008040" count="8" caption="GPIO Pin Control Register">
          <bitfield name="PU_PD" caption="These bits are used to enable an internal pull-up or pull-down resistor." mask="0x3" values="GPIO_CTRL__PU_PD"/>
          <bitfield name="PWR_GATING" caption="The GPIO pin will be tristated when the selected power well is off." mask="0xC"/>
          <bitfield name="INTR_DET" caption="Determines the interrupt capability of the GPIO input." mask="0x70"/>
          <bitfield name="EDGE_EN" caption="Determines the interrupt capability of the GPIO input." mask="0x80"/>
          <bitfield name="OUT_BUFF_TYPE" caption="0 = Push-Pull, 1 = Open Drain" mask="0x100"/>
          <bitfield name="GPIO_DIR" caption="Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output" mask="0x200"/>
          <bitfield name="GPIO_OUT_SEL" caption="GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register." mask="0x400"/>
          <bitfield name="POL" caption="1=Inverted; 0=Non-inverted" mask="0x800"/>
          <bitfield name="MUX_CTRL" caption="00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3." mask="0x7000" values="GPIO_CTRL__MUX_CTRL"/>
          <bitfield name="INP_DIS" caption="GPIO input disable" mask="0x8000"/>
          <bitfield name="ALT_GPIO_DATA" caption="GPIO Alternate Data Register." mask="0x10000"/>
          <bitfield name="GPIO_INP" caption="GPIO input from pin, independent of the Mux selection for the pin or the Direction." mask="0x1000000"/>
        </register>
        <register name="CTRL6" offset="0xc0" rw="RW" size="4" access-size="4" initval="0x00008040" count="8" caption="GPIO Pin Control Register">
          <bitfield name="PU_PD" caption="These bits are used to enable an internal pull-up or pull-down resistor." mask="0x3" values="GPIO_CTRL__PU_PD"/>
          <bitfield name="PWR_GATING" caption="The GPIO pin will be tristated when the selected power well is off." mask="0xC"/>
          <bitfield name="INTR_DET" caption="Determines the interrupt capability of the GPIO input." mask="0x70"/>
          <bitfield name="EDGE_EN" caption="Determines the interrupt capability of the GPIO input." mask="0x80"/>
          <bitfield name="OUT_BUFF_TYPE" caption="0 = Push-Pull, 1 = Open Drain" mask="0x100"/>
          <bitfield name="GPIO_DIR" caption="Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output" mask="0x200"/>
          <bitfield name="GPIO_OUT_SEL" caption="GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register." mask="0x400"/>
          <bitfield name="POL" caption="1=Inverted; 0=Non-inverted" mask="0x800"/>
          <bitfield name="MUX_CTRL" caption="00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3." mask="0x7000" values="GPIO_CTRL__MUX_CTRL"/>
          <bitfield name="INP_DIS" caption="GPIO input disable" mask="0x8000"/>
          <bitfield name="ALT_GPIO_DATA" caption="GPIO Alternate Data Register." mask="0x10000"/>
          <bitfield name="GPIO_INP" caption="GPIO input from pin, independent of the Mux selection for the pin or the Direction." mask="0x1000000"/>
        </register>
        <register name="CTRL7" offset="0xe0" rw="RW" size="4" access-size="4" initval="0x00008040" count="8" caption="GPIO Pin Control Register">
          <bitfield name="PU_PD" caption="These bits are used to enable an internal pull-up or pull-down resistor." mask="0x3" values="GPIO_CTRL__PU_PD"/>
          <bitfield name="PWR_GATING" caption="The GPIO pin will be tristated when the selected power well is off." mask="0xC"/>
          <bitfield name="INTR_DET" caption="Determines the interrupt capability of the GPIO input." mask="0x70"/>
          <bitfield name="EDGE_EN" caption="Determines the interrupt capability of the GPIO input." mask="0x80"/>
          <bitfield name="OUT_BUFF_TYPE" caption="0 = Push-Pull, 1 = Open Drain" mask="0x100"/>
          <bitfield name="GPIO_DIR" caption="Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output" mask="0x200"/>
          <bitfield name="GPIO_OUT_SEL" caption="GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register." mask="0x400"/>
          <bitfield name="POL" caption="1=Inverted; 0=Non-inverted" mask="0x800"/>
          <bitfield name="MUX_CTRL" caption="00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3." mask="0x7000" values="GPIO_CTRL__MUX_CTRL"/>
          <bitfield name="INP_DIS" caption="GPIO input disable" mask="0x8000"/>
          <bitfield name="ALT_GPIO_DATA" caption="GPIO Alternate Data Register." mask="0x10000"/>
          <bitfield name="GPIO_INP" caption="GPIO input from pin, independent of the Mux selection for the pin or the Direction." mask="0x1000000"/>
        </register>
        <register name="CTRL10" offset="0x100" rw="RW" size="4" access-size="4" initval="0x00008040" count="8" caption="GPIO Pin Control Register">
          <bitfield name="PU_PD" caption="These bits are used to enable an internal pull-up or pull-down resistor." mask="0x3" values="GPIO_CTRL__PU_PD"/>
          <bitfield name="PWR_GATING" caption="The GPIO pin will be tristated when the selected power well is off." mask="0xC"/>
          <bitfield name="INTR_DET" caption="Determines the interrupt capability of the GPIO input." mask="0x70"/>
          <bitfield name="EDGE_EN" caption="Determines the interrupt capability of the GPIO input." mask="0x80"/>
          <bitfield name="OUT_BUFF_TYPE" caption="0 = Push-Pull, 1 = Open Drain" mask="0x100"/>
          <bitfield name="GPIO_DIR" caption="Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output" mask="0x200"/>
          <bitfield name="GPIO_OUT_SEL" caption="GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register." mask="0x400"/>
          <bitfield name="POL" caption="1=Inverted; 0=Non-inverted" mask="0x800"/>
          <bitfield name="MUX_CTRL" caption="00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3." mask="0x7000" values="GPIO_CTRL__MUX_CTRL"/>
          <bitfield name="INP_DIS" caption="GPIO input disable" mask="0x8000"/>
          <bitfield name="ALT_GPIO_DATA" caption="GPIO Alternate Data Register." mask="0x10000"/>
          <bitfield name="GPIO_INP" caption="GPIO input from pin, independent of the Mux selection for the pin or the Direction." mask="0x1000000"/>
        </register>
        <register name="CTRL11" offset="0x120" rw="RW" size="4" access-size="4" initval="0x00008040" count="8" caption="GPIO Pin Control Register">
          <bitfield name="PU_PD" caption="These bits are used to enable an internal pull-up or pull-down resistor." mask="0x3" values="GPIO_CTRL__PU_PD"/>
          <bitfield name="PWR_GATING" caption="The GPIO pin will be tristated when the selected power well is off." mask="0xC"/>
          <bitfield name="INTR_DET" caption="Determines the interrupt capability of the GPIO input." mask="0x70"/>
          <bitfield name="EDGE_EN" caption="Determines the interrupt capability of the GPIO input." mask="0x80"/>
          <bitfield name="OUT_BUFF_TYPE" caption="0 = Push-Pull, 1 = Open Drain" mask="0x100"/>
          <bitfield name="GPIO_DIR" caption="Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output" mask="0x200"/>
          <bitfield name="GPIO_OUT_SEL" caption="GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register." mask="0x400"/>
          <bitfield name="POL" caption="1=Inverted; 0=Non-inverted" mask="0x800"/>
          <bitfield name="MUX_CTRL" caption="00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3." mask="0x7000" values="GPIO_CTRL__MUX_CTRL"/>
          <bitfield name="INP_DIS" caption="GPIO input disable" mask="0x8000"/>
          <bitfield name="ALT_GPIO_DATA" caption="GPIO Alternate Data Register." mask="0x10000"/>
          <bitfield name="GPIO_INP" caption="GPIO input from pin, independent of the Mux selection for the pin or the Direction." mask="0x1000000"/>
        </register>
        <register name="CTRL12" offset="0x140" rw="RW" size="4" access-size="4" initval="0x00008040" count="8" caption="GPIO Pin Control Register">
          <bitfield name="PU_PD" caption="These bits are used to enable an internal pull-up or pull-down resistor." mask="0x3" values="GPIO_CTRL__PU_PD"/>
          <bitfield name="PWR_GATING" caption="The GPIO pin will be tristated when the selected power well is off." mask="0xC"/>
          <bitfield name="INTR_DET" caption="Determines the interrupt capability of the GPIO input." mask="0x70"/>
          <bitfield name="EDGE_EN" caption="Determines the interrupt capability of the GPIO input." mask="0x80"/>
          <bitfield name="OUT_BUFF_TYPE" caption="0 = Push-Pull, 1 = Open Drain" mask="0x100"/>
          <bitfield name="GPIO_DIR" caption="Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output" mask="0x200"/>
          <bitfield name="GPIO_OUT_SEL" caption="GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register." mask="0x400"/>
          <bitfield name="POL" caption="1=Inverted; 0=Non-inverted" mask="0x800"/>
          <bitfield name="MUX_CTRL" caption="00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3." mask="0x7000" values="GPIO_CTRL__MUX_CTRL"/>
          <bitfield name="INP_DIS" caption="GPIO input disable" mask="0x8000"/>
          <bitfield name="ALT_GPIO_DATA" caption="GPIO Alternate Data Register." mask="0x10000"/>
          <bitfield name="GPIO_INP" caption="GPIO input from pin, independent of the Mux selection for the pin or the Direction." mask="0x1000000"/>
        </register>
        <register name="CTRL13" offset="0x160" rw="RW" size="4" access-size="4" initval="0x00008040" count="8" caption="GPIO Pin Control Register">
          <bitfield name="PU_PD" caption="These bits are used to enable an internal pull-up or pull-down resistor." mask="0x3" values="GPIO_CTRL__PU_PD"/>
          <bitfield name="PWR_GATING" caption="The GPIO pin will be tristated when the selected power well is off." mask="0xC"/>
          <bitfield name="INTR_DET" caption="Determines the interrupt capability of the GPIO input." mask="0x70"/>
          <bitfield name="EDGE_EN" caption="Determines the interrupt capability of the GPIO input." mask="0x80"/>
          <bitfield name="OUT_BUFF_TYPE" caption="0 = Push-Pull, 1 = Open Drain" mask="0x100"/>
          <bitfield name="GPIO_DIR" caption="Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output" mask="0x200"/>
          <bitfield name="GPIO_OUT_SEL" caption="GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register." mask="0x400"/>
          <bitfield name="POL" caption="1=Inverted; 0=Non-inverted" mask="0x800"/>
          <bitfield name="MUX_CTRL" caption="00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3." mask="0x7000" values="GPIO_CTRL__MUX_CTRL"/>
          <bitfield name="INP_DIS" caption="GPIO input disable" mask="0x8000"/>
          <bitfield name="ALT_GPIO_DATA" caption="GPIO Alternate Data Register." mask="0x10000"/>
          <bitfield name="GPIO_INP" caption="GPIO input from pin, independent of the Mux selection for the pin or the Direction." mask="0x1000000"/>
        </register>
        <register name="CTRL14" offset="0x180" rw="RW" size="4" access-size="4" initval="0x00008040" count="8" caption="GPIO Pin Control Register">
          <bitfield name="PU_PD" caption="These bits are used to enable an internal pull-up or pull-down resistor." mask="0x3" values="GPIO_CTRL__PU_PD"/>
          <bitfield name="PWR_GATING" caption="The GPIO pin will be tristated when the selected power well is off." mask="0xC"/>
          <bitfield name="INTR_DET" caption="Determines the interrupt capability of the GPIO input." mask="0x70"/>
          <bitfield name="EDGE_EN" caption="Determines the interrupt capability of the GPIO input." mask="0x80"/>
          <bitfield name="OUT_BUFF_TYPE" caption="0 = Push-Pull, 1 = Open Drain" mask="0x100"/>
          <bitfield name="GPIO_DIR" caption="Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output" mask="0x200"/>
          <bitfield name="GPIO_OUT_SEL" caption="GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register." mask="0x400"/>
          <bitfield name="POL" caption="1=Inverted; 0=Non-inverted" mask="0x800"/>
          <bitfield name="MUX_CTRL" caption="00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3." mask="0x7000" values="GPIO_CTRL__MUX_CTRL"/>
          <bitfield name="INP_DIS" caption="GPIO input disable" mask="0x8000"/>
          <bitfield name="ALT_GPIO_DATA" caption="GPIO Alternate Data Register." mask="0x10000"/>
          <bitfield name="GPIO_INP" caption="GPIO input from pin, independent of the Mux selection for the pin or the Direction." mask="0x1000000"/>
        </register>
        <register name="CTRL15" offset="0x1a0" rw="RW" size="4" access-size="4" initval="0x00008040" count="8" caption="GPIO Pin Control Register">
          <bitfield name="PU_PD" caption="These bits are used to enable an internal pull-up or pull-down resistor." mask="0x3" values="GPIO_CTRL__PU_PD"/>
          <bitfield name="PWR_GATING" caption="The GPIO pin will be tristated when the selected power well is off." mask="0xC"/>
          <bitfield name="INTR_DET" caption="Determines the interrupt capability of the GPIO input." mask="0x70"/>
          <bitfield name="EDGE_EN" caption="Determines the interrupt capability of the GPIO input." mask="0x80"/>
          <bitfield name="OUT_BUFF_TYPE" caption="0 = Push-Pull, 1 = Open Drain" mask="0x100"/>
          <bitfield name="GPIO_DIR" caption="Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output" mask="0x200"/>
          <bitfield name="GPIO_OUT_SEL" caption="GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register." mask="0x400"/>
          <bitfield name="POL" caption="1=Inverted; 0=Non-inverted" mask="0x800"/>
          <bitfield name="MUX_CTRL" caption="00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3." mask="0x7000" values="GPIO_CTRL__MUX_CTRL"/>
          <bitfield name="INP_DIS" caption="GPIO input disable" mask="0x8000"/>
          <bitfield name="ALT_GPIO_DATA" caption="GPIO Alternate Data Register." mask="0x10000"/>
          <bitfield name="GPIO_INP" caption="GPIO input from pin, independent of the Mux selection for the pin or the Direction." mask="0x1000000"/>
        </register>
        <register name="CTRL16" offset="0x1c0" rw="RW" size="4" access-size="4" initval="0x00008040" count="8" caption="GPIO Pin Control Register">
          <bitfield name="PU_PD" caption="These bits are used to enable an internal pull-up or pull-down resistor." mask="0x3" values="GPIO_CTRL__PU_PD"/>
          <bitfield name="PWR_GATING" caption="The GPIO pin will be tristated when the selected power well is off." mask="0xC"/>
          <bitfield name="INTR_DET" caption="Determines the interrupt capability of the GPIO input." mask="0x70"/>
          <bitfield name="EDGE_EN" caption="Determines the interrupt capability of the GPIO input." mask="0x80"/>
          <bitfield name="OUT_BUFF_TYPE" caption="0 = Push-Pull, 1 = Open Drain" mask="0x100"/>
          <bitfield name="GPIO_DIR" caption="Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output" mask="0x200"/>
          <bitfield name="GPIO_OUT_SEL" caption="GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register." mask="0x400"/>
          <bitfield name="POL" caption="1=Inverted; 0=Non-inverted" mask="0x800"/>
          <bitfield name="MUX_CTRL" caption="00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3." mask="0x7000" values="GPIO_CTRL__MUX_CTRL"/>
          <bitfield name="INP_DIS" caption="GPIO input disable" mask="0x8000"/>
          <bitfield name="ALT_GPIO_DATA" caption="GPIO Alternate Data Register." mask="0x10000"/>
          <bitfield name="GPIO_INP" caption="GPIO input from pin, independent of the Mux selection for the pin or the Direction." mask="0x1000000"/>
        </register>
        <register name="CTRL17" offset="0x1e0" rw="RW" size="4" access-size="4" initval="0x00008040" count="8" caption="GPIO Pin Control Register">
          <bitfield name="PU_PD" caption="These bits are used to enable an internal pull-up or pull-down resistor." mask="0x3" values="GPIO_CTRL__PU_PD"/>
          <bitfield name="PWR_GATING" caption="The GPIO pin will be tristated when the selected power well is off." mask="0xC"/>
          <bitfield name="INTR_DET" caption="Determines the interrupt capability of the GPIO input." mask="0x70"/>
          <bitfield name="EDGE_EN" caption="Determines the interrupt capability of the GPIO input." mask="0x80"/>
          <bitfield name="OUT_BUFF_TYPE" caption="0 = Push-Pull, 1 = Open Drain" mask="0x100"/>
          <bitfield name="GPIO_DIR" caption="Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output" mask="0x200"/>
          <bitfield name="GPIO_OUT_SEL" caption="GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register." mask="0x400"/>
          <bitfield name="POL" caption="1=Inverted; 0=Non-inverted" mask="0x800"/>
          <bitfield name="MUX_CTRL" caption="00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3." mask="0x7000" values="GPIO_CTRL__MUX_CTRL"/>
          <bitfield name="INP_DIS" caption="GPIO input disable" mask="0x8000"/>
          <bitfield name="ALT_GPIO_DATA" caption="GPIO Alternate Data Register." mask="0x10000"/>
          <bitfield name="GPIO_INP" caption="GPIO input from pin, independent of the Mux selection for the pin or the Direction." mask="0x1000000"/>
        </register>
        <register name="CTRL20" offset="0x200" rw="RW" size="4" access-size="4" initval="0x00008040" count="8" caption="GPIO Pin Control Register">
          <bitfield name="PU_PD" caption="These bits are used to enable an internal pull-up or pull-down resistor." mask="0x3" values="GPIO_CTRL__PU_PD"/>
          <bitfield name="PWR_GATING" caption="The GPIO pin will be tristated when the selected power well is off." mask="0xC"/>
          <bitfield name="INTR_DET" caption="Determines the interrupt capability of the GPIO input." mask="0x70"/>
          <bitfield name="EDGE_EN" caption="Determines the interrupt capability of the GPIO input." mask="0x80"/>
          <bitfield name="OUT_BUFF_TYPE" caption="0 = Push-Pull, 1 = Open Drain" mask="0x100"/>
          <bitfield name="GPIO_DIR" caption="Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output" mask="0x200"/>
          <bitfield name="GPIO_OUT_SEL" caption="GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register." mask="0x400"/>
          <bitfield name="POL" caption="1=Inverted; 0=Non-inverted" mask="0x800"/>
          <bitfield name="MUX_CTRL" caption="00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3." mask="0x7000" values="GPIO_CTRL__MUX_CTRL"/>
          <bitfield name="INP_DIS" caption="GPIO input disable" mask="0x8000"/>
          <bitfield name="ALT_GPIO_DATA" caption="GPIO Alternate Data Register." mask="0x10000"/>
          <bitfield name="GPIO_INP" caption="GPIO input from pin, independent of the Mux selection for the pin or the Direction." mask="0x1000000"/>
        </register>
        <register name="CTRL21" offset="0x220" rw="RW" size="4" access-size="4" initval="0x00008040" count="8" caption="GPIO Pin Control Register">
          <bitfield name="PU_PD" caption="These bits are used to enable an internal pull-up or pull-down resistor." mask="0x3" values="GPIO_CTRL__PU_PD"/>
          <bitfield name="PWR_GATING" caption="The GPIO pin will be tristated when the selected power well is off." mask="0xC"/>
          <bitfield name="INTR_DET" caption="Determines the interrupt capability of the GPIO input." mask="0x70"/>
          <bitfield name="EDGE_EN" caption="Determines the interrupt capability of the GPIO input." mask="0x80"/>
          <bitfield name="OUT_BUFF_TYPE" caption="0 = Push-Pull, 1 = Open Drain" mask="0x100"/>
          <bitfield name="GPIO_DIR" caption="Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output" mask="0x200"/>
          <bitfield name="GPIO_OUT_SEL" caption="GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register." mask="0x400"/>
          <bitfield name="POL" caption="1=Inverted; 0=Non-inverted" mask="0x800"/>
          <bitfield name="MUX_CTRL" caption="00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3." mask="0x7000" values="GPIO_CTRL__MUX_CTRL"/>
          <bitfield name="INP_DIS" caption="GPIO input disable" mask="0x8000"/>
          <bitfield name="ALT_GPIO_DATA" caption="GPIO Alternate Data Register." mask="0x10000"/>
          <bitfield name="GPIO_INP" caption="GPIO input from pin, independent of the Mux selection for the pin or the Direction." mask="0x1000000"/>
        </register>
        <register name="CTRL22" offset="0x240" rw="RW" size="4" access-size="4" initval="0x00008040" count="8" caption="GPIO Pin Control Register">
          <bitfield name="PU_PD" caption="These bits are used to enable an internal pull-up or pull-down resistor." mask="0x3" values="GPIO_CTRL__PU_PD"/>
          <bitfield name="PWR_GATING" caption="The GPIO pin will be tristated when the selected power well is off." mask="0xC"/>
          <bitfield name="INTR_DET" caption="Determines the interrupt capability of the GPIO input." mask="0x70"/>
          <bitfield name="EDGE_EN" caption="Determines the interrupt capability of the GPIO input." mask="0x80"/>
          <bitfield name="OUT_BUFF_TYPE" caption="0 = Push-Pull, 1 = Open Drain" mask="0x100"/>
          <bitfield name="GPIO_DIR" caption="Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output" mask="0x200"/>
          <bitfield name="GPIO_OUT_SEL" caption="GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register." mask="0x400"/>
          <bitfield name="POL" caption="1=Inverted; 0=Non-inverted" mask="0x800"/>
          <bitfield name="MUX_CTRL" caption="00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3." mask="0x7000" values="GPIO_CTRL__MUX_CTRL"/>
          <bitfield name="INP_DIS" caption="GPIO input disable" mask="0x8000"/>
          <bitfield name="ALT_GPIO_DATA" caption="GPIO Alternate Data Register." mask="0x10000"/>
          <bitfield name="GPIO_INP" caption="GPIO input from pin, independent of the Mux selection for the pin or the Direction." mask="0x1000000"/>
        </register>
        <register name="CTRL23" offset="0x260" rw="RW" size="4" access-size="4" initval="0x00008040" count="8" caption="GPIO Pin Control Register">
          <bitfield name="PU_PD" caption="These bits are used to enable an internal pull-up or pull-down resistor." mask="0x3" values="GPIO_CTRL__PU_PD"/>
          <bitfield name="PWR_GATING" caption="The GPIO pin will be tristated when the selected power well is off." mask="0xC"/>
          <bitfield name="INTR_DET" caption="Determines the interrupt capability of the GPIO input." mask="0x70"/>
          <bitfield name="EDGE_EN" caption="Determines the interrupt capability of the GPIO input." mask="0x80"/>
          <bitfield name="OUT_BUFF_TYPE" caption="0 = Push-Pull, 1 = Open Drain" mask="0x100"/>
          <bitfield name="GPIO_DIR" caption="Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output" mask="0x200"/>
          <bitfield name="GPIO_OUT_SEL" caption="GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register." mask="0x400"/>
          <bitfield name="POL" caption="1=Inverted; 0=Non-inverted" mask="0x800"/>
          <bitfield name="MUX_CTRL" caption="00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3." mask="0x7000" values="GPIO_CTRL__MUX_CTRL"/>
          <bitfield name="INP_DIS" caption="GPIO input disable" mask="0x8000"/>
          <bitfield name="ALT_GPIO_DATA" caption="GPIO Alternate Data Register." mask="0x10000"/>
          <bitfield name="GPIO_INP" caption="GPIO input from pin, independent of the Mux selection for the pin or the Direction." mask="0x1000000"/>
        </register>
        <register name="CTRL24" offset="0x280" rw="RW" size="4" access-size="4" initval="0x00008040" count="8" caption="GPIO Pin Control Register">
          <bitfield name="PU_PD" caption="These bits are used to enable an internal pull-up or pull-down resistor." mask="0x3" values="GPIO_CTRL__PU_PD"/>
          <bitfield name="PWR_GATING" caption="The GPIO pin will be tristated when the selected power well is off." mask="0xC"/>
          <bitfield name="INTR_DET" caption="Determines the interrupt capability of the GPIO input." mask="0x70"/>
          <bitfield name="EDGE_EN" caption="Determines the interrupt capability of the GPIO input." mask="0x80"/>
          <bitfield name="OUT_BUFF_TYPE" caption="0 = Push-Pull, 1 = Open Drain" mask="0x100"/>
          <bitfield name="GPIO_DIR" caption="Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output" mask="0x200"/>
          <bitfield name="GPIO_OUT_SEL" caption="GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register." mask="0x400"/>
          <bitfield name="POL" caption="1=Inverted; 0=Non-inverted" mask="0x800"/>
          <bitfield name="MUX_CTRL" caption="00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3." mask="0x7000" values="GPIO_CTRL__MUX_CTRL"/>
          <bitfield name="INP_DIS" caption="GPIO input disable" mask="0x8000"/>
          <bitfield name="ALT_GPIO_DATA" caption="GPIO Alternate Data Register." mask="0x10000"/>
          <bitfield name="GPIO_INP" caption="GPIO input from pin, independent of the Mux selection for the pin or the Direction." mask="0x1000000"/>
        </register>
        <register name="CTRL25" offset="0x2a0" rw="RW" size="4" access-size="4" initval="0x00008040" count="8" caption="GPIO Pin Control Register">
          <bitfield name="PU_PD" caption="These bits are used to enable an internal pull-up or pull-down resistor." mask="0x3" values="GPIO_CTRL__PU_PD"/>
          <bitfield name="PWR_GATING" caption="The GPIO pin will be tristated when the selected power well is off." mask="0xC"/>
          <bitfield name="INTR_DET" caption="Determines the interrupt capability of the GPIO input." mask="0x70"/>
          <bitfield name="EDGE_EN" caption="Determines the interrupt capability of the GPIO input." mask="0x80"/>
          <bitfield name="OUT_BUFF_TYPE" caption="0 = Push-Pull, 1 = Open Drain" mask="0x100"/>
          <bitfield name="GPIO_DIR" caption="Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output" mask="0x200"/>
          <bitfield name="GPIO_OUT_SEL" caption="GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register." mask="0x400"/>
          <bitfield name="POL" caption="1=Inverted; 0=Non-inverted" mask="0x800"/>
          <bitfield name="MUX_CTRL" caption="00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3." mask="0x7000" values="GPIO_CTRL__MUX_CTRL"/>
          <bitfield name="INP_DIS" caption="GPIO input disable" mask="0x8000"/>
          <bitfield name="ALT_GPIO_DATA" caption="GPIO Alternate Data Register." mask="0x10000"/>
          <bitfield name="GPIO_INP" caption="GPIO input from pin, independent of the Mux selection for the pin or the Direction." mask="0x1000000"/>
        </register>
        <register name="CTRL26" offset="0x2c0" rw="RW" size="4" access-size="4" initval="0x00008040" count="1" caption="GPIO Pin Control Register">
          <bitfield name="PU_PD" caption="These bits are used to enable an internal pull-up or pull-down resistor." mask="0x3" values="GPIO_CTRL__PU_PD"/>
          <bitfield name="PWR_GATING" caption="The GPIO pin will be tristated when the selected power well is off." mask="0xC"/>
          <bitfield name="INTR_DET" caption="Determines the interrupt capability of the GPIO input." mask="0x70"/>
          <bitfield name="EDGE_EN" caption="Determines the interrupt capability of the GPIO input." mask="0x80"/>
          <bitfield name="OUT_BUFF_TYPE" caption="0 = Push-Pull, 1 = Open Drain" mask="0x100"/>
          <bitfield name="GPIO_DIR" caption="Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output" mask="0x200"/>
          <bitfield name="GPIO_OUT_SEL" caption="GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register." mask="0x400"/>
          <bitfield name="POL" caption="1=Inverted; 0=Non-inverted" mask="0x800"/>
          <bitfield name="MUX_CTRL" caption="00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3." mask="0x7000" values="GPIO_CTRL__MUX_CTRL"/>
          <bitfield name="INP_DIS" caption="GPIO input disable" mask="0x8000"/>
          <bitfield name="ALT_GPIO_DATA" caption="GPIO Alternate Data Register." mask="0x10000"/>
          <bitfield name="GPIO_INP" caption="GPIO input from pin, independent of the Mux selection for the pin or the Direction." mask="0x1000000"/>
        </register>
        <register name="PARIN" offset="0x300" rw="RW" size="4" access-size="4" count="6" initval="0x00000000" caption="The GPIO Input Registers.">
        </register>
        <register name="PAROUT" offset="0x380" rw="RW" size="4" access-size="4" count="6" initval="0x00000000" caption="The GPIO Output Registers.">
        </register>
        <register name="CTRL2P0" offset="0x500" rw="RW" size="4" access-size="4" initval="0x00000000" count="8" caption="The GPIO PIN_CTRL2 Registers">
          <bitfield name="SLEW_CTRL" caption="Selects slew rate on the pin. 1=fast 0=slow" mask="0x1"/>
          <bitfield name="DRIV_STREN" caption="Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA" mask="0x30" values="GPIO_CTRL__DRIV_STREN"/>
        </register>
        <register name="CTRL2P1" offset="0x520" rw="RW" size="4" access-size="4" initval="0x00000000" count="8" caption="The GPIO PIN_CTRL2 Registers">
          <bitfield name="SLEW_CTRL" caption="Selects slew rate on the pin. 1=fast 0=slow" mask="0x1"/>
          <bitfield name="DRIV_STREN" caption="Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA" mask="0x30" values="GPIO_CTRL__DRIV_STREN"/>
        </register>
        <register name="CTRL2P2" offset="0x540" rw="RW" size="4" access-size="4" initval="0x00000000" count="8" caption="The GPIO PIN_CTRL2 Registers">
          <bitfield name="SLEW_CTRL" caption="Selects slew rate on the pin. 1=fast 0=slow" mask="0x1"/>
          <bitfield name="DRIV_STREN" caption="Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA" mask="0x30" values="GPIO_CTRL__DRIV_STREN"/>
        </register>
        <register name="CTRL2P3" offset="0x560" rw="RW" size="4" access-size="4" initval="0x00000000" count="8" caption="The GPIO PIN_CTRL2 Registers">
          <bitfield name="SLEW_CTRL" caption="Selects slew rate on the pin. 1=fast 0=slow" mask="0x1"/>
          <bitfield name="DRIV_STREN" caption="Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA" mask="0x30" values="GPIO_CTRL__DRIV_STREN"/>
        </register>
        <register name="CTRL2P4" offset="0x580" rw="RW" size="4" access-size="4" initval="0x00000000" count="8" caption="The GPIO PIN_CTRL2 Registers">
          <bitfield name="SLEW_CTRL" caption="Selects slew rate on the pin. 1=fast 0=slow" mask="0x1"/>
          <bitfield name="DRIV_STREN" caption="Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA" mask="0x30" values="GPIO_CTRL__DRIV_STREN"/>
        </register>
        <register name="CTRL2P5" offset="0x5a0" rw="RW" size="4" access-size="4" initval="0x00000000" count="8" caption="The GPIO PIN_CTRL2 Registers">
          <bitfield name="SLEW_CTRL" caption="Selects slew rate on the pin. 1=fast 0=slow" mask="0x1"/>
          <bitfield name="DRIV_STREN" caption="Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA" mask="0x30" values="GPIO_CTRL__DRIV_STREN"/>
        </register>
        <register name="CTRL2P6" offset="0x5c0" rw="RW" size="4" access-size="4" initval="0x00000000" count="8" caption="The GPIO PIN_CTRL2 Registers">
          <bitfield name="SLEW_CTRL" caption="Selects slew rate on the pin. 1=fast 0=slow" mask="0x1"/>
          <bitfield name="DRIV_STREN" caption="Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA" mask="0x30" values="GPIO_CTRL__DRIV_STREN"/>
        </register>
        <register name="CTRL2P7" offset="0x5e0" rw="RW" size="4" access-size="4" initval="0x00000000" count="8" caption="The GPIO PIN_CTRL2 Registers">
          <bitfield name="SLEW_CTRL" caption="Selects slew rate on the pin. 1=fast 0=slow" mask="0x1"/>
          <bitfield name="DRIV_STREN" caption="Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA" mask="0x30" values="GPIO_CTRL__DRIV_STREN"/>
        </register>
        <register name="CTRL2P10" offset="0x600" rw="RW" size="4" access-size="4" initval="0x00000000" count="8" caption="The GPIO PIN_CTRL2 Registers">
          <bitfield name="SLEW_CTRL" caption="Selects slew rate on the pin. 1=fast 0=slow" mask="0x1"/>
          <bitfield name="DRIV_STREN" caption="Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA" mask="0x30" values="GPIO_CTRL__DRIV_STREN"/>
        </register>
        <register name="CTRL2P11" offset="0x620" rw="RW" size="4" access-size="4" initval="0x00000000" count="8" caption="The GPIO PIN_CTRL2 Registers">
          <bitfield name="SLEW_CTRL" caption="Selects slew rate on the pin. 1=fast 0=slow" mask="0x1"/>
          <bitfield name="DRIV_STREN" caption="Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA" mask="0x30" values="GPIO_CTRL__DRIV_STREN"/>
        </register>
        <register name="CTRL2P12" offset="0x640" rw="RW" size="4" access-size="4" initval="0x00000000" count="8" caption="The GPIO PIN_CTRL2 Registers">
          <bitfield name="SLEW_CTRL" caption="Selects slew rate on the pin. 1=fast 0=slow" mask="0x1"/>
          <bitfield name="DRIV_STREN" caption="Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA" mask="0x30" values="GPIO_CTRL__DRIV_STREN"/>
        </register>
        <register name="CTRL2P13" offset="0x660" rw="RW" size="4" access-size="4" initval="0x00000000" count="8" caption="The GPIO PIN_CTRL2 Registers">
          <bitfield name="SLEW_CTRL" caption="Selects slew rate on the pin. 1=fast 0=slow" mask="0x1"/>
          <bitfield name="DRIV_STREN" caption="Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA" mask="0x30" values="GPIO_CTRL__DRIV_STREN"/>
        </register>
        <register name="CTRL2P14" offset="0x680" rw="RW" size="4" access-size="4" initval="0x00000000" count="8" caption="The GPIO PIN_CTRL2 Registers">
          <bitfield name="SLEW_CTRL" caption="Selects slew rate on the pin. 1=fast 0=slow" mask="0x1"/>
          <bitfield name="DRIV_STREN" caption="Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA" mask="0x30" values="GPIO_CTRL__DRIV_STREN"/>
        </register>
        <register name="CTRL2P15" offset="0x6a0" rw="RW" size="4" access-size="4" initval="0x00000000" count="8" caption="The GPIO PIN_CTRL2 Registers">
          <bitfield name="SLEW_CTRL" caption="Selects slew rate on the pin. 1=fast 0=slow" mask="0x1"/>
          <bitfield name="DRIV_STREN" caption="Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA" mask="0x30" values="GPIO_CTRL__DRIV_STREN"/>
        </register>
        <register name="CTRL2P16" offset="0x6c0" rw="RW" size="4" access-size="4" initval="0x00000000" count="8" caption="The GPIO PIN_CTRL2 Registers">
          <bitfield name="SLEW_CTRL" caption="Selects slew rate on the pin. 1=fast 0=slow" mask="0x1"/>
          <bitfield name="DRIV_STREN" caption="Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA" mask="0x30" values="GPIO_CTRL__DRIV_STREN"/>
        </register>
        <register name="CTRL2P17" offset="0x6e0" rw="RW" size="4" access-size="4" initval="0x00000000" count="8" caption="The GPIO PIN_CTRL2 Registers">
          <bitfield name="SLEW_CTRL" caption="Selects slew rate on the pin. 1=fast 0=slow" mask="0x1"/>
          <bitfield name="DRIV_STREN" caption="Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA" mask="0x30" values="GPIO_CTRL__DRIV_STREN"/>
        </register>
        <register name="CTRL2P20" offset="0x700" rw="RW" size="4" access-size="4" initval="0x00000000" count="8" caption="The GPIO PIN_CTRL2 Registers">
          <bitfield name="SLEW_CTRL" caption="Selects slew rate on the pin. 1=fast 0=slow" mask="0x1"/>
          <bitfield name="DRIV_STREN" caption="Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA" mask="0x30" values="GPIO_CTRL__DRIV_STREN"/>
        </register>
        <register name="CTRL2P21" offset="0x720" rw="RW" size="4" access-size="4" initval="0x00000000" count="8" caption="The GPIO PIN_CTRL2 Registers">
          <bitfield name="SLEW_CTRL" caption="Selects slew rate on the pin. 1=fast 0=slow" mask="0x1"/>
          <bitfield name="DRIV_STREN" caption="Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA" mask="0x30" values="GPIO_CTRL__DRIV_STREN"/>
        </register>
        <register name="CTRL2P22" offset="0x740" rw="RW" size="4" access-size="4" initval="0x00000000" count="8" caption="The GPIO PIN_CTRL2 Registers">
          <bitfield name="SLEW_CTRL" caption="Selects slew rate on the pin. 1=fast 0=slow" mask="0x1"/>
          <bitfield name="DRIV_STREN" caption="Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA" mask="0x30" values="GPIO_CTRL__DRIV_STREN"/>
        </register>
        <register name="CTRL2P23" offset="0x760" rw="RW" size="4" access-size="4" initval="0x00000000" count="8" caption="The GPIO PIN_CTRL2 Registers">
          <bitfield name="SLEW_CTRL" caption="Selects slew rate on the pin. 1=fast 0=slow" mask="0x1"/>
          <bitfield name="DRIV_STREN" caption="Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA" mask="0x30" values="GPIO_CTRL__DRIV_STREN"/>
        </register>
        <register name="CTRL2P24" offset="0x780" rw="RW" size="4" access-size="4" initval="0x00000000" count="8" caption="The GPIO PIN_CTRL2 Registers">
          <bitfield name="SLEW_CTRL" caption="Selects slew rate on the pin. 1=fast 0=slow" mask="0x1"/>
          <bitfield name="DRIV_STREN" caption="Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA" mask="0x30" values="GPIO_CTRL__DRIV_STREN"/>
        </register>
        <register name="CTRL2P25" offset="0x7a0" rw="RW" size="4" access-size="4" initval="0x00000000" count="8" caption="The GPIO PIN_CTRL2 Registers">
          <bitfield name="SLEW_CTRL" caption="Selects slew rate on the pin. 1=fast 0=slow" mask="0x1"/>
          <bitfield name="DRIV_STREN" caption="Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA" mask="0x30" values="GPIO_CTRL__DRIV_STREN"/>
        </register>
        <register name="CTRL2P26" offset="0x7c0" rw="RW" size="4" access-size="4" initval="0x00000000" count="1" caption="The GPIO PIN_CTRL2 Registers">
          <bitfield name="SLEW_CTRL" caption="Selects slew rate on the pin. 1=fast 0=slow" mask="0x1"/>
          <bitfield name="DRIV_STREN" caption="Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA" mask="0x30" values="GPIO_CTRL__DRIV_STREN"/>
        </register>
      </register-group>
      <value-group name="GPIO_CTRL__MUX_CTRL">
        <value name="GPIO" caption="GPIO function selected" value="0x0"/>
        <value name="FUNC1" caption="Signal function 1 selected" value="0x1"/>
        <value name="FUNC2" caption="Signal function 2 selected" value="0x2"/>
        <value name="FUNC3" caption="Signal function 3 selected" value="0x3"/>
      </value-group>
      <value-group name="GPIO_CTRL__PU_PD">
        <value name="NONE" caption="None. Pin tristates when no active driver is present on the pin." value="0x0"/>
        <value name="UP" caption="Pull Up Enabled" value="0x1"/>
        <value name="DOWN" caption="Pull Down Enabled" value="0x2"/>
        <value name="REPEATER" caption="Repeater mode. Pin is kept at previous voltage level when no active driver is present on the pin." value="0x3"/>
      </value-group>
      <value-group name="GPIO_CTRL__DRIV_STREN">
        <value name="LEVEL0" caption="For PIO12 = 2mA, PIO24 = 4mA" value="0x0"/>
        <value name="LEVEL1" caption="For PIO12 = 4mA, PIO24 = 8mA" value="0x1"/>
        <value name="LEVEL2" caption="For PIO12 = 8mA, PIO24 = 16mA" value="0x2"/>
        <value name="LEVEL3" caption="For PIO12 = 12mA, PIO24 = 24mA" value="0x3"/>
      </value-group>
    </module>
    <module name="WDT" id="88" version="1.0" caption="The function of the Watchdog Timer is to provide a mechanism to detect if the internal embedded controller has failed.">
      <register-group name="WDT" caption="The function of the Watchdog Timer is to provide a mechanism to detect if the internal embedded controller has failed.">
        <register name="LOAD" offset="0x0" rw="RW" size="2" access-size="2" initval="0xFFFF" caption="Writing this field reloads the Watch Dog Timer counter.">
        </register>
        <register name="CTRL" offset="0x4" rw="RW" size="2" access-size="2" initval="0x0000" caption="WDT Control Register">
          <bitfield name="WDT_EN" caption="WDT Block enabled" mask="0x1"/>
          <bitfield name="WDT_STS" caption="WDT_STATUS is set by hardware if the last reset of the device was caused by an underflow of the WDT. This bit must      be cleared by the EC firmware writing a '1' to this bit. Writing a '0' to this bit has no effect." mask="0x2"/>
          <bitfield name="HIB_TMR0_STL" caption="This bit enables the WDT Stall function if the Hibernation Timer 0 is active.      1=The WDT is stalled while the Hibernation Timer 0 is active      0=The WDT is not affected by Hibernation Timer 0." mask="0x4"/>
          <bitfield name="WK_TMR_STL" caption="This bit enables the WDT Stall function if the Week Timer is active.      1=The WDT is stalled while the Week Timer is active      0=The WDT is not affected by the Week Timer." mask="0x8"/>
          <bitfield name="JTAG_STL" caption="This bit enables the WDT Stall function if JTAG or SWD debug functions are active      1=The WDT is stalled while either JTAG or SWD is active      0=The WDT is not affected by the JTAG debug interface." mask="0x10"/>
          <bitfield name="WDT_RST" caption="If the WDT_RESET bit is set and the watch dog timer expires, the Watch dog module will         generate interrupt and clear the WDT_RESET to 0b." mask="0x200"/>
        </register>
        <register name="KICK" offset="0x8" rw="W" size="1" access-size="1" initval="0x00" caption="The WDT Kick Register is a strobe. Reads of this register return 0. Writes to this register cause the WDT to reload     the WDT Load Register value and start decrementing when the WDT_ENABLE bit in the WDT Control Register is set to '1'. When the WDT_ENABLE     bit in the WDT Control Register is cleared to '0', writes to the WDT Kick Register have no effect.">
        </register>
        <register name="CNT" offset="0xC" rw="R" size="2" access-size="2" initval="0xFFFF" caption="This read-only register provides the current WDT count.">
        </register>
        <register name="STS" offset="0x10" rw="RW" size="1" access-size="1" initval="0x00" caption="This register provides the current WDT count.">
          <bitfield name="WDT_EV_IRQ" caption="WDT_EVENT_IRQ : This bit indicates the status of interrupt from Watch dog module." mask="0x1"/>
        </register>
        <register name="IEN" offset="0x14" rw="RW" size="1" access-size="1" initval="0x00" caption="Watch Dog Interrupt Enable Register.">
          <bitfield name="WDT_INTEN" caption="WDT_Int_Enable: This is the interrupt enables bit for WDT_INT interrupt.                   1= WDT_INT Interrupt Enable                   0= WDT_INT Interrupt Disabled" mask="0x1"/>
        </register>
      </register-group>
    </module>
    <module name="TIMER32" id="108b" version="1.0" caption="This 32-bit timer block offers a simple mechanism for firmware to maintain a time base.">
      <register-group name="TIMER32" caption="This 32-bit timer block offers a simple mechanism for firmware to maintain a time base.">
        <register name="CNT" offset="0x0" rw="RW" size="4" access-size="4" initval="0x00000000" caption="This is the value of the Timer counter. This is updated by Hardware but may be set by Firmware.">
        </register>
        <register name="PRLD" offset="0x4" rw="RW" size="4" access-size="4" initval="0x00000000" caption="This is the value of the Timer pre-load for the counter. This is used by H/W when the counter is to be restarted    automatically; this will become the new value of the counter upon restart.">
        </register>
        <register name="STS" offset="0x8" rw="RW" size="4" access-size="4" initval="0x00000000" caption="This is the interrupt status that fires when the timer reaches its limit">
          <bitfield name="EVT_INT" caption="This is the interrupt status that fires when the timer reaches its limit. This is the interrupt status that fires when        the timer reaches its limit. This may be level or a self clearing signal cycle pulse, based on the AUTO_RESTART bit in the Timer        Control Register. If the timer is set to automatically restart, it will provide a pulse, otherwise a level is provided.(R/WC)" mask="0x1"/>
        </register>
        <register name="IEN" offset="0xC" rw="RW" size="4" access-size="4" initval="0x00000000" caption="This is the interrupt enable for the status EVENT_INTERRUPT bit in the Timer Status Register">
          <bitfield name="EN" caption="This is the interrupt enable for the status EVENT_INTERRUPT bit in the Timer Status Register." mask="0x1"/>
        </register>
        <register name="CTRL" offset="0x10" rw="RW" size="4" access-size="4" initval="0x00000000" caption="Timer Control Register">
          <bitfield name="EN" caption="This enables the block for operation. 1=This block will function normally;     0=This block will gate its clock and go into its lowest power state" mask="0x1"/>
          <bitfield name="CNT_UP" caption="This selects the counter direction. When the counter in incrementing the counter will saturate and trigger the event     when it reaches all F's. When the counter is decrementing the counter will saturate when it reaches 0h. 1=The counter will increment;     0=The counter will decrement" mask="0x4"/>
          <bitfield name="AU_RESTRT" caption="This will select the action taken upon completing a count.     1=The counter will automatically restart the count, using the contents of the Timer Preload Register to load the Timer Count Register.     The interrupt will be set in edge mode     0=The counter will simply enter a done state and wait for further control inputs. The interrupt will be set in level mode." mask="0x8"/>
          <bitfield name="SFT_RST" caption="This is a soft reset. This is self clearing 1 cycle after it is written. Firmware does not need     to wait before reconfiguring the Basic Timer following soft reset." mask="0x10"/>
          <bitfield name="STRT" caption="This bit triggers the timer counter. The counter will operate until it hits its terminating condition. This will     clear this bit. It should be noted that when operating in restart mode, there is no terminating condition for the counter, so     this bit will never clear. Clearing this bit will halt the timer counter." mask="0x20"/>
          <bitfield name="RLD" caption="This bit reloads the counter without interrupting it operation. This will not function if the timer has already     completed (when the START bit in this register is '0'). This is used to periodically prevent the timer from firing when an     event occurs. Usage while the timer is off may result in erroneous behaviour." mask="0x40"/>
          <bitfield name="HLT" caption="This is a halt bit. This will halt the timer as long as it is active. Once the halt is inactive, the timer will     start from where it left off. 1=Timer is halted. It stops counting. The clock divider will also be reset. 0=Timer runs normally." mask="0x80"/>
          <bitfield name="PRESCALE" caption="This is used to divide down the system clock through clock enables to lower the power consumption of the block and allow     slow timers. Updating this value during operation may result in erroneous clock enable pulses until the clock divider restarts.     The number of clocks per clock enable pulse is (Value + 1); a setting of 0 runs at the full clock speed, while a setting of 1     runs at half speed." mask="0xFFFF0000"/>
        </register>
      </register-group>
    </module>
    <module name="CCT" id="12" version="1.0" caption="This is a 16-bit auto-reloading timer/counter.">
      <register-group name="CCT" caption="This is a 16-bit auto-reloading timer/counter.">
        <register name="CTRL" offset="0x0" rw="RW" size="4" access-size="4" initval="0x00000000" caption="This register controls the capture and compare timer.">
          <bitfield name="ACT" caption="This bit is used to start the capture and compare timer running and power it down." mask="0x1"/>
          <bitfield name="FREE_EN" caption="Free-Running Timer Enable. This bit is used to start and stop the free running timer." mask="0x2"/>
          <bitfield name="FREE_RST" caption="Free Running Timer Reset. This bit stops the timer and resets the internal counter to 0000_0000h." mask="0x4"/>
          <bitfield name="TCLK" caption="This 3-bit field sets the clock source for the Free-Running Counter." mask="0x70"/>
          <bitfield name="CMP_EN0" caption="Compare Enable for Compare 0 Register." mask="0x100"/>
          <bitfield name="CMP_EN1" caption="Compare Enable for Compare 1 Register." mask="0x200"/>
          <bitfield name="CMP_SET1" caption="When read, returns the current value off the Compare Timer Output 1 state." mask="0x10000"/>
          <bitfield name="CMP_SET0" caption="When read, returns the current value off the Compare Timer Output 0 state." mask="0x20000"/>
          <bitfield name="CMP_CLR1" caption="When read, returns the current value off the Compare Timer Output 1 state." mask="0x1000000"/>
          <bitfield name="CMP_CLR0" caption="When read, returns the current value off the Compare Timer Output 0 state." mask="0x2000000"/>
        </register>
        <register name="CAP0_CTRL" offset="0x4" rw="RW" size="4" access-size="4" initval="0x00000000" caption="This register is used to configure capture and compare timers 0-3.">
          <bitfield name="CAP_EDGE0" caption="This field selects the edge type that triggers the capture of the Free Running Counter into Capture Register 0." mask="0x3"/>
          <bitfield name="FILTER_BYP0" caption="This bit enables bypassing the input noise filter for Capture Register 0, so that the input signal goes directly into the timer." mask="0x4"/>
          <bitfield name="FCLK_SEL0" caption="This 3-bit field sets the clock source for the input filter for Capture Register 0." mask="0xE0"/>
          <bitfield name="CAP_EDGE1" caption="This field selects the edge type that triggers the capture of the Free Running Counter into Capture Register 1." mask="0x300"/>
          <bitfield name="FILTER_BYP1" caption="This bit enables bypassing the input noise filter for Capture Register 1, so that the input signal goes directly into the timer." mask="0x400"/>
          <bitfield name="FCLK_SEL1" caption="This 3-bit field sets the clock source for the input filter for Capture Register 1." mask="0xE000"/>
          <bitfield name="CAP_EDGE2" caption="This field selects the edge type that triggers the capture of the Free Running Counter into Capture Register 2." mask="0x30000"/>
          <bitfield name="FILTER_BYP2" caption="This bit enables bypassing the input noise filter for Capture Register 2, so that the input signal goes directly into the timer." mask="0x40000"/>
          <bitfield name="FCLK_SEL2" caption="This 3-bit field sets the clock source for the input filter for Capture Register 2." mask="0xE00000"/>
          <bitfield name="CAP_EDGE3" caption="This field selects the edge type that triggers the capture of the Free Running Counter into Capture Register 3." mask="0x3000000"/>
          <bitfield name="FILTER_BYP3" caption="This bit enables bypassing the input noise filter for Capture Register 3, so that the input signal goes directly into the timer." mask="0x4000000"/>
          <bitfield name="FCLK_SEL3" caption="This 3-bit field sets the clock source for the input filter for Capture Register 3." mask="0xE0000000"/>
        </register>
        <register name="CAP1_CTRL" offset="0x8" rw="RW" size="4" access-size="4" initval="0x00000000" caption="This register is used to configure capture and compare timers 4-5.">
          <bitfield name="CAP_EDGE4" caption="This field selects the edge type that triggers the capture of the Free Running Counter into Capture Register 4." mask="0x3"/>
          <bitfield name="FILTER_BYP4" caption="This bit enables bypassing the input noise filter for Capture Register 4, so that the input signal goes directly into the timer." mask="0x4"/>
          <bitfield name="FCLK_SEL4" caption="This 3-bit field sets the clock source for the input filter for Capture Register 4." mask="0xE0"/>
          <bitfield name="CAP_EDGE5" caption="This field selects the edge type that triggers the capture of the Free Running Counter into Capture Register 5." mask="0x300"/>
          <bitfield name="FILTER_BYP5" caption="This bit enables bypassing the input noise filter for Capture Register 5, so that the input signal goes directly into the timer." mask="0x400"/>
          <bitfield name="FCLK_SEL5" caption="This 3-bit field sets the clock source for the input filter for Capture Register 5." mask="0xE000"/>
        </register>
        <register name="FREE_RUN" offset="0xC" rw="RW" size="4" access-size="4" initval="0x00000000" caption="This register contains the current value of the Free Running Timer.">
          <bitfield name="TMR" caption="This register contains the current value of the Free Running Timer." mask="0xFFFFFFFF"/>
        </register>
        <register name="CAP0" offset="0x10" rw="RW" size="4" access-size="4" initval="0x00000000" caption="This register saves the value copied from the Free Running timer on a programmed edge of ICT0.">
          <bitfield name="CAP_0" caption="This register saves the value copied from the Free Running timer on a programmed edge of ICT0." mask="0xFFFFFFFF"/>
        </register>
        <register name="CAP1" offset="0x14" rw="RW" size="4" access-size="4" initval="0x00000000" caption="This register saves the value copied from the Free Running timer on a programmed edge of ICT1.">
          <bitfield name="CAP_1" caption="This register saves the value copied from the Free Running timer on a programmed edge of ICT1." mask="0xFFFFFFFF"/>
        </register>
        <register name="CAP2" offset="0x18" rw="RW" size="4" access-size="4" initval="0x00000000" caption="This register saves the value copied from the Free Running timer on a programmed edge of ICT0.">
          <bitfield name="CAP_2" caption="This register saves the value copied from the Free Running timer on a programmed edge of ICT2." mask="0xFFFFFFFF"/>
        </register>
        <register name="CAP3" offset="0x1C" rw="RW" size="4" access-size="4" initval="0x00000000" caption="This register saves the value copied from the Free Running timer on a programmed edge of ICT0.">
          <bitfield name="CAP_3" caption="This register saves the value copied from the Free Running timer on a programmed edge of ICT3." mask="0xFFFFFFFF"/>
        </register>
        <register name="CAP4" offset="0x20" rw="RW" size="4" access-size="4" initval="0x00000000" caption="This register saves the value copied from the Free Running timer on a programmed edge of ICT4.">
          <bitfield name="CAP_4" caption="This register saves the value copied from the Free Running timer on a programmed edge of ICT4." mask="0xFFFFFFFF"/>
        </register>
        <register name="CAP5" offset="0x24" rw="RW" size="4" access-size="4" initval="0x00000000" caption="This register saves the value copied from the Free Running timer on a programmed edge of ICT5.">
          <bitfield name="CAP_5" caption="This register saves the value copied from the Free Running timer on a programmed edge of ICT5." mask="0xFFFFFFFF"/>
        </register>
        <register name="COMP0" offset="0x28" rw="RW" size="4" access-size="4" initval="0x00000000" caption="A COMPARE 0 interrupt is generated when this register matches the value in the Free Running Timer.">
          <bitfield name="COMP_0" caption="A COMPARE 0 interrupt is generated when this register matches the value in the Free Running Timer." mask="0xFFFFFFFF"/>
        </register>
        <register name="COMP1" offset="0x2C" rw="RW" size="4" access-size="4" initval="0x00000000" caption="A COMPARE 1 interrupt is generated when this register matches the value in the Free Running Timer.">
          <bitfield name="COMP_1" caption="A COMPARE 1 interrupt is generated when this register matches the value in the Free Running Timer." mask="0xFFFFFFFF"/>
        </register>
        <register name="MUX_SEL" offset="0x30" rw="RW" size="4" access-size="4" initval="0x00543210" caption="This register selects the pin mapping to the capture register.">
          <bitfield name="CAP0" caption="Mux Select for Capture 0 register." mask="0xF"/>
          <bitfield name="CAP1" caption="Mux Select for Capture 1 register." mask="0xF0"/>
          <bitfield name="CAP2" caption="Mux Select for Capture 2 register." mask="0xF00"/>
          <bitfield name="CAP3" caption="Mux Select for Capture 3 register." mask="0xF000"/>
          <bitfield name="CAP4" caption="Mux Select for Capture 4 register." mask="0xF0000"/>
          <bitfield name="CAP5" caption="Mux Select for Capture 5 register." mask="0xF00000"/>
        </register>
      </register-group>
    </module>
    <module name="HTM" id="29" version="1.0" caption="The Hibernation Timer can generate a wake event to the Embedded Controller (EC) when it is in a hibernation mode.">
      <register-group name="HTM" caption="The Hibernation Timer can generate a wake event to the Embedded Controller (EC) when it is in a hibernation mode.">
        <register name="PRLD" offset="0x0" rw="RW" size="2" access-size="2" initval="0x0000" caption="[15:0] This register is used to set the Hibernation Timer Preload value.">
        </register>
        <register name="CTRL" offset="0x4" rw="RW" size="2" access-size="2" initval="0x0000" caption="HTimer Control Register">
          <bitfield name="CTRL" caption="1= The Hibernation Timer has a resolution of 0.125s per LSB, which yields a maximum time in excess of 2 hours.     0= The Hibernation Timer has a resolution of 30.5us per LSB, which yields a maximum time of ~2seconds." mask="0x1"/>
        </register>
        <register name="CNT" offset="0x8" rw="R" size="2" access-size="2" initval="0x0000" caption="The current state of the Hibernation Timer.">
        </register>
      </register-group>
    </module>
    <module name="RTOS" id="140" version="1.0" caption="RTOS is a 32-bit timer designed to operate on the 32kHz oscillator which is available during all chip sleep states.">
      <register-group name="RTOS" caption="RTOS is a 32-bit timer designed to operate on the 32kHz oscillator which is available during all chip sleep states.">
        <register name="CNT" offset="0x0" rw="RW" size="4" access-size="4" initval="0x00000000" caption="RTOS Timer Count Register.">
          <bitfield name="CNTR" caption="This register contains the current value of the RTOS Timer counter. This register should be read as a DWORD. There is no latching mechanism         of the upper bytes implemented if the register is accessed as a byte or word. Reading the register with byte or word operations may give incorrect results." mask="0xFFFFFFFF"/>
        </register>
        <register name="PRLD" offset="0x4" rw="RW" size="4" access-size="4" initval="0x00000000" caption="RTOS Timer Preload Register">
          <bitfield name="PRELOAD" caption="The this register is loaded into the RTOS Timer counter either when the TIMER_START bit is written with a 1, or when the timer counter counts down to 0 and the AUTO_RELOAD bit is 1.      This register must be programmed with a new count value before the TIMER_START bit is set to 1. If this register is updated while the counter is operating, the new count value will only take effect if      the counter transitions form 1 to 0 while the AUTO_RELOAD bit is set." mask="0xFFFFFFFF"/>
        </register>
        <register name="CTRL" offset="0x8" rw="RW" size="4" access-size="4" initval="0x00000000" caption="RTOS Timer Control Register">
          <bitfield name="BLK_EN" caption="1=RTOS timer counter is enabled     0=RTOS timer disabled. All register bits are reset to their default state" mask="0x1"/>
          <bitfield name="AU_RELOAD" caption="1=The the RTOS Timer Preload Register is loaded into the timer counter and the counter is restarted when the counter transitions from 1 to 0     0=The timer counter halts when it transitions from 1 to 0 and will not restart." mask="0x2"/>
          <bitfield name="TMR_STRT" caption="Writing a 1 to this bit will load the timer counter with the RTOS Timer Preload Register and start counting. If the Preload Register is 0, counting will not start and this bit will be cleared to 0.     Writing a 0 to this bit will halt the counter and clear its contents to 0. The RTOS timer interrupt will not be generated. This bit is automatically cleared if the AUTO_RELOAD bit is 0 and the     timer counter transitions from 1 to 0." mask="0x4"/>
          <bitfield name="EXT_HW_HALT_EN" caption="1=The timer counter is halted when the external HALT signal is asserted. Counting is always enabled if HALT is de-asserted.     0=The HALT signal does not affect the RTOS Timer" mask="0x8"/>
          <bitfield name="FW_TMR_HALT" caption="1=The timer counter is halted. If the counter was running, clearing this bit will restart the counter from the value at which it halted     0=The timer counter, if enabled, will continue to run" mask="0x10"/>
        </register>
        <register name="SOFTIRQ" offset="0xC" rw="W" size="4" access-size="4" initval="0x00000000" caption="Soft Interrupt Register">
          <bitfield name="SWI0" caption="Software Interrupt. A write of a '1' to this bit will generate an SWI interrupt to the EC.     Writes of a '0' have no effect. Reads return '0'." mask="0x1"/>
          <bitfield name="SWI1" caption="Software Interrupt. A write of a '1' to this bit will generate an SWI interrupt to the EC.     Writes of a '0' have no effect. Reads return '0'." mask="0x2"/>
          <bitfield name="SWI2" caption="Software Interrupt. A write of a '1' to this bit will generate an SWI interrupt to the EC.     Writes of a '0' have no effect. Reads return '0'." mask="0x4"/>
          <bitfield name="SWI3" caption="Software Interrupt. A write of a '1' to this bit will generate an SWI interrupt to the EC.     Writes of a '0' have no effect. Reads return '0'." mask="0x8"/>
        </register>
      </register-group>
    </module>
    <module name="PWM" id="54" version="1.0" caption="The PWM block generates an arbitrary duty cycle output at frequencies from less than 0.1 Hz to 24 MHz.">
      <register-group name="PWM" caption="The PWM block generates an arbitrary duty cycle output at frequencies from less than 0.1 Hz to 24 MHz.">
        <register name="CNT_ON" offset="0x0" rw="RW" size="4" access-size="4" initval="0x00000000" caption="This field determines both the frequency and duty cycle of the PWM signal. Setting this field to a value of n will    cause the On time of the PWM to be n+1 cycles of the PWM Clock Source.    When this field is set to zero and the PWMX_COUNTER_OFF_TIME is not set to zero, the PWM_OUTPUT is held low (Full Off).">
        </register>
        <register name="CNT_OFF" offset="0x4" rw="RW" size="4" access-size="4" initval="0x0000FFFF" caption="This field determine both the frequency and duty cycle of the PWM signal. Setting this field to a value of n will    cause the Off time of the PWM to be n+1 cycles of the PWM Clock Source.    When this field is set to zero, the PWM_OUTPUT is held high (Full On).">
        </register>
        <register name="CFG" offset="0x8" rw="RW" size="4" access-size="4" initval="0x00000000" caption="PWMx CONFIGURATION REGISTER">
          <bitfield name="PWM_EN" caption="When the PWM_ENABLE is set to 0 the internal counters are reset and the internal state machine is set to the OFF state.     In addition, the PWM_OUTPUT signal is set to the inactive state as determined by the Invert bit. The PWMx Counter ON Time Register     and PWMx Counter OFF Time Register are not affected by the PWM_ENABLE bit and may be read and written while the PWM enable bit is 0.     1=Enabled (default); 0=Disabled (gates clocks to save power)." mask="0x1"/>
          <bitfield name="CLK_SEL" caption="This bit determines the clock source used by the PWM duty cycle and frequency control logic.                    1=CLOCK_LOW                    0=CLOCK_HIGH" mask="0x2"/>
          <bitfield name="INV" caption="1= PWM_OUTPUT ON State is active low; 0=PWM_OUTPUT ON State is active high." mask="0x4"/>
          <bitfield name="CLK_PRE_DIV" caption="The Clock source for the 16-bit down counter (see PWMx Counter ON Time Register and PWMx Counter OFF Time Register)     is determined by bit D1 of this register. The Clock source is then divided by the value of Pre-Divider+1 and the resulting     signal determines the rate at which the down counter will be decremented. For example, a Pre-Divider value of 1 divides     the input clock by 2 and a value of 2 divides the input clock by 3. A Pre-Divider of 0 will disable the Pre-Divider option." mask="0x78"/>
        </register>
      </register-group>
    </module>
    <module name="LED" id="111" version="1.0" caption="The LED is implemented using a PWM that can be driven either by the 48 MHz clock or by a 32.768 KHz clock input.">
      <register-group name="LED" caption="The LED is implemented using a PWM that can be driven either by the 48 MHz clock or by a 32.768 KHz clock input.">
        <register name="CFG" offset="0x0" rw="RW" size="4" access-size="4" initval="0x00001400" caption="LED Configuration">
          <bitfield name="CTRL" caption="CONTROL 3=PWM is always on                  2=LED blinking (standard PWM)                  1=LED breathing configuration                  0=PWM is always off. All internal registers and counters are reset to 0. Clocks are gated" mask="0x3"/>
          <bitfield name="CLK_SRC" caption="1=Clock source is the 48 MHz clock, 0=Clock source is the 32.768 KHz clock" mask="0x4"/>
          <bitfield name="SYNCH" caption="SYNCHRONIZE  When this bit is '1', all counters for all LEDs are reset to their initial values. When this bit is '0' in the LED Configuration Register for all LEDs, then all counters for LEDs that are configured to blink or breathe will increment or decrement, as required." mask="0x8"/>
          <bitfield name="PWM_SIZE" caption="PWM_SIZE This bit controls the behavior of PWM:                  3=Reserved                  2=PWM is configured as a 6-bit PWM                  1=PWM is configured as a 7-bit PWM                  0=PWM is configured as an 8-bit PWM" mask="0x30"/>
          <bitfield name="EN_UPDATE" caption="ENABLE_UPDATE  This bit is set to 1 when written with a '1'. Writes of '0' have no effect. Hardware clears this bit to 0 when the breathing configuration registers are updated at the end of a PWM period. The current state of the bit is readable any time." mask="0x40"/>
          <bitfield name="RST" caption="RESET  Writes of '1' to this bit resets the PWM registers to their default values. This bit is self clearing. Writes of '0' to this bit have no effect." mask="0x80"/>
          <bitfield name="WDT_RELOAD" caption="WDT_RELOAD  The PWM Watchdog Timer counter reload value. On system reset, it defaults to 14h, which corresponds to a 4 second Watchdog timeout value." mask="0xFF00"/>
          <bitfield name="SYMMETRY" caption="SYMMETRY  1=The rising and falling ramp times are in Asymmetric mode.                  0=The rising and falling ramp times are in Symmetric mode." mask="0x10000"/>
        </register>
        <register name="LIMIT" offset="0x4" rw="RW" size="4" access-size="4" initval="0x00000000" caption="LED Limits This register may be written at any time. Values written into the register are held in an holding register, which is transferred into the actual register at the end of a PWM period. The two byte fields may be written independently. Reads of this register return the current contents and not the value of the holding register.">
          <bitfield name="MIN" caption="In breathing mode, when the current duty cycle is less than or equal to this value the breathing apparatus holds the current duty cycle for the period specified by the field LD in register LED_DELAY, then starts incrementing the current duty cycle In blinking mode, this field defines the duty cycle of the blink function." mask="0xFF"/>
          <bitfield name="MAX" caption="In breathing mode, when the current duty cycle is greater than or equal to this value the breathing apparatus holds the current duty cycle for the period specified by the field HD in register LED_DELAY, then starts decrementing the current duty cycle" mask="0xFF00"/>
        </register>
        <register name="DLY" offset="0x8" rw="RW" size="4" access-size="4" initval="0x00000000" caption="LED Delay">
          <bitfield name="LOW_PULSE" caption="The number of PWM periods to wait before updating the current duty cycle when the current duty cycle is greater than or equal to the value MIN in register LED_LIMIT." mask="0xFFF"/>
          <bitfield name="HIGH_PULSE" caption="In breathing mode, the number of PWM periods to wait before updating the current duty cycle when the current duty cycle is greater than or equal to the value MAX in register LED_LIMIT." mask="0xFFF000"/>
        </register>
        <register name="STEP" offset="0xC" rw="RW" size="4" access-size="4" initval="0x00000000" caption="This register has eight segment fields which provide the amount the current duty cycle is adjusted at the end of every PWM period. Segment field selection is decoded based on the segment index. The segment index equation utilized depends on the SYMMETRY bit in the LED Configuration Register Register)              . In Symmetric Mode the Segment_Index[2:0] = Duty Cycle Bits[7:5]              . In Asymmetric Mode the Segment_Index[2:0] is the bit concatenation of following: Segment_Index[2] = (FALLING RAMP TIME in Figure 30-3, Clipping Example) and Segment_Index[1:0] = Duty Cycle Bits[7:6].">
          <bitfield name="S0" caption="Amount the current duty cycle is adjusted at the end of every PWM period when the segment index is equal to 000." mask="0xF"/>
          <bitfield name="S1" caption="Amount the current duty cycle is adjusted at the end of every PWM period when the segment index is equal to 001." mask="0xF0"/>
          <bitfield name="S2" caption="Amount the current duty cycle is adjusted at the end of every PWM period when the segment index is equal to 010." mask="0xF00"/>
          <bitfield name="S3" caption="Amount the current duty cycle is adjusted at the end of every PWM period when the segment index is equal to 011." mask="0xF000"/>
          <bitfield name="S4" caption="Amount the current duty cycle is adjusted at the end of every PWM period when the segment index is equal to 100." mask="0xF0000"/>
          <bitfield name="S5" caption="Amount the current duty cycle is adjusted at the end of every PWM period when the segment index is equal to 101" mask="0xF00000"/>
          <bitfield name="S6" caption="Amount the current duty cycle is adjusted at the end of every PWM period when the segment index is equal to 110." mask="0xF000000"/>
          <bitfield name="S7" caption="Amount the current duty cycle is adjusted at the end of every PWM period when the segment index is equal to 111." mask="0xF0000000"/>
        </register>
        <register name="INTRVL" offset="0x10" rw="RW" size="4" access-size="4" initval="0x00000000" caption="LED Update Interval">
          <bitfield name="I0" caption="The number of PWM periods between updates to current duty cycle when the segment index is equal to 000b." mask="0xF"/>
          <bitfield name="I1" caption="The number of PWM periods between updates to current duty cycle when the segment index is equal to 001b." mask="0xF0"/>
          <bitfield name="I2" caption="The number of PWM periods between updates to current duty cycle when the segment index is equal to 010b." mask="0xF00"/>
          <bitfield name="I3" caption="The number of PWM periods between updates to current duty cycle when the segment index is equal to 011b." mask="0xF000"/>
          <bitfield name="I4" caption="The number of PWM periods between updates to current duty cycle when the segment index is equal to 100b." mask="0xF0000"/>
          <bitfield name="I5" caption="The number of PWM periods between updates to current duty cycle when the segment index is equal to 101b." mask="0xF00000"/>
          <bitfield name="I6" caption="The number of PWM periods between updates to current duty cycle when the segment index is equal to 110b." mask="0xF000000"/>
          <bitfield name="I7" caption="The number of PWM periods between updates to current duty cycle when the segment index is equal to 111b." mask="0xF0000000"/>
        </register>
        <register name="OUTDLY" offset="0x14" rw="RW" size="4" access-size="4" initval="0x00000000" caption="LED Output Delay">
          <bitfield name="DELAY" caption="The delay, in counts of the clock defined in Clock Source (CLKSRC), in which output transitions are delayed.     When this field is 0, there is no added transition delay. When the LED is programmed to be Always On or Always Off, the     Output Delay field has no effect." mask="0xFF"/>
        </register>
      </register-group>
    </module>
    <module name="SMB" id="31" version="1.0" caption="The SMBus interface can handle standard SMBus 2.0 protocols as well as I2C interface.">
      <register-group name="SMB" caption="The SMBus interface can handle standard SMBus 2.0 protocols as well as I2C interface.">
        <register name="WCTRL" offset="0x0" rw="W" size="4" access-size="4" initval="0x00000000" caption="Control Register">
          <bitfield name="ACK" caption="The Acknowledge bit (ACK) must normally be asserted ('1'). This causes the controller to send an acknowledge automatically after each byte (this occurs during the 9th clock pulse). The ACK bit must not be asserted ('0') when the controller is operating in master/receiver mode and requires no further data to be sent from the slave transmitter. This causes a negative acknowledge on the I2C bus, which halts further transmission from the slave device." mask="0x1"/>
          <bitfield name="STO" caption="See STA description" mask="0x2"/>
          <bitfield name="STA" caption="The STA and STO bits control the generation of the I2C Start condition and the transmission of the Slave Address and R/nW bit (from the Data Register), generation of repeated Start condition, and generation of the Stop condition" mask="0x4"/>
          <bitfield name="ENI" caption="Enable Interrupt bit (ENI) controls the Interrupt Interface" mask="0x8"/>
          <bitfield name="ESO" caption="The Enable Serial Output bit (ESO) enables and disables the SMB Controller Core serial data output (SDAT)" mask="0x40"/>
          <bitfield name="PIN" caption="The Pending Interrupt Not (PIN) bit serves as a software reset function. Writing the PIN bit to a logic '1' de-asserts all status bits except for the nBB bit which is not affected by the PIN bit. The PIN bit is a self-clearing bit. Writing this bit to a logic '0' has no effect." mask="0x80"/>
        </register>
        <register name="RSTS" offset="0x0" rw="R" size="4" access-size="4" initval="0x00000081" caption="Status Register">
          <bitfield name="NBB" caption="The Bus Busy bit (NBB) is a read-only flag indicating when the bus is in use. A zero indicates that the bus is busy and access is not possible." mask="0x1"/>
          <bitfield name="LAB" caption="The Lost Arbitration Bit (LAB) is set when, in multi-master operation, arbitration is lost to another master on the bus" mask="0x2"/>
          <bitfield name="AAS" caption="The Addressed As Slave bit (AAS) is valid only when PIN is asserted ('0'). When acting as slave, AAS is set when an incoming address over the bus matches the value in the Own Address Register or if the 'general call' address (00h) has been received" mask="0x4"/>
          <bitfield name="LRB_AD0" caption="The Last Received Bit  or Address 0 (general call) bit (LRB/AD0) serves a dual function and is valid only while the PIN bit is asserted ('0').                When the AAS bit is not asserted ('0') (i.e., not addressed as a slave), the LRB/AD0 holds the value of the last received bit over the bus.                When the AAS bit is asserted ('1') (i.e., addressed as slave), the SMB Controller Core has been addressed as a slave." mask="0x8"/>
          <bitfield name="BER" caption="When Bus Error (BER) is asserted, a misplaced START or STOP condition or Bus Time-Outs have been detected." mask="0x10"/>
          <bitfield name="STS" caption="When in slave receiver mode, STS is asserted ('1') when an externally generated STOP condition is detected. Note that STS is used only in slave receiver mode." mask="0x20"/>
          <bitfield name="SAD" caption="SMBus Address Decoded (SAD)" mask="0x40"/>
          <bitfield name="PIN" caption="Pending Interrupt bit" mask="0x80"/>
        </register>
        <register name="OWN_ADDR" offset="0x4" rw="RW" size="4" access-size="4" initval="0x00000000" caption="Own Address Register           Note that the Data Register and Own Address fields are offset by one bit, so that programming Own Address 1 with a value of 55h will result in the value AAh being recognized as the SMB Controller Core slave address.">
          <bitfield name="ADDR1" caption="The Own Address 1 bits configure one of the two addresses to which the SMB Controller Core will respond when addressed as a slave." mask="0x7F"/>
          <bitfield name="ADDR2" caption="The Own Address 2 bits configure one of the two addresses to which the SMB Controller Core will respond when addressed as a slave." mask="0x7F00"/>
        </register>
        <register name="I2CDATA" offset="0x8" rw="RW" size="1" access-size="1" initval="0x00" caption="This register holds the data that are either shifted out to or shifted in from the I2C port.">
        </register>
        <register name="RSVD1" offset="0x9" rw="R" size="1" access-size="1" count="3" initval="0x00" caption="Reserved">
        </register>
        <register name="MCMD" offset="0xC" rw="RW" size="4" access-size="4" count="1" initval="0x00000000" caption="SMBus Master Command Register">
          <bitfield name="MRUN" caption="While this bit is 1, transfer bytes over SMBus. As long as WriteCount is non-zero, a byte from the Master Transmit Buffer is transmitted to the slave device and WriteCount is decremented." mask="0x1"/>
          <bitfield name="MPROCEED" caption="When this bit is 0, the Master State Machine does not transition out of the IDLE or PAUSE states. When this bit is 1, the Master State Machine immediately transitions to the WAIT-BUSBUSY and MRUN-RECEIVE states, respectively." mask="0x2"/>
          <bitfield name="START0" caption="If this bit is 1, send a Start bit on the SMBus before the first byte of the WriteCount is sent to the SMBus transmitter." mask="0x100"/>
          <bitfield name="STARTN" caption="If this bit is 1, send a Start bit just before the last byte of the WriteCount is sent to the SMBus transmitter." mask="0x200"/>
          <bitfield name="STOP" caption="If this bit is 1, send a Stop bit after the transaction completes." mask="0x400"/>
          <bitfield name="PEC_TERM" caption="If this bit is 1, a copy of the PEC register is transmitted when WriteCount is 0. After the PEC register is read, both the PEC register and this bit are cleared to 0." mask="0x800"/>
          <bitfield name="READM" caption="If this bit is 1, then the ReadCount field is replaced by the byte that is read from the SMBus when ReadCount[7:0] is 1. After ReadCount[7:0] is updated, this bit is cleared to 0." mask="0x1000"/>
          <bitfield name="READ_PEC" caption="If this bit is 0, reading from the SMBus stops when ReadCount reaches 0. If this bit is 1, reading continues when ReadCount is 0 for one more byte." mask="0x2000"/>
          <bitfield name="WR_CNT" caption="This field is a count of the number of bytes to transmit to the SMBus from the SMBus Master Transmit Buffer Register It is decremented by 1 for each byte written to the SMBus from the SMBus Master Transmit Buffer Register." mask="0xFF0000"/>
          <bitfield name="RD_CNT" caption="This field is a count of the number of bytes to read in from the SMBus to the SMBus Master Receive Buffer Register and must be greater than 0 in order for the Master State Machine to initiate a read phase. It is decremented by 1 for each byte read from the SMBus into the SMBus Master Receive Buffer Register. It can be overwritten by the first byte read in from the SMBus." mask="0xFF000000"/>
        </register>
        <register name="SCMD" offset="0x10" rw="RW" size="4" access-size="4" count="1" initval="0x00000000" caption="SMBus Slave Command Register">
          <bitfield name="SRUN" caption="Setting this bit to 1 enables the Slave State Machine to operate." mask="0x1"/>
          <bitfield name="SPROCEED" caption="When this bit is 0, the Slave State Machine does not transition out of the IDLE, REPEAT_START_WRITE or REPEAT_START_READ states. When this bit is 1, the Slave State Machine immediately transitions to the START_WAIT, RECEIVE and TRANSMIT states, respectively." mask="0x2"/>
          <bitfield name="PEC" caption="If Slave_WriteCount is 0 and Slave_PEC is 1 when the Master requests data, the PEC Register is copied to the DATA register. After the PEC Register is copied to the SMBus, the PEC Register is cleared and Slave_PEC is set to 0." mask="0x4"/>
          <bitfield name="WR_CNT" caption="This field is set to the number of bytes software expects to send to the Master." mask="0xFF00"/>
          <bitfield name="RD_CNT" caption="This field is decremented each time a byte is copied from DATA to the SMBus Slave Receive Buffer Register." mask="0xFF0000"/>
        </register>
        <register name="PEC" offset="0x14" rw="RW" size="4" access-size="4" initval="0x00000000" caption="Packet Error Check (PEC) Register">
          <bitfield name="PEC" caption="The SMBus Packet Error Check (PEC) byte." mask="0xFF"/>
        </register>
        <register name="RSHTM" offset="0x18" rw="RW" size="4" access-size="4" initval="0x0000004D" caption="Repeated Start Hold Time Register">
          <bitfield name="RSHTM" caption="This is the value of the timing requirement tHd:Sta in the I2C specification for a repeated START bit. This is used to hold      the clock until the Hold Time for the repeated Start Bit has been satisfied." mask="0xFF"/>
        </register>
        <register name="EXTND_LEN" offset="0x1C" rw="R" size="4" access-size="4" initval="0x00" caption="Extended Length Register">
          <bitfield name="EXTND_LEN" caption="Extended Length Register adds 8 MSB bits to the SMBUS Master/Slave Tx/Rx Length fields." mask="0xFF"/>
        </register>
        <register name="COMPL" offset="0x20" rw="RW" size="4" access-size="4" count="1" initval="0x00000000" caption="Completion Register">
          <bitfield name="DTEN" caption="When DTEN is asserted ('1'), Device Time-out checking is enabled. When DTEN is not asserted ('0'), Device Time-out checking is disabled." mask="0x4"/>
          <bitfield name="MCEN" caption="When MCEN is asserted ('1'), Master Cumulative Time-Out checking is enabled. When MCEN is not asserted ('0'), Master Cumulative Time-Out checking is disabled." mask="0x8"/>
          <bitfield name="SCEN" caption="When SCEN is asserted ('1'), Slave Cumulative Time-Out checking is enabled. When SCEN is not asserted ('0'), Slave Cumulative Time-Out checking is disabled." mask="0x10"/>
          <bitfield name="BIDEN" caption="When BIDEN is asserted ('1'), Bus Idle Detect Time-Out checking is enabled. When BIDEN is not asserted ('0'), Bus Idle Detect Time-Out checking is disabled." mask="0x20"/>
          <bitfield name="TIMERR" caption="The Time-out Error Detected bit (TIMERR) is asserted ('1') whenever any of the enabled time-out error detect status bits (CHDH, CHDL, SCTO, MCTO and DTO) are asserted." mask="0x40"/>
          <bitfield name="DTO" caption="DTO is the Device Time-out bit. (R/WC)" mask="0x100"/>
          <bitfield name="MCTO" caption="MCTO is the Master Cumulative Time-out bit. (R/WC)" mask="0x200"/>
          <bitfield name="SCTO" caption="SCTO is the Slave Cumulative Time-out bit(R/WC)" mask="0x400"/>
          <bitfield name="CHDL" caption="CHDL is the clock high time-out detect bit(R/WC)" mask="0x800"/>
          <bitfield name="CHDH" caption="CHDH is the bus idle time-out detect bit(R/WC)" mask="0x1000"/>
          <bitfield name="BER" caption="If this bit is 1, the BER bit in the Status register was set while either the Slave state machine or the Master state machine was not in the Idle state.(R/WC)" mask="0x2000"/>
          <bitfield name="LAB" caption="If this bit is 1, the LAB bit in the Status register was set while either the Slave state machine or the Master state machine was not in the Idle state.(R/WC)" mask="0x4000"/>
          <bitfield name="SNAKR" caption="If this bit is 1, the Slave state machine sent a NACK to the transmitting Master while the Slave was receiving data from the SMBus interface." mask="0x10000"/>
          <bitfield name="STR" caption="0: Slave has just finished the receive phase of a transaction.                 1: Slave has just finished the transmit phase of a transaction." mask="0x20000"/>
          <bitfield name="SPROT" caption="If this bit is 1, the WriteCount[7:0] counter in the Slave state machine either counted down to 0 before the Master sent a NACK signal, or the Slave received a NACK signal before the counter reached 0." mask="0x80000"/>
          <bitfield name="REP_RD" caption="If this bit is 1, the Slave State Machine stopped because it detected a Repeat Start bit, with bit[0] of the byte containing the slave address equal to 1, indicating that the Master requested a Read operation." mask="0x100000"/>
          <bitfield name="REP_WR" caption="If this bit is 1, the Slave State Machine stopped because it detected a Repeat Start bit, with bit[0] of the byte containing the slave address equal to 0, indicating that the Master requested a Write operation." mask="0x200000"/>
          <bitfield name="MNAKX" caption="If this bit is 1, the Master state machine received a NACK from the receiving Slave while the Master was transmitting data over the SMBus interface. (R/WC)" mask="0x1000000"/>
          <bitfield name="MTR" caption="0: Master has just finished the receive phase of a transaction.                 1: Master has just finished the transmit phase of a transaction." mask="0x2000000"/>
          <bitfield name="IDLE" caption="This bit is set when the I2C bus becomes idle (on the rising edge of nBB). (R/WC)" mask="0x20000000"/>
          <bitfield name="MDONE" caption="If this bit is 1, Master State machine completed operation and returned to the Idle state. It is cleared when written with a 1. Writes of a 0 have no effect. (R/WC)" mask="0x40000000"/>
          <bitfield name="SDONE" caption="If this bit is 1, Slave State machine completed operation and returned to the Idle state. It is cleared when written with a 1. Writes of a 0 have no effect.(R/WC)" mask="0x80000000"/>
        </register>
        <register name="IDLSC" offset="0x24" rw="RW" size="4" access-size="4" initval="0x01FC01ED" caption="Idle Scaling Register">
          <bitfield name="FAIR_BUS_IDL_MIN" caption="This field defines the number of ticks of the baud clock required to satisfy the fairness protocol. The default value for this field sets the idle window to 31us, which is the appropriate value for a 100 KHz bus" mask="0xFFF"/>
          <bitfield name="FAIR_IDL_DLY" caption="This field defines the number of ticks of the baud clock required to program the delay. The default value for this field sets the delay period to 32us, which is the appropriate value for a 100 KHz bus" mask="0xFFF0000"/>
        </register>
        <register name="CFG" offset="0x28" rw="RW" size="4" access-size="4" count="1" initval="0x00000000" caption="Configuration Register">
          <bitfield name="PORT_SEL" caption="The PORT SEL [3:0] bits determine which one of 16 possible bus ports apply to the active 2-wire SDAT and SCLK bus pair." mask="0xF"/>
          <bitfield name="TCEN" caption="When the Timing Check Enable bit (TCEN) is asserted ('1'), Bus Time-Outs are enabled" mask="0x10"/>
          <bitfield name="SLOW_CLK" caption="When this bit is 1, the base period for the Bus Clock Register is multiplied by 4, and thus the frequency is divided by 4." mask="0x20"/>
          <bitfield name="TEST" caption="Must be always written with 0." mask="0x40"/>
          <bitfield name="PECEN" caption="When the PEC Enable bit (PECEN) is asserted ('1'), Hardware PEC Support is enabled" mask="0x80"/>
          <bitfield name="FEN" caption="Input filtering enable. Input filtering is required by the I2C specification if external filtering is not available.      1=Input filtering is enabled; 0=Input filtering is disabled." mask="0x100"/>
          <bitfield name="RST" caption="When RESET is asserted ('1'), all logic and registers except for the RESET bit itself are initialized to the power-on default state." mask="0x200"/>
          <bitfield name="EN" caption="When ENAB (Enable) is not asserted ('0') (default), the SMB Controller Core is disabled and in the lowest power consumption state (Disabled State).                The ENAB bit must be asserted ('1') for normal operation." mask="0x400"/>
          <bitfield name="DSA" caption="0: Slave Address I2C Compatibility Mode (default). 1: SMBus Address Decode Mode" mask="0x800"/>
          <bitfield name="FAIR" caption="If this bit is 1, the MCTP Fairness protocol is in effect." mask="0x1000"/>
          <bitfield name="TEST0" caption="Must be always written with 0." mask="0x2000"/>
          <bitfield name="GC_DIS" caption="This is the General Call Disable bit.                0: the response to the General Call address as a slave is enabled                1: the response to the General Call address as a slave is disabled." mask="0x4000"/>
          <bitfield name="CFG_PROMIS" caption="This bit define the Mode of SM Bus Controler Mode of operation.         0= Normal Operation.         1=  Promiscuous Mode Enable." mask="0x8000"/>
          <bitfield name="FLUSH_SXBUF" caption="A write of a 1 to this bit forces the SMBus Slave Transmit Buffer Register to be marked empty. A write of 0 has no effect. This is a self-clearing bit." mask="0x10000"/>
          <bitfield name="FLUSH_SRBUF" caption="A write of a 1 to this bit forces the SMBus Slave Receive Buffer Register to be marked empty. A write of 0 has no effect. This is a self-clearing bit." mask="0x20000"/>
          <bitfield name="FLUSH_MXBUF" caption="A write of a 1 to this bit forces the SMBus Master Transmit Buffer Register to be marked empty. A write of 0 has no effect. This is a self-clearing bit." mask="0x40000"/>
          <bitfield name="FLUSH_MRBUF" caption="A write of a 1 to this bit forces the SMBus Master Receive Buffer Register to be marked empty. A write of 0 has no effect. This is a self-clearing bit." mask="0x80000"/>
          <bitfield name="EN_AAS" caption="0: Disable the AAS, 1: Enable the AAS Interrupt" mask="0x10000000"/>
          <bitfield name="ENIDI" caption="If this bit is 1, the Idle interrupt is enabled. If this bit is 0, the Idle interrupt is disabled." mask="0x20000000"/>
          <bitfield name="ENMI" caption="If this bit is 1, the Master Done interrupt is enabled. If this bit is 0, the Master Done interrupt is disabled." mask="0x40000000"/>
          <bitfield name="ENSI" caption="If this bit is 1, the Slave Done interrupt is enabled. If this bit is 0, the Slave Done interrupt is disabled" mask="0x80000000"/>
        </register>
        <register name="BUSCLK" offset="0x2C" rw="RW" size="4" access-size="4" initval="0x00004F4F" caption="Bus Clock Register">
          <bitfield name="LOW_PER" caption="This field defines the number of I2C Baud Clock periods that make up the low phase of the I2C/SMBus bus clock." mask="0xFF"/>
          <bitfield name="HIGH_PER" caption="This field defines the number of I2C Baud Clock periods that make up the high phase of the I2C/SMBus bus clock." mask="0xFF00"/>
        </register>
        <register name="BLKID" offset="0x30" rw="R" size="1" access-size="1" initval="0x11" caption="Block ID Register">
          <bitfield name="ID" caption="Block ID." mask="0xFF"/>
        </register>
        <register name="BLKREV" offset="0x34" rw="R" size="1" access-size="1" initval="0x00" caption="Revision Register">
          <bitfield name="REV" caption="Block Revision Number" mask="0xFF"/>
        </register>
        <register name="BBCTRL" offset="0x38" rw="RW" size="4" access-size="4" initval="0x00000060" caption="Bit-Bang Control Register">
          <bitfield name="BBEN" caption="Bit-Bang Mode Enable. 0 - Bit Bang Mode Disabled. 1 - Bit Bang Mode Enabled" mask="0x1"/>
          <bitfield name="CLDIR" caption="Bit-Bang Clock Direction. The CLDIR bit controls the direction of SCLK. 0 - Input, 1 - Output" mask="0x2"/>
          <bitfield name="DADIR" caption="Bit-Bang Data Direction. The DADIR bit controls the direction of SDAT. 0 - Input. 1 - Output" mask="0x4"/>
          <bitfield name="BBCLK" caption="Bit-Bang Clock. The BBCLK bit controls the state of SCLK when BBEN = and CLDIR = '1'" mask="0x8"/>
          <bitfield name="BBDAT" caption="Bit-Bang Data. The BBDAT bit controls the state of SDAT when BBEN = and DADIR = '1'" mask="0x10"/>
          <bitfield name="BBCLKI" caption="Bit-Bang Clock In. The BBCLKI bit always returns the state of SCLK." mask="0x20"/>
          <bitfield name="BBDATI" caption="Bit-Bang Data In. The BBDATI bit always returns the state of SDAT" mask="0x40"/>
        </register>
        <register name="TEST" offset="0x3C" rw="R" size="1" access-size="1" initval="0x05" caption="Test">
          <bitfield name="TEST" caption="This register must not be written, or undesirable results may occur." mask="0xFF"/>
        </register>
        <register name="DATATM" offset="0x40" rw="RW" size="4" access-size="4" initval="0x0C4D5006" caption="Data Timing Register">
          <bitfield name="DATA_HOLD" caption="The Data Hold [7:0] timer determines the SDAT hold time following SCLK driven low." mask="0xFF"/>
          <bitfield name="RESTART_SETUP" caption="The Restart Setup [7:0] timer determines the SDAT setup time from the rising edge of SCLK for a repeated START condition." mask="0xFF00"/>
          <bitfield name="STOP_SETUP" caption="The Stop Setup [7:0] timer determines the SDAT setup time from the rising edge of SCLK for a STOP condition." mask="0xFF0000"/>
          <bitfield name="FIRST_START_HOLD" caption="This field determines the SCL hold time following SDA driven low during the first START bit in a transfer. It is the parameter      THD:STA in the I2C Specification for an initial START bit. Repeated START hold time is determined by the Repeated START Hold Time Register." mask="0xFF000000"/>
        </register>
        <register name="TMOUTSC" offset="0x44" rw="RW" size="4" access-size="4" initval="0x4B9CC2C7" caption="Time-Out Scaling Register">
          <bitfield name="CLK_HIGH_TIM_OUT" caption="Clock High time out period = Clock High Time-Out [7:0] x Baud_Clock_Period x 2" mask="0xFF"/>
          <bitfield name="SLV_CUM_TIM_OUT" caption="Slave Cumulative Time-Out duration = Slave Cum Time-Out [7:0] x Baud_Clock_Period x 1024" mask="0xFF00"/>
          <bitfield name="MAST_CUM_TIM_OUT" caption="Master Cumulative Time-Out duration = Master Cum Time-Out [7:0] x Baud_Clock_Period x 512" mask="0xFF0000"/>
          <bitfield name="BUS_IDLE_MIN" caption="Bus Idle Minimum time = Bus Idle Min [7:0] x Baud_Clock_Period" mask="0xFF000000"/>
        </register>
        <register name="SLV_TXB" offset="0x48" rw="RW" size="4" access-size="4" initval="0x00000000" caption="SMBus Slave Transmit Buffer Register">
          <bitfield name="STXB" caption="SLAVE_TRANSMIT_BUFFER" mask="0xFF"/>
        </register>
        <register name="SLV_RXB" offset="0x4C" rw="RW" size="4" access-size="4" initval="0x00000000" caption="SMBus Slave Receive Buffer Register">
          <bitfield name="SRXB" caption="SLAVE_RECEIVE_BUFFER" mask="0xFF"/>
        </register>
        <register name="MTR_TXB" offset="0x50" rw="RW" size="4" access-size="4" initval="0x00000000" caption="SMBus Master Transmit Buffer Register">
          <bitfield name="MTXB" caption="MASTER_TRANSMIT_BUFFER" mask="0xFF"/>
        </register>
        <register name="MTR_RXB" offset="0x54" rw="RW" size="4" access-size="4" initval="0x00000000" caption="SMBus Master Receive Buffer Register">
          <bitfield name="MRXB" caption="MASTER_RECEIVE_BUFFER" mask="0xFF"/>
        </register>
        <register name="WAKE_STS" offset="0x60" rw="RW" size="4" access-size="4" initval="0x00000000" caption="WAKE STATUS Register">
          <bitfield name="START_BIT_DET" caption="This bit is set to '1' when a START bit is detected while the controller is enabled. This bit is cleared to '0' when      written with a '1'. Writes of '0' have no effect. (R/WC)" mask="0x1"/>
        </register>
        <register name="WAKE_EN" offset="0x64" rw="RW" size="4" access-size="4" initval="0x00000000" caption="WAKE ENABLE Register">
          <bitfield name="START_DET_INT_EN" caption="Enable Start Bit Detection Interrupt. The Start Bit Detection Interrupt is wake-capable.      1=Start Bit Detection Interrupt enabled; 0=Start Bit Detection Interrupt disabled" mask="0x1"/>
        </register>
        <register name="SLV_ADDR" offset="0x6C" rw="RW" size="1" access-size="1" initval="0x00" caption="This is the Slave Address Register">
          <bitfield name="SADDR" caption="This register stores value of address + LSB direction after the 8th clock of the Address Byte." mask="0xFF"/>
        </register>
        <register name="PRM_STS" offset="0x70" rw="RW" size="1" access-size="1" initval="0x00" caption="This is the Promiscuous Interrupt Register">
          <bitfield name="ADDR_INTR" caption="This is the Promiscuous Address Status interrupt and is set on the 8th clock of the I2C Address.         This bit will hold the Clock line low till this register bit is cleared. This is Write 1 to clear.         R/W1C." mask="0x1"/>
        </register>
        <register name="PRM_IEN" offset="0x74" rw="RW" size="1" access-size="1" initval="0x00" caption="This is the Promiscuous Interrupt Enable Register">
          <bitfield name="ADDR" caption="This is the Promiscuous interrupt enable register.         1= Interrupt Enable.          0= Interrupt Disabled. " mask="0x1"/>
        </register>
        <register name="PRM_CTRL" offset="0x78" rw="RW" size="1" access-size="1" initval="0x00" caption="This is the Promiscuous Control Register">
          <bitfield name="ACK_NAK" caption="This is the Promiscuous ACK / NAK response register.         1= ACK.          0= NAK. " mask="0x1"/>
        </register>
        <register name="SHDW_DATA" offset="0x7C" rw="RW" size="1" access-size="1" initval="0x00" caption="This is the I2C Shadow Data Register">
          <bitfield name="SHDW_DATA" caption="This is the I2C Shadow Data Register" mask="0xFF"/>
        </register>
      </register-group>
    </module>
    <module name="QMSPI" id="147" version="1.0" caption="The QMSPI may be used to communicate with various peripheral devices that use a Serial Peripheral Interface.">
      <register-group name="LDMA_RX" size="0x10" caption="Local DMA RX Component">
        <register name="LDMA_RXCTRL" offset="0x0" rw="RW" size="4" access-size="4" initval="0x00000000" caption="QMSPI RX Control Register">
          <bitfield name="CH_EN" caption="This enables the Local RX DMA Channel." mask="0x1"/>
          <bitfield name="RSTRT_EN" caption="This bit automatically re-enables the Local DMA Channel after completion of previous transfer." mask="0x2"/>
          <bitfield name="BUF_ADDR_EN" caption="Address re-enable will automatically re-enables the same address upon completion previous transfer." mask="0x4"/>
          <bitfield name="OVRD_LEN" caption="Override Lenght will override the length field to the QMSPI protocol FSM with the length programmed into the Local DMA." mask="0x8"/>
          <bitfield name="ACS_SZ" caption="Access Size selects the AHB Access Size." mask="0x30"/>
          <bitfield name="INC_ADDR_EN" caption="When set, the DMA Channels Start Address will increment on every access. If not set the address will not increment." mask="0x40"/>
        </register>
        <register name="LDMA_RXSTRT_ADDR" offset="0x4" rw="RW" size="4" access-size="4" initval="0x00000000" caption="QMSPI Local DMA Rx Start Address Register">
          <bitfield name="STRT_ADDR" caption="This is the Starting Address for the DMA access into the memory space (write to this address on Rx). This address is updated by the transfer size based on the Local DMA Access Size after every access." mask="0xFFFFFFFF"/>
        </register>
        <register name="LDMA_RX_LEN" offset="0x8" rw="RW" size="4" access-size="4" initval="0x00000000" caption="QMSPI Local DMA Rx Length Register">
          <bitfield name="RX_LEN" caption="This is the maximum Length of the transfer in Bytes that the DMA Channel will allow access to." mask="0xFFFFFFFF"/>
        </register>
        <register name="RSVD" offset="0xC" rw="R" size="4" access-size="4" initval="0x00000000" caption="Reserved Register"/>
      </register-group>
      <register-group name="LDMA_TX" size="0x10" caption="Local DMA TX Component">
        <register name="LDMA_TXCTRL" offset="0x0" rw="RW" size="4" access-size="4" initval="0x00000000" caption="QMSPI TX Control Register">
          <bitfield name="CH_EN" caption="This enables the Local TX DMA Channel." mask="0x1"/>
          <bitfield name="RSTRT_EN" caption="This bit automatically re-enables the Local DMA Channel after completion of previous transfer." mask="0x2"/>
          <bitfield name="BUF_ADDR_EN" caption="Address re-enable will automatically re-enables the same address upon completion previous transfer." mask="0x4"/>
          <bitfield name="OVRD_LEN" caption="Override Lenght will override the length field to the QMSPI protocol FSM with the length programmed into the Local DMA." mask="0x8"/>
          <bitfield name="ACS_SZ" caption="Access Size selects the AHB Access Size." mask="0x30"/>
          <bitfield name="INC_ADDR_EN" caption="When set, the DMA Channels Start Address will increment on every access. If not set the address will not increment." mask="0x40"/>
        </register>
        <register name="LDMA_TXSTRT_ADDR" offset="0x4" rw="RW" size="4" access-size="4" initval="0x00000000" caption="QMSPI Local DMA Tx Start Address Register">
          <bitfield name="STRT_ADDR" caption="This is the Starting Address for the DMA access into the memory space (Read from this address on Tx). This address is updated by the transfer size based on the Local DMA Access Size after every access." mask="0xFFFFFFFF"/>
        </register>
        <register name="LDMA_TX_LEN" offset="0x8" rw="RW" size="4" access-size="4" initval="0x00000000" caption="QMSPI Local DMA Tx Length Register">
          <bitfield name="TX_LEN" caption="This is the maximum Length of the transfer in Bytes that the DMA Channel will allow access to." mask="0xFFFFFFFF"/>
        </register>
        <register name="RSVD" offset="0xC" rw="R" size="4" access-size="4" initval="0x00000000" caption="Reserved Register"/>
      </register-group>
      <register-group name="QMSPI" caption="The QMSPI may be used to communicate with various peripheral devices that use a Serial Peripheral Interface.">
        <register name="MODE" offset="0x0" rw="RW" size="4" access-size="4" initval="0x00000000" caption="QMSPI Mode Register">
          <bitfield name="ACT" caption="This bit is used to activate the QMSPI block.     1=Enabled. The block is fully operational                 0=Disabled. Clocks are gated to conserve power and the output signals are set to their inactive state." mask="0x1"/>
          <bitfield name="SOFT_RESET" caption="Writing this bit with a 1 will reset the Quad SPI block. It is self-clearing." mask="0x2"/>
          <bitfield name="DMA_UNLGND_MOD" caption="When enabled the DMA is allowed to operate w/ unaligned transfer lengths." mask="0x4"/>
          <bitfield name="LDMA_RXEN" caption="This enables the Local DMA RX usage (instead of the Central DMA) when the Control register enables the DMA." mask="0x8"/>
          <bitfield name="LDMA_TXEN" caption="This enables the Local DMA TX usage (instead of the Central DMA) when the Control register enables the DMA." mask="0x10"/>
          <bitfield name="CPOL" caption="Polarity of the SPI clock line when there are no transactions in process. 1=SPI Clock starts High; 0=SPI Clock starts Low." mask="0x100"/>
          <bitfield name="CHPA_MOSI" caption="Clock phase of the Master data out. Common SPI modes require this field to be programmed with the same value as CHPA_MISO in this register.     e.g. Mode 0: CPOL=0; CHPA_MISO=0; CHPA_MOSI=0; Mode 3: CPOL=1; CHPA_MISO=1; CHPA_MOSI=1. See datasheet for alternate mode settings.                 If CPOL=1: 1=Data changes on the falling edge of the SPI clock; 0=Data changes on the rising edge of the SPI clock                 If CPOL=0: 1=Data changes on the rising edge of the SPI clock; 0=Data changes on the falling edge of the SPI clock" mask="0x200"/>
          <bitfield name="CHPA_MISO" caption="Clock phase of the Master data in. Common SPI modes require this field to be programmed with the same value as CHPA_MOSI in this register.     e.g. Mode 0: CPOL=0; CHPA_MISO=0; CHPA_MOSI=0; Mode 3: CPOL=1; CHPA_MISO=1; CHPA_MOSI=1. See datasheet for alternate mode settings.                 If CPOL=1: 1=Data are captured on the rising edge of the SPI clock; 0=Data are captured on the falling edge of the SPI clock                 If CPOL=0: 1=Data are captured on the falling edge of the SPI clock; 0=Data are captured on the rising edge of the SPI clock" mask="0x400"/>
          <bitfield name="CS" caption="This defines which Chip Select will be used by the H/W when doing a transfer." mask="0x3000"/>
          <bitfield name="CLK_DIV" caption="The SPI clock divide in number of system clocks. A value of 1 divides the master clock by 1, a value of 255 divides the master clock by 255. A value of 0 divides the master clock by 256." mask="0xFFFF0000"/>
        </register>
        <register name="CTRL" offset="0x4" rw="RW" size="4" access-size="4" initval="0x00000000" caption="QMSPI SPI Control">
          <bitfield name="TX_MODE" caption="This field sets the transmission mode. If this field is set for Dual Mode or Quad Mode then either      TX_TRANSFER_ENABLE or RX_TRANSFER_ENABLE must be 0.                  3=Reserved; 2=Quad Mode; 1=Dual Mode; 0=Single/Duplex Mode." mask="0x3"/>
          <bitfield name="TX_TRANS_EN" caption="This field bit selects the transmit function of the SPI interface.                 3=Transmit Enabled in 1 Mode. The MOSI or IO Bus will send out only 1's. The Transmit Buffer will not be used.                 2=Transmit Enabled in 0 Mode. The MOSI or IO Bus will send out only 0's. The Transmit Buffer will not be used.                 1=Transmit Enabled. Data will be fetched from the Transmit Buffer and sent out on the MOSI or IO Bus.                 0=Transmit is Disabled. Not data is sent. This will cause the MOSI be to be undriven, or the IO bus to be undriven if Receive is also disabled." mask="0xC"/>
          <bitfield name="TX_DMA_EN" caption="This bit enables DMA support for Transmit Transfer. If enabled, DMA will be requested to fill the FIFO until either     the interface reaches TRANSFER_LENGTH or the DMA sends a termination request. The size defined here must match DMA programmed access size.     1=DMA is enabled.and set to 1 Byte                 2=DMA is enabled and set to 2 Bytes                 3=DMA is enabled and set to 4 Bytes.     0=DMA is disabled. All data in the Transmit Buffer must be emptied by firmware" mask="0x30"/>
          <bitfield name="RX_TRANS_EN" caption="This bit enables the receive function of the SPI interface.                 1=Receive is enabled. Data received from the SPI Slave is stored in the Receive Buffer                 0=Receive is disabled" mask="0x40"/>
          <bitfield name="RX_DMA_EN" caption="This bit enables DMA support for Receive Transfer. If enabled, DMA will be requested to empty the FIFO until either the interface                 reaches TRANSFER_LENGTH or the DMA sends a termination request. The size defined here must match DMA programmed access size.                 1=DMA is enabled.and set to 1 Byte                 2=DMA is enabled and set to 2 Bytes                 3=DMA is enabled and set to 4 Bytes                 0=DMA is disabled. All data in the Receive Buffer must be emptied by firmware" mask="0x180"/>
          <bitfield name="CLOSE_TRANS_EN" caption="This selects what action is taken at the end of a transfer. When the transaction closes, the Chip Select de-asserts, the SPI      interface returns to IDLE and the DMA interface terminates When Description Buffers are in use this bit must be set only on the Last Buffer.     1=The transaction is terminated     0=The transaction is not terminated" mask="0x200"/>
          <bitfield name="TRANS_UNITS" caption="3=TRANSFER_LENGTH defined in units of 16-byte segments     2=TRANSFER_LENGTH defined in units of 4-byte segments     1=TRANSFER_LENGTH defined in units of bytes     0=TRANSFER_LENGTH defined in units of bits." mask="0xC00"/>
          <bitfield name="DESCR_BUFF_PTR" caption="This field selects the first buffer used if Description Buffers are enabled." mask="0xF000"/>
          <bitfield name="DESCR_BUFF_EN" caption="This enables the Description Buffers to be used.     1=Description Buffers in use. The first buffer is defined in DESCRIPTION_BUFFER_POINTER     0=Description Buffers disabled." mask="0x10000"/>
          <bitfield name="TRANS_LEN" caption="The length of the SPI transfer. The count is in bytes or bits, depending on the value of TRANSFER_LENGTH_BITS.     A value of 0 means an infinite length transfer." mask="0xFFFE0000"/>
        </register>
        <register name="EXE" offset="0x8" rw="RW" size="4" access-size="4" initval="0x00000000" caption="QMSPI Execute Register">
          <bitfield name="START" caption="Writing a 1 to this bit will start the SPI transfer. Writing a 0 to this bit has no effect. This bit is self-clearing.     This bit must not be set to 1 if the field STOP in this register is set to 1." mask="0x1"/>
          <bitfield name="STOP" caption="Writing a 1 to this bit will stop any transfer in progress at the next byte boundary. Writing a 0 to this bit has no effect.     This bit is self clearing. This bit must not be set to 1 if the field START in this register is set to 1." mask="0x2"/>
          <bitfield name="CLR_DAT_BUFF" caption="Writing a 1 to this bit will clear out the Transmit and Receive FIFOs. Any data stored in the FIFOs is discarded and all count fields are reset.     Writing a 0 to this bit has no effect. This bit is self clearing." mask="0x4"/>
        </register>
        <register name="IFCTRL" offset="0xC" rw="RW" size="4" access-size="4" initval="0x00000000" caption="QMSPI Interface Control Register">
          <bitfield name="WR_PRCT_OUT_VAL" caption="This bit sets the value on the WRITE PROTECT SPI Output Port if it is driven.                 1=WRITE PROTECT is driven to 1; 0=WRITE PROTECT is driven to 0" mask="0x1"/>
          <bitfield name="WR_PRCT_OUT_EN" caption="1=WRITE PROTECT SPI Output Port is driven                 0=WRITE PROTECT SPI Output Port is not driven" mask="0x2"/>
          <bitfield name="HLD_OUT_VAL" caption="This bit sets the value on the HOLD SPI Output Port if it is driven.                 1=HOLD is driven to 1; 0=HOLD is driven to 0." mask="0x4"/>
          <bitfield name="HLD_OUT_EN" caption="1=HOLD SPI Output Port is driven                 0=HOLD SPI Output Port is not driven." mask="0x8"/>
          <bitfield name="PD_ON_NOT_SEL" caption="1=Enable pull-down resistors on Receive pins while the SPI Chip Select signal is not asserted     0=No pull-down resistors enabled on Receive pins" mask="0x10"/>
          <bitfield name="PU_ON_NOTSEL" caption="1=Enable pull-up resistors on Receive pins while the SPI Chip Select signal is not asserted     0=No pull-up resistors enabled on Receive pins." mask="0x20"/>
          <bitfield name="PD_ON_NOTDRIVEN" caption="1=Enable pull-down resistors on Transmit pins while the pins are not driven     0=No pull-down resistors enabled ion Transmit pins." mask="0x40"/>
          <bitfield name="PU_ON_NOTDRIVEN" caption="1=Enable pull-up resistors on Transmit pins while the pins are not driven     0=No pull-up resistors enabled ion Transmit pins." mask="0x80"/>
        </register>
        <register name="STS" offset="0x10" rw="RW" size="4" access-size="4" initval="0x00002200" caption="QMSPI Status Register">
          <bitfield name="TRANS_COMPL" caption="In Manual Mode (neither DMA nor Description Buffers are enabled), this bit will be set to 1 when the transfer matches TRANSFER_LENGTH.                 If DMA Mode is enabled, this bit will be set to 1 when DMA_COMPLETE is set to 1. In Description Buffer Mode, this bit will be set to 1 only when the Last Buffer completes its transfer.     In all cases, this bit will be set to 1 if the STOP bit is set to 1 and the controller has completed the current 8 bits being copied.                 1=Transfer completed; 0=Transfer not complete." mask="0x1"/>
          <bitfield name="DMA_COMPL" caption="This field has no meaning if DMA is not enabled. This bit will be set to 1 when the DMA controller asserts the DONE signal to the SPI controller.     This occurs either when the SPI controller has closed the DMA transfer, or the DMA channel has completed its count. If both Transmit and Receive DMA transfers are      active, then this bit will only assert after both have completed. If CLOSE_TRANSFER_ENABLE is enabled, DMA_COMPLETE and TRANSFER_COMPLETE will be asserted simultaneously.     This status is not inhibited by the description buffers, so it can fire on all valid description buffers while operating in that mode.                 1=DMA completed; 0=DMA not completed." mask="0x2"/>
          <bitfield name="TX_BUFF_ERR" caption="1=Overflow error occurred (attempt to write to a full Transmit Buffer)                 0=No overflow occurred." mask="0x4"/>
          <bitfield name="RX_BUFF_ERR" caption="1=Underflow error occurred (attempt to read from an empty Receive Buffer)                 0=No underflow occurred." mask="0x8"/>
          <bitfield name="PRGM_ERR" caption="This bit if a programming error is detected.     1=Programming Error detected; 0=No programming error detected." mask="0x10"/>
          <bitfield name="LDMA_RXERR" caption="This bit is set if Local DMA Receive error is detected.     1=Local DMA RX Error detected; 0=No Local DMA RX detected." mask="0x20"/>
          <bitfield name="LDMA_TXERR" caption="This bit is set if Local DMA Transmit error is detected.     1=Local DMA TX Error detected; 0=No Local DMA TX detected." mask="0x40"/>
          <bitfield name="TX_BUFF_FULL" caption="1=The Transmit Buffer is full     0=The Transmit Buffer is not full." mask="0x100"/>
          <bitfield name="TX_BUFF_EMP" caption="1=The Transmit Buffer is empty     0=The Transmit Buffer is not empty." mask="0x200"/>
          <bitfield name="TX_BUFF_REQ" caption="This status is asserted if the Transmit Buffer reaches a high water mark established by the TRANSMIT_BUFFER_TRIGGER field.     1=TRANSMIT_BUFFER_COUNT is less than or equal to TRANSMIT_BUFFER_TRIGGER; 0=TRANSMIT_BUFFER_COUNT is greater than TRANSMIT_BUFFER_TRIGGER." mask="0x400"/>
          <bitfield name="TX_BUFF_STALL" caption="1=The SPI interface had been stalled due to a flow issue (an attempt by the interface to read from an empty Transmit Buffer)     0=No stalls occurred." mask="0x800"/>
          <bitfield name="RX_BUFF_FULL" caption="1=The Receive Buffer is full     0=The Receive Buffer is not full." mask="0x1000"/>
          <bitfield name="RX_BUFF_EMP" caption="1=The Receive Buffer is empty     0=The Receive Buffer is not empty." mask="0x2000"/>
          <bitfield name="RX_BUFF_REQ" caption="This status is asserted if the Receive Buffer reaches a high water mark established by the RECEIVE_BUFFER_TRIGGER field.                 1=RECEIVE_BUFFER_COUNT is greater than or equal to RECEIVE_BUFFER_TRIGGER                 0=RECEIVE_BUFFER_COUNT is less than RECEIVE_BUFFER_TRIGGER." mask="0x4000"/>
          <bitfield name="RX_BUFF_STALL" caption="1=The SPI interface had been stalled due to a flow issue (an attempt by the interface to write to a full Receive Buffer)     0=No stalls occurred." mask="0x8000"/>
          <bitfield name="TRANS_ACTIV" caption="1=A transfer is currently executing     0=No transfer currently in progress." mask="0x10000"/>
          <bitfield name="CUR_DESCR_BUF" caption="This field shows the Description Buffer currently active. This field has no meaning if Description Buffers are not enabled." mask="0xF000000"/>
        </register>
        <register name="BUF_CNT_STS" offset="0x14" rw="RW" size="4" access-size="4" initval="0x00000000" caption="QMSPI Buffer Count Status Register">
          <bitfield name="TX_BUFF_CNT" caption="This is a count of the number of bytes currently valid in the Transmit Buffer." mask="0xFFFF"/>
          <bitfield name="RX_BUFF_CNT" caption="This is a count of the number of bytes currently valid in the Receive Buffer." mask="0xFFFF0000"/>
        </register>
        <register name="IEN" offset="0x18" rw="RW" size="4" access-size="4" initval="0x00002000" caption="QMSPI Interrupt Enable Register">
          <bitfield name="TRANS_COMPL_EN" caption="1=Enable an interrupt if TRANSFER_COMPLETE is asserted     0=Disable the interrupt." mask="0x1"/>
          <bitfield name="DMA_COMPL_EN" caption="1=Enable an interrupt if DMA_COMPLETE is asserted     0=Disable the interrupt." mask="0x2"/>
          <bitfield name="TX_BUF_ERR_EN" caption="1=Enable an interrupt if TRANSMIT_BUFFER_ERROR is asserted     0=Disable the interrupt." mask="0x4"/>
          <bitfield name="RX_BUF_ERR_EN" caption="1=Enable an interrupt if RECEIVE_BUFFER_ERROR is asserted     0=Disable the interrupt." mask="0x8"/>
          <bitfield name="PRGM_ERR_EN" caption="1=Enable an interrupt if PROGRAMMING_ERROR is asserted     0=Disable the interrupt." mask="0x10"/>
          <bitfield name="LDMA_RXERRIE" caption="1=Enable an interrupt if Local DMA RX Error is asserted     0=Disable the interrupt." mask="0x20"/>
          <bitfield name="LDMA_TXERRIE" caption="1=Enable an interrupt if Local DMA TX Error is asserted     0=Disable the interrupt." mask="0x40"/>
          <bitfield name="TX_BUF_FULL_EN" caption="1=Enable an interrupt if TRANSMIT_BUFFER_FULL is asserted     0=Disable the interrupt." mask="0x100"/>
          <bitfield name="TX_BUF_EMPTY_EN" caption="1=Enable an interrupt if TRANSMIT_BUFFER_EMPTY is asserted     0=Disable the interrupt." mask="0x200"/>
          <bitfield name="TX_BUF_REQ_EN" caption="1=Enable an interrupt if TRANSMIT_BUFFER_REQUEST is asserted     0=Disable the interrupt." mask="0x400"/>
          <bitfield name="RX_BUF_FUL_EN" caption="1=Enable an interrupt if RECEIVE_BUFFER_FULL is asserted     0=Disable the interrupt." mask="0x1000"/>
          <bitfield name="RX_BUF_EMPTY_EN" caption="1=Enable an interrupt if RECEIVE_BUFFER_EMPTY is asserted     0=Disable the interrupt." mask="0x2000"/>
          <bitfield name="RX_BUF_REQ_EN" caption="1=Enable an interrupt if RECEIVE_BUFFER_REQUEST is asserted     0=Disable the interrupt." mask="0x4000"/>
        </register>
        <register name="BUF_CNT_TRIG" offset="0x1C" rw="RW" size="4" access-size="4" initval="0x00000000" caption="QMSPI Buffer Count Trigger Register">
          <bitfield name="TX_BUF_TRIG" caption="An interrupt is triggered if the TRANSMIT_BUFFER_COUNT field is less than or equal to this value. A value of 0 disables the interrupt." mask="0xFFFF"/>
          <bitfield name="RX_BUF_TRIG" caption="An interrupt is triggered if the RECEIVE_BUFFER_COUNT field is greater than or equal to this value. A value of 0 disables the interrupt." mask="0xFFFF0000"/>
        </register>
        <register name="TX_FIFO" offset="0x20" rw="RW" size="4" access-size="4" count="1" initval="0x00000000" caption="QMSPI Transmit Buffer Register">
          <bitfield name="TX_BUF" caption="Writes to this register store data to be transmitted from the SPI Master to the external SPI Slave.     Writes to this block will be written to the Transmit FIFO. A 1 Byte write fills 1 byte of the FIFO. A Word write fills 2 Bytes and a Doubleword write fills 4 bytes.     The data must always be aligned to the bottom most byte (so 1 byte write is on bits [7:0] and Word write is on [15:0]).     An overflow condition, TRANSMIT_BUFFER_ERROR, if a write to a full FIFO occurs. Write accesses to this register increment the TRANSMIT_BUFFER_COUNT field." mask="0xFFFFFFFF"/>
        </register>
        <register name="RX_FIFO" offset="0x24" rw="RW" size="4" access-size="4" count="1" initval="0x00000000" caption="QMSPI Receive Buffer Register">
          <bitfield name="RX_BUF" caption="Buffer that stores data from the external SPI Slave device to the SPI Master (this block), which is received over MISO or IO.     Reads from this register will empty the Rx FIFO. A 1 Byte read will have valid data on bits [7:0] and a Word read will have data on bits [15:0].     It is possible to request more data than the FIFO has (underflow condition), but this will cause an error (Rx Buffer Error).     Read accesses to this register decrement the RECEIVE_BUFFER_COUNT field." mask="0xFFFFFFFF"/>
        </register>
        <register name="CSTM" offset="0x28" rw="RW" size="4" access-size="4" initval="0x06060406" caption="QMSPI Chip Select Timing Register">
          <bitfield name="DLY_CS_ON_TO_CLOCK_START" caption="This selects the number of system clock cycles between CS assertion to the start of the SPI Clock." mask="0xF"/>
          <bitfield name="DLY_CLK_STOP_TO_CS_OFF" caption="This selects the number of system clock cycles between the last clock edge and the deassertion of CS." mask="0xF00"/>
          <bitfield name="DLY_LAST_DATA_HOLD" caption="This selects the number of system clock cycles between CS deassertion to the data ports for WP and HOLD     switching from input to output." mask="0xF0000"/>
          <bitfield name="DLY_CS_OFF_TO_CS_ON" caption="This selects the number of system clock cycles between CS deassertion to CS assertion. This is the minimum            pulse width of CS deassertion." mask="0xFF000000"/>
        </register>
        <register name="DESCR" offset="0x30" rw="RW" size="4" access-size="4" count="16" initval="0x00000000" caption="QMSPI Description Buffer 0 Register">
          <bitfield name="INFACE_MOD" caption="This field sets the transmission mode. If this field is set for Dual Mode or Quad Mode then either TX_TRANSFER_ENABLE or RX_TRANSFER_ENABLE must be 0.     3=Reserved; 2=Quad Mode; 1=Dual Mode; 0=Single/Duplex Mode." mask="0x3"/>
          <bitfield name="TX_TRANS_EN" caption="This field bit selects the transmit function of the SPI interface.     3=Transmit Enabled in 1 Mode. The MOSI or IO Bus will send out only 1's. The Transmit Buffer will not be used     2=Transmit Enabled in 0 Mode. The MOSI or IO Bus will send out only 0's. The Transmit Buffer will not be used.     1=Transmit Enabled. Data will be fetched from the Transmit Buffer and sent out on the MOSI or IO Bus.     0=Transmit is Disabled. No data is sent. This will cause the MOSI be to be undriven, or the IO bus to be undriven if Receive is also disabled." mask="0xC"/>
          <bitfield name="TX_DMA_EN" caption="This bit enables DMA support for Transmit Transfer. If enabled, DMA will be requested to fill the FIFO until either the interface     reaches TRANSFER_LENGTH or the DMA sends a termination request. The size defined here must match DMA programmed access size.     1=DMA is enabled.and set to 1 Byte      2=DMA is enabled and set to 2 Bytes      3=DMA is enabled and set to 4 Bytes     0=DMA is disabled. All data in the Transmit Buffer must be emptied by firmware." mask="0x30"/>
          <bitfield name="RX_TRANS_EN" caption="This bit enables the receive function of the SPI interface.     1=Receive is enabled. Data received from the SPI Slave is stored in the Receive Buffer; 0=Receive is disabled." mask="0x40"/>
          <bitfield name="RX_DMA_EN" caption="This bit enables DMA support for Receive Transfer. If enabled, DMA will be requested to empty the FIFO until either the interface reaches TRANSFER_LENGTH or the DMA sends a termination request. The size defined here must match DMA programmed access size.     1=DMA is enabled.and set to 1 Byte     2=DMA is enabled and set to 2 Bytes     3=DMA is enabled and set to 4 Bytes     0=DMA is disabled. All data in the Receive Buffer must be emptied by firmware." mask="0x180"/>
          <bitfield name="CLOSE_TRANS_EN" caption="This selects what action is taken at the end of a transfer. This bit must be set only on the Last Buffer.     1=The transfer is terminated. The Chip Select de-asserts, the SPI interface returns to IDLE and the DMA interface completes the transfer.     0=The transfer is not closed. Chip Select remains asserted and the DMA interface and the SPI interface remain active" mask="0x200"/>
          <bitfield name="TRANS_LEN" caption="3=TRANSFER_LENGTH defined in units of 16-byte segments,            2=TRANSFER_LENGTH defined in units of 4-byte segments     1=TRANSFER_LENGTH defined in units of bytes,     0=TRANSFER_LENGTH defined in units of bits" mask="0xC00"/>
          <bitfield name="DESCR_BUF_NXT_PTR" caption="This defines the next buffer to be used if Description Buffers are enabled and this is not the last buffer. This can point to the current buffer, creating an infinite loop." mask="0xF000"/>
          <bitfield name="DESCR_BUF_LAST" caption="Last Descriptor. 1=Last Description Buffer in the chain. 0=This is not the last buffer." mask="0x10000"/>
          <bitfield name="TX_LEN" caption="The length of the SPI transfer. The count is in bytes or bits, depending on the value of TRANSFER_LENGTH_BITS. A value of 0 means an infinite length transfer." mask="0xFFFE0000"/>
        </register>
        <register name="ALIAS_CTRL" offset="0xB0" rw="W" size="4" access-size="4" initval="0x00000000" caption="QMSPI Alias Control Register">
          <bitfield name="ALS_EXEC_STRT" caption="Alias for the QMSPI Execution:Start field." mask="0x1"/>
          <bitfield name="CLS_ALTMODE_EN" caption="Enable the CS1 Clock Divide to be active if CS1 is the interface in use." mask="0x2"/>
          <bitfield name="ALS_WR_TXBUF" caption="Alias that triggers a write to the Tx Buffer of 1 Byte using data from Alias Tx Buffer Data in this register." mask="0x4"/>
          <bitfield name="ALS_WRDBUF_XFRLEN" caption="Alias that triggers a write to the Description Buffer pointed to by Alias Description Buffer Select in this register to modify the Transfer Length field with the value of Alias Description Buffer Transfer Length in this register." mask="0x8"/>
          <bitfield name="ALS_MOD_CS" caption="Alias for the QMSPI Mode:Chip Select field." mask="0x30"/>
          <bitfield name="ALS_LDMA_INCR_ADD" caption="Alias that overrides the value in all QMSPI Local DMA * [Tx/Rx] Control:Increment Address Enable fields w/ this value." mask="0x40"/>
          <bitfield name="ALS_CTRL_DBUF_PTR" caption="Alias for the QMSPI Control:Description Buffer Pointer field." mask="0xF00"/>
          <bitfield name="ALS_DBUF_SEL" caption="Which Description Buffer will be modified by a write if Alias Write Description Buffer Transfer Length is set." mask="0xF000"/>
          <bitfield name="ALS_DBUF_XFR_LEN" caption="The value of the data written to the Description Buffers Transfer Length field, if the write is enabled." mask="0xFF0000"/>
          <bitfield name="ALS_TXDBUF_DATA" caption="The Byte of data written into the Tx Buffer if the write is enabled." mask="0xFF000000"/>
        </register>
        <register name="MODE_ALT1" offset="0xC0" rw="RW" size="4" access-size="4" initval="0x00000000" caption="QMSPI Mode Alternate 1 Register">
          <bitfield name="CS1_ALTMOD_EN" caption="Enable the CS1 Clock Divide to be active if CS1 is the interface in use." mask="0x1"/>
          <bitfield name="CS1_ALTCLK_DIV" caption="The SPI clock divide in number of system clocks when CS1 is in use and CS1 Alt Mode Enable is set." mask="0xFFFF0000"/>
        </register>
        <register name="TAPS" offset="0xD0" rw="RW" size="4" access-size="4" initval="0x00000000" caption="QMSPI TAPs Register">
          <bitfield name="SCK_TAP" caption="This will select the tap point for the feed-back SCK." mask="0xFF"/>
          <bitfield name="CTRL_TAP" caption="This will select the tap point for signals that go from the System Domain." mask="0xFF00"/>
        </register>
        <register name="TAP_ADJ" offset="0xD4" rw="RW" size="4" access-size="4" initval="0x00000000" caption="QMSPI TAP Control Register">
          <bitfield name="SCK_ADJ" caption="This is a signed value that will be added to the Select SCK Tap to come up with the final value for the delay." mask="0xFF"/>
          <bitfield name="CTRL_ADJ" caption="This is a signed value that will be added to the Select Control Tap to come up with the final value for the delay." mask="0xFF00"/>
        </register>
        <register name="TAP_CTRL" offset="0xD8" rw="RW" size="4" access-size="4" initval="0x00000000" caption="QMSPI TAP Adjustment Register">
          <bitfield name="AUTO_MOD" caption="This enables the automatic H/W trim of the Tap." mask="0x3"/>
          <bitfield name="CTRL" caption="This is a signed value that will be added to the Select Control Tap to come up with the final value for the delay." mask="0x4"/>
          <bitfield name="FW_GO" caption="This will force the auto-trim H/W to run and find a new trim value." mask="0x100"/>
          <bitfield name="AUTO_MULT" caption="This will multiply the target delay value the Auto-trim H/W will search for." mask="0x70000"/>
        </register>
        <register name="DESC_LDMA_TXEN" offset="0x104" rw="RW" size="4" access-size="4" initval="0x00000000" caption="QMSPI Descriptor Local DMA Tx Enable Register">
          <bitfield name="DESC_LDMA_TXEN" caption="This enables the Local TX DMA usage (instead of the Central DMA) when the Descriptor Buffer register enables the DMA." mask="0xFFFF"/>
        </register>
        <register name="DESC_LDMA_RXEN" offset="0x100" rw="RW" size="4" access-size="4" initval="0x00000000" caption="QMSPI Descriptor Local DMA Rx Enable Register">
          <bitfield name="DESC_LDMA_RXEN" caption="This enables the Local RX DMA usage (instead of the Central DMA) when the Descriptor Buffer register enables the DMA." mask="0xFFFF"/>
        </register>
        <register-group name="LDMA_RX" name-in-module="LDMA_RX" offset="0x110" size="0x10" count="3"/>
        <register-group name="LDMA_TX" name-in-module="LDMA_TX" offset="0x140" size="0x10" count="3"/>
      </register-group>
    </module>
    <module name="TFDP" id="68" version="1.0" caption="The TFDP serially transmits EC-originated diagnostic vectors to an external debug trace system.">
      <register-group name="TFDP" caption="The TFDP serially transmits EC-originated diagnostic vectors to an external debug trace system.">
        <register name="MSDATA" offset="0x0" rw="RW" size="1" access-size="1" initval="0x00" caption="Debug data to be shifted out on the TFDP Debug port. While data is being shifted out, the Host Interface will 'hold-off' additional writes to the data register until the transfer is complete.">
        </register>
        <register name="CTRL" offset="0x4" rw="RW" size="1" access-size="1" initval="0x00" caption="Debug Control Register">
          <bitfield name="EN" caption="Enable. 1=Clock enabled, 0=Clock is disabled (Default)" mask="0x1"/>
          <bitfield name="EDGE_SEL" caption="1= Data is shifted out on the falling edge of the debug clock, 0= Data is shifted out on the rising edge of the debug clock (Default)" mask="0x2"/>
          <bitfield name="DIVSEL" caption="Clock Divider Select." mask="0xC"/>
          <bitfield name="IP_DLY" caption="Inter-packet Delay. The delay is in terms of TFDP Debug output clocks." mask="0x70"/>
        </register>
      </register-group>
    </module>
    <module name="VTR_REG_BANK" id="213" version="1.0" caption="The VBAT Register Bank block is a block implemented for miscellaneous battery-backed registers.">
      <register-group name="VTR_REG_BANK" caption="The VBAT Register Bank block is a block implemented for miscellaneous battery-backed registers.">
        <register name="PFRS" offset="0x0" rw="RW" size="4" access-size="4" initval="0x80" caption="The Power-Fail and Reset Status Register collects and retains the VBAT RST and WDT event status when VCC1 is unpowered.">
          <bitfield name="DET_32KHZ" caption="Detect 32KHz Clock Input (R/WC)" mask="0x1"/>
          <bitfield name="SFT_RST" caption="This bit is set to '1b' if a was triggered by an assertion of the SOFT_SYS_RESET bit in the System Reset Register.      This bit is cleared to '0b' when written with a '1b'; writes of a '0b' have no effect. (R/WC)" mask="0x4"/>
          <bitfield name="RSTI" caption="This bit is set to '1b' if a RESET_SYS was triggered by a low signal on the RESETI# input pin. This bit is      cleared to '0b' when written with a '1b'; writes of a '0b' have no effect. (R/WC)" mask="0x10"/>
          <bitfield name="WDT_EVT" caption="This bit is set to '1b' if a RESET_SYS was triggered by a Watchdog Timer event. This bit is cleared to '0b' when      written with a '1b'; writes of a '0b' have no effect. (R/WC)" mask="0x20"/>
          <bitfield name="SYS_RSTREQ" caption="This bit is set to '1b' if a RESET_SYS was triggered by an ARM SYSRESETREQ event. This bit is cleared to '0b' when      written with a '1b'; writes of a '0b' have no effect. (R/WC)" mask="0x40"/>
        </register>
      </register-group>
    </module>
    <module name="EC_REG_BANK" id="95" version="1.0" caption="This block is designed to be accessed internally by the EC via the register interface.">
      <register-group name="EC_REG_BANK" caption="This block is designed to be accessed internally by the EC via the register interface.">
        <register name="SRAM_CNFG" offset="0x0" rw="RW" size="1" access-size="1" initval="0x00" caption="SRAM Configuration Register">
          <bitfield name="SRAM_SIZE" caption="SRAM Configuration Register:     0: 384KB         (352k Code, 32k Data)    1: 320kB         (288k Code, 32k Data)    2: 256kB         (224k Code, 32k Data)    3: Illegal 256kB (224k Code, 32k Data)" mask="0x3"/>
        </register>
        <register name="AHB_ERR_ADDR" offset="0x4" rw="RW" size="4" access-size="4" initval="0x00000000" caption="AHB Error Address [0:0]">
        </register>
        <register name="AHB_ERR_CTRL" offset="0x14" rw="RW" size="1" access-size="1" initval="0x00" caption="AHB Error Control [0:0] AHB_ERROR_DISABLE, 0: EC memory exceptions are enabled. 1: EC memory exceptions are disabled.">
        </register>
        <register name="INTR_CTRL" offset="0x18" rw="RW" size="4" access-size="4" initval="0x00000001" caption="Interrupt Control [0:0] NVIC_EN (NVIC_EN) This bit enables Alternate NVIC IRQ's Vectors. The Alternate NVIC Vectors provides each interrupt event with a dedicated (direct) NVIC vector.            0 = Alternate NVIC vectors disabled, 1= Alternate NVIC vectors enabled">
        </register>
        <register name="ETM_CTRL" offset="0x1C" rw="RW" size="4" access-size="4" initval="0x00000000" caption="ETM TRACE Enable [0:0] TRACE_EN (TRACE_EN) This bit enables the ARM TRACE debug port (ETM/ITM). The Trace Debug Interface pins are forced to the TRACE functions.            0 = ARM TRACE port disabled, 1= ARM TRACE port enabled">
        </register>
        <register name="DEBUG_CTRL" offset="0x20" rw="RW" size="4" access-size="4" initval="0x00000080" caption="Debug Enable Register">
          <bitfield name="JTAG_EN" caption="DEBUG_EN (JTAG_EN) This bit enables the JTAG/SWD debug port.               0= JTAG/SWD port disabled. JTAG/SWD cannot be enabled (i.e., the TRST# pin is ignored and the JTAG signals remain in their non-JTAG state)               1= JTAG/SWD port enabled. A high on TRST# enables JTAG or SWD, as determined by SWD_EN." mask="0x1"/>
          <bitfield name="DBG_PIN_CFG" caption="This field determines which pins are affected by the TRST# debug enable pin.      3=Reserved      2=The pins associated with the JTAG TCK and TMS switch to the debug interface when TRST# is de-asserted high. The pins      associated with TDI and TDO remain controlled by the associated GPIO. This setting should be used when the ARM Serial      Wire Debug (SWD) is required for debugging and the Serial Wire Viewer is not required      1=The pins associated with the JTAG TCK, TMS and TDO switch to the debug interface when TRST# is de-asserted high. The pin      associated with TDI remains controlled by the associated GPIO. This setting should be used when the ARM Serial Wire Debug      (SWD) and Serial Wire Viewer (SWV) are both required for debugging      0=All four pins associated with JTAG (TCK, TMS, TDI and TDO) switch to the debug interface when TRST# is de-asserted high.      This setting should be used when the JTAG TAP controller is required for debugging." mask="0x6" values="EC_REG_BANK_DEBUG_CTRL__PIN_CFG"/>
          <bitfield name="JTAG_PU_EN" caption="If this bit is set to '1b' internal pull-up resistors are automatically enabled on the appropriate debugging port      wires whenever the debug port is enabled (the DEBUG_EN bit in this register is '1b' and the JTAG_RST# pin is high). The setting      of DEBUG_PIN_CFG determines which pins have pull-ups enabled when the debug port is enabled." mask="0x8"/>
          <bitfield name="BS_EN" caption="This bit sets the boundary scan tap controller accessibility from JTAG port.             1= Boundary scan tap controller accessibile through JTAG Port.             0= Boundary scan tap controller not accessibile through JTAG Port." mask="0x10"/>
        </register>
        <register name="OTP_LOCK" offset="0x24" rw="RW" size="4" access-size="4" initval="0x00000000" caption="Lock Register">
          <bitfield name="TEST" caption="Test" mask="0x1"/>
          <bitfield name="VBAT_RAM_LOCK" caption="VBAT RAM LOCK bit.         0 = Not Locked.         1 = Locked." mask="0x2"/>
          <bitfield name="VBAT_REG_LOCK" caption="VBAT REG LOCK.         0 = Not Locked.         1 = Locked." mask="0x4"/>
          <bitfield name="SCUR_MBX_LOCK" caption="Secure Mailbox LOCK.         0 = Not Locked.         1 = Write Locked." mask="0x100"/>
        </register>
        <register name="WDT_CNT" offset="0x28" rw="RW" size="4" access-size="4" initval="0x00000000" caption="WDT Event Count [3:0] WDT_COUNT (WDT_COUNT) These EC R/W bits are cleared to 0 on VCC1 POR, but not on a WDT.            Note: This field is written by Boot ROM firmware to indicate the number of times a WDT fired before loading a good EC code image.">
        </register>
        <register name="AESH_BSWAP_CTRL" offset="0x2C" rw="RW" size="4" access-size="4" initval="0x00000000" caption="AES HASH Byte Swap Control Register.">
          <bitfield name="IP_BYTE_SWAP_EN" caption="Used to enable byte swap on a DWORD during AHB read from AES / HASH block: 1=Enable; 0=Disable." mask="0x1"/>
          <bitfield name="OP_BYTE_SWAP_EN" caption="Used to enable byte swap on a DWORD during AHB write from AES / HASH block: 1=Enable; 0=Disable." mask="0x2"/>
          <bitfield name="IP_BLK_SWAP_EN" caption="Used to enable word swap on a DWORD during AHB read from AES / HASH block 0=Disable." mask="0x1C" values="EC_REG_BANK_AESH_BSWAP_CTRL__IP_BLK_SWAP_EN"/>
          <bitfield name="OP_BLK_SWAP_EN" caption="Used to enable word swap on a DWORD during AHB write from AES / HASH block 0=Disable." mask="0xE0" values="EC_REG_BANK_AESH_BSWAP_CTRL__OP_BLK_SWAP_EN"/>
        </register>
        <register name="GPIO_BANK_PWR" offset="0x64" rw="RW" size="4" access-size="4" initval="0x00000000" caption="GPIO Bank Power Register">
          <bitfield name="TEST" caption="This bit must be programmed to 0h for proper operation of the device." mask="0x1"/>
          <bitfield name="VTR_LVL2" caption="Voltage value on VTR2. This bit is set by Firmware after a VTR Power On Reset.         It must be set by software if the VTR power rail is not active when RESET_SYS is de-asserted.         Write access is determined by bit 7.      1=VTR2 is powered by 1.8V      0=VTR2 is powered by 3.3V." mask="0x2"/>
          <bitfield name="GPIO_BANK_PWR_LOCK" caption="GPIO Bank Power Lock. 0: VTR_LEVEL bits[2:0] and GPIO Bank Power Lock bit are R/W      1 = VTR_LEVEL bits[2:0] and GPIO Bank Power Lock bit are Read Only." mask="0x80"/>
        </register>
        <register name="SRAM_BNK_SWP" offset="0x70" rw="RW" size="4" access-size="4" initval="0x00000000" caption="Security Monitor SRAM Bank Swap Register">
          <bitfield name="BNK_SWP" caption="SRAM bank Swap Register" mask="0x1"/>
        </register>
        <register name="VW_SRC_CNGF" offset="0x90" rw="RW" size="4" access-size="4" initval="0x00000007" caption="Virtual Wire Source Configuration Register">
          <bitfield name="VW_SRC" caption="VWIRE_SOURCE [2], VWIRE_SOURCE [1], VWIRE_SOURCE [0]" mask="0x7"/>
        </register>
        <register name="SPIMON_IB_CNGF" offset="0xC4" rw="RW" size="4" access-size="4" initval="0x00000000" caption="SPI Monitor's Inter-Bus Configuration Register">
          <bitfield name="MON0" caption="QSPI0 Monitor 0. 1 = Route QMSPI0 Traffic to Monitor. 0 = Route Host AP0 Traffic to Monitor" mask="0x100"/>
          <bitfield name="MON1" caption="QSPI1 Monitor 1. 1 = Route QMSPI1 Traffic to Monitor. 0 = Route Host AP1 Traffic to Monitor" mask="0x200"/>
          <bitfield name="IDL" caption="Lock bit for IDE" mask="0x1000"/>
          <bitfield name="IDV" caption="Delay Value" mask="0x1F00000"/>
          <bitfield name="IDU" caption="Delay Units" mask="0x6000000"/>
          <bitfield name="IDE" caption="Inter-Bus Intervention Enable" mask="0x8000000"/>
        </register>
        <register name="PD_MON_CTRL" offset="0x240" rw="RW" size="4" access-size="4" initval="0x00000000" caption="PAD Monitor Control Register">
          <bitfield name="CTRL_VTR1" caption="Pad Monitor Control VTR1. 0=OFF, 1=1ms delay, 2=10ms delay, 3=100ms delay" mask="0x3"/>
          <bitfield name="OVRD_VTR1" caption="PAD Monitor Override VTR1 0=Normal Operation 1=Override input_disable and pad_protect_n" mask="0x10"/>
          <bitfield name="VTR1_INPT_DIS" caption="PAD Monitor Override Input Disable VTR1. 0=Normal Operation 1=input_disable" mask="0x20"/>
          <bitfield name="VTR1_PROTECN" caption="PAD Monitor Override Protect N VTR1." mask="0x40"/>
          <bitfield name="CTRL_VTR2" caption="Pad Monitor Control VTR2. 0=OFF, 1=1ms delay, 2=10ms delay, 3=100ms delay" mask="0x300"/>
          <bitfield name="OVRD_VTR2" caption="PAD Monitor Override VTR2 0=Normal Operation 1=Override input_disable and pad_protect_n" mask="0x1000"/>
          <bitfield name="VTR2_INPT_DIS" caption="PAD Monitor Override Input Disable VTR2. 0=Normal Operation 1=input_disable" mask="0x2000"/>
          <bitfield name="VTR2_PROTECN" caption="PAD Monitor Override Protect N VTR2." mask="0x4000"/>
        </register>
        <register name="PD_MON_INT_EN" offset="0x244" rw="RW" size="4" access-size="4" initval="0x00000000" caption="PAD Monitor Interrupt Enable Register">
          <bitfield name="VTR1_PD_INTEN" caption="Pad Monitor VTR1 Power Down Interrupt Enable." mask="0x1"/>
          <bitfield name="VTR1_PU_INTEN" caption="Pad Monitor VTR1 Power Up Interrupt Enable" mask="0x2"/>
          <bitfield name="VTR2_PD_INTEN" caption="Pad Monitor VTR2 Power Down Interrupt Enable." mask="0x100"/>
          <bitfield name="VTR2_PU_INTEN" caption="Pad Monitor VTR2 Power Up Interrupt Enable" mask="0x200"/>
        </register>
        <register name="PD_MON_STS" offset="0x248" rw="RW" size="4" access-size="4" initval="0x00000000" caption="PAD Monitor Status Register">
          <bitfield name="VTR1_PD_STS" caption="Pad Monitor VTR1 Power Down Status" mask="0x1"/>
          <bitfield name="VTR1_PU_STS" caption="Pad Monitor VTR1 Power Up Status" mask="0x2"/>
          <bitfield name="VTR2_PD_STS" caption="Pad Monitor VTR2 Power Down Status" mask="0x100"/>
          <bitfield name="VTR2_PU_STS" caption="Pad Monitor VTR2 Power Up Status" mask="0x200"/>
        </register>
      </register-group>
      <value-group caption="PIN Config" name="EC_REG_BANK_DEBUG_CTRL__PIN_CFG">
        <value caption="2=The pins associated with the JTAG TCK and TMS switch to the debug interface when TRST# is de-asserted high. The pins           associated with TDI and TDO remain controlled by the associated GPIO. This setting should be used when the ARM Serial          Wire Debug (SWD) is required for debugging and the Serial Wire Viewer is not required " name="JTAG_TCK_TMS" value="0x2"/>
        <value caption="1=The pins associated with the JTAG TCK, TMS and TDO switch to the debug interface when TRST# is de-asserted high. The pin           associated with TDI remains controlled by the associated GPIO. This setting should be used when the ARM Serial Wire Debug             (SWD) and Serial Wire Viewer (SWV) are both required for debugging" name="JTAG_TCK_TMS_TDO" value="0x1"/>
        <value caption="0=All four pins associated with JTAG (TCK, TMS, TDI and TDO) switch to the debug interface when TRST# is de-asserted high.         This setting should be used when the JTAG TAP controller is required for debugging." name="JTAG_TCK_TMS_TDO_TDI" value="0x0"/>
      </value-group>
      <value-group caption="Counter Event Select" name="EC_REG_BANK_SECMON_CNTR_CTRL1__CNT_EVNT_SEL">
        <value caption="Channel0 CS Assertion Events " name="CH0_CS_ASRT" value="0x0"/>
        <value caption="Channel0 Opcode Events " name="CH0_OPCD_EVNT" value="0x1"/>
        <value caption="Channel0 Opcode Variation Events " name="CH0_OPCD_VRTN_EVNT" value="0x2"/>
        <value caption="Channel0 Match Monitor Data Mismatch Violation Events " name="CH0_DATMSMATH" value="0x3"/>
        <value caption="Channel0 RTMON + OOB Violation Events " name="CH0_RTMONOOBVLT" value="0x4"/>
        <value caption="Channel0 OOB Violation Events" name="CH0_OOBVLT_EVNT" value="0x5"/>
        <value caption="Channel1 CS Assertion Events " name="CH1_CS_ASRT" value="0x8"/>
        <value caption="Channel1 Opcode Events " name="CH1_OPCD_EVNT" value="0x9"/>
        <value caption="Channel1 Opcode Variation Events " name="CH1_OPCD_VRTN_EVNT" value="0xA"/>
        <value caption="Channel1 Match Monitor Data Mismatch Violation Events " name="CH1_DATMSMATH" value="0xB"/>
        <value caption="Channel1 RTMON + OOB Violation Events " name="CH1_RTMONOOBVLT" value="0xC"/>
        <value caption="Channel1 OOB Violation Events" name="CH1_OOBVLT_EVNT" value="0xD"/>
      </value-group>
      <value-group caption="" name="EC_REG_BANK_AESH_BSWAP_CTRL__IP_BLK_SWAP_EN">
        <value caption="4=Swap 32-bit doublewords in 128-byte blocks " name="SWAP_128_BYTE_BLOCK" value="0x4"/>
        <value caption="3=Swap doublewords in 64-byte blocks. Useful for SHA-256. Bus references issued in the order 0x3C, 0x38, 0x34, 0x30, 0x2C,          0x28, 0x24, 0x20, 0x1C, 0x18, 0x14, 0x10, 0xC, 0x8, 0x4, 0x0,..." name="SWAP_64_BYTE_BLOCK" value="0x3"/>
        <value caption="2=Swap doublewords in 16-byte blocks. Useful for AES. Bus references issued in the order 0xC, 0x8, 0x4, 0x0, 0x1C, 0x18,..." name="SWAP_16_BYTE_BLOCK" value="0x2"/>
        <value caption="1=Swap doublewords in 8-byte blocks. Useful for SHA-512, which works on 64-bit words. Bus references issued in the order 0x4,       0x0, 0xC, 0x8, ..." name="SWAP_8_BYTE_BLOCK" value="0x1"/>
        <value caption="0=Disable." name="DIS" value="0x0"/>
      </value-group>
      <value-group caption="" name="EC_REG_BANK_AESH_BSWAP_CTRL__OP_BLK_SWAP_EN">
        <value caption="4=Swap 32-bit doublewords in 128-byte blocks " name="SWAP_128_BYTE_BLOCK" value="0x4"/>
        <value caption="3=Swap doublewords in 64-byte blocks. Useful for SHA-256. Bus references issued in the order 0x3C, 0x38, 0x34, 0x30, 0x2C,          0x28, 0x24, 0x20, 0x1C, 0x18, 0x14, 0x10, 0xC, 0x8, 0x4, 0x0,..." name="SWAP_64_BYTE_BLOCK" value="0x3"/>
        <value caption="2=Swap doublewords in 16-byte blocks. Useful for AES. Bus references issued in the order 0xC, 0x8, 0x4, 0x0, 0x1C, 0x18,..." name="SWAP_16_BYTE_BLOCK" value="0x2"/>
        <value caption="1=Swap doublewords in 8-byte blocks. Useful for SHA-512, which works on 64-bit words. Bus references issued in the order 0x4,       0x0, 0xC, 0x8, ..." name="SWAP_8_BYTE_BLOCK" value="0x1"/>
        <value caption="0=Disable." name="DIS" value="0x0"/>
      </value-group>
    </module>
    <module name="OTP" id="96" version="1.0" caption="OTP Programming registers.">
      <register-group name="OTP" caption="OTP Programming registers.">
        <register name="WR_LOCK0" offset="0x44" rw="RW" size="1" access-size="1" initval="0x00" caption="This is the Write Lock Register.">
          <bitfield name="WL0" caption="When any of the bits are set, the corresponding 32byte range in the OTP is not writable." mask="0xFF"/>
        </register>
        <register name="WR_LOCK1" offset="0x45" rw="RW" size="1" access-size="1" initval="0x00" caption="This is the Write Lock Register.">
          <bitfield name="WL1" caption="When any of the bits are set, the corresponding 32byte range in the OTP is not writable." mask="0xFF"/>
        </register>
        <register name="WR_LOCK2" offset="0x46" rw="RW" size="1" access-size="1" initval="0x00" caption="This is the Write Lock Register.">
          <bitfield name="WL2" caption="When any of the bits are set, the corresponding 32byte range in the OTP is not writable." mask="0xFF"/>
        </register>
        <register name="WR_LOCK3" offset="0x47" rw="RW" size="1" access-size="1" initval="0x00" caption="This is the Write Lock Register.">
          <bitfield name="WL3" caption="When any of the bits are set, the corresponding 32byte range in the OTP is not writable." mask="0xFF"/>
        </register>
        <register name="RD_LOCK0" offset="0x48" rw="RW" size="1" access-size="1" initval="0x00" caption="This is the Read Lock Register.">
          <bitfield name="RL0" caption="When any of the bits are set, the corresponding 32byte range in the OTP is not readable." mask="0xFF"/>
        </register>
        <register name="RD_LOCK1" offset="0x49" rw="RW" size="1" access-size="1" initval="0x00" caption="This is the Read Lock Register.">
          <bitfield name="RL1" caption="When any of the bits are set, the corresponding 32byte range in the OTP is not readable." mask="0xFF"/>
        </register>
        <register name="RD_LOCK2" offset="0x4A" rw="RW" size="1" access-size="1" initval="0x00" caption="This is the Read Lock Register.">
          <bitfield name="RL2" caption="When any of the bits are set, the corresponding 32byte range in the OTP is not readable." mask="0xFF"/>
        </register>
        <register name="RD_LOCK3" offset="0x4B" rw="RW" size="1" access-size="1" initval="0x00" caption="This is the Read Lock Register.">
          <bitfield name="RL3" caption="When any of the bits are set, the corresponding 32byte range in the OTP is not readable." mask="0xFF"/>
        </register>
        <register name="WR_FINE_LCK" offset="0x4C" rw="RW" size="4" access-size="4" initval="0x00" caption="This is the Write Fine Lock Register.">
          <bitfield name="WR_FINE_LCK" caption="Each bit locks write to a byte in the OTP range starting byte 320 to 351 0=Not Locked 1=Locked." mask="0xFFFFFFFF"/>
        </register>
        <register name="RD_FINE_LCK" offset="0x50" rw="RW" size="4" access-size="4" initval="0x00" caption="This is the Read Fine Lock Register.">
          <bitfield name="RD_FINE_LCK" caption="Each bit locks read to a byte in the OTP range starting byte 320 to 351 0=Not Locked 1=Locked." mask="0xFFFFFFFF"/>
        </register>
      </register-group>
    </module>
    <module name="SPT" id="170" version="1.0" caption="SPI Peripheral Target Register.">
      <register-group name="SPT" caption="SPI Peripheral Target Register.">
        <register name="SPI_CFG" offset="0x0" rw="RW" size="4" access-size="4" initval="0x00040000" caption="SPI Peripheral Target Communication Configuration Register.">
          <bitfield name="SNG_QUD_SEL" caption="This field defines the Single / Quad Wire mode of operation for SPI Peripheral Target block.         0 = Single Wire Slave SPI block operation.         1 = Quad Wire Slave SPI block operation." mask="0x1"/>
          <bitfield name="TAR_TIM_SEL" caption="Turn Around Time select for Quad wire mode.         0h = 1 cycle.         1h = 2 cycles.         2h = 4 cycles.         3h = 8 cycles.         Other values are reserved." mask="0x700"/>
          <bitfield name="WAIT_TIME" caption="These bits set the amount of wait time in cycles before transmitting data back to master.         During this wait time status bits will be transmitted" mask="0xFF0000"/>
        </register>
        <register name="SPI_STS" offset="0x4" rw="RW" size="4" access-size="4" initval="0x00000500" caption="SPI Peripheral Target Status Register.">
          <bitfield name="MEM_WR_DONE" caption="When the ARM BUS side has fully finished the last transaction from the FIFO to write the data to         Memory for Posted Writes . Clear with new Write request." mask="0x1"/>
          <bitfield name="MEM_RD_DONE" caption="When the ARM BUS side has fully finished writing the last written DWord to the FIFO for a set of data         read from Memory for Posted Reads. - cleared with new Read request." mask="0x2"/>
          <bitfield name="MEM_WR_BUSY" caption="When an Memory Write transaction is currently being processed." mask="0x8"/>
          <bitfield name="MEM_RD_BUSY" caption="When an Memory Read transaction is currently being processed." mask="0x10"/>
          <bitfield name="SREG_TRANS" caption="When an SREG transaction is currently being processed." mask="0x20"/>
          <bitfield name="POLL_HIGH" caption="If this bit is set, then something in the high 16-bit of status register is set and needs to be checked.         SPI Master should take action to clear this." mask="0x40"/>
          <bitfield name="RXF_EMP" caption="Signifies all Memory write transactions for the SPI Masters requested size have been performed.         New transactions are allowed." mask="0x100"/>
          <bitfield name="RXF_FUL" caption="The RX FIFO is full of data to be written to Memory." mask="0x200"/>
          <bitfield name="TXF_EMP" caption="Signifies SPI Master has read the data requested from Memory. Can be used to show there is data         the SPI Master has requested and not been read yet. New read transactions will be aligned." mask="0x400"/>
          <bitfield name="TXF_FUL" caption="The TX FIFO is full of data that was read from Memory." mask="0x800"/>
          <bitfield name="TMCLK_CNT_ERR" caption="This bit is set when the SPI Clock Count Test Mode is set and there is an uneven amount of clocks." mask="0x2000"/>
          <bitfield name="IBF_FLG" caption="Set when the Host writes to the Input Buffer signaling there is data for the EC to read." mask="0x4000"/>
          <bitfield name="OBF_FLG" caption="Set when the EC writes to the Output Buffer signaling there is data for the Host to read." mask="0x8000"/>
          <bitfield name="SPIM_RST_REQ" caption="Set when the SPI Master Requested a Configuration Reset." mask="0x10000"/>
          <bitfield name="RXF_RST_DN" caption="Set after the SPI Master initiates a RX FIFO reset and the reset has been processed. FIFO is cleared." mask="0x20000"/>
          <bitfield name="TXF_RST_DN" caption="Set after the SPI Master initiates a TX FIFO reset and the reset has been processed. FIFO is cleared." mask="0x40000"/>
          <bitfield name="OOL0_ERR" caption="This flag is set with the transfer address requested by the master is out of Limit 0 range or when the BAR is disabled." mask="0x80000"/>
          <bitfield name="OOL1_ERR" caption="This flag is set with the transfer address requested by the master is out of Limit 1 range or when the BAR is disabled." mask="0x100000"/>
          <bitfield name="ARMBUS_ERR" caption="ARM Bus Error returned for the curren data transfer." mask="0x200000"/>
          <bitfield name="UNDEF_CMD_ERR" caption="Undefined Command Error: The command received from the master isn't defined." mask="0x400000"/>
          <bitfield name="DV_BUSY" caption="If the Master requested a transaction whose destination is busy the request is ignored.         Should use the poll or wait for interrupts." mask="0x800000"/>
          <bitfield name="RXF_SIZE_ERR" caption="If size requested is more than what Master provided and the Master terminates early error flag         shut down request signal to ARM Bus. Size requested is less than what Master provided -- ignored and         continue transaction, may be taking in garbage." mask="0x1000000"/>
          <bitfield name="TXF_UNFLW" caption="If Master reads more than what is in FIFO, FIFO will flag an underflow error and the data returned         will just be the last valid pointer value." mask="0x2000000"/>
          <bitfield name="TXF_OVRFLW" caption="If Master doesn't read all of the data it requested from the posted read block cycle, than data         will still be left in the FIFO. This will cause misalignment with the following transactions and a new         read cycle can cause overflow." mask="0x4000000"/>
          <bitfield name="RXF_UNFLW" caption="If the SPI Peripheral Target reads RX FIFO when it is empty, RX FIFO Underflow flag will be set. This condition         will never happen under normal situation." mask="0x8000000"/>
          <bitfield name="RXF_OVRFLW" caption="If SPI Master writes more than the space in the FIFO, the FIFO will flag an overflow error and data         will not be stored." mask="0x10000000"/>
        </register>
        <register name="SPI_EC_STS" offset="0x8" rw="RW" size="4" access-size="4" initval="0x00000500" caption="SPI Peripheral Target EC Status Register.">
          <bitfield name="MEM_WR_DONE" caption="When the ARM BUS side has fully finished the last transaction from the FIFO to write the data to         Memory for Posted Writes .- clear with new Write request." mask="0x1"/>
          <bitfield name="MEM_RD_DONE" caption="When the ARM BUS side has fully finished writing the last written DWord to the FIFO for a set of data         read from Memory for Posted Reads. - cleared with new Read request." mask="0x2"/>
          <bitfield name="MEM_WR_BUSY" caption="When an Memory Write transaction is currently being processed." mask="0x8"/>
          <bitfield name="MEM_RD_BUSY" caption="When an Memory Read transaction is currently being processed." mask="0x10"/>
          <bitfield name="SREG_TRANS" caption="When an SREG transaction is currently being processed." mask="0x20"/>
          <bitfield name="POLL_HI" caption="If this bit is set, then something in the high 16-bit of status register is set and needs to be checked.         SPI Master should take action to clear this." mask="0x40"/>
          <bitfield name="RXF_EMP" caption="Signifies all Memory write transactions for the SPI Masters requested size have been performed.         New transactions are allowed." mask="0x100"/>
          <bitfield name="RXF_FUL" caption="The RX FIFO is full of data to be written to Memory." mask="0x200"/>
          <bitfield name="TXF_EMP" caption="Signifies SPI Master has read the data requested from Memory. Can be used to show there is data         the SPI Master has requested and not been read yet. New read transactions will be aligned." mask="0x400"/>
          <bitfield name="TXF_FUL" caption="The TX FIFO is full of data that was read from Memory." mask="0x800"/>
          <bitfield name="TMCLK_CNT_ERR" caption="This bit is set when the SPI Clock Count Test Mode is set and there is an uneven amount of clocks." mask="0x2000"/>
          <bitfield name="IBF_FLG" caption="Set when the Host writes to the Input Buffer signaling there is data for the EC to read." mask="0x4000"/>
          <bitfield name="OBF_FLG" caption="Set when the EC writes to the Output Buffer signaling there is data for the Host to read." mask="0x8000"/>
          <bitfield name="SPIM_RST_REQ" caption="Set when the SPI Master Requested a Configuration Reset." mask="0x10000"/>
          <bitfield name="RXF_RST_DN" caption="Set after the SPI Master initiates a RX FIFO reset and the reset has been processed. FIFO is cleared." mask="0x20000"/>
          <bitfield name="TXF_RST_DN" caption="Set after the SPI Master initiates a TX FIFO reset and the reset has been processed. FIFO is cleared." mask="0x40000"/>
          <bitfield name="OOL0_ERR" caption="This flag is set with the transfer address requested by the master is out of Limit 0 range or when the BAR is disabled." mask="0x80000"/>
          <bitfield name="OOL1_ERR" caption="This flag is set with the transfer address requested by the master is out of Limit 1 range or when the BAR is disabled." mask="0x100000"/>
          <bitfield name="ARMBUS_ERR" caption="ARM Bus Error returned for the curren data transfer." mask="0x200000"/>
          <bitfield name="UNDEF_CMD_ERR" caption="Undefined Command Error: The command received from the master isn't defined." mask="0x400000"/>
          <bitfield name="DV_BUSY" caption="If the Master requested a transaction whose destination is busy the request is ignored.         Should use the poll or wait for interrupts." mask="0x800000"/>
          <bitfield name="RXF_SIZE_ERR" caption="If size requested is more than what Master provided and the Master terminates early error flag         shut down request signal to ARM Bus. Size requested is less than what Master provided -- ignored and         continue transaction, may be taking in garbage." mask="0x1000000"/>
          <bitfield name="TXF_UNFLW" caption="If Master reads more than what is in FIFO, FIFO will flag an underflow error and the data returned         will just be the last valid pointer value." mask="0x2000000"/>
          <bitfield name="TXF_OVRFLW" caption="If Master doesn't read all of the data it requested from the posted read block cycle, than data         will still be left in the FIFO. This will cause misalignment with the following transactions and a new         read cycle can cause overflow." mask="0x4000000"/>
          <bitfield name="RXF_UNFLW" caption="If the SPI Peripheral Target reads RX FIFO when it is empty, RX FIFO Underflow flag will be set. This condition         will never happen under normal situation." mask="0x8000000"/>
          <bitfield name="RXF_OVRFLW" caption="If SPI Master writes more than the space in the FIFO, the FIFO will flag an overflow error and data         will not be stored." mask="0x10000000"/>
        </register>
        <register name="SPI_IEN" offset="0xC" rw="RW" size="4" access-size="4" initval="0x00000000" caption="SPI Peripheral Target Interrupt Enable Register.">
          <bitfield name="MEM_WR_DONE" caption="Enable Memory Write Done Interrupt to SPI Master." mask="0x1"/>
          <bitfield name="MEM_RD_DONE" caption="Enable Memory Read Done Interrupt to SPI Master." mask="0x2"/>
          <bitfield name="MEM_WR_BUSY" caption="Enable Memory Write Busy Interrupt to SPI Master." mask="0x8"/>
          <bitfield name="MEM_RD_BUSY" caption="Enable Memory Read Busy Interrupt to SPI Master." mask="0x10"/>
          <bitfield name="SREG_TRANS" caption="Enable SREG Trans Busy Interrupt to SPI Master." mask="0x20"/>
          <bitfield name="POLL_HI" caption="Enable Poll High Request Interrupt to SPI Master." mask="0x40"/>
          <bitfield name="RXF_EMP" caption="Enable SREG RX FIFO Empty Interrupt to SPI Master." mask="0x100"/>
          <bitfield name="RXF_FUL" caption="Enable RX FIFO Full Interrupt to SPI Master." mask="0x200"/>
          <bitfield name="TXF_EMP" caption="Enable TX FIFO Empty Interrupt to SPI Master." mask="0x400"/>
          <bitfield name="TXF_FUL" caption="Enable TX FIFI FULL Interrupt to SPI Master." mask="0x800"/>
          <bitfield name="TMCLK_CNT_ERR" caption="Enable Test Mode SPI Clock Count Error Interrupt to SPI Master." mask="0x2000"/>
          <bitfield name="IBF_FLG" caption="Enable Input Buffer Signaling Interrupt to SPI Master." mask="0x4000"/>
          <bitfield name="OBF_FLG" caption="Enable Output Buffer signaling Interrupt to SPI Master." mask="0x8000"/>
          <bitfield name="SPIM_RST_REQ" caption="Enable SPI Master Request Reset Interrupt to SPI Master." mask="0x10000"/>
          <bitfield name="RXF_RST_DN" caption="Enable RX FIFO Reset Done Interrupt to SPI Master." mask="0x20000"/>
          <bitfield name="TXF_RST_DN" caption="Enable TX FIFO Reset Done Interrupt to SPI Master." mask="0x40000"/>
          <bitfield name="OOL0_ERR" caption="Enable Out Of Limit 0 Error Interrupt to SPI Master." mask="0x80000"/>
          <bitfield name="OOL1_ERR" caption="Enable Out Of Limit 1 Error Interrupt to SPI Master." mask="0x100000"/>
          <bitfield name="ARMBUS_ERR" caption="Enable AHB BUS Error Interrupt to SPI Master." mask="0x200000"/>
          <bitfield name="UNDEF_CMD_ERR" caption="Enable Undefined Command Error Interrupt to SPI Master." mask="0x400000"/>
          <bitfield name="DV_BUSY" caption="Enable Device Busy Interrupt to SPI Master." mask="0x800000"/>
          <bitfield name="RXF_SIZE_ERR" caption="Enable RX FIFO SIZE Error Interrupt to SPI Master." mask="0x1000000"/>
          <bitfield name="TXF_UNFLW" caption="Enable TX FIFO Underflow Interrupt to SPI Master." mask="0x2000000"/>
          <bitfield name="TXF_OVRFLOW" caption="Enable TX FIFO Overflow Interrupt to SPI Master." mask="0x4000000"/>
          <bitfield name="RXF_UNFLW" caption="Enable RX FIFO Underflow Interrupt to SPI Master." mask="0x8000000"/>
          <bitfield name="RXF_OVRFLW" caption="Enable RX FIFO Overflow Interrupt to SPI Master." mask="0x10000000"/>
        </register>
        <register name="EC_IEN" offset="0x10" rw="RW" size="4" access-size="4" initval="0x00000000" caption="SPI Peripheral Target EC Interrupt Enable Register.">
          <bitfield name="MEM_WR_DONE" caption="Enable Memory Write Done Interrupt to EC." mask="0x1"/>
          <bitfield name="MEM_RD_DONE" caption="Enable Memory Read Done Interrupt to EC." mask="0x2"/>
          <bitfield name="MEM_WR_BUSY" caption="Enable Memory Write Busy Interrupt to EC." mask="0x8"/>
          <bitfield name="MEM_RD_BUSY" caption="Enable Memory Read Busy Interrupt to EC." mask="0x10"/>
          <bitfield name="SREG_TRANS" caption="Enable SREG Trans Busy Interrupt to EC." mask="0x20"/>
          <bitfield name="POLL_HI" caption="Enable Poll High Request Interrupt to EC." mask="0x40"/>
          <bitfield name="RXF_EMP" caption="Enable SREG RX FIFO Empty Interrupt to EC." mask="0x100"/>
          <bitfield name="RXF_FUL" caption="Enable RX FIFO Full Interrupt to EC." mask="0x200"/>
          <bitfield name="TXF_EMP" caption="Enable TX FIFO Empty Interrupt to EC." mask="0x400"/>
          <bitfield name="TXF_FUL" caption="Enable TX FIFI FULL Interrupt to EC." mask="0x800"/>
          <bitfield name="TMCLK_CNT_ERR" caption="Enable Test Mode SPI Clock Count Error Interrupt to EC." mask="0x2000"/>
          <bitfield name="IBF_FLG" caption="Enable Input Buffer Signaling Interrupt to EC." mask="0x4000"/>
          <bitfield name="OBF_FLG" caption="Enable Output Buffer signaling Interrupt to EC." mask="0x8000"/>
          <bitfield name="SPIM_RST_REQ" caption="Enable SPI Master Request Reset Interrupt to EC." mask="0x10000"/>
          <bitfield name="RXF_RST_DN" caption="Enable RX FIFO Reset Done Interrupt to EC." mask="0x20000"/>
          <bitfield name="TXF_RST_DN" caption="Enable TX FIFO Reset Done Interrupt to EC." mask="0x40000"/>
          <bitfield name="OOL0_ERR" caption="Enable Out Of Limit 0 Error Interrupt to EC." mask="0x80000"/>
          <bitfield name="OOL1_ERR" caption="Enable Out Of Limit 1 Error Interrupt to EC." mask="0x100000"/>
          <bitfield name="ARMBUS_ERR" caption="Enable AHB BUS Error Interrupt to EC." mask="0x200000"/>
          <bitfield name="UNDEF_CMD_ERR" caption="Enable Undefined Command Error Interrupt to EC." mask="0x400000"/>
          <bitfield name="DV_BUSY" caption="Enable Device Busy Interrupt to EC." mask="0x800000"/>
          <bitfield name="RXF_SIZE_ERR" caption="Enable RX FIFO SIZE Error Interrupt to EC." mask="0x1000000"/>
          <bitfield name="TXF_UNFLW" caption="Enable TX FIFO Underflow Interrupt to EC." mask="0x2000000"/>
          <bitfield name="TXF_OVRFLW" caption="Enable TX FIFO Overflow Interrupt to EC." mask="0x4000000"/>
          <bitfield name="RXF_UNFLW" caption="Enable RX FIFO Underflow Interrupt to EC." mask="0x8000000"/>
          <bitfield name="RXF_OVRFLW" caption="Enable RX FIFO Overflow Interrupt to EC." mask="0x10000000"/>
        </register>
        <register name="MEM_CFG" offset="0x14" rw="RW" size="4" access-size="4" initval="0x00000000" caption="SPI Peripheral Target Memory Configuration Register.">
          <bitfield name="BAR_EN0_SEL" caption="Enables Region 0 operation.         0 = Disable Region 0.         1 = Enable Region 0." mask="0x1"/>
          <bitfield name="BAR_EN1_SEL" caption="Enables Region 1 operation.         0 = Disable Region 1.         1 = Enable Region 1." mask="0x2"/>
        </register>
        <register name="MEM_BAR0" offset="0x18" rw="RW" size="4" access-size="4" initval="0x00000000" caption="SPI Peripheral Target Memory Base Address0 Register.">
          <bitfield name="BAS_ADD0" caption="Base Address for Region 0." mask="0xFFFFFFFF"/>
        </register>
        <register name="MEM_WR_LIM0" offset="0x1C" rw="RW" size="4" access-size="4" initval="0x00000000" caption="SPI Peripheral Target Memory Write LIMIT 0 Register.">
          <bitfield name="LMT0" caption="Write Limit for Region 0." mask="0x7FFF"/>
        </register>
        <register name="MEM_RD_LIM0" offset="0x20" rw="RW" size="4" access-size="4" initval="0x00000000" caption="SPI Peripheral Target Memory Read LIMIT 0 Register.">
          <bitfield name="LMT0" caption="Read Limit for Region 0." mask="0x7FFF"/>
        </register>
        <register name="MEM_BAR1" offset="0x24" rw="RW" size="4" access-size="4" initval="0x00000000" caption="SPI Peripheral Target Memory Base Address1 Register.">
          <bitfield name="ADD1" caption="Base Address for Region 1." mask="0xFFFFFFFF"/>
        </register>
        <register name="MEM_WR_LIM1" offset="0x28" rw="RW" size="4" access-size="4" initval="0x00000000" caption="SPI Peripheral Target Memory Write LIMIT 1 Register.">
          <bitfield name="LMT1" caption="Write Limit for Region 1." mask="0x7FFF"/>
        </register>
        <register name="MEM_RD_LIM1" offset="0x2C" rw="RW" size="4" access-size="4" initval="0x00000000" caption="SPI Peripheral Target Memory Read LIMIT 1 Register.">
          <bitfield name="LMT1" caption="Read Limit for Region 1." mask="0x7FFF"/>
        </register>
        <register name="RXF_HOST_BAR" offset="0x30" rw="R" size="4" access-size="4" initval="0x00000000" caption="SPI Peripheral Target RX FIFO Host Bar Register.">
          <bitfield name="BAR" caption="RX FIFO Host Bar Register." mask="0xFFFF"/>
        </register>
        <register name="RXF_BYTE_CNT" offset="0x34" rw="R" size="4" access-size="4" initval="0x00000000" caption="SPI Peripheral Target RX FIFO Byte Counter Register.">
          <bitfield name="BCNT" caption="RX FIFO Byte Count Register." mask="0x7FFF"/>
        </register>
        <register name="TXF_HOST_BAR" offset="0x38" rw="R" size="4" access-size="4" initval="0x00000000" caption="SPI Peripheral Target TX FIFO Host Bar Register.">
          <bitfield name="BAR" caption="TX FIFO Host Bar Register." mask="0xFFFF"/>
        </register>
        <register name="TXF_BYTE_CNT" offset="0x3C" rw="R" size="4" access-size="4" initval="0x00000000" caption="SPI Peripheral Target TX FIFO Byte Counter Register.">
          <bitfield name="BCNT" caption="TX FIFO Byte Count Register." mask="0x7FFF"/>
        </register>
        <register name="SYS_CFG" offset="0x40" rw="RW" size="4" access-size="4" initval="0x000004C0" caption="SPI Peripheral Target System Configuration Register.">
          <bitfield name="SOFT_RST" caption="Soft reset for entire SPI Peripheral Target Block. This bit is self clearing." mask="0x1"/>
          <bitfield name="LOCK_QUAD_SNGL_WRMOD" caption="Lock Quad / Single Write Mode bit, write access from SPI Master." mask="0x2"/>
          <bitfield name="LOCK_TAR_TIME" caption="Lock Tar Time bit, write access from SPI Master." mask="0x4"/>
          <bitfield name="LOCK_WAIT_CYCL" caption="Lock Wait Cycle bits, write access from SPI Master." mask="0x8"/>
          <bitfield name="LOCK_MEM_CFG" caption="Lock Memory Configuration register, write access from SPI Master." mask="0x10"/>
          <bitfield name="LOCK_SPIINT_EN" caption="Lock SPI Interrupt Enable register, write access from SPI Master." mask="0x20"/>
          <bitfield name="LOCK_MEM_BAR0" caption="Lock Memory Bar 0 register, write access from SPI Master." mask="0x40"/>
          <bitfield name="LOCK_MEM_BAR1" caption="Lock Memory Bar 1 register, write access from SPI Master." mask="0x80"/>
          <bitfield name="LOCK_TEST_MODE" caption="Lock TEST Mode register, write access from SPI Master." mask="0x400"/>
          <bitfield name="SPI_SLV_EN" caption="Enable / Disable SPI Peripheral Target Block.         0 = Disable SPI Peripheral Target module.         1 = Enable SPI Peripheral Target module." mask="0x10000"/>
          <bitfield name="MAS_ECREG" caption="Fixed in hardware to 1" mask="0x20000"/>
          <bitfield name="SIM_EN" caption="Enable SPI Peripheral Target Simple Mode operation." mask="0x40000"/>
          <bitfield name="ECDATL" caption="Notification to TX FIFO Engine that data is available for AHB Transfer. This register         but is cleared by Hardware at the end of the transaction, with SPI_CS_N de-assertion.         (R/WC)." mask="0x80000"/>
        </register>
        <register name="SPIM2EC_MBX" offset="0x44" rw="RW" size="4" access-size="4" initval="0x00000000" caption="SPI Peripheral Target Master to EC Mailbox Register.">
          <bitfield name="M2EC" caption="Write only register for the Host. When data is written to this register the IBF Flag         is set. EC can read the data and writes of 0xFFFF will clear this register. Any form of         read will clear the flag for this register." mask="0xFFFFFFFF"/>
        </register>
        <register name="EC2SPIM_MBX" offset="0x48" rw="RW" size="4" access-size="4" initval="0x00000000" caption="SPI Peripheral Target Master to EC Mailbox Register.">
          <bitfield name="EC2M" caption="Read only register for the Host. When data is written to this register the OBF Flag         is set. Host can read the data and writes of 0xFFFF_FFFF will clear this register, also         clearing the flag. Any form of read will clear the flag for this register" mask="0xFFFFFFFF"/>
        </register>
      </register-group>
    </module>
    <module name="FPU" version="1.0.0" caption="Floating Point Unit">
      <register-group name="FPU" caption="Floating Point Unit">
        <register name="FPCCR" offset="0x4" rw="RW" size="4" access-size="4" initval="0xC0000000" caption="Floating-Point Context Control Register">
          <bitfield name="LSPACT" caption="" mask="0x1"/>
          <bitfield name="USER" caption="" mask="0x2"/>
          <bitfield name="THREAD" caption="" mask="0x8"/>
          <bitfield name="HFRDY" caption="" mask="0x10"/>
          <bitfield name="MMRDY" caption="" mask="0x20"/>
          <bitfield name="BFRDY" caption="" mask="0x40"/>
          <bitfield name="MONRDY" caption="" mask="0x100"/>
          <bitfield name="LSPEN" caption="" mask="0x40000000"/>
          <bitfield name="ASPEN" caption="" mask="0x80000000"/>
        </register>
        <register name="FPCAR" offset="0x8" rw="RW" size="4" access-size="4" caption="Floating-Point Context Address Register">
          <bitfield name="ADDRESS" caption="Address for FP registers in exception stack frame" mask="0xFFFFFFF8"/>
        </register>
        <register name="FPDSCR" offset="0xC" rw="RW" size="4" access-size="4" initval="0x00000000" caption="Floating-Point Default Status Control Register">
          <bitfield name="RMODE" caption="Default value for FPSCR.RMODE" mask="0xC00000" values="FPU_FPDSCR__RMODE"/>
          <bitfield name="FZ" caption="Default value for FPSCR.FZ" mask="0x1000000"/>
          <bitfield name="DN" caption="Default value for FPSCR.DN" mask="0x2000000"/>
          <bitfield name="AHP" caption="Default value for FPSCR.AHP" mask="0x4000000"/>
        </register>
        <register name="MVFR0" offset="0x10" rw="R" size="4" access-size="4" caption="Media and FP Feature Register 0">
          <bitfield name="A_SIMD_registers" caption="" mask="0xF"/>
          <bitfield name="Single_precision" caption="" mask="0xF0"/>
          <bitfield name="Double_precision" caption="" mask="0xF00"/>
          <bitfield name="FP_excep_trapping" caption="" mask="0xF000"/>
          <bitfield name="Divide" caption="" mask="0xF0000"/>
          <bitfield name="Square_root" caption="" mask="0xF00000"/>
          <bitfield name="Short_vectors" caption="" mask="0xF000000"/>
          <bitfield name="FP_rounding_modes" caption="" mask="0xF0000000"/>
        </register>
        <register name="MVFR1" offset="0x14" rw="R" size="4" access-size="4" caption="Media and FP Feature Register 1">
          <bitfield name="FtZ_mode" caption="" mask="0xF"/>
          <bitfield name="D_NaN_mode" caption="" mask="0xF0"/>
          <bitfield name="FP_HPFP" caption="" mask="0xF000000"/>
          <bitfield name="FP_fused_MAC" caption="" mask="0xF0000000"/>
        </register>
      </register-group>
      <value-group name="FPU_FPDSCR__RMODE">
        <value name="RN" caption="Round to Nearest" value="0x0"/>
        <value name="RP" caption="Round towards Positive Infinity" value="0x1"/>
        <value name="RM" caption="Round towards Negative Infinity" value="0x2"/>
        <value name="RZ" caption="Round towards Zero" value="0x3"/>
      </value-group>
    </module>
    <module name="IMSPI" id="173" version="1.0" caption="Internal Master SPI.">
      <register-group name="IMSPI" caption="Internal Master SPI.">
        <register name="IMSPI_MODE" offset="0x0" rw="RW" size="4" access-size="4" initval="0x00000000" caption="IMSPI Mode Register">
          <bitfield name="ACTIVATE" caption="This bit enables the controller. 1=The controller is enabled; 0=The controller is disabled and placed in its lowest power state." mask="0x1"/>
          <bitfield name="SOFT_RESET" caption="A write of '1b' to this bit resets the controller. This bit is self-clearing." mask="0x2"/>
          <bitfield name="DLY2_SUSB" caption="This bit is routed to the DLY2_SUSB# pin function." mask="0x4"/>
          <bitfield name="CPOL" caption="This bit corresponds to the Polarity control for the underlying SPI controller. It describes the default state of      the SPI Clock signal. 1=The clock starts in a high state; 0=The clock starts in a low state." mask="0x100"/>
          <bitfield name="CPHA_MOSI" caption="This field is the CPHA field of the underlying SPI controller which affects only the MOSI Data. This field changes      determines the clock edge on which data are sent, in combination with the CPOL field. 1=If CPOL=0, data sent on Rising Edge;      if CPOL=1, data sent on Falling Edge ; 0=If CPOL=0, data sent on Falling Edge; if CPOL=1, data sent on Rising Edge." mask="0x200"/>
          <bitfield name="CPHA_MISO" caption="This field is the CPHA field of the underlying SPI controller which affects only the MISO Data. This field changes      determines the clock edge on which data are captured, in combination with the CPOL field. For standard SPI Modes, this must be      programmed with the same value as CPHA_MOSI. 1=If CPOL=0, data captured on Falling Edge; if CPOL=1, data captured on Rising Edge      0=If CPOL=0, data captured on Rising Edge; if CPOL=1, data captured on Falling Edge." mask="0x400"/>
          <bitfield name="CLOCK_DIVIDE" caption="This SPI clock divide in terms of the number of system clocks. 255:1=The SPI clock period is equal to this number of      system clocks. 0=The SPI clock period is equal to 256 system clocks." mask="0xFF0000"/>
          <bitfield name="IF_MODE" caption="This field sets the interface mode for the SPI controller. 3=Reserved; 2=Quad Mode; 1=Dual Mode; 0=Single Mode." mask="0x3000000"/>
        </register>
        <register name="IMSPI_STATUS" offset="0x4" rw="RW" size="4" access-size="4" initval="0x00000000" caption="IMSPI Status Register">
          <bitfield name="TIMEOUT" caption="This flags when a transfer has terminated due to timeout on the response phase. 1=A transfer error occurred due to an      invalid response; 0=No error occurred. (R/WC)" mask="0x1"/>
          <bitfield name="INVALID_RESPONSE" caption="The IMSPI has detected an invalid response field and therefore is aborting the transfer in failure. 1=A transfer error      occurred due to an invalid response; 0=No error occurred. (R/WC)" mask="0x2"/>
        </register>
        <register name="IMSPI_INT_ENABLE" offset="0x8" rw="RW" size="4" access-size="4" initval="0x00000000" caption="IMSPI Interrupt Enable Register">
          <bitfield name="TIMEOUT_LE" caption="Assert an IMSPI interrupt when the TIMEOUT status is asserted. 1=Enable Interrupt; 0=Disable Interrupt" mask="0x1"/>
          <bitfield name="INVALID_RESPONSE_LE" caption="Assert an EEPROM interrupt when the INVALID_RESPONSE status is asserted. 1=Enable Interrupt; 0=Disable Interrupt" mask="0x2"/>
        </register>
        <register name="IMSPI_TIMEOUT_CONTROL" offset="0xC" rw="RW" size="4" access-size="4" initval="0x00000000" caption="IMSPI Timeout Control Register">
          <bitfield name="RESPONSE_TIMEOUT" caption="This field is the maximum number of response cycles the IMSPI will wait until flagging a timeout. A setting of 0 will      disable the timeout feature." mask="0x1F"/>
        </register>
      </register-group>
    </module>
    <module name="CRYPTO" id="203" version="1.0.0" caption="Crypto block interrupt">
    </module>
    <module name="ENV_MON" id="205" version="1.0.0" caption="Environmental Monitor Block">
      <register-group name="ENV_MON" caption="Environmental Monitor Block">
        <register name="EXT1_TEMP" offset="0x0" rw="R" size="2" access-size="2" initval="0" caption="External Diode 1 Temp Register">
          <bitfield name="DIODE1_TEMP" caption="External Diode 1 Temp Byte Register" mask="0xFFFF"/>
        </register>
        <register name="INT_TEMP" offset="0x2" rw="R" size="2" access-size="2" initval="0" caption="Internal Temp Register">
          <bitfield name="INT_TEMP" caption="Internal Temp Byte Register" mask="0xFFFF"/>
        </register>
        <register name="EXT2_TEMP" offset="0x4" rw="R" size="2" access-size="2" initval="0" caption="External Diode 2 Temp Register">
          <bitfield name="DIODE2_TEMP" caption="External Diode 2 Temp Byte Register" mask="0xFFFF"/>
        </register>
        <register name="EXT3_TEMP" offset="0x6" rw="R" size="2" access-size="2" initval="0" caption="External Diode 3 Temp Register">
          <bitfield name="DIODE3_TEMP" caption="External Diode 3 Temp Byte Register" mask="0xFFFF"/>
        </register>
        <register name="EXT4_TEMP" offset="0x8" rw="R" size="2" access-size="2" initval="0" caption="External Diode 4 Temp Register">
          <bitfield name="DIODE4_TEMP" caption="External Diode 4 Temp Byte Register" mask="0xFFFF"/>
        </register>
        <register name="VIN_VOLT" offset="0xE" rw="R" size="1" access-size="1" initval="0xFF" caption="Stores the voltage Measured on VIN channel">
          <bitfield name="VIN_VOLT" caption="Stores the voltage Measured on VIN channel" mask="0xFF"/>
        </register>
        <register name="EXT1A_TEMP" offset="0x12" rw="R" size="2" access-size="2" initval="0x0000" caption="Stores the fractional and integer data for External Diode 1A Register">
          <bitfield name="DIODE1A_TEMP" caption="Stores the fractional and integer data for External Diode 1A Register" mask="0xFFFF"/>
        </register>
        <register name="EXT2A_TEMP" offset="0x14" rw="R" size="2" access-size="2" initval="0x0000" caption="Stores the fractional and integer data for External Diode 2A Register">
          <bitfield name="DIODE2A_TEMP" caption="Stores the fractional and integer data for External Diode 2A Register" mask="0xFFFF"/>
        </register>
        <register name="EXT3A_TEMP" offset="0x16" rw="R" size="2" access-size="2" initval="0x0000" caption="Stores the fractional and integer data for External Diode 3A Register">
          <bitfield name="DIODE3A_TEMP" caption="Stores the fractional and integer data for External Diode 3A Register" mask="0xFFFF"/>
        </register>
        <register name="EXT4A_TEMP" offset="0x18" rw="R" size="2" access-size="2" initval="0x0000" caption="Stores the fractional and integer data for External Diode 4A Register">
          <bitfield name="DIODE4A_TEMP" caption="Stores the fractional and integerdata for External Diode 4A Register" mask="0xFFFF"/>
        </register>
        <register name="VCP_VOLT" offset="0x21" rw="R" size="1" access-size="1" initval="0xFF" caption="Stores the VCP Voltage Monitor data">
          <bitfield name="VCP_VOLT" caption="Stores the VCP Voltage Monitor data" mask="0xFF"/>
        </register>
        <register name="VTT_VOLT" offset="0x23" rw="R" size="1" access-size="1" initval="0xFF" caption="Stores the VTT Voltage Monitor data">
          <bitfield name="VTT_VOLT" caption="Stores the VTT Voltage Monitor data" mask="0xFF"/>
        </register>
        <register name="TEMP_CFG1" offset="0x2B" rw="RW" size="1" access-size="1" initval="0x00" caption="Controls temp sensing for external diodes">
          <bitfield name="TEMP_CFG1" caption="Controls temp sensing for external diodes" mask="0xFF"/>
        </register>
        <register name="TEMP_CFG2" offset="0x2C" rw="RW" size="1" access-size="1" initval="0x00" caption="Controls temp sensing for external diodes">
          <bitfield name="TEMP_CFG2" caption="Controls temp sensing for external diodes" mask="0xFF"/>
        </register>
        <register name="VOLT_CFG" offset="0x2D" rw="RW" size="1" access-size="1" initval="0x00" caption="Controls Voltage sensing for external voltages">
          <bitfield name="VOLT_CFG" caption="Controls Voltage sensing for external voltages" mask="0xFF"/>
        </register>
        <register name="THEM_CFG" offset="0x2E" rw="RW" size="1" access-size="1" initval="0x00" caption="Controls Thermistor or diodes Configuration">
          <bitfield name="THEM_CFG" caption="Controls Thermistor or diodes Configuration" mask="0xFF"/>
        </register>
        <register name="CNVR_CFG" offset="0x2F" rw="RW" size="1" access-size="1" initval="0x00" caption="Controls Temperature Conversion for the temperature channels">
          <bitfield name="CNVR_CFG" caption="Controls Temperature Conversion for the temperature channels" mask="0xFF"/>
        </register>
        <register name="AVG_EN" offset="0x30" rw="RW" size="1" access-size="1" initval="0x00" caption="Software Averaging Enable">
          <bitfield name="AVG_EN" caption="Software Averaging Enable" mask="0xFF"/>
        </register>
        <register name="BCOMP1_EN" offset="0x38" rw="RW" size="1" access-size="1" initval="0x00" caption="Configure Beta compensation settings for External Diode1">
          <bitfield name="BCOMP1_EN" caption="Beta compensation settings for External Diode1 Enable" mask="0xFF"/>
        </register>
        <register name="BCOMP2_EN" offset="0x39" rw="RW" size="1" access-size="1" initval="0x1F" caption="Configure Beta compensation settings for External Diode2">
          <bitfield name="BCOMP2_EN" caption="Beta compensation settings for External Diode2 Enable" mask="0xFF"/>
        </register>
        <register name="LCK_STRT" offset="0x40" rw="RW" size="1" access-size="1" initval="0x01" caption="Lock Start Register">
          <bitfield name="BCOMP2_EN" caption="Enables the software lock and monitoring functionality" mask="0xFF"/>
        </register>
        <register name="FLT_INTSTS" offset="0x41" rw="RW" size="1" access-size="1" initval="0x00" caption="Fault Interrupt Status Register">
          <bitfield name="FLT_INTSTS" caption="Stores the status of the External Diode Faults" mask="0xFF"/>
        </register>
        <register name="FLT_TEMPSTS" offset="0x42" rw="RW" size="1" access-size="1" initval="0x00" caption="Fault temperature Status Register">
          <bitfield name="FLT_TEMPSTS" caption="Stores the status of the External Diode Faults" mask="0xFF"/>
        </register>
        <register name="THRMTRP_STS" offset="0x43" rw="R" size="1" access-size="1" initval="0x00" caption="ThermTrip Pin Status Register">
          <bitfield name="THRMTRP_STS" caption="Stores the pin state of the signals that affect the SYS_SHDN_n signal" mask="0xFF"/>
        </register>
        <register name="INT_TEMP_STS" offset="0x44" rw="RW" size="1" access-size="1" initval="0x00" caption="Temperature of Internal Diode Register">
          <bitfield name="TEMP_STS" caption="Stores the status bits for the Internal Diode" mask="0xFF"/>
        </register>
        <register name="VLT_INTSTS" offset="0x45" rw="RW" size="1" access-size="1" initval="0x00" caption="Volt Interrupt Status Register">
          <bitfield name="VLTINTSTS" caption="Stores the status bits for voltage inputs" mask="0xFF"/>
        </register>
        <register name="VCP_LIMIT" offset="0x46" rw="RW" size="2" access-size="2" initval="0x0000" caption="VCP Limit Register">
          <bitfield name="VCP_LIMIT" caption="Limit for VCP Voltage Monitor" mask="0xFFFF"/>
        </register>
        <register name="VTR_LIMIT" offset="0x48" rw="RW" size="2" access-size="2" initval="0xFF00" caption="VTR Limit Register">
          <bitfield name="VTR_LIMIT" caption="Limit for VTR Voltage Monitor" mask="0xFFFF"/>
        </register>
        <register name="VTT_LIMIT" offset="0x4A" rw="RW" size="2" access-size="2" initval="0xFF00" caption="VTT Limit Register">
          <bitfield name="VTT_LIMIT" caption="Limit for VTT Voltage Monitor" mask="0xFFFF"/>
        </register>
        <register name="VIN_LIMIT" offset="0x4C" rw="RW" size="2" access-size="2" initval="0xFF00" caption="VIN Limit Register">
          <bitfield name="VTT_LIMIT" caption="Limit for VIN Voltage Monitor" mask="0xFFFF"/>
        </register>
        <register name="EXT1_TMPLO_LMT" offset="0x4E" rw="RW" size="1" access-size="1" initval="0x81" caption="Low limit for External Diode 1 Register">
          <bitfield name="TMPLO1_LIMIT" caption="Low limit for External Diode 1 Register" mask="0xFF"/>
        </register>
        <register name="EXT1_TMPHI_LMT" offset="0x4F" rw="RW" size="1" access-size="1" initval="0x7F" caption="High limit for External Diode 1 Register">
          <bitfield name="TMPHI1_LIMIT" caption="High limit for External Diode 1 Register" mask="0xFF"/>
        </register>
        <register name="INT_TMPLO_LMT" offset="0x50" rw="RW" size="1" access-size="1" initval="0x81" caption="Low limit for Internal Diode Register">
          <bitfield name="TMPLO_LIMIT" caption="Low limit for Internal Diode Register" mask="0xFF"/>
        </register>
        <register name="INT_TMPHI_LMT" offset="0x51" rw="RW" size="1" access-size="1" initval="0x7F" caption="High limit for Internal Diode Register">
          <bitfield name="TMPHI_LIMIT" caption="High limit for internal Diode Register" mask="0xFF"/>
        </register>
        <register name="EXT2_TMPLO_LMT" offset="0x52" rw="RW" size="1" access-size="1" initval="0x81" caption="Low limit for External Diode 2 Register">
          <bitfield name="TMPLO2_LIMIT" caption="Low limit for External Diode 2 Register" mask="0xFF"/>
        </register>
        <register name="EXT2_TMPHI_LMT" offset="0x53" rw="RW" size="1" access-size="1" initval="0x7F" caption="High limit for External Diode 2 Register">
          <bitfield name="TMPHI2_LIMIT" caption="High limit for External Diode 2 Register" mask="0xFF"/>
        </register>
        <register name="EXT3_TMPLO_LMT" offset="0x54" rw="RW" size="1" access-size="1" initval="0x81" caption="Low limit for External Diode 3 Register">
          <bitfield name="TMPLO3_LIMIT" caption="Low limit for External Diode 3 Register" mask="0xFF"/>
        </register>
        <register name="EXT3_TMPHI_LMT" offset="0x55" rw="RW" size="1" access-size="1" initval="0x7F" caption="High limit for External Diode 3 Register">
          <bitfield name="TMPHI3_LIMIT" caption="High limit for External Diode 3 Register" mask="0xFF"/>
        </register>
        <register name="EXT4_TMPLO_LMT" offset="0x56" rw="RW" size="1" access-size="1" initval="0x81" caption="Low limit for External Diode 4 Register">
          <bitfield name="TMPLO4_LIMIT" caption="Low limit for External Diode 4 Register" mask="0xFF"/>
        </register>
        <register name="EXT4_TMPHI_LMT" offset="0x57" rw="RW" size="1" access-size="1" initval="0x7F" caption="High limit for External Diode 4 Register">
          <bitfield name="TMPHI4_LIMIT" caption="High limit for External Diode 4 Register" mask="0xFF"/>
        </register>
        <register name="EXT1A_TMPLO_LMT" offset="0x58" rw="RW" size="1" access-size="1" initval="0x81" caption="Low limit for External Diode 1A Register">
          <bitfield name="TMPLO1A_LIMIT" caption="Low limit for External Diode 1A Register" mask="0xFF"/>
        </register>
        <register name="EXT1A_TMPHI_LMT" offset="0x59" rw="RW" size="1" access-size="1" initval="0x7F" caption="High limit for External Diode 1A Register">
          <bitfield name="TMPHI1A_LIMIT" caption="High limit for External Diode 1A Register" mask="0xFF"/>
        </register>
        <register name="EXT2A_TMPLO_LMT" offset="0x5A" rw="RW" size="1" access-size="1" initval="0x81" caption="Low limit for External Diode 2A Register">
          <bitfield name="TMPLO2A_LIMIT" caption="Low limit for External Diode 2A Register" mask="0xFF"/>
        </register>
        <register name="EXT2A_TMPHI_LMT" offset="0x5B" rw="RW" size="1" access-size="1" initval="0x7F" caption="High limit for External Diode 2A Register">
          <bitfield name="TMPHI2A_LIMIT" caption="High limit for External Diode 2A Register" mask="0xFF"/>
        </register>
        <register name="EXT3A_TMPLO_LMT" offset="0x5C" rw="RW" size="1" access-size="1" initval="0x81" caption="Low limit for External Diode 3A Register">
          <bitfield name="TMPLO3A_LIMIT" caption="Low limit for External Diode 3A Register" mask="0xFF"/>
        </register>
        <register name="EXT3A_TMPHI_LMT" offset="0x5D" rw="RW" size="1" access-size="1" initval="0x7F" caption="High limit for External Diode 3A Register">
          <bitfield name="TMPHI3A_LIMIT" caption="High limit for External Diode 3A Register" mask="0xFF"/>
        </register>
        <register name="EXT4A_TMPLO_LMT" offset="0x5E" rw="RW" size="1" access-size="1" initval="0x81" caption="Low limit for External Diode 4A Register">
          <bitfield name="TMPLO4A_LIMIT" caption="Low limit for External Diode 4A Register" mask="0xFF"/>
        </register>
        <register name="EXT4A_TMPHI_LMT" offset="0x5F" rw="RW" size="1" access-size="1" initval="0x7F" caption="High limit for External Diode 4A Register">
          <bitfield name="TMPHI4A_LIMIT" caption="High limit for External Diode 4A Register" mask="0xFF"/>
        </register>
        <register name="BCOMP3_EN" offset="0x64" rw="RW" size="1" access-size="1" initval="0x1F" caption="External Diode3 Beta compensation Register">
          <bitfield name="BCOMP3_EN" caption="Beta compensation settings for External Diode3 Enable" mask="0xFF"/>
        </register>
        <register name="BCOMP4_EN" offset="0x65" rw="RW" size="1" access-size="1" initval="0x1F" caption="External Diode4 Beta compensation Register">
          <bitfield name="BCOMP4_EN" caption="Beta compensation settings for External Diode4 Enable" mask="0xFF"/>
        </register>
        <register name="BCOMP_INTD_EN" offset="0x67" rw="RW" size="1" access-size="1" initval="0x0E" caption="Internal Diode Beta compensation Register">
          <bitfield name="BCOMP4_EN" caption="Beta compensation settings for internal Diode1 Enable" mask="0xFF"/>
        </register>
        <register name="CONV_SRATE" offset="0x6C" rw="RW" size="1" access-size="1" initval="0x00" caption="Conversion Seconds Rate Register">
          <bitfield name="CONV_SRATE" caption="Conversion Seconds Rate Register" mask="0xFF"/>
        </register>
        <register name="CONV_MOD" offset="0x6E" rw="RW" size="1" access-size="1" initval="0x00" caption="Conversion Mode Register">
          <bitfield name="CONV_MOD" caption="Conversion Mode Register" mask="0xFF"/>
        </register>
        <register name="REC_EN" offset="0x70" rw="RW" size="1" access-size="1" initval="0xFF" caption="REC Enable Register">
          <bitfield name="REC_EN" caption="Enables REC for all external diode channels" mask="0xFF"/>
        </register>
        <register name="VSET_VLT" offset="0x71" rw="R" size="1" access-size="1" initval="0xFF" caption="VSET Voltage Reading Register">
          <bitfield name="VSET_VLT" caption="Stores the VSET Voltage Monitor reading" mask="0xFF"/>
        </register>
        <register name="THERM1" offset="0x75" rw="R" size="1" access-size="1" initval="0x7F" caption="Thermal Trip Temperature Diode 1 Register">
          <bitfield name="THERM1" caption="Stores the calculated ThermTrip temperature high limit derived from the voltage on VSET and compared against External Diode 1." mask="0xFF"/>
        </register>
        <register name="FLSF_STS" offset="0x76" rw="R" size="1" access-size="1" initval="0x00" caption="FailSafe Status Register">
          <bitfield name="FLSF_STS" caption="Stores the status indicate which ThermTrip input condition caused the SYS_SHDN# pin to be asserted." mask="0xFF"/>
        </register>
        <register name="FLSF_CFG" offset="0x77" rw="RW" size="1" access-size="1" initval="0x00" caption="FailSafe Configuration Register">
          <bitfield name="FLSF_CFG" caption="Stores configuration bits that are retained over all power modes" mask="0xFF"/>
        </register>
        <register name="SHDN_STS" offset="0x78" rw="R" size="1" access-size="1" initval="0x00" caption="Shutdown Status Register">
          <bitfield name="SHDN_STS" caption="Stores the status bits that indicate which diode caused the SYS_SHDN# output to assert." mask="0xFF"/>
        </register>
        <register name="SHDN_CFG" offset="0x79" rw="RW" size="1" access-size="1" initval="0x01" caption="Shutdown Configuration Register">
          <bitfield name="SHDN_CFG" caption="Stores configuration bits that are retained over all power modes" mask="0xFF"/>
        </register>
        <register name="FLT_INTSTS_EN" offset="0x7A" rw="RW" size="1" access-size="1" initval="0x01" caption="Fault Interrupt Status Enable Register">
          <bitfield name="FLT_INTSTS_EN" caption="Controls whether the External Diode Fault events generates interrupt if the associated status bit is 1." mask="0xFF"/>
        </register>
        <register name="TMP_INTSTS" offset="0x7B" rw="RW" size="1" access-size="1" initval="0x00" caption="Temp Interrupt Status Enable Register">
          <bitfield name="TMP_INTSTS" caption="Controls whether the External Diode events generate an interrupt if the associated status bit is set." mask="0xFF"/>
        </register>
        <register name="SPCL_FN" offset="0x7C" rw="RW" size="1" access-size="1" initval="0x00" caption="Special Function Register">
          <bitfield name="TMP_INTSTS" caption="Controls the bit that resets the FailSafe Status Register" mask="0xFF"/>
        </register>
        <register name="INTTMP_INTEN" offset="0x7D" rw="RW" size="1" access-size="1" initval="0x00" caption="Int Temp Interrupt Status Enable Register">
          <bitfield name="INTTMP_INTEN" caption="Controls whether the Internal Diode event generate an interrupt if the associated status bit is set." mask="0xFF"/>
        </register>
        <register name="VLT_INTEN" offset="0x7E" rw="RW" size="1" access-size="1" initval="0x00" caption="Volt Interrupt Status Enable Register">
          <bitfield name="VLT_INTEN" caption="Controls whether the Voltage event generate an interrupt if the associated status bit is set." mask="0xFF"/>
        </register>
        <register name="THRMTRP_TMP2" offset="0x80" rw="RW" size="1" access-size="1" initval="0x7F" caption="Thermal Trip Temperature Diode 2 Register">
          <bitfield name="THRMTRP_TMP2" caption="ThermTrip temperature high limit compared against External Diode 2" mask="0xFF"/>
        </register>
        <register name="THRMTRP_TMP3" offset="0x81" rw="RW" size="1" access-size="1" initval="0x7F" caption="Thermal Trip Temperature Diode 3 Register">
          <bitfield name="THRMTRP_TMP3" caption="ThermTrip temperature high limit compared against External Diode 3" mask="0xFF"/>
        </register>
        <register name="THRMTRP_TMP4" offset="0x82" rw="RW" size="1" access-size="1" initval="0x7F" caption="Thermal Trip Temperature Diode 4 Register">
          <bitfield name="THRMTRP_TMP4" caption="ThermTrip temperature high limit compared against External Diode 4" mask="0xFF"/>
        </register>
        <register name="THRMTRP_TMP1A" offset="0x83" rw="RW" size="1" access-size="1" initval="0x7F" caption="Thermal Trip Temperature Diode 1A Register">
          <bitfield name="THRMTRP_TMP1A" caption="ThermTrip temperature high limit compared against External Diode 1A" mask="0xFF"/>
        </register>
        <register name="THRMTRP_TMP2A" offset="0x84" rw="RW" size="1" access-size="1" initval="0x7F" caption="Thermal Trip Temperature Diode 2A Register">
          <bitfield name="THRMTRP_TMP2A" caption="ThermTrip temperature high limit compared against External Diode 2A" mask="0xFF"/>
        </register>
        <register name="THRMTRP_TMP3A" offset="0x85" rw="RW" size="1" access-size="1" initval="0x7F" caption="Thermal Trip Temperature Diode 3A Register">
          <bitfield name="THRMTRP_TMP3A" caption="ThermTrip temperature high limit compared against External Diode 3A" mask="0xFF"/>
        </register>
        <register name="THRMTRP_TMP4A" offset="0x86" rw="RW" size="1" access-size="1" initval="0x7F" caption="Thermal Trip Temperature Diode 4A Register">
          <bitfield name="THRMTRP_TMP4A" caption="ThermTrip temperature high limit compared against External Diode 4A" mask="0xFF"/>
        </register>
        <register name="ADJ_CH1" offset="0x88" rw="RW" size="1" access-size="1" initval="0x00" caption="Adjusted Channel 1 Register">
          <bitfield name="ADJ_CH1" caption="Contain EMC IP Trim Adjust values for External Channel 1" mask="0xFF"/>
        </register>
        <register name="ADJ_CH2" offset="0x89" rw="RW" size="1" access-size="1" initval="0x00" caption="Adjusted Channel 2 Register">
          <bitfield name="ADJ_CH2" caption="Contain EMC IP Trim Adjust values for External Channel 2" mask="0xFF"/>
        </register>
        <register name="ADJ_CH3" offset="0x8A" rw="RW" size="1" access-size="1" initval="0x00" caption="Adjusted Channel 3 Register">
          <bitfield name="ADJ_CH3" caption="Contain EMC IP Trim Adjust values for External Channel 3" mask="0xFF"/>
        </register>
        <register name="ADJ_CH4" offset="0x8B" rw="RW" size="1" access-size="1" initval="0x00" caption="Adjusted Channel 4 Register">
          <bitfield name="ADJ_CH4" caption="Contain EMC IP Trim Adjust values for External Channel 4" mask="0xFF"/>
        </register>
        <register name="ADJ_CH1A" offset="0x8C" rw="RW" size="1" access-size="1" initval="0x00" caption="Adjusted Channel 1A Register">
          <bitfield name="ADJ_CH1A" caption="Contain EMC IP Trim Adjust values for External Channel 1A" mask="0xFF"/>
        </register>
        <register name="ADJ_CH2A" offset="0x8D" rw="RW" size="1" access-size="1" initval="0x00" caption="Adjusted Channel 2A Register">
          <bitfield name="ADJ_CH2A" caption="Contain EMC IP Trim Adjust values for External Channel 2A" mask="0xFF"/>
        </register>
        <register name="ADJ_CH3A" offset="0x8E" rw="RW" size="1" access-size="1" initval="0x00" caption="Adjusted Channel 3A Register">
          <bitfield name="ADJ_CH3A" caption="Contain EMC IP Trim Adjust values for External Channel 3A" mask="0xFF"/>
        </register>
        <register name="ADJ_CH4A" offset="0x8F" rw="RW" size="1" access-size="1" initval="0x00" caption="Adjusted Channel 4A Register">
          <bitfield name="ADJ_CH4A" caption="Contain EMC IP Trim Adjust values for External Channel 4A" mask="0xFF"/>
        </register>
        <register name="UNLCK" offset="0xFC" rw="R" size="1" access-size="1" initval="0x00" caption="Unlock Register">
          <bitfield name="UNLCK" caption="Unlock Register" mask="0xFF"/>
        </register>
        <register name="SYS_SHDN_RST" offset="0x400" rw="R" size="1" access-size="1" initval="0x00" caption="System Shutdown Reset Register">
          <bitfield name="SYS_SHDN_RST" caption="Used to de-assert the SYS_SHDN# signal Register" mask="0xFF"/>
        </register>
      </register-group>
    </module>
    <module name="SPI_MON" id="206" version="1.0.0" caption="SPI Monitor Block">
      <register-group name="FLASH_SET" caption="Per Flash Device Register Definition" size="0x80">
        <register name="OP_PRMT" offset="0x00" rw="RW" size="4" access-size="4" count="8" initval="0x00000000" caption="Permit Address Register">
          <bitfield name="PRMT" caption="Permit. Each array organized into 8 32-bit registers set per Flash device.    1 = Permit, and if not recognized then ignore.     0 = Kill immediately upon seeing this opcode." mask="0xFFFFFFFF"/>
        </register>
        <register name="OP_KILLMD" offset="0x20" rw="RW" size="4" access-size="4" count="8" initval="0x00000000" caption="Kill Address Register">
          <bitfield name="KILL" caption="Kill. Each array organized into 8 32-bit registers set per Flash device.    1 = If Killed, then kill as a Write: Holding CS# low.    0 = If Killed, then kill as a Read: Force CS# high first." mask="0xFFFFFFFF"/>
        </register>
        <register name="OP_WPROT" offset="0x40" rw="RW" size="4" access-size="4" count="8" initval="0x00000000" caption="Write Protect Address Register">
          <bitfield name="WPROT" caption="Write Protect. Each array organized into 8 32-bit registers set per Flash device.    1 = Make the corresponding bits RO in Permit and Killmd regs.    0 = Corresponding bits are R/W." mask="0xFFFFFFFF"/>
        </register>
        <register name="OP_LOCK" offset="0x60" rw="RW" size="4" access-size="4" count="8" initval="0x00000000" caption="Lock Address Register">
          <bitfield name="LOCK" caption="Lock. Each array organized into 8 32-bit registers set per Flash device.    1 = Make the corresponding bits RO in Permit and Killmd regs, overriding the Wprot register. Any 1 bit in this register is locked.    0 = Corresponding bits are R/W or RO, as determined by the Wprot register." mask="0xFFFFFFFF"/>
        </register>
      </register-group>
      <register-group name="RN_TM" caption="Run Time Registers" size="0x8">
        <register name="RT_START" offset="0x00" rw="RW" size="4" access-size="4" initval="0x00000000" caption="Runtime Monitoring Start Register">
          <bitfield name="STRT" caption="A Flash address shifted by 12 (4K byte units). Bottom 12 address bits are 000h" mask="0xFFFFF"/>
          <bitfield name="E32" caption="Enable 32KByte Erase opcode for this region. 0 = Disable, 1 = Enable" mask="0x1000000"/>
          <bitfield name="E64" caption="Enable 64KByte Erase opcode for this region. 0 = Disable, 1 = Enable" mask="0x2000000"/>
          <bitfield name="DV" caption="Flash Device 0 = CS0#, 1 = CS1#." mask="0x8000000"/>
          <bitfield name="RD" caption="Read Allowed for Region. 0 = No, 1 = Yes" mask="0x10000000"/>
          <bitfield name="WR" caption="Write Allowed for Region. 0 = No, 1 = Yes" mask="0x20000000"/>
          <bitfield name="EN" caption="Enable Register Pair for Monitoring. 0 = No, 1 = Yes" mask="0x80000000"/>
        </register>
        <register name="RT_LIMIT" offset="0x04" rw="RW" size="4" access-size="4" initval="0x00000000" caption="Runtime Monitoring Limit Register">
          <bitfield name="LMT" caption="Limit Register" mask="0xFFFFF"/>
        </register>
      </register-group>
      <register-group name="MT_MON" caption="Match Monitor Region Registers" size="0xC">
        <register name="MTMON_BEGIN" offset="0x00" rw="RW" size="4" access-size="4" initval="0x00000000" caption="Match Monitor Region Begin Register">
          <bitfield name="BGN" caption="The 19 bits of base address within the designated SPI Flash, specifying the last aligned 8K block." mask="0x7FFFF"/>
          <bitfield name="DV" caption="Flash Device number, applying to both Begin and End fields 0 = CS0#, 1 = CS1#" mask="0x80000000"/>
        </register>
        <register name="MTMON_END" offset="0x04" rw="RW" size="4" access-size="4" initval="0x00000000" caption="Match Monitor Region End Register">
          <bitfield name="END" caption="The 19 bits of base address within the designated SPI Flash, specifying the last aligned 8K block." mask="0x7FFFF"/>
        </register>
        <register name="MAP" offset="0x08" rw="RW" size="4" access-size="4" initval="0x00000000" caption="Match Monitor Region Map Register">
          <bitfield name="MAP" caption="The 19 bits of base address within the designated SPI Flash, specifying the last aligned 8K block." mask="0x7FFFF"/>
          <bitfield name="ME" caption="Match Enable for individual Region R" mask="0x80000000"/>
        </register>
      </register-group>
      <register-group name="LT_MON" caption="Load Monitor Region Registers" size="0x18">
        <register name="LM_CTRLSTS" offset="0x00" rw="RW" size="4" access-size="4" initval="0x00000000" caption="Loadtime Monitor Control/Status Register">
          <bitfield name="W" caption="Waiting" mask="0x1"/>
          <bitfield name="B" caption="Begin Byte seen" mask="0x2"/>
          <bitfield name="E" caption="End Byte seen" mask="0x4"/>
          <bitfield name="F" caption="Finalized and result ready" mask="0x8"/>
          <bitfield name="W_INTEN" caption="Enable Waiting Interrupt" mask="0x100"/>
          <bitfield name="B_INTEN" caption="Enable Begin Byte seen Interrupt" mask="0x200"/>
          <bitfield name="E_INTEN" caption="Enable End Byte seen Interrupt" mask="0x400"/>
          <bitfield name="F_INTEN" caption="Enable Finalized and result ready Interrupt" mask="0x800"/>
        </register>
        <register name="LM_CHN_CTRL" offset="0x04" rw="RW" size="4" access-size="4" initval="0x00000000" caption="Loadtime Monitor Channel Control Register">
          <bitfield name="GO" caption="GO: Run the Load Monitor for this channel" mask="0x1"/>
          <bitfield name="RST" caption="RST: Stop and Reset calculation for this channel when set to 1" mask="0x2"/>
          <bitfield name="RSF" caption="RSF: Reset just Result FIFO pointer when this bit is set to 1" mask="0x4"/>
          <bitfield name="FPTR" caption="FPTR: Result FIFO pointer. In 32Bit. Ranges: 0 to 11 for SHA-384 result 0 to 7 for SHA-256 result" mask="0xF00"/>
        </register>
        <register name="LM_BEGIN" offset="0x08" rw="RW" size="4" access-size="4" initval="0x00000000" caption="Loadtime Monitor Channel Begin Register">
          <bitfield name="BADDR" caption="A byte address within the designated Flash, specifying the first byte of the load image." mask="0x7FFFFFFF"/>
          <bitfield name="DV" caption="Flash Device number, applying to both Begin and End fields. 0 = CS0#, 1 = CS1#" mask="0x80000000"/>
        </register>
        <register name="LM_END" offset="0x0C" rw="RW" size="4" access-size="4" initval="0x00000000" caption="Loadtime Monitor Channel End Register">
          <bitfield name="EADDR" caption="A byte address within the designated Flash, specifying the last byte of the load image." mask="0xFFFFFFFF"/>
        </register>
        <register name="LM_COUNT" offset="0x10" rw="R" size="4" access-size="4" initval="0x00000000" caption="Loadtime Monitor Channel Count Register">
          <bitfield name="CNT" caption="A Read-Only count of bytes processed." mask="0xFFFFFFFF"/>
        </register>
        <register name="LM_DIGEST" offset="0x14" rw="R" size="4" access-size="4" initval="0x00000000" caption="Loadtime Monitor Channel Digest Register">
          <bitfield name="DGST" caption="A Read-Only FIFO Portal to Hash digest result. 12 or 8 Dwords depending on algorithm." mask="0xFFFFFFFF"/>
        </register>
      </register-group>
      <register-group name="SPI_MON" caption="SPI Monitor Block">
        <register name="MNTR_CTRL" offset="0x00" rw="RW" size="4" access-size="4" initval="0x00000000" caption="SPI Monitor Control Register">
          <bitfield name="ACT" caption="Activate 1= Activate, 0= De-activate" mask="0x1"/>
          <bitfield name="LCK_ACT" caption="Lock Activate 1= Activate field Locked, 0= Activate field unlocked" mask="0x2"/>
          <bitfield name="SFT_RST" caption="Soft Reset. This field is auto cleared by hardware. 1= Soft Reset SPI Monitor, 0 = No Effect" mask="0x100"/>
          <bitfield name="TAP_SEL" caption="CPTR_CLK_TAP_SEL selects which 0.5ns delay tap to have the capture clock on.      00h = 0 ns delay (or if TAP_EN = 0).     01h = 0.5ns nom delay; +/- 50%     02h = 1.0ns      03h = 1.5ns     04h = 2.0ns     etc.     1Fh = 15.5ns" mask="0x1F0000"/>
          <bitfield name="TAP_EN" caption="CPTR_CLK_TAP_EN enable the delay taps. It is recommended that a customer set the TAP_EN bit to 1, and the TAP_SEL field to 04h." mask="0x200000"/>
        </register>
        <register name="CFG_STS" offset="0x04" rw="RW" size="4" access-size="4" initval="0x00000000" caption="SPI Configuration Status Register">
          <bitfield name="IMD" caption="Flash Intervention Mode. 0 = Power-Off (POR), 1 = RESET# Pulse " mask="0x1"/>
          <bitfield name="RST2CSH" caption="RESET# to CS# High Delay. 2^n x 20us, 00h=20us, 1Fh= 1.3sec. IRQ triggers at this point also." mask="0x3E"/>
          <bitfield name="QBD" caption="Quad Bus Disable, 1 = Half Bus Mode,  0 = IO[3:0] are all controlled by EQS." mask="0x40"/>
          <bitfield name="XQS" caption="Cross-Over Q-Switch status. (BMC-&gt;CPU). RO image of Interbus bit which as 1 overrides EQS bit at both SPI buses without changing their states." mask="0x80"/>
          <bitfield name="EQS" caption="Enable Q-Switch (Isolator) to Host. 0 = Disable, 1 = Enable." mask="0x100"/>
          <bitfield name="CSRT" caption="Chip Select Routing.      000 = Both CSn#_In pass directly to CSn# Out, both enabled out.     001 = CS1n_In passes to CS1# Output, but CS0# Output is disabled (floats high).     010 = CS0n_In passes to CS0# Output, but CS1# Output is disabled (floats high).     100 = Swap CS1#/CS0#_In to CS0#/CS1# Out respectively, both enabled out.     101 = CS0n_In passes to CS1# Out, and CS0# Output is disabled (floats high).     110 = CS1n_In passes to CS0# Out, and CS1# Output is disabled (floats high).     x11 = CS0n/CS1n Outputs are both disabled (floating high) regardless of inputs." mask="0xE00"/>
          <bitfield name="F0F" caption="Enable following of Address Mode. (SPI Snooping) for each Flash. 0=Disable, 1=Enable" mask="0x1000"/>
          <bitfield name="F1F" caption="Enable following of Address Mode. (SPI Snooping) for each Flash. 0=Disable, 1=Enable" mask="0x2000"/>
          <bitfield name="F0A" caption="Set 3B/4B Address Mode for Flash 0. 0=3B Address Mode, 1=4B Address Mode" mask="0x4000"/>
          <bitfield name="F1A" caption="Set 3B/4B Address Mode for Flash 1. 0=3B Address Mode, 1=4B Address Mode" mask="0x8000"/>
          <bitfield name="F0SIZE" caption="Flash 0 Size. Flash sizes are expressed in bytes as a power of 2, matching a Flash Get-ID convention.     For the most common cases:      17h = 23d =&gt; 2^23 = 8MByte     18h = 24d =&gt; 2^24 = 16MByte     19h = 25d =&gt; 2^25 = 32MByte     1Ah = 26d =&gt; 2^26 = 64MByte" mask="0x1F0000"/>
          <bitfield name="E0W" caption="Enable Wrap Detection. 0=Disable, 1=Enable." mask="0x200000"/>
          <bitfield name="F0P" caption="Flash 0 Present. 0=Not Present, 1=Present" mask="0x800000"/>
          <bitfield name="F1SIZE" caption="Flash 1 Size. Flash sizes are expressed in bytes as a power of 2, matching a Flash Get-ID convention.     For the most common cases:      17h = 23d =&gt; 2^23 = 8MByte     18h = 24d =&gt; 2^24 = 16MByte     19h = 25d =&gt; 2^25 = 32MByte     1Ah = 26d =&gt; 2^26 = 64MByte" mask="0x1F000000"/>
          <bitfield name="E1W" caption="Enable Wrap Detection. 0=Disable, 1=Enable" mask="0x20000000"/>
          <bitfield name="F1P" caption="Flash 1 Present. 0=Not Present, 1=Present" mask="0x80000000"/>
        </register>
        <register name="SPICFG2" offset="0x08" rw="RW" size="4" access-size="4" initval="0x00000000" caption="SPI Monitor Configuration 2 Register">
          <bitfield name="HRM" caption="Host Reset Mode. 0 = APn_RESET#, 1 = Pin." mask="0x1"/>
          <bitfield name="HRL" caption="HRM Bit Lock. 0 = Unlocked, 1 = Locked." mask="0x2"/>
          <bitfield name="DIV" caption="Disable Inter Vention. 1 = IRQ-only Mode." mask="0x100"/>
          <bitfield name="DIL" caption="DIV Bit Lock. 0 = Unlocked, 1 = Locked." mask="0x200"/>
          <bitfield name="RIV" caption="Special Region InterVention Mode. If DIV=1 then RIV is ignored.     If DIV=0 and RIV=1 then: Reads that are forbidden by the Runtime Region register set     are only cancelled by gating off CSn# for that SPI command, and setting the IRQ.     No system shutdown results, and subsequent legal Reads are allowed." mask="0x1000"/>
          <bitfield name="RIL" caption="RIV Bit Lock. 0 = Unlocked, 1 = Locked." mask="0x2000"/>
          <bitfield name="ALG" caption="Hash Algorithm Mode. 0 = SHA-384, 1 = Reserved " mask="0x10000"/>
          <bitfield name="ALL" caption="ALG Bit Lock. 0 = Unlocked, 1 = Locked." mask="0x20000"/>
        </register>
        <register name="VIOCTRLSTS" offset="0x0C" rw="RW" size="4" access-size="4" initval="0x00000000" caption="Violation IRQ Control/Status Register">
          <bitfield name="OP" caption="Opcode Violation" mask="0x1"/>
          <bitfield name="MC" caption="Data Mismatch Violation" mask="0x2"/>
          <bitfield name="OB" caption="Out of Bounds. Outside all Runtime Regions" mask="0x4"/>
          <bitfield name="RG" caption="Runtime Region R/W Permission Violation" mask="0x8"/>
          <bitfield name="MT" caption="Timeout in Match Phase" mask="0x10"/>
          <bitfield name="AW" caption="Address Wrap within a Flash device." mask="0x20"/>
          <bitfield name="EOP" caption="Enable Opcode Violation Interrupt. 0 = Disable, 1 = Enable" mask="0x100"/>
          <bitfield name="EMC" caption="Enable Data Mismatch Violation Interrupt. 0 = Disable, 1 = Enable" mask="0x200"/>
          <bitfield name="EOB" caption="Enable Out of Bounds Interrupt. 0 = Disable, 1 = Enable" mask="0x400"/>
          <bitfield name="ERG" caption="Enable Runtime Region R/W Permission Violation Interrupt. 0 = Disable, 1 = Enable" mask="0x800"/>
          <bitfield name="EMT" caption="Enable Timeout in Match Phase Interrupt. 0 = Disable, 1 = Enable" mask="0x1000"/>
          <bitfield name="EAW" caption="Enable Address Wrap within a Flash device Interrupt. 0 = Disable, 1 = Enable" mask="0x2000"/>
        </register>
        <register name="IVN_STS" offset="0x10" rw="R" size="1" access-size="1" initval="0x00" caption="SPI Intervention Status Register">
          <bitfield name="FCS" caption="Flash Chip Selects forced high and bus forced low." mask="0x1"/>
          <bitfield name="FPO" caption="Flash Power or RESET# Activated." mask="0x2"/>
          <bitfield name="HRS" caption="Host held in Reset" mask="0x4"/>
          <bitfield name="HIS" caption="Host held Isolated" mask="0x8"/>
        </register>
        <register name="IVN_REC" offset="0x11" rw="W" size="1" access-size="1" initval="0x00" caption="SPI Intervention Recovery Register">
          <bitfield name="FCC" caption="Write 1 to clear FCS Flash Chip Selects forced high and bus forced low." mask="0x1"/>
          <bitfield name="FPC" caption="Write 1 to clear FPO Flash Power or RESET# Activated." mask="0x2"/>
          <bitfield name="HRC" caption="Write 1 to clear HRS Host held in Reset" mask="0x4"/>
          <bitfield name="HIC" caption="Write 1 to clear HIS Host held Isolated" mask="0x8"/>
        </register>
        <register name="VIO_STS" offset="0x14" rw="RW" size="4" access-size="4" initval="0x00000000" caption="Violation Log Register">
          <bitfield name="OP" caption="Opcode Violation" mask="0x1"/>
          <bitfield name="ROB" caption="Region Failure, Out of Bounds" mask="0x4"/>
          <bitfield name="REG" caption="Runtime Region Violation" mask="0x8"/>
          <bitfield name="AWP" caption="Address Wrap" mask="0x20"/>
          <bitfield name="DV" caption="Device Number" mask="0x40"/>
          <bitfield name="REGION" caption="Region Number" mask="0xF80"/>
          <bitfield name="RD" caption="Killed as a Read" mask="0x1000"/>
          <bitfield name="PE" caption="Killed as a Program or Erase" mask="0x2000"/>
          <bitfield name="AM" caption="Flash Address Mode" mask="0x4000"/>
          <bitfield name="CLR" caption="Clear Register RW1C. This bit is auto clearing" mask="0x8000"/>
          <bitfield name="OPCOD" caption="Flash Opcode" mask="0xFF0000"/>
          <bitfield name="DAT" caption="SPI Data Byte" mask="0xFF000000"/>
        </register>
        <register name="ERR_ADDR" offset="0x18" rw="R" size="4" access-size="4" initval="0x00000000" caption="Error Byte Address Register">
          <bitfield name="ADDR" caption="Byte address at which the error occurred, within the designated Flash" mask="0xFFFFFFFF"/>
        </register>
        <register-group name="FLASH_SET" name-in-module="FLASH_SET" offset="0x20" size="0x80" count="2"/>
        <register-group name="RN_TM" name-in-module="RN_TM" offset="0x120" size="0x8" count="16"/>
        <register name="MTMON_CTRLSTS" offset="0x1D0" rw="RW" size="4" access-size="4" initval="0x00000000" caption="Match Monitor Control/Status Register">
          <bitfield name="T" caption="Timeout" mask="0x1"/>
          <bitfield name="F" caption="First Fetch in any Match region" mask="0x2"/>
          <bitfield name="AM" caption="Set to 1 on a 3B/4B Address Mode switch on either Flash." mask="0x4"/>
          <bitfield name="ET_IRQ" caption="Enable Timeout Interrupt" mask="0x100"/>
          <bitfield name="EF_IRQ" caption="Enable First Fetch in any Match region Interrupt" mask="0x200"/>
          <bitfield name="AM_IRQ" caption="Enable 3B/4B Address Mode switch on either Flash Interrupt" mask="0x400"/>
          <bitfield name="FIFO_MTY" caption="FIFO Empty" mask="0x10000"/>
          <bitfield name="FIFO_FUL" caption="FIFO Full" mask="0x20000"/>
          <bitfield name="FIFO_OVRF" caption="FIFO Overflow" mask="0x40000"/>
          <bitfield name="FIFO_UDRF" caption="FIFO Underflow" mask="0x80000"/>
          <bitfield name="CLR_FIFO" caption="Clear FIFO. This field is autocleared by hardware" mask="0x1000000"/>
        </register>
        <register name="MTMON_ENMD" offset="0x1D4" rw="RW" size="4" access-size="4" initval="0x00000000" caption="Match Monitor Enable/Mode Register">
          <bitfield name="MON_EN" caption="Enable Data Matching. 0 = Disabled, 1 = Enabled" mask="0x1"/>
          <bitfield name="MON_MS" caption="Match Pattern Source Mode: 0 = SRAM, 1 = Internal Flash." mask="0x100"/>
        </register>
        <register name="MTMON_TCTRL" offset="0x1D8" rw="RW" size="4" access-size="4" initval="0x00000000" caption="Match Fetch Timeout Control Register">
          <bitfield name="ST" caption="Start Timeout Counter" mask="0x1"/>
          <bitfield name="TV" caption="Timeout Value 0 to 32" mask="0x1F0000"/>
          <bitfield name="TU" caption="Timeout Unit 00 = none (off), 01 = 32ms, 10 = 128ms, 11 = 1sec" mask="0x600000"/>
        </register>
        <register-group name="MT_MON" name-in-module="MT_MON" offset="0x1E0" size="0xC" count="8"/>
        <register name="MTMON_VIOSTS" offset="0x240" rw="RW" size="4" access-size="4" initval="0x00000000" caption="Match Monitor Violation Log Register">
          <bitfield name="MTO" caption="Match Monitor Timeout. This is read-Only bit." mask="0x10"/>
          <bitfield name="DV" caption="Device Number. This is read-Only bit. 0 = CS0, 1 = CS1." mask="0x40"/>
          <bitfield name="RGN" caption="Region. This is read-Only bit. Shows which of 8 Match regions [7:0] got the mismatch." mask="0xF80"/>
          <bitfield name="AM" caption="Flash Address Mode 0 = 3-byte, 1 = 4-byte" mask="0x4000"/>
          <bitfield name="CLR" caption="Clear Register RW1C. This bit is auto clearing" mask="0x8000"/>
          <bitfield name="OPCOD" caption="Flash Opcode" mask="0xFF0000"/>
          <bitfield name="DATA" caption="SPI Data Byte" mask="0xFF000000"/>
        </register>
        <register name="MTMON_VIOADDR" offset="0x244" rw="R" size="4" access-size="4" initval="0x00000000" caption="Match Monitor Violation Address Register">
          <bitfield name="ADDR" caption="Byte address at which the error occurred, within the designated Flash" mask="0xFFFFFFFF"/>
        </register>
        <register name="LTMON_AGGR" offset="0x250" rw="RW" size="4" access-size="4" initval="0x00000000" caption="Loadtime (Hash) IRQ Aggregation Register">
          <bitfield name="IRQ0" caption="Load 0 Interrupt" mask="0x1"/>
          <bitfield name="IRQ1" caption="Load 1 Interrupt" mask="0x2"/>
          <bitfield name="IRQ2" caption="Load 2 Interrupt" mask="0x4"/>
          <bitfield name="IRQ3" caption="Load 3 Interrupt" mask="0x8"/>
          <bitfield name="IRQ4" caption="Load 4 Interrupt" mask="0x10"/>
          <bitfield name="IRQ5" caption="Load 5 Interrupt" mask="0x20"/>
          <bitfield name="IRQ6" caption="Load 6 Interrupt" mask="0x40"/>
          <bitfield name="IRQ7" caption="Load 7 Interrupt" mask="0x80"/>
          <bitfield name="EN_IRQ0" caption="Enable Load 0 Interrupt" mask="0x100"/>
          <bitfield name="EN_IRQ1" caption="Enable Load 1 Interrupt" mask="0x200"/>
          <bitfield name="EN_IRQ2" caption="Enable Load 2 Interrupt" mask="0x400"/>
          <bitfield name="EN_IRQ3" caption="Enable Load 3 Interrupt" mask="0x800"/>
          <bitfield name="EN_IRQ4" caption="Enable Load 4 Interrupt" mask="0x1000"/>
          <bitfield name="EN_IRQ5" caption="Enable Load 5 Interrupt" mask="0x2000"/>
          <bitfield name="EN_IRQ6" caption="Enable Load 6 Interrupt" mask="0x4000"/>
          <bitfield name="EN_IRQ7" caption="Enable Load 7 Interrupt" mask="0x8000"/>
        </register>
        <register-group name="LT_MON" name-in-module="LT_MON" offset="0x254" size="0x18" count="8"/>
        <register name="LTMON_CTRLSTS" offset="0x314" rw="RW" size="4" access-size="4" initval="0x00000000" caption="Load Monitor Control/Status Register">
          <bitfield name="FIFO_MTY" caption="FIFO Empty" mask="0x1"/>
          <bitfield name="FIFO_FUL" caption="FIFO Full" mask="0x2"/>
          <bitfield name="FIFO_OVRF" caption="FIFO Overflow" mask="0x4"/>
          <bitfield name="FIFO_UDRF" caption="FIFO Underflow" mask="0x8"/>
          <bitfield name="CLR_FIFO" caption="Clear FIFO " mask="0x100"/>
        </register>
      </register-group>
    </module>
    <module name="NVIC" version="1.0.0" caption="Nested Vectored Interrupt Controller">
      <register-group name="NVIC" caption="Nested Vectored Interrupt Controller">
        <register name="ISER" offset="0x0" rw="RW" size="4" access-size="4" count="1" initval="0" caption="Interrupt Set Enable Register">
          <bitfield name="SETENA" caption="Interrupt set enable bits" mask="0xFFFFFFFF"/>
        </register>
        <register name="ICER" offset="0x80" rw="RW" size="4" access-size="4" count="1" initval="0" caption="Interrupt Clear Enable Register">
          <bitfield name="CLRENA" caption="Interrupt clear-enable bits" mask="0xFFFFFFFF"/>
        </register>
        <register name="ISPR" offset="0x100" rw="RW" size="4" access-size="4" count="1" initval="0" caption="Interrupt Set Pending Register">
          <bitfield name="SETPEND" caption="Interrupt set-pending bits" mask="0xFFFFFFFF"/>
        </register>
        <register name="ICPR" offset="0x180" rw="RW" size="4" access-size="4" count="1" initval="0" caption="Interrupt Clear Pending Register">
          <bitfield name="CLRPEND" caption="Interrupt clear-pending bits" mask="0xFFFFFFFF"/>
        </register>
        <register name="IABR" offset="0x200" rw="RW" size="4" access-size="4" count="1" initval="0" caption="Interrupt Active Bit Register">
          <bitfield name="ACTIVE" caption="Interrupt active bits" mask="0xFFFFFFFF"/>
        </register>
        <register name="IP" offset="0x300" rw="RW" size="1" access-size="1" count="8" initval="0" caption="Interrupt Priority Register n">
          <bitfield name="PRI0" caption="Priority of interrupt n" mask="0x7"/>
        </register>
        <register name="STIR" offset="0xE00" rw="W" size="4" access-size="4" caption="Software Trigger Interrupt Register">
          <bitfield name="INTID" caption="Interrupt ID to trigger" mask="0x1FF"/>
        </register>
      </register-group>
    </module>
    <module name="SysTick" version="1.0.0" caption="System timer">
      <register-group name="SysTick" caption="System timer">
        <register name="CSR" offset="0x0" rw="RW" size="4" access-size="4" initval="0x0" caption="SysTick Control and Status Register">
          <bitfield name="ENABLE" caption="SysTick Counter Enable" mask="0x1" values="SysTick_CSR__ENABLE"/>
          <bitfield name="TICKINT" caption="SysTick Exception Request Enable" mask="0x2" values="SysTick_CSR__TICKINT"/>
          <bitfield name="CLKSOURCE" caption="Clock Source 0=external, 1=processor" mask="0x4" values="SysTick_CSR__CLKSOURCE"/>
          <bitfield name="COUNTFLAG" caption="Timer counted to 0 since last read of register" mask="0x10000"/>
        </register>
        <register name="RVR" offset="0x4" rw="RW" size="4" access-size="4" caption="SysTick Reload Value Register">
          <bitfield name="RELOAD" caption="Value to load into the SysTick Current Value Register when the counter reaches 0" mask="0xFFFFFF"/>
        </register>
        <register name="CVR" offset="0x8" rw="RW" size="4" access-size="4" caption="SysTick Current Value Register">
          <bitfield name="CURRENT" caption="Current value at the time the register is accessed" mask="0xFFFFFF"/>
        </register>
        <register name="CALIB" offset="0xC" rw="R" size="4" access-size="4" initval="0" caption="SysTick Calibration Value Register">
          <bitfield name="TENMS" caption="Reload value to use for 10ms timing" mask="0xFFFFFF"/>
          <bitfield name="SKEW" caption="TENMS is rounded from non-integer ratio" mask="0x40000000" values="SysTick_CALIB__SKEW"/>
          <bitfield name="NOREF" caption="No Separate Reference Clock" mask="0x80000000" values="SysTick_CALIB__NOREF"/>
        </register>
      </register-group>
      <value-group name="SysTick_CSR__CLKSOURCE">
        <value name="VALUE_0" caption="External clock" value="0"/>
        <value name="VALUE_1" caption="Processor clock" value="1"/>
      </value-group>
      <value-group name="SysTick_CSR__ENABLE">
        <value name="VALUE_0" caption="Counter disabled" value="0"/>
        <value name="VALUE_1" caption="Counter enabled" value="1"/>
      </value-group>
      <value-group name="SysTick_CSR__TICKINT">
        <value name="VALUE_0" caption="Counting down to 0 does not assert the SysTick exception request" value="0"/>
        <value name="VALUE_1" caption="Counting down to 0 asserts the SysTick exception request" value="1"/>
      </value-group>
      <value-group name="SysTick_CALIB__NOREF">
        <value name="VALUE_0" caption="The reference clock is provided" value="0"/>
        <value name="VALUE_1" caption="The reference clock is not provided" value="1"/>
      </value-group>
      <value-group name="SysTick_CALIB__SKEW">
        <value name="VALUE_0" caption="10ms calibration value is exact" value="0"/>
        <value name="VALUE_1" caption="10ms calibration value is inexact, because of the clock frequency" value="1"/>
      </value-group>
    </module>
    <module name="SystemControl" version="1.0.0" caption="System Control Registers">
      <register-group name="SystemControl" caption="System Control Registers">
        <register name="ICTR" offset="0x4" rw="R" size="4" access-size="4" caption="Interrupt Controller Type Register">
          <bitfield name="INTLINESNUM" caption="" mask="0xF"/>
        </register>
        <register name="ACTLR" offset="0x8" rw="RW" size="4" access-size="4" caption="Auxiliary Control Register">
          <bitfield name="DISMCYCINT" caption="Disable interruption of LDM/STM instructions" mask="0x1"/>
          <bitfield name="DISDEFWBUF" caption="Disable wruite buffer use during default memory map accesses" mask="0x2"/>
          <bitfield name="DISFOLD" caption="Disable IT folding" mask="0x4"/>
          <bitfield name="DISFPCA" caption="Disable automatic update of CONTROL.FPCA" mask="0x100"/>
          <bitfield name="DISOOFP" caption="Disable out-of-order FP instructions" mask="0x200"/>
        </register>
        <register name="CPUID" offset="0xD00" rw="R" size="4" access-size="4" initval="0x410FC241" caption="CPUID Base Register">
          <bitfield name="REVISION" caption="Processor revision number" mask="0xF"/>
          <bitfield name="PARTNO" caption="Process Part Number, 0xC24=Cortex-M4" mask="0xFFF0"/>
          <bitfield name="CONSTANT" caption="Constant" mask="0xF0000"/>
          <bitfield name="VARIANT" caption="Variant number" mask="0xF00000"/>
          <bitfield name="IMPLEMENTER" caption="Implementer code, 0x41=ARM" mask="0xFF000000"/>
        </register>
        <register name="ICSR" offset="0xD04" rw="RW" size="4" access-size="4" initval="0" caption="Interrupt Control and State Register">
          <bitfield name="VECTACTIVE" caption="Active exception number" mask="0x1FF"/>
          <bitfield name="RETTOBASE" caption="No preempted active exceptions to execute" mask="0x800"/>
          <bitfield name="VECTPENDING" caption="Exception number of the highest priority pending enabled exception" mask="0x3F000"/>
          <bitfield name="ISRPENDING" caption="Interrupt pending flag" mask="0x400000"/>
          <bitfield name="ISRPREEMPT" caption="Debug only" mask="0x800000"/>
          <bitfield name="PENDSTCLR" caption="SysTick clear-pending bit" mask="0x2000000" values="SystemControl_ICSR__PENDSTCLR"/>
          <bitfield name="PENDSTSET" caption="SysTick set-pending bit" mask="0x4000000" values="SystemControl_ICSR__PENDSTSET"/>
          <bitfield name="PENDSVCLR" caption="PendSV clear-pending bit" mask="0x8000000" values="SystemControl_ICSR__PENDSVCLR"/>
          <bitfield name="PENDSVSET" caption="PendSV set-pending bit" mask="0x10000000" values="SystemControl_ICSR__PENDSVSET"/>
          <bitfield name="NMIPENDSET" caption="NMI set-pending bit" mask="0x80000000" values="SystemControl_ICSR__NMIPENDSET"/>
        </register>
        <register name="AIRCR" offset="0xD0C" rw="RW" size="4" access-size="4" initval="0xFA050000" caption="Application Interrupt and Reset Control Register">
          <bitfield name="VECTRESET" caption="Must write 0" mask="0x1"/>
          <bitfield name="VECTCLRACTIVE" caption="Must write 0" mask="0x2"/>
          <bitfield name="SYSRESETREQ" caption="System Reset Request" mask="0x4" values="SystemControl_AIRCR__SYSRESETREQ"/>
          <bitfield name="PRIGROUP" caption="Interrupt priority grouping" mask="0x700"/>
          <bitfield name="ENDIANNESS" caption="Data endianness, 0=little, 1=big" mask="0x8000" values="SystemControl_AIRCR__ENDIANNESS"/>
          <bitfield name="VECTKEY" caption="Register key" mask="0xFFFF0000"/>
        </register>
        <register name="SCR" offset="0xD10" rw="RW" size="4" access-size="4" initval="0" caption="System Control Register">
          <bitfield name="SLEEPONEXIT" caption="Sleep-on-exit on handler return" mask="0x2" values="SystemControl_SCR__SLEEPONEXIT"/>
          <bitfield name="SLEEPDEEP" caption="Deep Sleep used as low power mode" mask="0x4" values="SystemControl_SCR__SLEEPDEEP"/>
          <bitfield name="SEVONPEND" caption="Send Event on Pending bit" mask="0x10" values="SystemControl_SCR__SEVONPEND"/>
        </register>
        <register name="CCR" offset="0xD14" rw="RW" size="4" access-size="4" initval="0x00000200" caption="Configuration and Control Register">
          <bitfield name="NONBASETHRDENA" caption="Indicates how processor enters Thread mode" mask="0x1"/>
          <bitfield name="USERSETMPEND" caption="Enables unprivileged software access to STIR register" mask="0x2"/>
          <bitfield name="UNALIGN_TRP" caption="Enables unaligned access traps" mask="0x8" values="SystemControl_CCR__UNALIGN_TRP"/>
          <bitfield name="DIV_0_TRP" caption="Enables divide by 0 trap" mask="0x10"/>
          <bitfield name="BFHFNMIGN" caption="Ignore LDM/STM BusFault for -1/-2 priority handlers" mask="0x100"/>
          <bitfield name="STKALIGN" caption="Indicates stack alignment on exception entry" mask="0x200" values="SystemControl_CCR__STKALIGN"/>
        </register>
        <register name="SHPR1" offset="0xD18" rw="RW" size="4" access-size="4" caption="System Handler Priority Register 1">
          <bitfield name="PRI_4" caption="Priority of system handler 4, MemManage" mask="0xFF"/>
          <bitfield name="PRI_5" caption="Priority of system handler 5, BusFault" mask="0xFF00"/>
          <bitfield name="PRI_6" caption="Priority of system handler 6, UsageFault" mask="0xFF0000"/>
        </register>
        <register name="SHPR2" offset="0xD1C" rw="RW" size="4" access-size="4" initval="0" caption="System Handler Priority Register 2">
          <bitfield name="PRI_11" caption="Priority of system handler 11, SVCall" mask="0xFF000000"/>
        </register>
        <register name="SHPR3" offset="0xD20" rw="RW" size="4" access-size="4" initval="0" caption="System Handler Priority Register 3">
          <bitfield name="PRI_14" caption="Priority of system handler 14, PendSV" mask="0xFF0000"/>
          <bitfield name="PRI_15" caption="Priority of system handler 15, SysTick exception" mask="0xFF000000"/>
        </register>
        <register name="SHCSR" offset="0xD24" rw="RW" size="4" access-size="4" caption="System Handler Control and State Register">
          <bitfield name="MEMFAULTACT" caption="MemManage exception active bit" mask="0x1"/>
          <bitfield name="BUSFAULTACT" caption="BusFault exception active bit" mask="0x2"/>
          <bitfield name="USGFAULTACT" caption="UsageFault exception active bit" mask="0x8"/>
          <bitfield name="SVCALLACT" caption="SVCall active bit" mask="0x80"/>
          <bitfield name="MONITORACT" caption="DebugMonitor exception active bit" mask="0x100"/>
          <bitfield name="PENDSVACT" caption="PendSV exception active bit" mask="0x400"/>
          <bitfield name="SYSTICKACT" caption="SysTick exception active bit" mask="0x800"/>
          <bitfield name="USGFAULTPENDED" caption="UsageFault exception pending bit" mask="0x1000"/>
          <bitfield name="MEMFAULTPENDED" caption="MemManage exception pending bit" mask="0x2000"/>
          <bitfield name="BUSFAULTPENDED" caption="BusFault exception pending bit" mask="0x4000"/>
          <bitfield name="SVCALLPENDED" caption="SVCall pending bit" mask="0x8000"/>
          <bitfield name="MEMFAULTENA" caption="MemManage enable bit" mask="0x10000"/>
          <bitfield name="BUSFAULTENA" caption="BusFault enable bit" mask="0x20000"/>
          <bitfield name="USGFAULTENA" caption="UsageFault enable bit" mask="0x40000"/>
        </register>
        <register name="CFSR" offset="0xD28" rw="RW" size="4" access-size="4" caption="Configurable Fault Status Register">
          <bitfield name="IACCVIOL" caption="Instruction access violation" mask="0x1"/>
          <bitfield name="DACCVIOL" caption="Data access violation" mask="0x2"/>
          <bitfield name="MUNSTKERR" caption="MemManage Fault on unstacking for exception return" mask="0x8"/>
          <bitfield name="MSTKERR" caption="MemManage Fault on stacking for exception entry" mask="0x10"/>
          <bitfield name="MLSPERR" caption="MemManager Fault occured during FP lazy state preservation" mask="0x20"/>
          <bitfield name="MMARVALID" caption="MemManage Fault Address Register valid" mask="0x80"/>
          <bitfield name="IBUSERR" caption="Instruction bus error" mask="0x100"/>
          <bitfield name="PRECISERR" caption="Precise data bus error" mask="0x200"/>
          <bitfield name="IMPRECISERR" caption="Imprecise data bus error" mask="0x400"/>
          <bitfield name="UNSTKERR" caption="BusFault on unstacking for exception return" mask="0x800"/>
          <bitfield name="STKERR" caption="BusFault on stacking for exception entry" mask="0x1000"/>
          <bitfield name="LSPERR" caption="BusFault occured during FP lazy state preservation" mask="0x2000"/>
          <bitfield name="BFARVALID" caption="BusFault Address Register valid" mask="0x8000"/>
          <bitfield name="UNDEFINSTR" caption="Undefined instruction UsageFault" mask="0x10000"/>
          <bitfield name="INVSTATE" caption="Invalid state UsageFault" mask="0x20000"/>
          <bitfield name="INVPC" caption="Invalid PC load UsageFault" mask="0x40000"/>
          <bitfield name="NOCP" caption="No coprocessor UsageFault" mask="0x80000"/>
          <bitfield name="UNALIGNED" caption="Unaligned access UsageFault" mask="0x1000000"/>
          <bitfield name="DIVBYZERO" caption="Divide by zero UsageFault" mask="0x2000000"/>
        </register>
        <register name="HFSR" offset="0xD2C" rw="RW" size="4" access-size="4" caption="HardFault Status Register">
          <bitfield name="VECTTBL" caption="BusFault on a Vector Table read during exception processing" mask="0x2"/>
          <bitfield name="FORCED" caption="Forced Hard Fault" mask="0x40000000"/>
          <bitfield name="DEBUGEVT" caption="Debug: always write 0" mask="0x80000000"/>
        </register>
        <register name="DFSR" offset="0xD30" rw="RW" size="4" access-size="4" caption="Debug Fault Status Register">
          <bitfield name="HALTED" caption="" mask="0x1"/>
          <bitfield name="BKPT" caption="" mask="0x2"/>
          <bitfield name="DWTTRAP" caption="" mask="0x4"/>
          <bitfield name="VCATCH" caption="" mask="0x8"/>
          <bitfield name="EXTERNAL" caption="" mask="0x10"/>
        </register>
        <register name="MMFAR" offset="0xD34" rw="RW" size="4" access-size="4" caption="MemManage Fault Address Register">
          <bitfield name="ADDRESS" caption="Address that generated the MemManage fault" mask="0xFFFFFFFF"/>
        </register>
        <register name="BFAR" offset="0xD38" rw="RW" size="4" access-size="4" caption="BusFault Address Register">
          <bitfield name="ADDRESS" caption="Address that generated the BusFault" mask="0xFFFFFFFF"/>
        </register>
        <register name="AFSR" offset="0xD3C" rw="RW" size="4" access-size="4" caption="Auxiliary Fault Status Register">
          <bitfield name="IMPDEF" caption="AUXFAULT input signals" mask="0xFFFFFFFF"/>
        </register>
        <register name="PFR" offset="0xD40" rw="RW" size="4" access-size="4" count="2" caption="Processor Feature Register">
        </register>
        <register name="DFR" offset="0xD48" rw="R" size="4" access-size="4" caption="Debug Feature Register">
        </register>
        <register name="ADR" offset="0xD4C" rw="R" size="4" access-size="4" caption="Auxiliary Feature Register">
        </register>
        <register name="MMFR" offset="0xD50" rw="R" size="4" access-size="4" count="4" caption="Memory Model Feature Register">
        </register>
        <register name="ISAR" offset="0xD60" rw="R" size="4" access-size="4" count="5" caption="Instruction Set Attributes Register">
        </register>
        <register name="CPACR" offset="0xD88" rw="RW" size="4" access-size="4" caption="Coprocessor Access Control Register">
          <bitfield name="CP10" caption="Access privileges for coprocessor 10" mask="0x300000" values="SystemControl_CPACR__CP10"/>
          <bitfield name="CP11" caption="Access privileges for coprocessor 11" mask="0xC00000" values="SystemControl_CPACR__CP11"/>
        </register>
      </register-group>
      <value-group name="SystemControl_ICSR__NMIPENDSET">
        <value name="VALUE_0" caption="Write: no effect; read: NMI exception is not pending" value="0"/>
        <value name="VALUE_1" caption="Write: changes NMI exception state to pending; read: NMI exception is pending" value="1"/>
      </value-group>
      <value-group name="SystemControl_ICSR__PENDSTCLR">
        <value name="VALUE_0" caption="No effect" value="0"/>
        <value name="VALUE_1" caption="Removes the pending state from the SysTick exception" value="1"/>
      </value-group>
      <value-group name="SystemControl_ICSR__PENDSTSET">
        <value name="VALUE_0" caption="Write: no effect; read: SysTick exception is not pending" value="0"/>
        <value name="VALUE_1" caption="Write: changes SysTick exception state to pending; read: SysTick exception is pending" value="1"/>
      </value-group>
      <value-group name="SystemControl_ICSR__PENDSVCLR">
        <value name="VALUE_0" caption="No effect" value="0"/>
        <value name="VALUE_1" caption="Removes the pending state from the PendSV exception" value="1"/>
      </value-group>
      <value-group name="SystemControl_ICSR__PENDSVSET">
        <value name="VALUE_0" caption="Write: no effect; read: PendSV exception is not pending" value="0"/>
        <value name="VALUE_1" caption="Write: changes PendSV exception state to pending; read: PendSV exception is pending" value="1"/>
      </value-group>
      <value-group name="SystemControl_AIRCR__ENDIANNESS">
        <value name="VALUE_0" caption="Little-endian" value="0"/>
        <value name="VALUE_1" caption="Big-endian" value="1"/>
      </value-group>
      <value-group name="SystemControl_AIRCR__SYSRESETREQ">
        <value name="VALUE_0" caption="No system reset request" value="0"/>
        <value name="VALUE_1" caption="Asserts a signal to the outer system that requests a reset" value="1"/>
      </value-group>
      <value-group name="SystemControl_SCR__SEVONPEND">
        <value name="VALUE_0" caption="Only enabled interrupts or events can wakeup the processor, disabled interrupts are excluded" value="0"/>
        <value name="VALUE_1" caption="Enabled events and all interrupts, including disabled interrupts, can wakeup the processor" value="1"/>
      </value-group>
      <value-group name="SystemControl_SCR__SLEEPDEEP">
        <value name="VALUE_0" caption="Sleep" value="0"/>
        <value name="VALUE_1" caption="Deep sleep" value="1"/>
      </value-group>
      <value-group name="SystemControl_SCR__SLEEPONEXIT">
        <value name="VALUE_0" caption="Do not sleep when returning to Thread mode" value="0"/>
        <value name="VALUE_1" caption="Enter sleep, or deep sleep, on return from an ISR" value="1"/>
      </value-group>
      <value-group name="SystemControl_CCR__STKALIGN">
        <value name="VALUE_0" caption="4-byte aligned" value="0"/>
        <value name="VALUE_1" caption="8-byte aligned" value="1"/>
      </value-group>
      <value-group name="SystemControl_CCR__UNALIGN_TRP">
        <value name="VALUE_0" caption="Do not trap unaligned halfword and word accesses" value="0"/>
        <value name="VALUE_1" caption="Trap unaligned halfword and word accesses" value="1"/>
      </value-group>
      <value-group name="SystemControl_CPACR__CP10">
        <value name="DENIED" caption="Access denied" value="0x0"/>
        <value name="PRIV" caption="Privileged access only" value="0x1"/>
        <value name="FULL" caption="Full access" value="0x3"/>
      </value-group>
      <value-group name="SystemControl_CPACR__CP11">
        <value name="DENIED" caption="Access denied" value="0x0"/>
        <value name="PRIV" caption="Privileged access only" value="0x1"/>
        <value name="FULL" caption="Full access" value="0x3"/>
      </value-group>
    </module>
  </modules>
  <pinouts>
    <pinout name="CEC1736_S0_2ZW" caption="CEC1736-S0-I/2ZW">
      <pin position="A4" pad="GPIO000"/>
      <pin position="J2" pad="GPIO002"/>
      <pin position="C6" pad="GPIO003"/>
      <pin position="C1" pad="GPIO004"/>
      <pin position="D6" pad="GPIO012"/>
      <pin position="F2" pad="GPIO013"/>
      <pin position="B3" pad="GPIO015"/>
      <pin position="K4" pad="GPIO016"/>
      <pin position="K1" pad="GPIO020"/>
      <pin position="J3" pad="GPIO021"/>
      <pin position="J7" pad="GPIO022"/>
      <pin position="E9" pad="GPIO023"/>
      <pin position="F7" pad="GPIO024"/>
      <pin position="A10" pad="GPIO026"/>
      <pin position="D5" pad="GPIO027"/>
      <pin position="B6" pad="GPIO030"/>
      <pin position="A3" pad="GPIO031"/>
      <pin position="K10" pad="GPIO032"/>
      <pin position="B4" pad="GPIO033"/>
      <pin position="A5" pad="GPIO034"/>
      <pin position="H9" pad="GPIO045"/>
      <pin position="A7" pad="GPIO046"/>
      <pin position="C2" pad="GPIO047"/>
      <pin position="B2" pad="GPIO050"/>
      <pin position="E1" pad="GPIO053"/>
      <pin position="K2" pad="GPIO055"/>
      <pin position="K7" pad="GPIO056"/>
      <pin position="D4" pad="GPIO057"/>
      <pin position="A1" pad="GPIO063"/>
      <pin position="D10" pad="GPIO070"/>
      <pin position="J9" pad="GPIO071"/>
      <pin position="E4" pad="GPIO104"/>
      <pin position="E2" pad="GPIO105"/>
      <pin position="E3" pad="GPIO106"/>
      <pin position="A6" pad="GPIO107"/>
      <pin position="F4" pad="GPIO112"/>
      <pin position="A2" pad="GPIO113"/>
      <pin position="H10" pad="GPIO120"/>
      <pin position="F9" pad="GPIO121"/>
      <pin position="K9" pad="GPIO122"/>
      <pin position="F10" pad="GPIO123"/>
      <pin position="J8" pad="GPIO124"/>
      <pin position="J10" pad="GPIO125"/>
      <pin position="G10" pad="GPIO126"/>
      <pin position="F3" pad="GPIO127"/>
      <pin position="B1" pad="GPIO130"/>
      <pin position="D2" pad="GPIO131"/>
      <pin position="C9" pad="GPIO132"/>
      <pin position="B7" pad="GPIO140"/>
      <pin position="A9" pad="GPIO143"/>
      <pin position="B9" pad="GPIO144"/>
      <pin position="B10" pad="GPIO145"/>
      <pin position="C10" pad="GPIO146"/>
      <pin position="B8" pad="GPIO147"/>
      <pin position="A8" pad="GPIO150"/>
      <pin position="H2" pad="GPIO156"/>
      <pin position="H1" pad="GPIO157"/>
      <pin position="B5" pad="GPIO163"/>
      <pin position="E10" pad="GPIO165"/>
      <pin position="G5" pad="GPIO170"/>
      <pin position="G9" pad="GPIO171"/>
      <pin position="K8" pad="GPIO200"/>
      <pin position="G2" pad="GPIO201"/>
      <pin position="K5" pad="GPIO202"/>
      <pin position="K3" pad="GPIO203"/>
      <pin position="K6" pad="GPIO204"/>
      <pin position="F8" pad="GPIO223"/>
      <pin position="J6" pad="GPIO224"/>
      <pin position="J4" pad="GPIO227"/>
      <pin position="J5" pad="GPIO250"/>
      <pin position="E8" pad="GPIO253"/>
      <pin position="G1" pad="JTAG_RST_N"/>
      <pin position="G4" pad="nRESET_IN"/>
      <pin position="G6" pad="VSS_ANALOG"/>
      <pin position="F1" pad="VTR_PLL"/>
      <pin position="D9" pad="VSS"/>
      <pin position="D7" pad="VTR_REG"/>
      <pin position="H5" pad="VTR1"/>
      <pin position="C5" pad="VTR_ANALOG"/>
      <pin position="D1" pad="VR_CAP"/>
      <pin position="E7" pad="VSS"/>
      <pin position="H6" pad="VTR2"/>
      <pin position="J1" pad="VSS"/>
      <pin position="G7" pad="VSS"/>
    </pinout>
  </pinouts>
</avr-tools-device-file>
