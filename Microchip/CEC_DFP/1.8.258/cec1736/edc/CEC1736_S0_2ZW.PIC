<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<edc:PIC xmlns:atdf="http://crownking/atdf" xmlns:edc="http://crownking/edc" xmlns:ltx="http://crownking/ltx" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://crownking/edc edc/PIC.xsd" edc:name="CEC1736_S0_2ZW" edc:arch="arm32bit" edc:procid="0x0000" atdf:architecture="CORTEX-M4" atdf:family="CEC173X" edc:hasFreeze="false" edc:masksetid="SG003">
  <edc:Properties>
    <edc:Property edc:propkey="file.registers.are.odd.address.accessible" edc:propvalue="true"/>
  </edc:Properties>
  <edc:Power>
    <edc:VDD edc:minvoltage="3.135" edc:maxvoltage="3.63" edc:nominalvoltage="3.300"/>
  </edc:Power>
  <edc:Programming edc:haslvp2="true"/>
  <edc:ArchDef edc:name="arm32bit" edc:desc="arm32bit">
    <edc:MemTraits edc:addrinc="0x1" edc:locsize="0x1" edc:wordimpl="0xFFFFFFFF" edc:wordinit="0xFFFFFFFF" edc:wordsafe="0xFFFFFFFF" edc:wordsize="0x4"/>
  </edc:ArchDef>
  <edc:InstructionSet edc:instructionsetid="armv7m"/>
  <edc:InterruptList>
    <edc:Interrupt edc:irq="-15" edc:cname="Reset" edc:desc="Reset Vector, invoked on Power up and warm reset"/>
    <edc:Interrupt edc:irq="-14" edc:cname="NonMaskableInt" edc:desc="Non maskable Interrupt, cannot be stopped or preempted"/>
    <edc:Interrupt edc:irq="-13" edc:cname="HardFault" edc:desc="Hard Fault, all classes of Fault"/>
    <edc:Interrupt edc:irq="-12" edc:cname="MemoryManagement" edc:desc="Memory Management, MPU mismatch, including Access Violation and No Match"/>
    <edc:Interrupt edc:irq="-11" edc:cname="BusFault" edc:desc="Bus Fault, Pre-Fetch-, Memory Access Fault, other address/memory related Fault"/>
    <edc:Interrupt edc:irq="-10" edc:cname="UsageFault" edc:desc="Usage Fault, i.e. Undef Instruction, Illegal State Transition"/>
    <edc:Interrupt edc:irq="-5" edc:cname="SVCall" edc:desc="System Service Call via SVC instruction"/>
    <edc:Interrupt edc:irq="-4" edc:cname="DebugMonitor" edc:desc="Debug Monitor"/>
    <edc:Interrupt edc:irq="-2" edc:cname="PendSV" edc:desc="Pendable request for system service"/>
    <edc:Interrupt edc:irq="-1" edc:cname="SysTick" edc:desc="System Tick Timer"/>
    <edc:Interrupt edc:irq="0" edc:cname="GIRQ08" edc:desc="GIRQ08" ltx:memberofperipheral="ECIA"/>
    <edc:Interrupt edc:irq="1" edc:cname="GIRQ09" edc:desc="GIRQ09" ltx:memberofperipheral="ECIA"/>
    <edc:Interrupt edc:irq="2" edc:cname="GIRQ10" edc:desc="GIRQ10" ltx:memberofperipheral="ECIA"/>
    <edc:Interrupt edc:irq="3" edc:cname="GIRQ11" edc:desc="GIRQ11" ltx:memberofperipheral="ECIA"/>
    <edc:Interrupt edc:irq="4" edc:cname="GIRQ12" edc:desc="GIRQ12" ltx:memberofperipheral="ECIA"/>
    <edc:Interrupt edc:irq="5" edc:cname="GIRQ13" edc:desc="GIRQ13" ltx:memberofperipheral="ECIA"/>
    <edc:Interrupt edc:irq="6" edc:cname="GIRQ14" edc:desc="GIRQ14" ltx:memberofperipheral="ECIA"/>
    <edc:Interrupt edc:irq="7" edc:cname="GIRQ15" edc:desc="GIRQ15" ltx:memberofperipheral="ECIA"/>
    <edc:Interrupt edc:irq="8" edc:cname="GIRQ16" edc:desc="GIRQ16" ltx:memberofperipheral="ECIA"/>
    <edc:Interrupt edc:irq="9" edc:cname="GIRQ17" edc:desc="GIRQ17" ltx:memberofperipheral="ECIA"/>
    <edc:Interrupt edc:irq="10" edc:cname="GIRQ18" edc:desc="GIRQ18" ltx:memberofperipheral="ECIA"/>
    <edc:Interrupt edc:irq="12" edc:cname="GIRQ20" edc:desc="GIRQ20" ltx:memberofperipheral="ECIA"/>
    <edc:Interrupt edc:irq="13" edc:cname="GIRQ21" edc:desc="GIRQ21" ltx:memberofperipheral="ECIA"/>
    <edc:Interrupt edc:irq="14" edc:cname="GIRQ23" edc:desc="GIRQ23" ltx:memberofperipheral="ECIA"/>
    <edc:Interrupt edc:irq="15" edc:cname="GIRQ24" edc:desc="GIRQ24" ltx:memberofperipheral="ECIA"/>
    <edc:Interrupt edc:irq="17" edc:cname="GIRQ26" edc:desc="GIRQ26" ltx:memberofperipheral="ECIA"/>
    <edc:Interrupt edc:irq="20" edc:cname="I2CSMB0" edc:desc="I2CSMB0" ltx:memberofperipheral="SMB0"/>
    <edc:Interrupt edc:irq="21" edc:cname="I2CSMB1" edc:desc="I2CSMB1" ltx:memberofperipheral="SMB1"/>
    <edc:Interrupt edc:irq="22" edc:cname="I2CSMB2" edc:desc="I2CSMB2" ltx:memberofperipheral="SMB2"/>
    <edc:Interrupt edc:irq="23" edc:cname="I2CSMB3" edc:desc="I2CSMB3" ltx:memberofperipheral="SMB3"/>
    <edc:Interrupt edc:irq="24" edc:cname="DMA_CH00" edc:desc="DMA_CH00" ltx:memberofperipheral="DMA_CHAN00"/>
    <edc:Interrupt edc:irq="25" edc:cname="DMA_CH01" edc:desc="DMA_CH01" ltx:memberofperipheral="DMA_CHAN01"/>
    <edc:Interrupt edc:irq="26" edc:cname="DMA_CH02" edc:desc="DMA_CH02" ltx:memberofperipheral="DMA_CHAN02"/>
    <edc:Interrupt edc:irq="27" edc:cname="DMA_CH03" edc:desc="DMA_CH03" ltx:memberofperipheral="DMA_CHAN03"/>
    <edc:Interrupt edc:irq="28" edc:cname="DMA_CH04" edc:desc="DMA_CH04" ltx:memberofperipheral="DMA_CHAN04"/>
    <edc:Interrupt edc:irq="29" edc:cname="DMA_CH05" edc:desc="DMA_CH05" ltx:memberofperipheral="DMA_CHAN05"/>
    <edc:Interrupt edc:irq="30" edc:cname="DMA_CH06" edc:desc="DMA_CH06" ltx:memberofperipheral="DMA_CHAN06"/>
    <edc:Interrupt edc:irq="31" edc:cname="DMA_CH07" edc:desc="DMA_CH07" ltx:memberofperipheral="DMA_CHAN07"/>
    <edc:Interrupt edc:irq="32" edc:cname="DMA_CH08" edc:desc="DMA_CH08" ltx:memberofperipheral="DMA_CHAN08"/>
    <edc:Interrupt edc:irq="33" edc:cname="DMA_CH09" edc:desc="DMA_CH09" ltx:memberofperipheral="DMA_CHAN09"/>
    <edc:Interrupt edc:irq="40" edc:cname="UART0" edc:desc="UART0" ltx:memberofperipheral="UART0"/>
    <edc:Interrupt edc:irq="65" edc:cname="PKE_ERR" edc:desc="PKE_ERR" ltx:memberofperipheral="PKE_ERR"/>
    <edc:Interrupt edc:irq="66" edc:cname="PKE_END" edc:desc="PKE_END" ltx:memberofperipheral="PKE_END"/>
    <edc:Interrupt edc:irq="67" edc:cname="RNG" edc:desc="RNG" ltx:memberofperipheral="RNG"/>
    <edc:Interrupt edc:irq="68" edc:cname="AES" edc:desc="AES" ltx:memberofperipheral="AES"/>
    <edc:Interrupt edc:irq="69" edc:cname="HASH" edc:desc="HASH" ltx:memberofperipheral="HASH"/>
    <edc:Interrupt edc:irq="83" edc:cname="LED0" edc:desc="LED0" ltx:memberofperipheral="LED0"/>
    <edc:Interrupt edc:irq="84" edc:cname="LED1" edc:desc="LED1" ltx:memberofperipheral="LED1"/>
    <edc:Interrupt edc:irq="90" edc:cname="SPT0" edc:desc="SPT0" ltx:memberofperipheral="SPT0"/>
    <edc:Interrupt edc:irq="91" edc:cname="QMSPI0" edc:desc="QMSPI0" ltx:memberofperipheral="QMSPI0"/>
    <edc:Interrupt edc:irq="92" edc:cname="QMSPI1" edc:desc="QMSPI1" ltx:memberofperipheral="QMSPI1"/>
    <edc:Interrupt edc:irq="111" edc:cname="RTMR" edc:desc="RTMR" ltx:memberofperipheral="RTOS"/>
    <edc:Interrupt edc:irq="112" edc:cname="HTMR0" edc:desc="HTMR0" ltx:memberofperipheral="HTM0"/>
    <edc:Interrupt edc:irq="113" edc:cname="HTMR1" edc:desc="HTMR1" ltx:memberofperipheral="HTM1"/>
    <edc:Interrupt edc:irq="134" edc:cname="EMC" edc:desc="EMC" ltx:memberofperipheral="ENV_MON"/>
    <edc:Interrupt edc:irq="140" edc:cname="TIMER32_0" edc:desc="TIMER32_0" ltx:memberofperipheral="TIMER32_0"/>
    <edc:Interrupt edc:irq="141" edc:cname="TIMER32_1" edc:desc="TIMER32_1" ltx:memberofperipheral="TIMER32_1"/>
    <edc:Interrupt edc:irq="146" edc:cname="CCT" edc:desc="CCT" ltx:memberofperipheral="CCT"/>
    <edc:Interrupt edc:irq="147" edc:cname="CCT_CAP0" edc:desc="CCT_CAP0" ltx:memberofperipheral="CCT"/>
    <edc:Interrupt edc:irq="148" edc:cname="CCT_CAP1" edc:desc="CCT_CAP1" ltx:memberofperipheral="CCT"/>
    <edc:Interrupt edc:irq="149" edc:cname="CCT_CAP2" edc:desc="CCT_CAP2" ltx:memberofperipheral="CCT"/>
    <edc:Interrupt edc:irq="150" edc:cname="CCT_CAP3" edc:desc="CCT_CAP3" ltx:memberofperipheral="CCT"/>
    <edc:Interrupt edc:irq="151" edc:cname="CCT_CAP4" edc:desc="CCT_CAP4" ltx:memberofperipheral="CCT"/>
    <edc:Interrupt edc:irq="152" edc:cname="CCT_CAP5" edc:desc="CCT_CAP5" ltx:memberofperipheral="CCT"/>
    <edc:Interrupt edc:irq="153" edc:cname="CCT_CMP0" edc:desc="CCT_CMP0" ltx:memberofperipheral="CCT"/>
    <edc:Interrupt edc:irq="154" edc:cname="CCT_CMP1" edc:desc="CCT_CMP1" ltx:memberofperipheral="CCT"/>
    <edc:Interrupt edc:irq="158" edc:cname="I2CSMB4" edc:desc="I2CSMB4" ltx:memberofperipheral="SMB4"/>
    <edc:Interrupt edc:irq="171" edc:cname="WDT" edc:desc="WDT" ltx:memberofperipheral="WDT"/>
    <edc:Interrupt edc:irq="174" edc:cname="CLK_MON" edc:desc="CLK_MON" ltx:memberofperipheral="PCR"/>
    <edc:Interrupt edc:irq="181" edc:cname="SWI0" edc:desc="SWI0" ltx:memberofperipheral="RTOS"/>
    <edc:Interrupt edc:irq="182" edc:cname="SWI1" edc:desc="SWI1" ltx:memberofperipheral="RTOS"/>
    <edc:Interrupt edc:irq="183" edc:cname="SWI2" edc:desc="SWI2" ltx:memberofperipheral="RTOS"/>
    <edc:Interrupt edc:irq="184" edc:cname="SWI3" edc:desc="SWI3" ltx:memberofperipheral="RTOS"/>
    <edc:Interrupt edc:irq="185" edc:cname="IMSPI" edc:desc="IMSPI" ltx:memberofperipheral="IMSPI"/>
    <edc:Interrupt edc:irq="187" edc:cname="SPT1" edc:desc="SPT1" ltx:memberofperipheral="SPT1"/>
    <edc:Interrupt edc:irq="188" edc:cname="SPIMON0_VLTN" edc:desc="SPIMON0_VLTN" ltx:memberofperipheral="SPI_MON0"/>
    <edc:Interrupt edc:irq="189" edc:cname="SPIMON0_MTMON" edc:desc="SPIMON0_MTMON" ltx:memberofperipheral="SPI_MON0"/>
    <edc:Interrupt edc:irq="190" edc:cname="SPIMON0_LTMON" edc:desc="SPIMON0_LTMON" ltx:memberofperipheral="SPI_MON0"/>
    <edc:Interrupt edc:irq="191" edc:cname="SPIMON1_VLTN" edc:desc="SPIMON1_VLTN" ltx:memberofperipheral="SPI_MON1"/>
    <edc:Interrupt edc:irq="192" edc:cname="SPIMON1_MTMON" edc:desc="SPIMON1_MTMON" ltx:memberofperipheral="SPI_MON1"/>
    <edc:Interrupt edc:irq="193" edc:cname="SPIMON1_LTMON" edc:desc="SPIMON1_LTMON" ltx:memberofperipheral="SPI_MON1"/>
    <edc:Interrupt edc:irq="194" edc:cname="VTR1_PAD_MON" edc:desc="VTR1_PAD_MON" ltx:memberofperipheral="EC_REG_BANK"/>
    <edc:Interrupt edc:irq="195" edc:cname="VTR2_PAD_MON" edc:desc="VTR2_PAD_MON" ltx:memberofperipheral="EC_REG_BANK"/>
  </edc:InterruptList>
  <edc:PeripheralList>
    <edc:Peripheral edc:cname="PCR" edc:desc=""/>
    <edc:Peripheral edc:cname="DMA_MAIN" edc:desc=""/>
    <edc:Peripheral edc:cname="DMA_CHAN00" edc:desc=""/>
    <edc:Peripheral edc:cname="DMA_CHAN01" edc:desc=""/>
    <edc:Peripheral edc:cname="DMA_CHAN02" edc:desc=""/>
    <edc:Peripheral edc:cname="DMA_CHAN03" edc:desc=""/>
    <edc:Peripheral edc:cname="DMA_CHAN04" edc:desc=""/>
    <edc:Peripheral edc:cname="DMA_CHAN05" edc:desc=""/>
    <edc:Peripheral edc:cname="DMA_CHAN06" edc:desc=""/>
    <edc:Peripheral edc:cname="DMA_CHAN07" edc:desc=""/>
    <edc:Peripheral edc:cname="DMA_CHAN08" edc:desc=""/>
    <edc:Peripheral edc:cname="DMA_CHAN09" edc:desc=""/>
    <edc:Peripheral edc:cname="ECIA" edc:desc=""/>
    <edc:Peripheral edc:cname="GCR" edc:desc=""/>
    <edc:Peripheral edc:cname="UART0" edc:desc=""/>
    <edc:Peripheral edc:cname="GPIO" edc:desc=""/>
    <edc:Peripheral edc:cname="WDT" edc:desc=""/>
    <edc:Peripheral edc:cname="TIMER32_0" edc:desc=""/>
    <edc:Peripheral edc:cname="TIMER32_1" edc:desc=""/>
    <edc:Peripheral edc:cname="CCT" edc:desc=""/>
    <edc:Peripheral edc:cname="HTM0" edc:desc=""/>
    <edc:Peripheral edc:cname="HTM1" edc:desc=""/>
    <edc:Peripheral edc:cname="RTOS" edc:desc=""/>
    <edc:Peripheral edc:cname="PWM0" edc:desc=""/>
    <edc:Peripheral edc:cname="LED0" edc:desc=""/>
    <edc:Peripheral edc:cname="LED1" edc:desc=""/>
    <edc:Peripheral edc:cname="SMB0" edc:desc=""/>
    <edc:Peripheral edc:cname="SMB1" edc:desc=""/>
    <edc:Peripheral edc:cname="SMB2" edc:desc=""/>
    <edc:Peripheral edc:cname="SMB3" edc:desc=""/>
    <edc:Peripheral edc:cname="SMB4" edc:desc=""/>
    <edc:Peripheral edc:cname="QMSPI0" edc:desc=""/>
    <edc:Peripheral edc:cname="QMSPI1" edc:desc=""/>
    <edc:Peripheral edc:cname="TFDP" edc:desc=""/>
    <edc:Peripheral edc:cname="VTR_REG_BANK" edc:desc=""/>
    <edc:Peripheral edc:cname="EC_REG_BANK" edc:desc=""/>
    <edc:Peripheral edc:cname="OTP" edc:desc=""/>
    <edc:Peripheral edc:cname="SPT0" edc:desc=""/>
    <edc:Peripheral edc:cname="SPT1" edc:desc=""/>
    <edc:Peripheral edc:cname="FPU" edc:desc=""/>
    <edc:Peripheral edc:cname="IMSPI" edc:desc=""/>
    <edc:Peripheral edc:cname="NVIC" edc:desc=""/>
    <edc:Peripheral edc:cname="SysTick" edc:desc=""/>
    <edc:Peripheral edc:cname="SystemControl" edc:desc=""/>
    <edc:Peripheral edc:cname="PKE_ERR" edc:desc=""/>
    <edc:Peripheral edc:cname="PKE_END" edc:desc=""/>
    <edc:Peripheral edc:cname="RNG" edc:desc=""/>
    <edc:Peripheral edc:cname="AES" edc:desc=""/>
    <edc:Peripheral edc:cname="HASH" edc:desc=""/>
    <edc:Peripheral edc:cname="ENV_MON" edc:desc=""/>
    <edc:Peripheral edc:cname="SPI_MON0" edc:desc=""/>
    <edc:Peripheral edc:cname="SPI_MON1" edc:desc=""/>
  </edc:PeripheralList>
  <edc:PhysicalSpace>
    <edc:NMMRPlace edc:regionid="corenmmrs">
      <edc:SFRDef edc:nzwidth="0x20" edc:cname="R0" edc:impl="0xFFFFFFFF" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx" edc:desc="General-Purpose Register" edc:nmmrid="0"/>
      <edc:SFRDef edc:nzwidth="0x20" edc:cname="R1" edc:impl="0xFFFFFFFF" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx" edc:desc="General-Purpose Register" edc:nmmrid="4"/>
      <edc:SFRDef edc:nzwidth="0x20" edc:cname="R2" edc:impl="0xFFFFFFFF" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx" edc:desc="General-Purpose Register" edc:nmmrid="8"/>
      <edc:SFRDef edc:nzwidth="0x20" edc:cname="R3" edc:impl="0xFFFFFFFF" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx" edc:desc="General-Purpose Register" edc:nmmrid="12"/>
      <edc:SFRDef edc:nzwidth="0x20" edc:cname="R4" edc:impl="0xFFFFFFFF" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx" edc:desc="General-Purpose Register" edc:nmmrid="16"/>
      <edc:SFRDef edc:nzwidth="0x20" edc:cname="R5" edc:impl="0xFFFFFFFF" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx" edc:desc="General-Purpose Register" edc:nmmrid="20"/>
      <edc:SFRDef edc:nzwidth="0x20" edc:cname="R6" edc:impl="0xFFFFFFFF" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx" edc:desc="General-Purpose Register" edc:nmmrid="24"/>
      <edc:SFRDef edc:nzwidth="0x20" edc:cname="R7" edc:impl="0xFFFFFFFF" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx" edc:desc="General-Purpose Register" edc:nmmrid="28"/>
      <edc:SFRDef edc:nzwidth="0x20" edc:cname="R8" edc:impl="0xFFFFFFFF" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx" edc:desc="General-Purpose Register" edc:nmmrid="32"/>
      <edc:SFRDef edc:nzwidth="0x20" edc:cname="R9" edc:impl="0xFFFFFFFF" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx" edc:desc="General-Purpose Register" edc:nmmrid="36"/>
      <edc:SFRDef edc:nzwidth="0x20" edc:cname="R10" edc:impl="0xFFFFFFFF" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx" edc:desc="General-Purpose Register" edc:nmmrid="40"/>
      <edc:SFRDef edc:nzwidth="0x20" edc:cname="R11" edc:impl="0xFFFFFFFF" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx" edc:desc="General-Purpose Register" edc:nmmrid="44"/>
      <edc:SFRDef edc:nzwidth="0x20" edc:cname="R12" edc:impl="0xFFFFFFFF" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx" edc:desc="General-Purpose Register" edc:nmmrid="48"/>
      <edc:SFRDef edc:nzwidth="0x20" edc:cname="SP" edc:impl="0xFFFFFFFF" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx" edc:desc="Stack Pointer" edc:nmmrid="52"/>
      <edc:SFRDef edc:nzwidth="0x20" edc:cname="MSP" edc:impl="0xFFFFFFFF" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx" edc:desc="Main Stack Pointer" edc:nmmrid="64"/>
      <edc:SFRDef edc:nzwidth="0x20" edc:cname="PSP" edc:impl="0xFFFFFFFF" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx" edc:desc="Process Stack Pointer" edc:nmmrid="68"/>
      <edc:SFRDef edc:nzwidth="0x20" edc:cname="LR" edc:impl="0xFFFFFFFF" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="11111111111111111111111111111111" edc:mclr="11111111111111111111111111111111" edc:desc="Link Register" edc:nmmrid="56"/>
      <edc:SFRDef edc:nzwidth="0x20" edc:cname="PC" edc:impl="0xFFFFFFFF" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx" edc:desc="Program Counter" edc:nmmrid="60"/>
      <edc:SFRDef edc:nzwidth="0x20" edc:cname="PSR" edc:impl="0xFF00FDFF" edc:access="nnnnnnnn--------nnnnnn-nnnnnnnnn" edc:por="00000001000000000000000000000000" edc:mclr="00000001000000000000000000000000" edc:desc="Program Status Register" edc:nmmrid="72"/>
      <edc:SFRDef edc:nzwidth="0x20" edc:cname="APSR" edc:impl="0xF80F0000" edc:access="nnnnn-------nnnn----------------" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:desc="Application Program Status Register" edc:nmmrid="76"/>
      <edc:SFRDef edc:nzwidth="0x20" edc:cname="IPSR" edc:impl="0x1FF" edc:access="-----------------------rrrrrrrrr" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:desc="Interrupt Program Status Register" edc:nmmrid="80"/>
      <edc:SFRDef edc:nzwidth="0x20" edc:cname="EPSR" edc:impl="0x700FC00" edc:access="-----rrr--------rrrrrr----------" edc:por="00000001000000000000000000000000" edc:mclr="00000001000000000000000000000000" edc:desc="Execution Program Status Register" edc:nmmrid="84"/>
      <edc:SFRDef edc:nzwidth="0x20" edc:cname="PRIMASK" edc:impl="0x1" edc:access="-------------------------------n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:desc="Priority Mask Register" edc:nmmrid="88"/>
      <edc:SFRDef edc:nzwidth="0x20" edc:cname="FAULTMASK" edc:impl="0x1" edc:access="-------------------------------n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:desc="Fault Mask Register" edc:nmmrid="92"/>
      <edc:SFRDef edc:nzwidth="0x20" edc:cname="BASEPRI" edc:impl="0xFF" edc:access="------------------------nnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:desc="Base Priority Mask Register" edc:nmmrid="96"/>
      <edc:SFRDef edc:nzwidth="0x20" edc:cname="CONTROL" edc:impl="0x7" edc:access="-----------------------------nnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:desc="Control Register" edc:nmmrid="100"/>
      <edc:SFRDef edc:nzwidth="0x20" edc:cname="FPSCR" edc:impl="0xFFF79F9F" edc:access="nnnnnnnnnnnn-nnnn--nnnnnn--nnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:desc="Floating-Point Status And Control Register" edc:nmmrid="144"/>
      <edc:JoinedSFRDef edc:nzwidth="0x40" edc:cname="D0" edc:impl="0xFFFFFFFFFFFFFFFF" edc:desc="Floating-Point Extension Register">
        <edc:SFRDef edc:nzwidth="0x20" edc:cname="S0" edc:impl="0xFFFFFFFF" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:desc="Floating-Point Extension Register" edc:nmmrid="148"/>
        <edc:SFRDef edc:nzwidth="0x20" edc:cname="S1" edc:impl="0xFFFFFFFF" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:desc="Floating-Point Extension Register" edc:nmmrid="152"/>
      </edc:JoinedSFRDef>
      <edc:JoinedSFRDef edc:nzwidth="0x40" edc:cname="D1" edc:impl="0xFFFFFFFFFFFFFFFF" edc:desc="Floating-Point Extension Register">
        <edc:SFRDef edc:nzwidth="0x20" edc:cname="S2" edc:impl="0xFFFFFFFF" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:desc="Floating-Point Extension Register" edc:nmmrid="156"/>
        <edc:SFRDef edc:nzwidth="0x20" edc:cname="S3" edc:impl="0xFFFFFFFF" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:desc="Floating-Point Extension Register" edc:nmmrid="160"/>
      </edc:JoinedSFRDef>
      <edc:JoinedSFRDef edc:nzwidth="0x40" edc:cname="D2" edc:impl="0xFFFFFFFFFFFFFFFF" edc:desc="Floating-Point Extension Register">
        <edc:SFRDef edc:nzwidth="0x20" edc:cname="S4" edc:impl="0xFFFFFFFF" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:desc="Floating-Point Extension Register" edc:nmmrid="164"/>
        <edc:SFRDef edc:nzwidth="0x20" edc:cname="S5" edc:impl="0xFFFFFFFF" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:desc="Floating-Point Extension Register" edc:nmmrid="168"/>
      </edc:JoinedSFRDef>
      <edc:JoinedSFRDef edc:nzwidth="0x40" edc:cname="D3" edc:impl="0xFFFFFFFFFFFFFFFF" edc:desc="Floating-Point Extension Register">
        <edc:SFRDef edc:nzwidth="0x20" edc:cname="S6" edc:impl="0xFFFFFFFF" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:desc="Floating-Point Extension Register" edc:nmmrid="172"/>
        <edc:SFRDef edc:nzwidth="0x20" edc:cname="S7" edc:impl="0xFFFFFFFF" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:desc="Floating-Point Extension Register" edc:nmmrid="176"/>
      </edc:JoinedSFRDef>
      <edc:JoinedSFRDef edc:nzwidth="0x40" edc:cname="D4" edc:impl="0xFFFFFFFFFFFFFFFF" edc:desc="Floating-Point Extension Register">
        <edc:SFRDef edc:nzwidth="0x20" edc:cname="S8" edc:impl="0xFFFFFFFF" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:desc="Floating-Point Extension Register" edc:nmmrid="180"/>
        <edc:SFRDef edc:nzwidth="0x20" edc:cname="S9" edc:impl="0xFFFFFFFF" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:desc="Floating-Point Extension Register" edc:nmmrid="184"/>
      </edc:JoinedSFRDef>
      <edc:JoinedSFRDef edc:nzwidth="0x40" edc:cname="D5" edc:impl="0xFFFFFFFFFFFFFFFF" edc:desc="Floating-Point Extension Register">
        <edc:SFRDef edc:nzwidth="0x20" edc:cname="S10" edc:impl="0xFFFFFFFF" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:desc="Floating-Point Extension Register" edc:nmmrid="188"/>
        <edc:SFRDef edc:nzwidth="0x20" edc:cname="S11" edc:impl="0xFFFFFFFF" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:desc="Floating-Point Extension Register" edc:nmmrid="192"/>
      </edc:JoinedSFRDef>
      <edc:JoinedSFRDef edc:nzwidth="0x40" edc:cname="D6" edc:impl="0xFFFFFFFFFFFFFFFF" edc:desc="Floating-Point Extension Register">
        <edc:SFRDef edc:nzwidth="0x20" edc:cname="S12" edc:impl="0xFFFFFFFF" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:desc="Floating-Point Extension Register" edc:nmmrid="196"/>
        <edc:SFRDef edc:nzwidth="0x20" edc:cname="S13" edc:impl="0xFFFFFFFF" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:desc="Floating-Point Extension Register" edc:nmmrid="200"/>
      </edc:JoinedSFRDef>
      <edc:JoinedSFRDef edc:nzwidth="0x40" edc:cname="D7" edc:impl="0xFFFFFFFFFFFFFFFF" edc:desc="Floating-Point Extension Register">
        <edc:SFRDef edc:nzwidth="0x20" edc:cname="S14" edc:impl="0xFFFFFFFF" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:desc="Floating-Point Extension Register" edc:nmmrid="204"/>
        <edc:SFRDef edc:nzwidth="0x20" edc:cname="S15" edc:impl="0xFFFFFFFF" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:desc="Floating-Point Extension Register" edc:nmmrid="208"/>
      </edc:JoinedSFRDef>
      <edc:JoinedSFRDef edc:nzwidth="0x40" edc:cname="D8" edc:impl="0xFFFFFFFFFFFFFFFF" edc:desc="Floating-Point Extension Register">
        <edc:SFRDef edc:nzwidth="0x20" edc:cname="S16" edc:impl="0xFFFFFFFF" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:desc="Floating-Point Extension Register" edc:nmmrid="212"/>
        <edc:SFRDef edc:nzwidth="0x20" edc:cname="S17" edc:impl="0xFFFFFFFF" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:desc="Floating-Point Extension Register" edc:nmmrid="216"/>
      </edc:JoinedSFRDef>
      <edc:JoinedSFRDef edc:nzwidth="0x40" edc:cname="D9" edc:impl="0xFFFFFFFFFFFFFFFF" edc:desc="Floating-Point Extension Register">
        <edc:SFRDef edc:nzwidth="0x20" edc:cname="S18" edc:impl="0xFFFFFFFF" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:desc="Floating-Point Extension Register" edc:nmmrid="220"/>
        <edc:SFRDef edc:nzwidth="0x20" edc:cname="S19" edc:impl="0xFFFFFFFF" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:desc="Floating-Point Extension Register" edc:nmmrid="224"/>
      </edc:JoinedSFRDef>
      <edc:JoinedSFRDef edc:nzwidth="0x40" edc:cname="D10" edc:impl="0xFFFFFFFFFFFFFFFF" edc:desc="Floating-Point Extension Register">
        <edc:SFRDef edc:nzwidth="0x20" edc:cname="S20" edc:impl="0xFFFFFFFF" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:desc="Floating-Point Extension Register" edc:nmmrid="228"/>
        <edc:SFRDef edc:nzwidth="0x20" edc:cname="S21" edc:impl="0xFFFFFFFF" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:desc="Floating-Point Extension Register" edc:nmmrid="232"/>
      </edc:JoinedSFRDef>
      <edc:JoinedSFRDef edc:nzwidth="0x40" edc:cname="D11" edc:impl="0xFFFFFFFFFFFFFFFF" edc:desc="Floating-Point Extension Register">
        <edc:SFRDef edc:nzwidth="0x20" edc:cname="S22" edc:impl="0xFFFFFFFF" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:desc="Floating-Point Extension Register" edc:nmmrid="236"/>
        <edc:SFRDef edc:nzwidth="0x20" edc:cname="S23" edc:impl="0xFFFFFFFF" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:desc="Floating-Point Extension Register" edc:nmmrid="240"/>
      </edc:JoinedSFRDef>
      <edc:JoinedSFRDef edc:nzwidth="0x40" edc:cname="D12" edc:impl="0xFFFFFFFFFFFFFFFF" edc:desc="Floating-Point Extension Register">
        <edc:SFRDef edc:nzwidth="0x20" edc:cname="S24" edc:impl="0xFFFFFFFF" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:desc="Floating-Point Extension Register" edc:nmmrid="244"/>
        <edc:SFRDef edc:nzwidth="0x20" edc:cname="S25" edc:impl="0xFFFFFFFF" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:desc="Floating-Point Extension Register" edc:nmmrid="248"/>
      </edc:JoinedSFRDef>
      <edc:JoinedSFRDef edc:nzwidth="0x40" edc:cname="D13" edc:impl="0xFFFFFFFFFFFFFFFF" edc:desc="Floating-Point Extension Register">
        <edc:SFRDef edc:nzwidth="0x20" edc:cname="S26" edc:impl="0xFFFFFFFF" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:desc="Floating-Point Extension Register" edc:nmmrid="252"/>
        <edc:SFRDef edc:nzwidth="0x20" edc:cname="S27" edc:impl="0xFFFFFFFF" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:desc="Floating-Point Extension Register" edc:nmmrid="256"/>
      </edc:JoinedSFRDef>
      <edc:JoinedSFRDef edc:nzwidth="0x40" edc:cname="D14" edc:impl="0xFFFFFFFFFFFFFFFF" edc:desc="Floating-Point Extension Register">
        <edc:SFRDef edc:nzwidth="0x20" edc:cname="S28" edc:impl="0xFFFFFFFF" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:desc="Floating-Point Extension Register" edc:nmmrid="260"/>
        <edc:SFRDef edc:nzwidth="0x20" edc:cname="S29" edc:impl="0xFFFFFFFF" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:desc="Floating-Point Extension Register" edc:nmmrid="264"/>
      </edc:JoinedSFRDef>
      <edc:JoinedSFRDef edc:nzwidth="0x40" edc:cname="D15" edc:impl="0xFFFFFFFFFFFFFFFF" edc:desc="Floating-Point Extension Register">
        <edc:SFRDef edc:nzwidth="0x20" edc:cname="S30" edc:impl="0xFFFFFFFF" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:desc="Floating-Point Extension Register" edc:nmmrid="268"/>
        <edc:SFRDef edc:nzwidth="0x20" edc:cname="S31" edc:impl="0xFFFFFFFF" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:desc="Floating-Point Extension Register" edc:nmmrid="272"/>
      </edc:JoinedSFRDef>
    </edc:NMMRPlace>
    <edc:GPRDataSector edc:regionid="CODE_SRAM" edc:beginaddr="0xC8000" edc:endaddr="0x118000" edc:isexecutable="true" edc:rw="rw"/>
    <edc:GPRDataSector edc:regionid="DATA_SRAM" edc:beginaddr="0x118000" edc:endaddr="0x122000" edc:rw="rw"/>
    <edc:GPRDataSector edc:regionid="BOOTROM_SRAM" edc:beginaddr="0x122000" edc:endaddr="0x128000" edc:rw="rw"/>
    <edc:GPRDataSector edc:regionid="DATA_SRAM2" edc:beginaddr="0x128000" edc:endaddr="0x138000" edc:rw="rw"/>
    <edc:GPRDataSector edc:regionid="DATA_SRAM3" edc:beginaddr="0x138000" edc:endaddr="0x148000" edc:rw="rw"/>
    <edc:GPRDataSector edc:regionid="DATA_SRAM_ALIAS" edc:beginaddr="0x20000000" edc:endaddr="0x20008000" edc:rw="rw"/>
    <edc:SFRDataSector edc:regionid="EC_DEVICE_REGISTERS" edc:beginaddr="0x40000000" edc:endaddr="0x40070370" edc:rw="rw">
      <edc:AdjustPoint edc:offset="0x400" edc:_addr="0x40000000"/>
      <edc:SFRDef ltx:memberofperipheral="WDT" edc:cname="LOAD" edc:nzwidth="0x10" edc:access="nnnnnnnnnnnnnnnn" edc:por="1111111111111111" edc:mclr="1111111111111111" edc:_addr="0x40000400"/>
      <edc:AdjustPoint edc:offset="0x2" edc:_addr="0x40000402"/>
      <edc:SFRDef ltx:memberofperipheral="WDT" edc:cname="CTRL" edc:nzwidth="0x10" edc:access="------n----nnnnn" edc:por="0000000000000000" edc:mclr="0000000000000000" edc:impl="0x21F" edc:_addr="0x40000404">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="WDT">
            <edc:SFRFieldDef edc:cname="WDT_EN" edc:nzwidth="0x1" edc:desc="WDT Block enabled"/>
            <edc:SFRFieldDef edc:cname="WDT_STS" edc:nzwidth="0x1" edc:desc="WDT_STATUS is set by hardware if the last reset of the device was caused by an underflow of the WDT. This bit must      be cleared by the EC firmware writing a '1' to this bit. Writing a '0' to this bit has no effect."/>
            <edc:SFRFieldDef edc:cname="HIB_TMR0_STL" edc:nzwidth="0x1" edc:desc="This bit enables the WDT Stall function if the Hibernation Timer 0 is active.      1=The WDT is stalled while the Hibernation Timer 0 is active      0=The WDT is not affected by Hibernation Timer 0."/>
            <edc:SFRFieldDef edc:cname="WK_TMR_STL" edc:nzwidth="0x1" edc:desc="This bit enables the WDT Stall function if the Week Timer is active.      1=The WDT is stalled while the Week Timer is active      0=The WDT is not affected by the Week Timer."/>
            <edc:SFRFieldDef edc:cname="JTAG_STL" edc:nzwidth="0x1" edc:desc="This bit enables the WDT Stall function if JTAG or SWD debug functions are active      1=The WDT is stalled while either JTAG or SWD is active      0=The WDT is not affected by the JTAG debug interface."/>
            <edc:AdjustPoint edc:offset="0x4"/>
            <edc:SFRFieldDef edc:cname="WDT_RST" edc:nzwidth="0x1" edc:desc="If the WDT_RESET bit is set and the watch dog timer expires, the Watch dog module will         generate interrupt and clear the WDT_RESET to 0b."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:AdjustPoint edc:offset="0x2" edc:_addr="0x40000406"/>
      <edc:SFRDef ltx:memberofperipheral="WDT" edc:cname="KICK" edc:nzwidth="0x8" edc:access="wwwwwwww" edc:por="00000000" edc:mclr="00000000" edc:_addr="0x40000408"/>
      <edc:AdjustPoint edc:offset="0x3" edc:_addr="0x40000409"/>
      <edc:SFRDef ltx:memberofperipheral="WDT" edc:cname="CNT" edc:nzwidth="0x10" edc:access="rrrrrrrrrrrrrrrr" edc:por="1111111111111111" edc:mclr="1111111111111111" edc:_addr="0x4000040C"/>
      <edc:AdjustPoint edc:offset="0x2" edc:_addr="0x4000040E"/>
      <edc:SFRDef ltx:memberofperipheral="WDT" edc:cname="STS" edc:nzwidth="0x8" edc:access="-------n" edc:por="00000000" edc:mclr="00000000" edc:impl="0x1" edc:_addr="0x40000410">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="WDT">
            <edc:SFRFieldDef edc:cname="WDT_EV_IRQ" edc:nzwidth="0x1" edc:desc="WDT_EVENT_IRQ : This bit indicates the status of interrupt from Watch dog module."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:AdjustPoint edc:offset="0x3" edc:_addr="0x40000411"/>
      <edc:SFRDef ltx:memberofperipheral="WDT" edc:cname="IEN" edc:nzwidth="0x8" edc:access="-------n" edc:por="00000000" edc:mclr="00000000" edc:impl="0x1" edc:_addr="0x40000414">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="WDT">
            <edc:SFRFieldDef edc:cname="WDT_INTEN" edc:nzwidth="0x1" edc:desc="WDT_Int_Enable: This is the interrupt enables bit for WDT_INT interrupt.                   1= WDT_INT Interrupt Enable                   0= WDT_INT Interrupt Disabled"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:AdjustPoint edc:offset="0x86B" edc:_addr="0x40000415"/>
      <edc:SFRDef ltx:memberofperipheral="TIMER32_0" edc:cname="CNT" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x40000C80"/>
      <edc:SFRDef ltx:memberofperipheral="TIMER32_0" edc:cname="PRLD" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x40000C84"/>
      <edc:SFRDef ltx:memberofperipheral="TIMER32_0" edc:cname="STS" edc:nzwidth="0x20" edc:access="-------------------------------n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x1" edc:_addr="0x40000C88">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="TIMER32_0">
            <edc:SFRFieldDef edc:cname="EVT_INT" edc:nzwidth="0x1" edc:desc="This is the interrupt status that fires when the timer reaches its limit. This is the interrupt status that fires when        the timer reaches its limit. This may be level or a self clearing signal cycle pulse, based on the AUTO_RESTART bit in the Timer        Control Register. If the timer is set to automatically restart, it will provide a pulse, otherwise a level is provided.(R/WC)"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="TIMER32_0" edc:cname="IEN" edc:nzwidth="0x20" edc:access="-------------------------------n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x1" edc:_addr="0x40000C8C">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="TIMER32_0">
            <edc:SFRFieldDef edc:cname="EN" edc:nzwidth="0x1" edc:desc="This is the interrupt enable for the status EVENT_INTERRUPT bit in the Timer Status Register."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="TIMER32_0" edc:cname="CTRL" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnn--------nnnnnn-n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0xFFFF00FD" edc:_addr="0x40000C90">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="TIMER32_0">
            <edc:SFRFieldDef edc:cname="EN" edc:nzwidth="0x1" edc:desc="This enables the block for operation. 1=This block will function normally;     0=This block will gate its clock and go into its lowest power state"/>
            <edc:AdjustPoint edc:offset="0x1"/>
            <edc:SFRFieldDef edc:cname="CNT_UP" edc:nzwidth="0x1" edc:desc="This selects the counter direction. When the counter in incrementing the counter will saturate and trigger the event     when it reaches all F's. When the counter is decrementing the counter will saturate when it reaches 0h. 1=The counter will increment;     0=The counter will decrement"/>
            <edc:SFRFieldDef edc:cname="AU_RESTRT" edc:nzwidth="0x1" edc:desc="This will select the action taken upon completing a count.     1=The counter will automatically restart the count, using the contents of the Timer Preload Register to load the Timer Count Register.     The interrupt will be set in edge mode     0=The counter will simply enter a done state and wait for further control inputs. The interrupt will be set in level mode."/>
            <edc:SFRFieldDef edc:cname="SFT_RST" edc:nzwidth="0x1" edc:desc="This is a soft reset. This is self clearing 1 cycle after it is written. Firmware does not need     to wait before reconfiguring the Basic Timer following soft reset."/>
            <edc:SFRFieldDef edc:cname="STRT" edc:nzwidth="0x1" edc:desc="This bit triggers the timer counter. The counter will operate until it hits its terminating condition. This will     clear this bit. It should be noted that when operating in restart mode, there is no terminating condition for the counter, so     this bit will never clear. Clearing this bit will halt the timer counter."/>
            <edc:SFRFieldDef edc:cname="RLD" edc:nzwidth="0x1" edc:desc="This bit reloads the counter without interrupting it operation. This will not function if the timer has already     completed (when the START bit in this register is '0'). This is used to periodically prevent the timer from firing when an     event occurs. Usage while the timer is off may result in erroneous behaviour."/>
            <edc:SFRFieldDef edc:cname="HLT" edc:nzwidth="0x1" edc:desc="This is a halt bit. This will halt the timer as long as it is active. Once the halt is inactive, the timer will     start from where it left off. 1=Timer is halted. It stops counting. The clock divider will also be reset. 0=Timer runs normally."/>
            <edc:AdjustPoint edc:offset="0x8"/>
            <edc:SFRFieldDef edc:cname="PRESCALE" edc:nzwidth="0x10" edc:desc="This is used to divide down the system clock through clock enables to lower the power consumption of the block and allow     slow timers. Updating this value during operation may result in erroneous clock enable pulses until the clock divider restarts.     The number of clocks per clock enable pulse is (Value + 1); a setting of 0 runs at the full clock speed, while a setting of 1     runs at half speed."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:AdjustPoint edc:offset="0xC" edc:_addr="0x40000C94"/>
      <edc:SFRDef ltx:memberofperipheral="TIMER32_1" edc:cname="CNT" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x40000CA0"/>
      <edc:SFRDef ltx:memberofperipheral="TIMER32_1" edc:cname="PRLD" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x40000CA4"/>
      <edc:SFRDef ltx:memberofperipheral="TIMER32_1" edc:cname="STS" edc:nzwidth="0x20" edc:access="-------------------------------n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x1" edc:_addr="0x40000CA8">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="TIMER32_1">
            <edc:SFRFieldDef edc:cname="EVT_INT" edc:nzwidth="0x1" edc:desc="This is the interrupt status that fires when the timer reaches its limit. This is the interrupt status that fires when        the timer reaches its limit. This may be level or a self clearing signal cycle pulse, based on the AUTO_RESTART bit in the Timer        Control Register. If the timer is set to automatically restart, it will provide a pulse, otherwise a level is provided.(R/WC)"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="TIMER32_1" edc:cname="IEN" edc:nzwidth="0x20" edc:access="-------------------------------n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x1" edc:_addr="0x40000CAC">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="TIMER32_1">
            <edc:SFRFieldDef edc:cname="EN" edc:nzwidth="0x1" edc:desc="This is the interrupt enable for the status EVENT_INTERRUPT bit in the Timer Status Register."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="TIMER32_1" edc:cname="CTRL" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnn--------nnnnnn-n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0xFFFF00FD" edc:_addr="0x40000CB0">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="TIMER32_1">
            <edc:SFRFieldDef edc:cname="EN" edc:nzwidth="0x1" edc:desc="This enables the block for operation. 1=This block will function normally;     0=This block will gate its clock and go into its lowest power state"/>
            <edc:AdjustPoint edc:offset="0x1"/>
            <edc:SFRFieldDef edc:cname="CNT_UP" edc:nzwidth="0x1" edc:desc="This selects the counter direction. When the counter in incrementing the counter will saturate and trigger the event     when it reaches all F's. When the counter is decrementing the counter will saturate when it reaches 0h. 1=The counter will increment;     0=The counter will decrement"/>
            <edc:SFRFieldDef edc:cname="AU_RESTRT" edc:nzwidth="0x1" edc:desc="This will select the action taken upon completing a count.     1=The counter will automatically restart the count, using the contents of the Timer Preload Register to load the Timer Count Register.     The interrupt will be set in edge mode     0=The counter will simply enter a done state and wait for further control inputs. The interrupt will be set in level mode."/>
            <edc:SFRFieldDef edc:cname="SFT_RST" edc:nzwidth="0x1" edc:desc="This is a soft reset. This is self clearing 1 cycle after it is written. Firmware does not need     to wait before reconfiguring the Basic Timer following soft reset."/>
            <edc:SFRFieldDef edc:cname="STRT" edc:nzwidth="0x1" edc:desc="This bit triggers the timer counter. The counter will operate until it hits its terminating condition. This will     clear this bit. It should be noted that when operating in restart mode, there is no terminating condition for the counter, so     this bit will never clear. Clearing this bit will halt the timer counter."/>
            <edc:SFRFieldDef edc:cname="RLD" edc:nzwidth="0x1" edc:desc="This bit reloads the counter without interrupting it operation. This will not function if the timer has already     completed (when the START bit in this register is '0'). This is used to periodically prevent the timer from firing when an     event occurs. Usage while the timer is off may result in erroneous behaviour."/>
            <edc:SFRFieldDef edc:cname="HLT" edc:nzwidth="0x1" edc:desc="This is a halt bit. This will halt the timer as long as it is active. Once the halt is inactive, the timer will     start from where it left off. 1=Timer is halted. It stops counting. The clock divider will also be reset. 0=Timer runs normally."/>
            <edc:AdjustPoint edc:offset="0x8"/>
            <edc:SFRFieldDef edc:cname="PRESCALE" edc:nzwidth="0x10" edc:desc="This is used to divide down the system clock through clock enables to lower the power consumption of the block and allow     slow timers. Updating this value during operation may result in erroneous clock enable pulses until the clock divider restarts.     The number of clocks per clock enable pulse is (Value + 1); a setting of 0 runs at the full clock speed, while a setting of 1     runs at half speed."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:AdjustPoint edc:offset="0x34C" edc:_addr="0x40000CB4"/>
      <edc:SFRDef ltx:memberofperipheral="CCT" edc:cname="CTRL" edc:nzwidth="0x20" edc:access="------nn------nn------nn-nnn-nnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x3030377" edc:_addr="0x40001000">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="CCT">
            <edc:SFRFieldDef edc:cname="ACT" edc:nzwidth="0x1" edc:desc="This bit is used to start the capture and compare timer running and power it down."/>
            <edc:SFRFieldDef edc:cname="FREE_EN" edc:nzwidth="0x1" edc:desc="Free-Running Timer Enable. This bit is used to start and stop the free running timer."/>
            <edc:SFRFieldDef edc:cname="FREE_RST" edc:nzwidth="0x1" edc:desc="Free Running Timer Reset. This bit stops the timer and resets the internal counter to 0000_0000h."/>
            <edc:AdjustPoint edc:offset="0x1"/>
            <edc:SFRFieldDef edc:cname="TCLK" edc:nzwidth="0x3" edc:desc="This 3-bit field sets the clock source for the Free-Running Counter."/>
            <edc:AdjustPoint edc:offset="0x1"/>
            <edc:SFRFieldDef edc:cname="CMP_EN0" edc:nzwidth="0x1" edc:desc="Compare Enable for Compare 0 Register."/>
            <edc:SFRFieldDef edc:cname="CMP_EN1" edc:nzwidth="0x1" edc:desc="Compare Enable for Compare 1 Register."/>
            <edc:AdjustPoint edc:offset="0x6"/>
            <edc:SFRFieldDef edc:cname="CMP_SET1" edc:nzwidth="0x1" edc:desc="When read, returns the current value off the Compare Timer Output 1 state."/>
            <edc:SFRFieldDef edc:cname="CMP_SET0" edc:nzwidth="0x1" edc:desc="When read, returns the current value off the Compare Timer Output 0 state."/>
            <edc:AdjustPoint edc:offset="0x6"/>
            <edc:SFRFieldDef edc:cname="CMP_CLR1" edc:nzwidth="0x1" edc:desc="When read, returns the current value off the Compare Timer Output 1 state."/>
            <edc:SFRFieldDef edc:cname="CMP_CLR0" edc:nzwidth="0x1" edc:desc="When read, returns the current value off the Compare Timer Output 0 state."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="CCT" edc:cname="CAP0_CTRL" edc:nzwidth="0x20" edc:access="nnn--nnnnnn--nnnnnn--nnnnnn--nnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0xE7E7E7E7" edc:_addr="0x40001004">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="CCT">
            <edc:SFRFieldDef edc:cname="CAP_EDGE0" edc:nzwidth="0x2" edc:desc="This field selects the edge type that triggers the capture of the Free Running Counter into Capture Register 0.">
              <edc:SFRFieldSemantic edc:cname="FALLING" edc:desc="Capture on falling edge" edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="RISING" edc:desc="Capture on rising edge" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="BOTH" edc:desc="Capture on both falling and rising edges" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="DISABLED" edc:desc="Capture event disabled" edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="FILTER_BYP0" edc:nzwidth="0x1" edc:desc="This bit enables bypassing the input noise filter for Capture Register 0, so that the input signal goes directly into the timer."/>
            <edc:AdjustPoint edc:offset="0x2"/>
            <edc:SFRFieldDef edc:cname="FCLK_SEL0" edc:nzwidth="0x3" edc:desc="This 3-bit field sets the clock source for the input filter for Capture Register 0.">
              <edc:SFRFieldSemantic edc:cname="DIV_1" edc:desc="Divide by 1 (48 MHz)" edc:when="(field &amp; 0x7) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="DIV_2" edc:desc="Divide by 2 (24 MHz)" edc:when="(field &amp; 0x7) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="DIV_4" edc:desc="Divide by 4 (12 MHz)" edc:when="(field &amp; 0x7) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="DIV_8" edc:desc="Divide by 8 (6 MHz)" edc:when="(field &amp; 0x7) == 0x03"/>
              <edc:SFRFieldSemantic edc:cname="DIV_16" edc:desc="Divide by 16 (3 MHz)" edc:when="(field &amp; 0x7) == 0x04"/>
              <edc:SFRFieldSemantic edc:cname="DIV_32" edc:desc="Divide by 32 (1.5 MHz)" edc:when="(field &amp; 0x7) == 0x05"/>
              <edc:SFRFieldSemantic edc:cname="DIV_64" edc:desc="Divide by 64 (750 KHz)" edc:when="(field &amp; 0x7) == 0x06"/>
              <edc:SFRFieldSemantic edc:cname="DIV_128" edc:desc="Divide by 128 (375 KHz)" edc:when="(field &amp; 0x7) == 0x07"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="CAP_EDGE1" edc:nzwidth="0x2" edc:desc="This field selects the edge type that triggers the capture of the Free Running Counter into Capture Register 1.">
              <edc:SFRFieldSemantic edc:cname="FALLING" edc:desc="Capture on falling edge" edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="RISING" edc:desc="Capture on rising edge" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="BOTH" edc:desc="Capture on both falling and rising edges" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="DISABLED" edc:desc="Capture event disabled" edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="FILTER_BYP1" edc:nzwidth="0x1" edc:desc="This bit enables bypassing the input noise filter for Capture Register 1, so that the input signal goes directly into the timer."/>
            <edc:AdjustPoint edc:offset="0x2"/>
            <edc:SFRFieldDef edc:cname="FCLK_SEL1" edc:nzwidth="0x3" edc:desc="This 3-bit field sets the clock source for the input filter for Capture Register 1.">
              <edc:SFRFieldSemantic edc:cname="DIV_1" edc:desc="Divide by 1 (48 MHz)" edc:when="(field &amp; 0x7) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="DIV_2" edc:desc="Divide by 2 (24 MHz)" edc:when="(field &amp; 0x7) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="DIV_4" edc:desc="Divide by 4 (12 MHz)" edc:when="(field &amp; 0x7) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="DIV_8" edc:desc="Divide by 8 (6 MHz)" edc:when="(field &amp; 0x7) == 0x03"/>
              <edc:SFRFieldSemantic edc:cname="DIV_16" edc:desc="Divide by 16 (3 MHz)" edc:when="(field &amp; 0x7) == 0x04"/>
              <edc:SFRFieldSemantic edc:cname="DIV_32" edc:desc="Divide by 32 (1.5 MHz)" edc:when="(field &amp; 0x7) == 0x05"/>
              <edc:SFRFieldSemantic edc:cname="DIV_64" edc:desc="Divide by 64 (750 KHz)" edc:when="(field &amp; 0x7) == 0x06"/>
              <edc:SFRFieldSemantic edc:cname="DIV_128" edc:desc="Divide by 128 (375 KHz)" edc:when="(field &amp; 0x7) == 0x07"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="CAP_EDGE2" edc:nzwidth="0x2" edc:desc="This field selects the edge type that triggers the capture of the Free Running Counter into Capture Register 2.">
              <edc:SFRFieldSemantic edc:cname="FALLING" edc:desc="Capture on falling edge" edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="RISING" edc:desc="Capture on rising edge" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="BOTH" edc:desc="Capture on both falling and rising edges" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="DISABLED" edc:desc="Capture event disabled" edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="FILTER_BYP2" edc:nzwidth="0x1" edc:desc="This bit enables bypassing the input noise filter for Capture Register 2, so that the input signal goes directly into the timer."/>
            <edc:AdjustPoint edc:offset="0x2"/>
            <edc:SFRFieldDef edc:cname="FCLK_SEL2" edc:nzwidth="0x3" edc:desc="This 3-bit field sets the clock source for the input filter for Capture Register 2.">
              <edc:SFRFieldSemantic edc:cname="DIV_1" edc:desc="Divide by 1 (48 MHz)" edc:when="(field &amp; 0x7) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="DIV_2" edc:desc="Divide by 2 (24 MHz)" edc:when="(field &amp; 0x7) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="DIV_4" edc:desc="Divide by 4 (12 MHz)" edc:when="(field &amp; 0x7) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="DIV_8" edc:desc="Divide by 8 (6 MHz)" edc:when="(field &amp; 0x7) == 0x03"/>
              <edc:SFRFieldSemantic edc:cname="DIV_16" edc:desc="Divide by 16 (3 MHz)" edc:when="(field &amp; 0x7) == 0x04"/>
              <edc:SFRFieldSemantic edc:cname="DIV_32" edc:desc="Divide by 32 (1.5 MHz)" edc:when="(field &amp; 0x7) == 0x05"/>
              <edc:SFRFieldSemantic edc:cname="DIV_64" edc:desc="Divide by 64 (750 KHz)" edc:when="(field &amp; 0x7) == 0x06"/>
              <edc:SFRFieldSemantic edc:cname="DIV_128" edc:desc="Divide by 128 (375 KHz)" edc:when="(field &amp; 0x7) == 0x07"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="CAP_EDGE3" edc:nzwidth="0x2" edc:desc="This field selects the edge type that triggers the capture of the Free Running Counter into Capture Register 3.">
              <edc:SFRFieldSemantic edc:cname="FALLING" edc:desc="Capture on falling edge" edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="RISING" edc:desc="Capture on rising edge" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="BOTH" edc:desc="Capture on both falling and rising edges" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="DISABLED" edc:desc="Capture event disabled" edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="FILTER_BYP3" edc:nzwidth="0x1" edc:desc="This bit enables bypassing the input noise filter for Capture Register 3, so that the input signal goes directly into the timer."/>
            <edc:AdjustPoint edc:offset="0x2"/>
            <edc:SFRFieldDef edc:cname="FCLK_SEL3" edc:nzwidth="0x3" edc:desc="This 3-bit field sets the clock source for the input filter for Capture Register 3.">
              <edc:SFRFieldSemantic edc:cname="DIV_1" edc:desc="Divide by 1 (48 MHz)" edc:when="(field &amp; 0x7) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="DIV_2" edc:desc="Divide by 2 (24 MHz)" edc:when="(field &amp; 0x7) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="DIV_4" edc:desc="Divide by 4 (12 MHz)" edc:when="(field &amp; 0x7) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="DIV_8" edc:desc="Divide by 8 (6 MHz)" edc:when="(field &amp; 0x7) == 0x03"/>
              <edc:SFRFieldSemantic edc:cname="DIV_16" edc:desc="Divide by 16 (3 MHz)" edc:when="(field &amp; 0x7) == 0x04"/>
              <edc:SFRFieldSemantic edc:cname="DIV_32" edc:desc="Divide by 32 (1.5 MHz)" edc:when="(field &amp; 0x7) == 0x05"/>
              <edc:SFRFieldSemantic edc:cname="DIV_64" edc:desc="Divide by 64 (750 KHz)" edc:when="(field &amp; 0x7) == 0x06"/>
              <edc:SFRFieldSemantic edc:cname="DIV_128" edc:desc="Divide by 128 (375 KHz)" edc:when="(field &amp; 0x7) == 0x07"/>
            </edc:SFRFieldDef>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="CCT" edc:cname="CAP1_CTRL" edc:nzwidth="0x20" edc:access="----------------nnn--nnnnnn--nnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0xE7E7" edc:_addr="0x40001008">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="CCT">
            <edc:SFRFieldDef edc:cname="CAP_EDGE4" edc:nzwidth="0x2" edc:desc="This field selects the edge type that triggers the capture of the Free Running Counter into Capture Register 4.">
              <edc:SFRFieldSemantic edc:cname="FALLING" edc:desc="Capture on falling edge" edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="RISING" edc:desc="Capture on rising edge" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="BOTH" edc:desc="Capture on both falling and rising edges" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="DISABLED" edc:desc="Capture event disabled" edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="FILTER_BYP4" edc:nzwidth="0x1" edc:desc="This bit enables bypassing the input noise filter for Capture Register 4, so that the input signal goes directly into the timer."/>
            <edc:AdjustPoint edc:offset="0x2"/>
            <edc:SFRFieldDef edc:cname="FCLK_SEL4" edc:nzwidth="0x3" edc:desc="This 3-bit field sets the clock source for the input filter for Capture Register 4.">
              <edc:SFRFieldSemantic edc:cname="DIV_1" edc:desc="Divide by 1 (48 MHz)" edc:when="(field &amp; 0x7) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="DIV_2" edc:desc="Divide by 2 (24 MHz)" edc:when="(field &amp; 0x7) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="DIV_4" edc:desc="Divide by 4 (12 MHz)" edc:when="(field &amp; 0x7) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="DIV_8" edc:desc="Divide by 8 (6 MHz)" edc:when="(field &amp; 0x7) == 0x03"/>
              <edc:SFRFieldSemantic edc:cname="DIV_16" edc:desc="Divide by 16 (3 MHz)" edc:when="(field &amp; 0x7) == 0x04"/>
              <edc:SFRFieldSemantic edc:cname="DIV_32" edc:desc="Divide by 32 (1.5 MHz)" edc:when="(field &amp; 0x7) == 0x05"/>
              <edc:SFRFieldSemantic edc:cname="DIV_64" edc:desc="Divide by 64 (750 KHz)" edc:when="(field &amp; 0x7) == 0x06"/>
              <edc:SFRFieldSemantic edc:cname="DIV_128" edc:desc="Divide by 128 (375 KHz)" edc:when="(field &amp; 0x7) == 0x07"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="CAP_EDGE5" edc:nzwidth="0x2" edc:desc="This field selects the edge type that triggers the capture of the Free Running Counter into Capture Register 5.">
              <edc:SFRFieldSemantic edc:cname="FALLING" edc:desc="Capture on falling edge" edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="RISING" edc:desc="Capture on rising edge" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="BOTH" edc:desc="Capture on both falling and rising edges" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="DISABLED" edc:desc="Capture event disabled" edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="FILTER_BYP5" edc:nzwidth="0x1" edc:desc="This bit enables bypassing the input noise filter for Capture Register 5, so that the input signal goes directly into the timer."/>
            <edc:AdjustPoint edc:offset="0x2"/>
            <edc:SFRFieldDef edc:cname="FCLK_SEL5" edc:nzwidth="0x3" edc:desc="This 3-bit field sets the clock source for the input filter for Capture Register 5.">
              <edc:SFRFieldSemantic edc:cname="DIV_1" edc:desc="Divide by 1 (48 MHz)" edc:when="(field &amp; 0x7) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="DIV_2" edc:desc="Divide by 2 (24 MHz)" edc:when="(field &amp; 0x7) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="DIV_4" edc:desc="Divide by 4 (12 MHz)" edc:when="(field &amp; 0x7) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="DIV_8" edc:desc="Divide by 8 (6 MHz)" edc:when="(field &amp; 0x7) == 0x03"/>
              <edc:SFRFieldSemantic edc:cname="DIV_16" edc:desc="Divide by 16 (3 MHz)" edc:when="(field &amp; 0x7) == 0x04"/>
              <edc:SFRFieldSemantic edc:cname="DIV_32" edc:desc="Divide by 32 (1.5 MHz)" edc:when="(field &amp; 0x7) == 0x05"/>
              <edc:SFRFieldSemantic edc:cname="DIV_64" edc:desc="Divide by 64 (750 KHz)" edc:when="(field &amp; 0x7) == 0x06"/>
              <edc:SFRFieldSemantic edc:cname="DIV_128" edc:desc="Divide by 128 (375 KHz)" edc:when="(field &amp; 0x7) == 0x07"/>
            </edc:SFRFieldDef>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="CCT" edc:cname="FREE_RUN" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x4000100C">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="CCT">
            <edc:SFRFieldDef edc:cname="TMR" edc:nzwidth="0x20" edc:desc="This register contains the current value of the Free Running Timer."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="CCT" edc:cname="CAP0" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x40001010">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="CCT">
            <edc:SFRFieldDef edc:cname="CAP_0" edc:nzwidth="0x20" edc:desc="This register saves the value copied from the Free Running timer on a programmed edge of ICT0."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="CCT" edc:cname="CAP1" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x40001014">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="CCT">
            <edc:SFRFieldDef edc:cname="CAP_1" edc:nzwidth="0x20" edc:desc="This register saves the value copied from the Free Running timer on a programmed edge of ICT1."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="CCT" edc:cname="CAP2" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x40001018">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="CCT">
            <edc:SFRFieldDef edc:cname="CAP_2" edc:nzwidth="0x20" edc:desc="This register saves the value copied from the Free Running timer on a programmed edge of ICT2."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="CCT" edc:cname="CAP3" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x4000101C">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="CCT">
            <edc:SFRFieldDef edc:cname="CAP_3" edc:nzwidth="0x20" edc:desc="This register saves the value copied from the Free Running timer on a programmed edge of ICT3."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="CCT" edc:cname="CAP4" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x40001020">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="CCT">
            <edc:SFRFieldDef edc:cname="CAP_4" edc:nzwidth="0x20" edc:desc="This register saves the value copied from the Free Running timer on a programmed edge of ICT4."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="CCT" edc:cname="CAP5" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x40001024">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="CCT">
            <edc:SFRFieldDef edc:cname="CAP_5" edc:nzwidth="0x20" edc:desc="This register saves the value copied from the Free Running timer on a programmed edge of ICT5."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="CCT" edc:cname="COMP0" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x40001028">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="CCT">
            <edc:SFRFieldDef edc:cname="COMP_0" edc:nzwidth="0x20" edc:desc="A COMPARE 0 interrupt is generated when this register matches the value in the Free Running Timer."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="CCT" edc:cname="COMP1" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x4000102C">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="CCT">
            <edc:SFRFieldDef edc:cname="COMP_1" edc:nzwidth="0x20" edc:desc="A COMPARE 1 interrupt is generated when this register matches the value in the Free Running Timer."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="CCT" edc:cname="MUX_SEL" edc:nzwidth="0x20" edc:access="--------nnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000010101000011001000010000" edc:mclr="00000000010101000011001000010000" edc:impl="0xFFFFFF" edc:_addr="0x40001030">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="CCT">
            <edc:SFRFieldDef edc:cname="CAP0" edc:nzwidth="0x4" edc:desc="Mux Select for Capture 0 register."/>
            <edc:SFRFieldDef edc:cname="CAP1" edc:nzwidth="0x4" edc:desc="Mux Select for Capture 1 register."/>
            <edc:SFRFieldDef edc:cname="CAP2" edc:nzwidth="0x4" edc:desc="Mux Select for Capture 2 register."/>
            <edc:SFRFieldDef edc:cname="CAP3" edc:nzwidth="0x4" edc:desc="Mux Select for Capture 3 register."/>
            <edc:SFRFieldDef edc:cname="CAP4" edc:nzwidth="0x4" edc:desc="Mux Select for Capture 4 register."/>
            <edc:SFRFieldDef edc:cname="CAP5" edc:nzwidth="0x4" edc:desc="Mux Select for Capture 5 register."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:AdjustPoint edc:offset="0x13CC" edc:_addr="0x40001034"/>
      <edc:SFRDef ltx:memberofperipheral="DMA_MAIN" edc:cname="ACTRST" edc:nzwidth="0x8" edc:access="------nn" edc:por="00000000" edc:mclr="00000000" edc:impl="0x3" edc:_addr="0x40002400">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="DMA_MAIN">
            <edc:SFRFieldDef edc:cname="ACT" edc:nzwidth="0x1" edc:desc="Enable the blocks operation. (R/WS)                1=Enable block. Each individual channel must be enabled separately.                0=Disable all channels."/>
            <edc:SFRFieldDef edc:cname="SOFT_RST" edc:nzwidth="0x1" edc:desc="Soft reset the entire module. This bit is self-clearing."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:AdjustPoint edc:offset="0x3" edc:_addr="0x40002401"/>
      <edc:SFRDef ltx:memberofperipheral="DMA_MAIN" edc:cname="DATA_PKT" edc:nzwidth="0x20" edc:access="rrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrr" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x40002404"/>
      <edc:AdjustPoint edc:offset="0x38" edc:_addr="0x40002408"/>
      <edc:SFRDef ltx:memberofperipheral="DMA_CHAN00" edc:cname="ACTIVATE" edc:nzwidth="0x8" edc:access="-------n" edc:por="00000000" edc:mclr="00000000" edc:impl="0x1" edc:_addr="0x40002440">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="DMA_CHAN00">
            <edc:SFRFieldDef edc:cname="CHN" edc:nzwidth="0x1" edc:desc="Enable this channel for operation. The DMA Main Control:Activate must also be enabled for this channel to be operational.                  1=Enable channel(block). Each individual channel must be enabled separately.                  0=Disable channel(block)."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:AdjustPoint edc:offset="0x3" edc:_addr="0x40002441"/>
      <edc:SFRDef ltx:memberofperipheral="DMA_CHAN00" edc:cname="MSTART" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x40002444"/>
      <edc:SFRDef ltx:memberofperipheral="DMA_CHAN00" edc:cname="MEND" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x40002448"/>
      <edc:SFRDef ltx:memberofperipheral="DMA_CHAN00" edc:cname="DSTART" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x4000244C"/>
      <edc:SFRDef ltx:memberofperipheral="DMA_CHAN00" edc:cname="CTRL" edc:nzwidth="0x20" edc:access="------nn-nnnnnnnnnnnnnnn--nnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x37FFF3F" edc:_addr="0x40002450">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="DMA_CHAN00">
            <edc:SFRFieldDef edc:cname="RUN" edc:nzwidth="0x1" edc:desc="This is a control field. Note: This bit only applies to Hardware Flow Control mode.                  1= This channel is enabled and will service transfer requests                  0=This channel is disabled. All transfer requests are ignored."/>
            <edc:SFRFieldDef edc:cname="REQ" edc:nzwidth="0x1" edc:desc="This is a status field.                  1= There is a transfer request from the Master Device                  0= There is no transfer request from the Master Device"/>
            <edc:SFRFieldDef edc:cname="DONE" edc:nzwidth="0x1" edc:desc="This is a status signal. It is only valid while DMA Channel Control: Run is Enabled.                   This is the inverse of the DMA Channel Control: Busy field, except this is qualified with the DMA Channel Control:Run field.                  1=Channel is done                  0=Channel is not done or it is OFF"/>
            <edc:SFRFieldDef edc:cname="STS" edc:nzwidth="0x2" edc:desc="This is a status signal. The status decode is listed in priority order with the highest priority first.                  3: Error detected by the DMA                  2: The DMA Channel is externally done, in that the Device has terminated the transfer over the Hardware Flow Control through the Port dma_term                  1: The DMA Channel is locally done, in that Memory Start Address equals Memory End Address                  0: DMA Channel Control:Run is Disabled (0x0)">
              <edc:SFRFieldSemantic edc:cname="ERROR" edc:desc="3: Error detected by the DMA" edc:when="(field &amp; 0x3) == 0x03"/>
              <edc:SFRFieldSemantic edc:cname="EXT_DONE" edc:desc="2: The DMA Channel is externally done, in that the Device has terminated the transfer over the Hardware Flow Control through the Port dma_term" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="LOC_DONE" edc:desc="1: The DMA Channel is locally done, in that Memory Start Address equals Memory End Address" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="DIS" edc:desc="0: DMA Channel Control:Run is Disabled (0x0)" edc:when="(field &amp; 0x3) == 0x00"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="BUSY" edc:nzwidth="0x1" edc:desc="This is a status signal.                  1=The DMA Channel is busy (FSM is not IDLE)                  0=The DMA Channel is not busy (FSM is IDLE)"/>
            <edc:AdjustPoint edc:offset="0x2"/>
            <edc:SFRFieldDef edc:cname="TX_DIR" edc:nzwidth="0x1" edc:desc="This determines the direction of the DMA Transfer.                  1=Data Packet Read from Memory Start Address followed by Data Packet Write to Device Address                  0=Data Packet Read from Device Address followed by Data Packet Write to Memory Start Address"/>
            <edc:SFRFieldDef edc:cname="HW_FLOW_CTRL_DEV" edc:nzwidth="0x7" edc:desc="This is the device that is connected to this channel as its Hardware Flow Control master.                  The Flow Control Interface is a bus with each master concatenated onto it.                  This selects which bus index of the concatenated Flow Control Interface bus is targeted towards this channel.                  The Flow Control Interface Port list is dma_req, dma_term, and dma_done."/>
            <edc:SFRFieldDef edc:cname="INC_MEM_ADDR" edc:nzwidth="0x1" edc:desc="This will enable an auto-increment to the DMA Channel Memory Address.                  1=Increment the DMA Channel Memory Address by DMA Channel Control:Transfer Size after every Data Packet transfer                  0=Do nothing"/>
            <edc:SFRFieldDef edc:cname="INC_DEV_ADDR" edc:nzwidth="0x1" edc:desc="This will enable an auto-increment to the DMA Channel Device Address.                  1: Increment the DMA Channel Device Address by DMA Channel Control:Transfer Size after every Data Packet transfer                  0: Do nothing"/>
            <edc:SFRFieldDef edc:cname="LOCK" edc:nzwidth="0x1" edc:desc="This is used to lock the arbitration of the Channel Arbiter on this channel once this channel is granted. Once this is locked, it will remain on the arbiter until it has completed it transfer (either the Transfer Aborted, Transfer Done or Transfer Terminated conditions)."/>
            <edc:SFRFieldDef edc:cname="DIS_HW_FLOW_CTRL" edc:nzwidth="0x1" edc:desc="This will Disable the Hardware Flow Control. When disabled, any DMA Master device attempting to communicate to the DMA over the DMA Flow Control Interface (Ports: dma_req, dma_term, and dma_done) will be ignored. This should be set before using the DMA channel in Firmware Flow Control mode."/>
            <edc:SFRFieldDef edc:cname="TRANS_SIZE" edc:nzwidth="0x3" edc:desc="This is the transfer size in Bytes of each Data Packet transfer.                  Note: The transfer size must be a legal AMBA transfer size. Valid sizes are 1, 2 and 4 Bytes."/>
            <edc:AdjustPoint edc:offset="0x1"/>
            <edc:SFRFieldDef edc:cname="TRANS_GO" edc:nzwidth="0x1" edc:desc="This is used for the Firmware Flow Control DMA transfer."/>
            <edc:SFRFieldDef edc:cname="TRANS_ABORT" edc:nzwidth="0x1" edc:desc="This is used to abort the current transfer on this DMA Channel. The aborted transfer will be forced to terminate immediately."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="DMA_CHAN00" edc:cname="ISTS" edc:nzwidth="0x8" edc:access="-----nnn" edc:por="00000000" edc:mclr="00000000" edc:impl="0x7" edc:_addr="0x40002454">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="DMA_CHAN00">
            <edc:SFRFieldDef edc:cname="BUS_ERR" edc:nzwidth="0x1" edc:desc="This is an interrupt source register. This flags when there is an Error detected over the internal 32-bit Bus.                  1: Error detected. (R/WC)"/>
            <edc:SFRFieldDef edc:cname="FLOW_CTRL" edc:nzwidth="0x1" edc:desc="This is an interrupt source register. This flags when the DMA Channel has encountered a Hardware Flow Control Request     after the DMA Channel has completed the transfer. This means the Master Device is attempting to overflow the DMA.                  1=Hardware Flow Control is requesting after the transfer has completed                  0=No Hardware Flow Control event"/>
            <edc:SFRFieldDef edc:cname="DONE" edc:nzwidth="0x1" edc:desc="This is an interrupt source register. This flags when the DMA Channel has completed a transfer successfully on its side.     A completed transfer is defined as when the DMA Channel reaches its limit; Memory Start Address equals Memory End Address.     A completion due to a Hardware Flow Control Terminate will not flag this interrupt.                  1=Memory Start Address equals Memory End Address                  0=Memory Start Address does not equal Memory End Address"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:AdjustPoint edc:offset="0x3" edc:_addr="0x40002455"/>
      <edc:SFRDef ltx:memberofperipheral="DMA_CHAN00" edc:cname="IEN" edc:nzwidth="0x8" edc:access="-----nnn" edc:por="00000000" edc:mclr="00000000" edc:impl="0x7" edc:_addr="0x40002458">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="DMA_CHAN00">
            <edc:SFRFieldDef edc:cname="STS_EN_BUS_ERR" edc:nzwidth="0x1" edc:desc="This is an interrupt enable for DMA Channel Interrupt:Status Bus Error.                  1=Enable Interrupt                  0=Disable Interrupt"/>
            <edc:SFRFieldDef edc:cname="STS_EN_FLOW_CTRL" edc:nzwidth="0x1" edc:desc="This is an interrupt enable for DMA Channel Interrupt:Status Flow Control Error.                  1=Enable Interrupt                  0=Disable Interrupt"/>
            <edc:SFRFieldDef edc:cname="STS_EN_DONE" edc:nzwidth="0x1" edc:desc="This is an interrupt enable for DMA Channel Interrupt:Status Done.                  1=Enable Interrupt                  0=Disable Interrupt"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:AdjustPoint edc:offset="0x7" edc:_addr="0x40002459"/>
      <edc:SFRDef ltx:memberofperipheral="DMA_CHAN00" edc:cname="CRC_EN" edc:nzwidth="0x20" edc:access="------------------------------nn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x3" edc:_addr="0x40002460">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="DMA_CHAN00">
            <edc:SFRFieldDef edc:cname="MODE" edc:nzwidth="0x1" edc:desc="1=Enable the calculation of CRC-32 for DMA Channel N     0=Disable the calculation of CRC-32 for DMA Channel N"/>
            <edc:SFRFieldDef edc:cname="POST_TRANS" edc:nzwidth="0x1" edc:desc="The bit enables the transfer of the calculated CRC-32 after the completion of the DMA transaction.     If the DMA transaction is aborted by either firmware or an internal bus error, the transfer will not occur.     If the target of the DMA transfer is a device and the device signaled the termination of the DMA transaction,     the CRC post transfer will not occur.     1=Enable the transfer of CRC-32 for DMA Channel N after the DMA transaction completes     0=Disable the automatic transfer of the CRC"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="DMA_CHAN00" edc:cname="CRC_DATA" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x40002464">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="DMA_CHAN00">
            <edc:SFRFieldDef edc:cname="CRC" edc:nzwidth="0x20" edc:desc="Writes to this register initialize the CRC generator. Reads from this register return the output of the     CRC that is calculated from the data transferred by DMA Channel N. The output of the CRC generator is bit-reversed     and inverted on reads, as required by the CRC-32-IEEE definition. A CRC can be accumulated across multiple DMA transactions     on Channel N. If it is necessary to save the intermediate CRC value, the result of the read of this register must be     bit-reversed and inverted before being written back to this register."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="DMA_CHAN00" edc:cname="CRC_POST_STS" edc:nzwidth="0x20" edc:access="----------------------------nnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0xF" edc:_addr="0x40002468">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="DMA_CHAN00">
            <edc:SFRFieldDef edc:cname="CRC_DONE" edc:nzwidth="0x1" edc:desc="This bit is set to '1b' when the CRC calculation has completed from either normal or forced termination.     It is cleared to '0b' when the DMA controller starts a new transfer on the channel."/>
            <edc:SFRFieldDef edc:cname="CRC_RUNNING" edc:nzwidth="0x1" edc:desc="This bit is set to '1b' when the DMA controller starts the post-transfer transmission of the CRC.     It is only set when the post-transfer is enabled by the CRC_POST_TRANSFER_ENABLE field. This bit is cleared     to '0b' when the post-transfer completes."/>
            <edc:SFRFieldDef edc:cname="CRC_DATA_DONE" edc:nzwidth="0x1" edc:desc="This bit is set to '1b' when the DMA controller has completed the post-transfer of the CRC data.     This bit is cleared to '0b' when the a new DMA transfer starts."/>
            <edc:SFRFieldDef edc:cname="CRC_DATA_READY" edc:nzwidth="0x1" edc:desc="This bit is set to '1b' when the DMA controller is processing the post-transfer of the CRC data.     This bit is cleared to '0b' when the post-transfer completes."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:AdjustPoint edc:offset="0x14" edc:_addr="0x4000246C"/>
      <edc:SFRDef ltx:memberofperipheral="DMA_CHAN01" edc:cname="ACTIVATE" edc:nzwidth="0x8" edc:access="-------n" edc:por="00000000" edc:mclr="00000000" edc:impl="0x1" edc:_addr="0x40002480">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="DMA_CHAN01">
            <edc:SFRFieldDef edc:cname="CHN" edc:nzwidth="0x1" edc:desc="Enable this channel for operation. The DMA Main Control:Activate must also be enabled for this channel to be operational.                  1=Enable channel(block). Each individual channel must be enabled separately.                  0=Disable channel(block)."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:AdjustPoint edc:offset="0x3" edc:_addr="0x40002481"/>
      <edc:SFRDef ltx:memberofperipheral="DMA_CHAN01" edc:cname="MSTART" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x40002484"/>
      <edc:SFRDef ltx:memberofperipheral="DMA_CHAN01" edc:cname="MEND" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x40002488"/>
      <edc:SFRDef ltx:memberofperipheral="DMA_CHAN01" edc:cname="DSTART" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x4000248C"/>
      <edc:SFRDef ltx:memberofperipheral="DMA_CHAN01" edc:cname="CTRL" edc:nzwidth="0x20" edc:access="------nn-nnnnnnnnnnnnnnn--nnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x37FFF3F" edc:_addr="0x40002490">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="DMA_CHAN01">
            <edc:SFRFieldDef edc:cname="RUN" edc:nzwidth="0x1" edc:desc="This is a control field. Note: This bit only applies to Hardware Flow Control mode.                  1= This channel is enabled and will service transfer requests                  0=This channel is disabled. All transfer requests are ignored."/>
            <edc:SFRFieldDef edc:cname="REQ" edc:nzwidth="0x1" edc:desc="This is a status field.                  1= There is a transfer request from the Master Device                  0= There is no transfer request from the Master Device"/>
            <edc:SFRFieldDef edc:cname="DONE" edc:nzwidth="0x1" edc:desc="This is a status signal. It is only valid while DMA Channel Control: Run is Enabled.                   This is the inverse of the DMA Channel Control: Busy field, except this is qualified with the DMA Channel Control:Run field.                  1=Channel is done                  0=Channel is not done or it is OFF"/>
            <edc:SFRFieldDef edc:cname="STS" edc:nzwidth="0x2" edc:desc="This is a status signal. The status decode is listed in priority order with the highest priority first.                  3: Error detected by the DMA                  2: The DMA Channel is externally done, in that the Device has terminated the transfer over the Hardware Flow Control through the Port dma_term                  1: The DMA Channel is locally done, in that Memory Start Address equals Memory End Address                  0: DMA Channel Control:Run is Disabled (0x0)">
              <edc:SFRFieldSemantic edc:cname="ERROR" edc:desc="3: Error detected by the DMA" edc:when="(field &amp; 0x3) == 0x03"/>
              <edc:SFRFieldSemantic edc:cname="EXT_DONE" edc:desc="2: The DMA Channel is externally done, in that the Device has terminated the transfer over the Hardware Flow Control through the Port dma_term" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="LOC_DONE" edc:desc="1: The DMA Channel is locally done, in that Memory Start Address equals Memory End Address" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="DIS" edc:desc="0: DMA Channel Control:Run is Disabled (0x0)" edc:when="(field &amp; 0x3) == 0x00"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="BUSY" edc:nzwidth="0x1" edc:desc="This is a status signal.                  1=The DMA Channel is busy (FSM is not IDLE)                  0=The DMA Channel is not busy (FSM is IDLE)"/>
            <edc:AdjustPoint edc:offset="0x2"/>
            <edc:SFRFieldDef edc:cname="TX_DIR" edc:nzwidth="0x1" edc:desc="This determines the direction of the DMA Transfer.                  1=Data Packet Read from Memory Start Address followed by Data Packet Write to Device Address                  0=Data Packet Read from Device Address followed by Data Packet Write to Memory Start Address"/>
            <edc:SFRFieldDef edc:cname="HW_FLOW_CTRL_DEV" edc:nzwidth="0x7" edc:desc="This is the device that is connected to this channel as its Hardware Flow Control master.                  The Flow Control Interface is a bus with each master concatenated onto it.                  This selects which bus index of the concatenated Flow Control Interface bus is targeted towards this channel.                  The Flow Control Interface Port list is dma_req, dma_term, and dma_done."/>
            <edc:SFRFieldDef edc:cname="INC_MEM_ADDR" edc:nzwidth="0x1" edc:desc="This will enable an auto-increment to the DMA Channel Memory Address.                  1=Increment the DMA Channel Memory Address by DMA Channel Control:Transfer Size after every Data Packet transfer                  0=Do nothing"/>
            <edc:SFRFieldDef edc:cname="INC_DEV_ADDR" edc:nzwidth="0x1" edc:desc="This will enable an auto-increment to the DMA Channel Device Address.                  1: Increment the DMA Channel Device Address by DMA Channel Control:Transfer Size after every Data Packet transfer                  0: Do nothing"/>
            <edc:SFRFieldDef edc:cname="LOCK" edc:nzwidth="0x1" edc:desc="This is used to lock the arbitration of the Channel Arbiter on this channel once this channel is granted. Once this is locked, it will remain on the arbiter until it has completed it transfer (either the Transfer Aborted, Transfer Done or Transfer Terminated conditions)."/>
            <edc:SFRFieldDef edc:cname="DIS_HW_FLOW_CTRL" edc:nzwidth="0x1" edc:desc="This will Disable the Hardware Flow Control. When disabled, any DMA Master device attempting to communicate to the DMA over the DMA Flow Control Interface (Ports: dma_req, dma_term, and dma_done) will be ignored. This should be set before using the DMA channel in Firmware Flow Control mode."/>
            <edc:SFRFieldDef edc:cname="TRANS_SIZE" edc:nzwidth="0x3" edc:desc="This is the transfer size in Bytes of each Data Packet transfer.                  Note: The transfer size must be a legal AMBA transfer size. Valid sizes are 1, 2 and 4 Bytes."/>
            <edc:AdjustPoint edc:offset="0x1"/>
            <edc:SFRFieldDef edc:cname="TRANS_GO" edc:nzwidth="0x1" edc:desc="This is used for the Firmware Flow Control DMA transfer."/>
            <edc:SFRFieldDef edc:cname="TRANS_ABORT" edc:nzwidth="0x1" edc:desc="This is used to abort the current transfer on this DMA Channel. The aborted transfer will be forced to terminate immediately."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="DMA_CHAN01" edc:cname="ISTS" edc:nzwidth="0x8" edc:access="-----nnn" edc:por="00000000" edc:mclr="00000000" edc:impl="0x7" edc:_addr="0x40002494">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="DMA_CHAN01">
            <edc:SFRFieldDef edc:cname="BUS_ERROR" edc:nzwidth="0x1" edc:desc="This is an interrupt source register. This flags when there is an Error detected over the internal 32-bit Bus.                  1: Error detected. (R/WC)"/>
            <edc:SFRFieldDef edc:cname="FLOW_CTRL" edc:nzwidth="0x1" edc:desc="This is an interrupt source register. This flags when the DMA Channel has encountered a Hardware Flow Control Request     after the DMA Channel has completed the transfer. This means the Master Device is attempting to overflow the DMA.                  1=Hardware Flow Control is requesting after the transfer has completed                  0=No Hardware Flow Control event"/>
            <edc:SFRFieldDef edc:cname="DONE" edc:nzwidth="0x1" edc:desc="This is an interrupt source register. This flags when the DMA Channel has completed a transfer successfully on its side.     A completed transfer is defined as when the DMA Channel reaches its limit; Memory Start Address equals Memory End Address.     A completion due to a Hardware Flow Control Terminate will not flag this interrupt.                  1=Memory Start Address equals Memory End Address                  0=Memory Start Address does not equal Memory End Address"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:AdjustPoint edc:offset="0x3" edc:_addr="0x40002495"/>
      <edc:SFRDef ltx:memberofperipheral="DMA_CHAN01" edc:cname="IEN" edc:nzwidth="0x8" edc:access="-----nnn" edc:por="00000000" edc:mclr="00000000" edc:impl="0x7" edc:_addr="0x40002498">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="DMA_CHAN01">
            <edc:SFRFieldDef edc:cname="STS_EN_BUS_ERR" edc:nzwidth="0x1" edc:desc="This is an interrupt enable for DMA Channel Interrupt:Status Bus Error.                  1=Enable Interrupt                  0=Disable Interrupt"/>
            <edc:SFRFieldDef edc:cname="STS_EN_FLOW_CTRL" edc:nzwidth="0x1" edc:desc="This is an interrupt enable for DMA Channel Interrupt:Status Flow Control Error.                  1=Enable Interrupt                  0=Disable Interrupt"/>
            <edc:SFRFieldDef edc:cname="STS_EN_DONE" edc:nzwidth="0x1" edc:desc="This is an interrupt enable for DMA Channel Interrupt:Status Done.                  1=Enable Interrupt                  0=Disable Interrupt"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:AdjustPoint edc:offset="0x7" edc:_addr="0x40002499"/>
      <edc:SFRDef ltx:memberofperipheral="DMA_CHAN01" edc:cname="FILL_EN" edc:nzwidth="0x20" edc:access="-------------------------------n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x1" edc:_addr="0x400024A0">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="DMA_CHAN01">
            <edc:SFRFieldDef edc:cname="MODE" edc:nzwidth="0x1" edc:desc="1=Enable the DMA Channel Fill Engine N     0=Disable the DMA Channel Fill Engine"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="DMA_CHAN01" edc:cname="FILL_DATA" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x400024A4">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="DMA_CHAN01">
            <edc:SFRFieldDef edc:cname="DATA" edc:nzwidth="0x20" edc:desc="This is the data pattern used to fill memory."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="DMA_CHAN01" edc:cname="FILL_STS" edc:nzwidth="0x20" edc:access="------------------------------nn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x3" edc:_addr="0x400024A8">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="DMA_CHAN01">
            <edc:SFRFieldDef edc:cname="DONE" edc:nzwidth="0x1" edc:desc="This bit is set to '1b' when the CRC calculation has completed from either normal or forced termination.     It is cleared to '0b' when the DMA controller starts a new transfer on the channel."/>
            <edc:SFRFieldDef edc:cname="RUNNING" edc:nzwidth="0x1" edc:desc="This bit is set to '1b' when the DMA controller starts the post-transfer transmission of the CRC.     It is only set when the post-transfer is enabled by the CRC_POST_TRANSFER_ENABLE field. This bit is cleared     to '0b' when the post-transfer completes."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:AdjustPoint edc:offset="0x14" edc:_addr="0x400024AC"/>
      <edc:SFRDef ltx:memberofperipheral="DMA_CHAN02" edc:cname="ACTIVATE" edc:nzwidth="0x8" edc:access="-------n" edc:por="00000000" edc:mclr="00000000" edc:impl="0x1" edc:_addr="0x400024C0">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="DMA_CHAN02">
            <edc:SFRFieldDef edc:cname="CHN" edc:nzwidth="0x1" edc:desc="Enable this channel for operation. The DMA Main Control:Activate must also be enabled for this channel to be operational.                  1=Enable channel(block). Each individual channel must be enabled separately.                  0=Disable channel(block)."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:AdjustPoint edc:offset="0x3" edc:_addr="0x400024C1"/>
      <edc:SFRDef ltx:memberofperipheral="DMA_CHAN02" edc:cname="MSTART" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x400024C4"/>
      <edc:SFRDef ltx:memberofperipheral="DMA_CHAN02" edc:cname="MEND" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x400024C8"/>
      <edc:SFRDef ltx:memberofperipheral="DMA_CHAN02" edc:cname="DSTART" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x400024CC"/>
      <edc:SFRDef ltx:memberofperipheral="DMA_CHAN02" edc:cname="CTRL" edc:nzwidth="0x20" edc:access="------nn-nnnnnnnnnnnnnnn--nnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x37FFF3F" edc:_addr="0x400024D0">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="DMA_CHAN02">
            <edc:SFRFieldDef edc:cname="RUN" edc:nzwidth="0x1" edc:desc="This is a control field. Note: This bit only applies to Hardware Flow Control mode.                  1= This channel is enabled and will service transfer requests                  0=This channel is disabled. All transfer requests are ignored."/>
            <edc:SFRFieldDef edc:cname="REQ" edc:nzwidth="0x1" edc:desc="This is a status field.                  1= There is a transfer request from the Master Device                  0= There is no transfer request from the Master Device"/>
            <edc:SFRFieldDef edc:cname="DONE" edc:nzwidth="0x1" edc:desc="This is a status signal. It is only valid while DMA Channel Control: Run is Enabled.                   This is the inverse of the DMA Channel Control: Busy field, except this is qualified with the DMA Channel Control:Run field.                  1=Channel is done                  0=Channel is not done or it is OFF"/>
            <edc:SFRFieldDef edc:cname="STS" edc:nzwidth="0x2" edc:desc="This is a status signal. The status decode is listed in priority order with the highest priority first.                  3: Error detected by the DMA                  2: The DMA Channel is externally done, in that the Device has terminated the transfer over the Hardware Flow Control through the Port dma_term                  1: The DMA Channel is locally done, in that Memory Start Address equals Memory End Address                  0: DMA Channel Control:Run is Disabled (0x0)">
              <edc:SFRFieldSemantic edc:cname="ERROR" edc:desc="3: Error detected by the DMA" edc:when="(field &amp; 0x3) == 0x03"/>
              <edc:SFRFieldSemantic edc:cname="EXT_DONE" edc:desc="2: The DMA Channel is externally done, in that the Device has terminated the transfer over the Hardware Flow Control through the Port dma_term" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="LOC_DONE" edc:desc="1: The DMA Channel is locally done, in that Memory Start Address equals Memory End Address" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="DIS" edc:desc="0: DMA Channel Control:Run is Disabled (0x0)" edc:when="(field &amp; 0x3) == 0x00"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="BUSY" edc:nzwidth="0x1" edc:desc="This is a status signal.                  1=The DMA Channel is busy (FSM is not IDLE)                  0=The DMA Channel is not busy (FSM is IDLE)"/>
            <edc:AdjustPoint edc:offset="0x2"/>
            <edc:SFRFieldDef edc:cname="TX_DIR" edc:nzwidth="0x1" edc:desc="This determines the direction of the DMA Transfer.                  1=Data Packet Read from Memory Start Address followed by Data Packet Write to Device Address                  0=Data Packet Read from Device Address followed by Data Packet Write to Memory Start Address"/>
            <edc:SFRFieldDef edc:cname="HW_FLOW_CTRL_DEV" edc:nzwidth="0x7" edc:desc="This is the device that is connected to this channel as its Hardware Flow Control master.                  The Flow Control Interface is a bus with each master concatenated onto it.                  This selects which bus index of the concatenated Flow Control Interface bus is targeted towards this channel.                  The Flow Control Interface Port list is dma_req, dma_term, and dma_done."/>
            <edc:SFRFieldDef edc:cname="INC_MEM_ADDR" edc:nzwidth="0x1" edc:desc="This will enable an auto-increment to the DMA Channel Memory Address.                  1=Increment the DMA Channel Memory Address by DMA Channel Control:Transfer Size after every Data Packet transfer                  0=Do nothing"/>
            <edc:SFRFieldDef edc:cname="INC_DEV_ADDR" edc:nzwidth="0x1" edc:desc="This will enable an auto-increment to the DMA Channel Device Address.                  1: Increment the DMA Channel Device Address by DMA Channel Control:Transfer Size after every Data Packet transfer                  0: Do nothing"/>
            <edc:SFRFieldDef edc:cname="LOCK" edc:nzwidth="0x1" edc:desc="This is used to lock the arbitration of the Channel Arbiter on this channel once this channel is granted. Once this is locked, it will remain on the arbiter until it has completed it transfer (either the Transfer Aborted, Transfer Done or Transfer Terminated conditions)."/>
            <edc:SFRFieldDef edc:cname="DIS_HW_FLOW_CTRL" edc:nzwidth="0x1" edc:desc="This will Disable the Hardware Flow Control. When disabled, any DMA Master device attempting to communicate to the DMA over the DMA Flow Control Interface (Ports: dma_req, dma_term, and dma_done) will be ignored. This should be set before using the DMA channel in Firmware Flow Control mode."/>
            <edc:SFRFieldDef edc:cname="TRANS_SIZE" edc:nzwidth="0x3" edc:desc="This is the transfer size in Bytes of each Data Packet transfer.                  Note: The transfer size must be a legal AMBA transfer size. Valid sizes are 1, 2 and 4 Bytes."/>
            <edc:AdjustPoint edc:offset="0x1"/>
            <edc:SFRFieldDef edc:cname="TRANS_GO" edc:nzwidth="0x1" edc:desc="This is used for the Firmware Flow Control DMA transfer."/>
            <edc:SFRFieldDef edc:cname="TRANS_ABORT" edc:nzwidth="0x1" edc:desc="This is used to abort the current transfer on this DMA Channel. The aborted transfer will be forced to terminate immediately."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="DMA_CHAN02" edc:cname="ISTS" edc:nzwidth="0x8" edc:access="-----nnn" edc:por="00000000" edc:mclr="00000000" edc:impl="0x7" edc:_addr="0x400024D4">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="DMA_CHAN02">
            <edc:SFRFieldDef edc:cname="BUS_ERR" edc:nzwidth="0x1" edc:desc="This is an interrupt source register. This flags when there is an Error detected over the internal 32-bit Bus.                  1: Error detected. (R/WC)"/>
            <edc:SFRFieldDef edc:cname="FLOW_CTRL" edc:nzwidth="0x1" edc:desc="This is an interrupt source register. This flags when the DMA Channel has encountered a Hardware Flow Control Request     after the DMA Channel has completed the transfer. This means the Master Device is attempting to overflow the DMA.                  1=Hardware Flow Control is requesting after the transfer has completed                  0=No Hardware Flow Control event"/>
            <edc:SFRFieldDef edc:cname="DONE" edc:nzwidth="0x1" edc:desc="This is an interrupt source register. This flags when the DMA Channel has completed a transfer successfully on its side.     A completed transfer is defined as when the DMA Channel reaches its limit; Memory Start Address equals Memory End Address.     A completion due to a Hardware Flow Control Terminate will not flag this interrupt.                  1=Memory Start Address equals Memory End Address                  0=Memory Start Address does not equal Memory End Address"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:AdjustPoint edc:offset="0x3" edc:_addr="0x400024D5"/>
      <edc:SFRDef ltx:memberofperipheral="DMA_CHAN02" edc:cname="IEN" edc:nzwidth="0x8" edc:access="-----nnn" edc:por="00000000" edc:mclr="00000000" edc:impl="0x7" edc:_addr="0x400024D8">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="DMA_CHAN02">
            <edc:SFRFieldDef edc:cname="STS_EN_BUS_ERR" edc:nzwidth="0x1" edc:desc="This is an interrupt enable for DMA Channel Interrupt:Status Bus Error.                  1=Enable Interrupt                  0=Disable Interrupt"/>
            <edc:SFRFieldDef edc:cname="STS_EN_FLOW_CTRL" edc:nzwidth="0x1" edc:desc="This is an interrupt enable for DMA Channel Interrupt:Status Flow Control Error.                  1=Enable Interrupt                  0=Disable Interrupt"/>
            <edc:SFRFieldDef edc:cname="STS_EN_DONE" edc:nzwidth="0x1" edc:desc="This is an interrupt enable for DMA Channel Interrupt:Status Done.                  1=Enable Interrupt                  0=Disable Interrupt"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:AdjustPoint edc:offset="0x27" edc:_addr="0x400024D9"/>
      <edc:SFRDef ltx:memberofperipheral="DMA_CHAN03" edc:cname="ACTIVATE" edc:nzwidth="0x8" edc:access="-------n" edc:por="00000000" edc:mclr="00000000" edc:impl="0x1" edc:_addr="0x40002500">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="DMA_CHAN03">
            <edc:SFRFieldDef edc:cname="CHN" edc:nzwidth="0x1" edc:desc="Enable this channel for operation. The DMA Main Control:Activate must also be enabled for this channel to be operational.                  1=Enable channel(block). Each individual channel must be enabled separately.                  0=Disable channel(block)."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:AdjustPoint edc:offset="0x3" edc:_addr="0x40002501"/>
      <edc:SFRDef ltx:memberofperipheral="DMA_CHAN03" edc:cname="MSTART" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x40002504"/>
      <edc:SFRDef ltx:memberofperipheral="DMA_CHAN03" edc:cname="MEND" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x40002508"/>
      <edc:SFRDef ltx:memberofperipheral="DMA_CHAN03" edc:cname="DSTART" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x4000250C"/>
      <edc:SFRDef ltx:memberofperipheral="DMA_CHAN03" edc:cname="CTRL" edc:nzwidth="0x20" edc:access="------nn-nnnnnnnnnnnnnnn--nnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x37FFF3F" edc:_addr="0x40002510">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="DMA_CHAN03">
            <edc:SFRFieldDef edc:cname="RUN" edc:nzwidth="0x1" edc:desc="This is a control field. Note: This bit only applies to Hardware Flow Control mode.                  1= This channel is enabled and will service transfer requests                  0=This channel is disabled. All transfer requests are ignored."/>
            <edc:SFRFieldDef edc:cname="REQ" edc:nzwidth="0x1" edc:desc="This is a status field.                  1= There is a transfer request from the Master Device                  0= There is no transfer request from the Master Device"/>
            <edc:SFRFieldDef edc:cname="DONE" edc:nzwidth="0x1" edc:desc="This is a status signal. It is only valid while DMA Channel Control: Run is Enabled.                   This is the inverse of the DMA Channel Control: Busy field, except this is qualified with the DMA Channel Control:Run field.                  1=Channel is done                  0=Channel is not done or it is OFF"/>
            <edc:SFRFieldDef edc:cname="STS" edc:nzwidth="0x2" edc:desc="This is a status signal. The status decode is listed in priority order with the highest priority first.                  3: Error detected by the DMA                  2: The DMA Channel is externally done, in that the Device has terminated the transfer over the Hardware Flow Control through the Port dma_term                  1: The DMA Channel is locally done, in that Memory Start Address equals Memory End Address                  0: DMA Channel Control:Run is Disabled (0x0)">
              <edc:SFRFieldSemantic edc:cname="ERROR" edc:desc="3: Error detected by the DMA" edc:when="(field &amp; 0x3) == 0x03"/>
              <edc:SFRFieldSemantic edc:cname="EXT_DONE" edc:desc="2: The DMA Channel is externally done, in that the Device has terminated the transfer over the Hardware Flow Control through the Port dma_term" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="LOC_DONE" edc:desc="1: The DMA Channel is locally done, in that Memory Start Address equals Memory End Address" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="DIS" edc:desc="0: DMA Channel Control:Run is Disabled (0x0)" edc:when="(field &amp; 0x3) == 0x00"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="BUSY" edc:nzwidth="0x1" edc:desc="This is a status signal.                  1=The DMA Channel is busy (FSM is not IDLE)                  0=The DMA Channel is not busy (FSM is IDLE)"/>
            <edc:AdjustPoint edc:offset="0x2"/>
            <edc:SFRFieldDef edc:cname="TX_DIR" edc:nzwidth="0x1" edc:desc="This determines the direction of the DMA Transfer.                  1=Data Packet Read from Memory Start Address followed by Data Packet Write to Device Address                  0=Data Packet Read from Device Address followed by Data Packet Write to Memory Start Address"/>
            <edc:SFRFieldDef edc:cname="HW_FLOW_CTRL_DEV" edc:nzwidth="0x7" edc:desc="This is the device that is connected to this channel as its Hardware Flow Control master.                  The Flow Control Interface is a bus with each master concatenated onto it.                  This selects which bus index of the concatenated Flow Control Interface bus is targeted towards this channel.                  The Flow Control Interface Port list is dma_req, dma_term, and dma_done."/>
            <edc:SFRFieldDef edc:cname="INC_MEM_ADDR" edc:nzwidth="0x1" edc:desc="This will enable an auto-increment to the DMA Channel Memory Address.                  1=Increment the DMA Channel Memory Address by DMA Channel Control:Transfer Size after every Data Packet transfer                  0=Do nothing"/>
            <edc:SFRFieldDef edc:cname="INC_DEV_ADDR" edc:nzwidth="0x1" edc:desc="This will enable an auto-increment to the DMA Channel Device Address.                  1: Increment the DMA Channel Device Address by DMA Channel Control:Transfer Size after every Data Packet transfer                  0: Do nothing"/>
            <edc:SFRFieldDef edc:cname="LOCK" edc:nzwidth="0x1" edc:desc="This is used to lock the arbitration of the Channel Arbiter on this channel once this channel is granted. Once this is locked, it will remain on the arbiter until it has completed it transfer (either the Transfer Aborted, Transfer Done or Transfer Terminated conditions)."/>
            <edc:SFRFieldDef edc:cname="DIS_HW_FLOW_CTRL" edc:nzwidth="0x1" edc:desc="This will Disable the Hardware Flow Control. When disabled, any DMA Master device attempting to communicate to the DMA over the DMA Flow Control Interface (Ports: dma_req, dma_term, and dma_done) will be ignored. This should be set before using the DMA channel in Firmware Flow Control mode."/>
            <edc:SFRFieldDef edc:cname="TRANS_SIZE" edc:nzwidth="0x3" edc:desc="This is the transfer size in Bytes of each Data Packet transfer.                  Note: The transfer size must be a legal AMBA transfer size. Valid sizes are 1, 2 and 4 Bytes."/>
            <edc:AdjustPoint edc:offset="0x1"/>
            <edc:SFRFieldDef edc:cname="TRANS_GO" edc:nzwidth="0x1" edc:desc="This is used for the Firmware Flow Control DMA transfer."/>
            <edc:SFRFieldDef edc:cname="TRANS_ABORT" edc:nzwidth="0x1" edc:desc="This is used to abort the current transfer on this DMA Channel. The aborted transfer will be forced to terminate immediately."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="DMA_CHAN03" edc:cname="ISTS" edc:nzwidth="0x8" edc:access="-----nnn" edc:por="00000000" edc:mclr="00000000" edc:impl="0x7" edc:_addr="0x40002514">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="DMA_CHAN03">
            <edc:SFRFieldDef edc:cname="BUS_ERR" edc:nzwidth="0x1" edc:desc="This is an interrupt source register. This flags when there is an Error detected over the internal 32-bit Bus.                  1: Error detected. (R/WC)"/>
            <edc:SFRFieldDef edc:cname="FLOW_CTRL" edc:nzwidth="0x1" edc:desc="This is an interrupt source register. This flags when the DMA Channel has encountered a Hardware Flow Control Request     after the DMA Channel has completed the transfer. This means the Master Device is attempting to overflow the DMA.                  1=Hardware Flow Control is requesting after the transfer has completed                  0=No Hardware Flow Control event"/>
            <edc:SFRFieldDef edc:cname="DONE" edc:nzwidth="0x1" edc:desc="This is an interrupt source register. This flags when the DMA Channel has completed a transfer successfully on its side.     A completed transfer is defined as when the DMA Channel reaches its limit; Memory Start Address equals Memory End Address.     A completion due to a Hardware Flow Control Terminate will not flag this interrupt.                  1=Memory Start Address equals Memory End Address                  0=Memory Start Address does not equal Memory End Address"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:AdjustPoint edc:offset="0x3" edc:_addr="0x40002515"/>
      <edc:SFRDef ltx:memberofperipheral="DMA_CHAN03" edc:cname="IEN" edc:nzwidth="0x8" edc:access="-----nnn" edc:por="00000000" edc:mclr="00000000" edc:impl="0x7" edc:_addr="0x40002518">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="DMA_CHAN03">
            <edc:SFRFieldDef edc:cname="STS_EN_BUS_ERR" edc:nzwidth="0x1" edc:desc="This is an interrupt enable for DMA Channel Interrupt:Status Bus Error.                  1=Enable Interrupt                  0=Disable Interrupt"/>
            <edc:SFRFieldDef edc:cname="STS_EN_FLOW_CTRL" edc:nzwidth="0x1" edc:desc="This is an interrupt enable for DMA Channel Interrupt:Status Flow Control Error.                  1=Enable Interrupt                  0=Disable Interrupt"/>
            <edc:SFRFieldDef edc:cname="STS_EN_DONE" edc:nzwidth="0x1" edc:desc="This is an interrupt enable for DMA Channel Interrupt:Status Done.                  1=Enable Interrupt                  0=Disable Interrupt"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:AdjustPoint edc:offset="0x27" edc:_addr="0x40002519"/>
      <edc:SFRDef ltx:memberofperipheral="DMA_CHAN04" edc:cname="ACTIVATE" edc:nzwidth="0x8" edc:access="-------n" edc:por="00000000" edc:mclr="00000000" edc:impl="0x1" edc:_addr="0x40002540">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="DMA_CHAN04">
            <edc:SFRFieldDef edc:cname="CHN" edc:nzwidth="0x1" edc:desc="Enable this channel for operation. The DMA Main Control:Activate must also be enabled for this channel to be operational.                  1=Enable channel(block). Each individual channel must be enabled separately.                  0=Disable channel(block)."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:AdjustPoint edc:offset="0x3" edc:_addr="0x40002541"/>
      <edc:SFRDef ltx:memberofperipheral="DMA_CHAN04" edc:cname="MSTART" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x40002544"/>
      <edc:SFRDef ltx:memberofperipheral="DMA_CHAN04" edc:cname="MEND" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x40002548"/>
      <edc:SFRDef ltx:memberofperipheral="DMA_CHAN04" edc:cname="DSTART" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x4000254C"/>
      <edc:SFRDef ltx:memberofperipheral="DMA_CHAN04" edc:cname="CTRL" edc:nzwidth="0x20" edc:access="------nn-nnnnnnnnnnnnnnn--nnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x37FFF3F" edc:_addr="0x40002550">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="DMA_CHAN04">
            <edc:SFRFieldDef edc:cname="RUN" edc:nzwidth="0x1" edc:desc="This is a control field. Note: This bit only applies to Hardware Flow Control mode.                  1= This channel is enabled and will service transfer requests                  0=This channel is disabled. All transfer requests are ignored."/>
            <edc:SFRFieldDef edc:cname="REQ" edc:nzwidth="0x1" edc:desc="This is a status field.                  1= There is a transfer request from the Master Device                  0= There is no transfer request from the Master Device"/>
            <edc:SFRFieldDef edc:cname="DONE" edc:nzwidth="0x1" edc:desc="This is a status signal. It is only valid while DMA Channel Control: Run is Enabled.                   This is the inverse of the DMA Channel Control: Busy field, except this is qualified with the DMA Channel Control:Run field.                  1=Channel is done                  0=Channel is not done or it is OFF"/>
            <edc:SFRFieldDef edc:cname="STS" edc:nzwidth="0x2" edc:desc="This is a status signal. The status decode is listed in priority order with the highest priority first.                  3: Error detected by the DMA                  2: The DMA Channel is externally done, in that the Device has terminated the transfer over the Hardware Flow Control through the Port dma_term                  1: The DMA Channel is locally done, in that Memory Start Address equals Memory End Address                  0: DMA Channel Control:Run is Disabled (0x0)">
              <edc:SFRFieldSemantic edc:cname="ERROR" edc:desc="3: Error detected by the DMA" edc:when="(field &amp; 0x3) == 0x03"/>
              <edc:SFRFieldSemantic edc:cname="EXT_DONE" edc:desc="2: The DMA Channel is externally done, in that the Device has terminated the transfer over the Hardware Flow Control through the Port dma_term" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="LOC_DONE" edc:desc="1: The DMA Channel is locally done, in that Memory Start Address equals Memory End Address" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="DIS" edc:desc="0: DMA Channel Control:Run is Disabled (0x0)" edc:when="(field &amp; 0x3) == 0x00"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="BUSY" edc:nzwidth="0x1" edc:desc="This is a status signal.                  1=The DMA Channel is busy (FSM is not IDLE)                  0=The DMA Channel is not busy (FSM is IDLE)"/>
            <edc:AdjustPoint edc:offset="0x2"/>
            <edc:SFRFieldDef edc:cname="TX_DIR" edc:nzwidth="0x1" edc:desc="This determines the direction of the DMA Transfer.                  1=Data Packet Read from Memory Start Address followed by Data Packet Write to Device Address                  0=Data Packet Read from Device Address followed by Data Packet Write to Memory Start Address"/>
            <edc:SFRFieldDef edc:cname="HW_FLOW_CTRL_DEV" edc:nzwidth="0x7" edc:desc="This is the device that is connected to this channel as its Hardware Flow Control master.                  The Flow Control Interface is a bus with each master concatenated onto it.                  This selects which bus index of the concatenated Flow Control Interface bus is targeted towards this channel.                  The Flow Control Interface Port list is dma_req, dma_term, and dma_done."/>
            <edc:SFRFieldDef edc:cname="INC_MEM_ADDR" edc:nzwidth="0x1" edc:desc="This will enable an auto-increment to the DMA Channel Memory Address.                  1=Increment the DMA Channel Memory Address by DMA Channel Control:Transfer Size after every Data Packet transfer                  0=Do nothing"/>
            <edc:SFRFieldDef edc:cname="INC_DEV_ADDR" edc:nzwidth="0x1" edc:desc="This will enable an auto-increment to the DMA Channel Device Address.                  1: Increment the DMA Channel Device Address by DMA Channel Control:Transfer Size after every Data Packet transfer                  0: Do nothing"/>
            <edc:SFRFieldDef edc:cname="LOCK" edc:nzwidth="0x1" edc:desc="This is used to lock the arbitration of the Channel Arbiter on this channel once this channel is granted. Once this is locked, it will remain on the arbiter until it has completed it transfer (either the Transfer Aborted, Transfer Done or Transfer Terminated conditions)."/>
            <edc:SFRFieldDef edc:cname="DIS_HW_FLOW_CTRL" edc:nzwidth="0x1" edc:desc="This will Disable the Hardware Flow Control. When disabled, any DMA Master device attempting to communicate to the DMA over the DMA Flow Control Interface (Ports: dma_req, dma_term, and dma_done) will be ignored. This should be set before using the DMA channel in Firmware Flow Control mode."/>
            <edc:SFRFieldDef edc:cname="TRANS_SIZE" edc:nzwidth="0x3" edc:desc="This is the transfer size in Bytes of each Data Packet transfer.                  Note: The transfer size must be a legal AMBA transfer size. Valid sizes are 1, 2 and 4 Bytes."/>
            <edc:AdjustPoint edc:offset="0x1"/>
            <edc:SFRFieldDef edc:cname="TRANS_GO" edc:nzwidth="0x1" edc:desc="This is used for the Firmware Flow Control DMA transfer."/>
            <edc:SFRFieldDef edc:cname="TRANS_ABORT" edc:nzwidth="0x1" edc:desc="This is used to abort the current transfer on this DMA Channel. The aborted transfer will be forced to terminate immediately."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="DMA_CHAN04" edc:cname="ISTS" edc:nzwidth="0x8" edc:access="-----nnn" edc:por="00000000" edc:mclr="00000000" edc:impl="0x7" edc:_addr="0x40002554">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="DMA_CHAN04">
            <edc:SFRFieldDef edc:cname="BUS_ERR" edc:nzwidth="0x1" edc:desc="This is an interrupt source register. This flags when there is an Error detected over the internal 32-bit Bus.                  1: Error detected. (R/WC)"/>
            <edc:SFRFieldDef edc:cname="FLOW_CTRL" edc:nzwidth="0x1" edc:desc="This is an interrupt source register. This flags when the DMA Channel has encountered a Hardware Flow Control Request     after the DMA Channel has completed the transfer. This means the Master Device is attempting to overflow the DMA.                  1=Hardware Flow Control is requesting after the transfer has completed                  0=No Hardware Flow Control event"/>
            <edc:SFRFieldDef edc:cname="DONE" edc:nzwidth="0x1" edc:desc="This is an interrupt source register. This flags when the DMA Channel has completed a transfer successfully on its side.     A completed transfer is defined as when the DMA Channel reaches its limit; Memory Start Address equals Memory End Address.     A completion due to a Hardware Flow Control Terminate will not flag this interrupt.                  1=Memory Start Address equals Memory End Address                  0=Memory Start Address does not equal Memory End Address"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:AdjustPoint edc:offset="0x3" edc:_addr="0x40002555"/>
      <edc:SFRDef ltx:memberofperipheral="DMA_CHAN04" edc:cname="IEN" edc:nzwidth="0x8" edc:access="-----nnn" edc:por="00000000" edc:mclr="00000000" edc:impl="0x7" edc:_addr="0x40002558">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="DMA_CHAN04">
            <edc:SFRFieldDef edc:cname="STS_EN_BUS_ERR" edc:nzwidth="0x1" edc:desc="This is an interrupt enable for DMA Channel Interrupt:Status Bus Error.                  1=Enable Interrupt                  0=Disable Interrupt"/>
            <edc:SFRFieldDef edc:cname="STS_EN_FLOW_CTRL" edc:nzwidth="0x1" edc:desc="This is an interrupt enable for DMA Channel Interrupt:Status Flow Control Error.                  1=Enable Interrupt                  0=Disable Interrupt"/>
            <edc:SFRFieldDef edc:cname="STS_EN_DONE" edc:nzwidth="0x1" edc:desc="This is an interrupt enable for DMA Channel Interrupt:Status Done.                  1=Enable Interrupt                  0=Disable Interrupt"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:AdjustPoint edc:offset="0x27" edc:_addr="0x40002559"/>
      <edc:SFRDef ltx:memberofperipheral="DMA_CHAN05" edc:cname="ACTIVATE" edc:nzwidth="0x8" edc:access="-------n" edc:por="00000000" edc:mclr="00000000" edc:impl="0x1" edc:_addr="0x40002580">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="DMA_CHAN05">
            <edc:SFRFieldDef edc:cname="CHN" edc:nzwidth="0x1" edc:desc="Enable this channel for operation. The DMA Main Control:Activate must also be enabled for this channel to be operational.                  1=Enable channel(block). Each individual channel must be enabled separately.                  0=Disable channel(block)."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:AdjustPoint edc:offset="0x3" edc:_addr="0x40002581"/>
      <edc:SFRDef ltx:memberofperipheral="DMA_CHAN05" edc:cname="MSTART" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x40002584"/>
      <edc:SFRDef ltx:memberofperipheral="DMA_CHAN05" edc:cname="MEND" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x40002588"/>
      <edc:SFRDef ltx:memberofperipheral="DMA_CHAN05" edc:cname="DSTART" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x4000258C"/>
      <edc:SFRDef ltx:memberofperipheral="DMA_CHAN05" edc:cname="CTRL" edc:nzwidth="0x20" edc:access="------nn-nnnnnnnnnnnnnnn--nnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x37FFF3F" edc:_addr="0x40002590">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="DMA_CHAN05">
            <edc:SFRFieldDef edc:cname="RUN" edc:nzwidth="0x1" edc:desc="This is a control field. Note: This bit only applies to Hardware Flow Control mode.                  1= This channel is enabled and will service transfer requests                  0=This channel is disabled. All transfer requests are ignored."/>
            <edc:SFRFieldDef edc:cname="REQ" edc:nzwidth="0x1" edc:desc="This is a status field.                  1= There is a transfer request from the Master Device                  0= There is no transfer request from the Master Device"/>
            <edc:SFRFieldDef edc:cname="DONE" edc:nzwidth="0x1" edc:desc="This is a status signal. It is only valid while DMA Channel Control: Run is Enabled.                   This is the inverse of the DMA Channel Control: Busy field, except this is qualified with the DMA Channel Control:Run field.                  1=Channel is done                  0=Channel is not done or it is OFF"/>
            <edc:SFRFieldDef edc:cname="STS" edc:nzwidth="0x2" edc:desc="This is a status signal. The status decode is listed in priority order with the highest priority first.                  3: Error detected by the DMA                  2: The DMA Channel is externally done, in that the Device has terminated the transfer over the Hardware Flow Control through the Port dma_term                  1: The DMA Channel is locally done, in that Memory Start Address equals Memory End Address                  0: DMA Channel Control:Run is Disabled (0x0)">
              <edc:SFRFieldSemantic edc:cname="ERROR" edc:desc="3: Error detected by the DMA" edc:when="(field &amp; 0x3) == 0x03"/>
              <edc:SFRFieldSemantic edc:cname="EXT_DONE" edc:desc="2: The DMA Channel is externally done, in that the Device has terminated the transfer over the Hardware Flow Control through the Port dma_term" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="LOC_DONE" edc:desc="1: The DMA Channel is locally done, in that Memory Start Address equals Memory End Address" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="DIS" edc:desc="0: DMA Channel Control:Run is Disabled (0x0)" edc:when="(field &amp; 0x3) == 0x00"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="BUSY" edc:nzwidth="0x1" edc:desc="This is a status signal.                  1=The DMA Channel is busy (FSM is not IDLE)                  0=The DMA Channel is not busy (FSM is IDLE)"/>
            <edc:AdjustPoint edc:offset="0x2"/>
            <edc:SFRFieldDef edc:cname="TX_DIR" edc:nzwidth="0x1" edc:desc="This determines the direction of the DMA Transfer.                  1=Data Packet Read from Memory Start Address followed by Data Packet Write to Device Address                  0=Data Packet Read from Device Address followed by Data Packet Write to Memory Start Address"/>
            <edc:SFRFieldDef edc:cname="HW_FLOW_CTRL_DEV" edc:nzwidth="0x7" edc:desc="This is the device that is connected to this channel as its Hardware Flow Control master.                  The Flow Control Interface is a bus with each master concatenated onto it.                  This selects which bus index of the concatenated Flow Control Interface bus is targeted towards this channel.                  The Flow Control Interface Port list is dma_req, dma_term, and dma_done."/>
            <edc:SFRFieldDef edc:cname="INC_MEM_ADDR" edc:nzwidth="0x1" edc:desc="This will enable an auto-increment to the DMA Channel Memory Address.                  1=Increment the DMA Channel Memory Address by DMA Channel Control:Transfer Size after every Data Packet transfer                  0=Do nothing"/>
            <edc:SFRFieldDef edc:cname="INC_DEV_ADDR" edc:nzwidth="0x1" edc:desc="This will enable an auto-increment to the DMA Channel Device Address.                  1: Increment the DMA Channel Device Address by DMA Channel Control:Transfer Size after every Data Packet transfer                  0: Do nothing"/>
            <edc:SFRFieldDef edc:cname="LOCK" edc:nzwidth="0x1" edc:desc="This is used to lock the arbitration of the Channel Arbiter on this channel once this channel is granted. Once this is locked, it will remain on the arbiter until it has completed it transfer (either the Transfer Aborted, Transfer Done or Transfer Terminated conditions)."/>
            <edc:SFRFieldDef edc:cname="DIS_HW_FLOW_CTRL" edc:nzwidth="0x1" edc:desc="This will Disable the Hardware Flow Control. When disabled, any DMA Master device attempting to communicate to the DMA over the DMA Flow Control Interface (Ports: dma_req, dma_term, and dma_done) will be ignored. This should be set before using the DMA channel in Firmware Flow Control mode."/>
            <edc:SFRFieldDef edc:cname="TRANS_SIZE" edc:nzwidth="0x3" edc:desc="This is the transfer size in Bytes of each Data Packet transfer.                  Note: The transfer size must be a legal AMBA transfer size. Valid sizes are 1, 2 and 4 Bytes."/>
            <edc:AdjustPoint edc:offset="0x1"/>
            <edc:SFRFieldDef edc:cname="TRANS_GO" edc:nzwidth="0x1" edc:desc="This is used for the Firmware Flow Control DMA transfer."/>
            <edc:SFRFieldDef edc:cname="TRANS_ABORT" edc:nzwidth="0x1" edc:desc="This is used to abort the current transfer on this DMA Channel. The aborted transfer will be forced to terminate immediately."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="DMA_CHAN05" edc:cname="ISTS" edc:nzwidth="0x8" edc:access="-----nnn" edc:por="00000000" edc:mclr="00000000" edc:impl="0x7" edc:_addr="0x40002594">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="DMA_CHAN05">
            <edc:SFRFieldDef edc:cname="BUS_ERR" edc:nzwidth="0x1" edc:desc="This is an interrupt source register. This flags when there is an Error detected over the internal 32-bit Bus.                  1: Error detected. (R/WC)"/>
            <edc:SFRFieldDef edc:cname="FLOW_CTRL" edc:nzwidth="0x1" edc:desc="This is an interrupt source register. This flags when the DMA Channel has encountered a Hardware Flow Control Request     after the DMA Channel has completed the transfer. This means the Master Device is attempting to overflow the DMA.                  1=Hardware Flow Control is requesting after the transfer has completed                  0=No Hardware Flow Control event"/>
            <edc:SFRFieldDef edc:cname="DONE" edc:nzwidth="0x1" edc:desc="This is an interrupt source register. This flags when the DMA Channel has completed a transfer successfully on its side.     A completed transfer is defined as when the DMA Channel reaches its limit; Memory Start Address equals Memory End Address.     A completion due to a Hardware Flow Control Terminate will not flag this interrupt.                  1=Memory Start Address equals Memory End Address                  0=Memory Start Address does not equal Memory End Address"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:AdjustPoint edc:offset="0x3" edc:_addr="0x40002595"/>
      <edc:SFRDef ltx:memberofperipheral="DMA_CHAN05" edc:cname="IEN" edc:nzwidth="0x8" edc:access="-----nnn" edc:por="00000000" edc:mclr="00000000" edc:impl="0x7" edc:_addr="0x40002598">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="DMA_CHAN05">
            <edc:SFRFieldDef edc:cname="STS_EN_BUS_ERR" edc:nzwidth="0x1" edc:desc="This is an interrupt enable for DMA Channel Interrupt:Status Bus Error.                  1=Enable Interrupt                  0=Disable Interrupt"/>
            <edc:SFRFieldDef edc:cname="STS_EN_FLOW_CTRL" edc:nzwidth="0x1" edc:desc="This is an interrupt enable for DMA Channel Interrupt:Status Flow Control Error.                  1=Enable Interrupt                  0=Disable Interrupt"/>
            <edc:SFRFieldDef edc:cname="STS_EN_DONE" edc:nzwidth="0x1" edc:desc="This is an interrupt enable for DMA Channel Interrupt:Status Done.                  1=Enable Interrupt                  0=Disable Interrupt"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:AdjustPoint edc:offset="0x27" edc:_addr="0x40002599"/>
      <edc:SFRDef ltx:memberofperipheral="DMA_CHAN06" edc:cname="ACTIVATE" edc:nzwidth="0x8" edc:access="-------n" edc:por="00000000" edc:mclr="00000000" edc:impl="0x1" edc:_addr="0x400025C0">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="DMA_CHAN06">
            <edc:SFRFieldDef edc:cname="CHN" edc:nzwidth="0x1" edc:desc="Enable this channel for operation. The DMA Main Control:Activate must also be enabled for this channel to be operational.                  1=Enable channel(block). Each individual channel must be enabled separately.                  0=Disable channel(block)."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:AdjustPoint edc:offset="0x3" edc:_addr="0x400025C1"/>
      <edc:SFRDef ltx:memberofperipheral="DMA_CHAN06" edc:cname="MSTART" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x400025C4"/>
      <edc:SFRDef ltx:memberofperipheral="DMA_CHAN06" edc:cname="MEND" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x400025C8"/>
      <edc:SFRDef ltx:memberofperipheral="DMA_CHAN06" edc:cname="DSTART" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x400025CC"/>
      <edc:SFRDef ltx:memberofperipheral="DMA_CHAN06" edc:cname="CTRL" edc:nzwidth="0x20" edc:access="------nn-nnnnnnnnnnnnnnn--nnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x37FFF3F" edc:_addr="0x400025D0">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="DMA_CHAN06">
            <edc:SFRFieldDef edc:cname="RUN" edc:nzwidth="0x1" edc:desc="This is a control field. Note: This bit only applies to Hardware Flow Control mode.                  1= This channel is enabled and will service transfer requests                  0=This channel is disabled. All transfer requests are ignored."/>
            <edc:SFRFieldDef edc:cname="REQ" edc:nzwidth="0x1" edc:desc="This is a status field.                  1= There is a transfer request from the Master Device                  0= There is no transfer request from the Master Device"/>
            <edc:SFRFieldDef edc:cname="DONE" edc:nzwidth="0x1" edc:desc="This is a status signal. It is only valid while DMA Channel Control: Run is Enabled.                   This is the inverse of the DMA Channel Control: Busy field, except this is qualified with the DMA Channel Control:Run field.                  1=Channel is done                  0=Channel is not done or it is OFF"/>
            <edc:SFRFieldDef edc:cname="STS" edc:nzwidth="0x2" edc:desc="This is a status signal. The status decode is listed in priority order with the highest priority first.                  3: Error detected by the DMA                  2: The DMA Channel is externally done, in that the Device has terminated the transfer over the Hardware Flow Control through the Port dma_term                  1: The DMA Channel is locally done, in that Memory Start Address equals Memory End Address                  0: DMA Channel Control:Run is Disabled (0x0)">
              <edc:SFRFieldSemantic edc:cname="ERROR" edc:desc="3: Error detected by the DMA" edc:when="(field &amp; 0x3) == 0x03"/>
              <edc:SFRFieldSemantic edc:cname="EXT_DONE" edc:desc="2: The DMA Channel is externally done, in that the Device has terminated the transfer over the Hardware Flow Control through the Port dma_term" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="LOC_DONE" edc:desc="1: The DMA Channel is locally done, in that Memory Start Address equals Memory End Address" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="DIS" edc:desc="0: DMA Channel Control:Run is Disabled (0x0)" edc:when="(field &amp; 0x3) == 0x00"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="BUSY" edc:nzwidth="0x1" edc:desc="This is a status signal.                  1=The DMA Channel is busy (FSM is not IDLE)                  0=The DMA Channel is not busy (FSM is IDLE)"/>
            <edc:AdjustPoint edc:offset="0x2"/>
            <edc:SFRFieldDef edc:cname="TX_DIR" edc:nzwidth="0x1" edc:desc="This determines the direction of the DMA Transfer.                  1=Data Packet Read from Memory Start Address followed by Data Packet Write to Device Address                  0=Data Packet Read from Device Address followed by Data Packet Write to Memory Start Address"/>
            <edc:SFRFieldDef edc:cname="HW_FLOW_CTRL_DEV" edc:nzwidth="0x7" edc:desc="This is the device that is connected to this channel as its Hardware Flow Control master.                  The Flow Control Interface is a bus with each master concatenated onto it.                  This selects which bus index of the concatenated Flow Control Interface bus is targeted towards this channel.                  The Flow Control Interface Port list is dma_req, dma_term, and dma_done."/>
            <edc:SFRFieldDef edc:cname="INC_MEM_ADDR" edc:nzwidth="0x1" edc:desc="This will enable an auto-increment to the DMA Channel Memory Address.                  1=Increment the DMA Channel Memory Address by DMA Channel Control:Transfer Size after every Data Packet transfer                  0=Do nothing"/>
            <edc:SFRFieldDef edc:cname="INC_DEV_ADDR" edc:nzwidth="0x1" edc:desc="This will enable an auto-increment to the DMA Channel Device Address.                  1: Increment the DMA Channel Device Address by DMA Channel Control:Transfer Size after every Data Packet transfer                  0: Do nothing"/>
            <edc:SFRFieldDef edc:cname="LOCK" edc:nzwidth="0x1" edc:desc="This is used to lock the arbitration of the Channel Arbiter on this channel once this channel is granted. Once this is locked, it will remain on the arbiter until it has completed it transfer (either the Transfer Aborted, Transfer Done or Transfer Terminated conditions)."/>
            <edc:SFRFieldDef edc:cname="DIS_HW_FLOW_CTRL" edc:nzwidth="0x1" edc:desc="This will Disable the Hardware Flow Control. When disabled, any DMA Master device attempting to communicate to the DMA over the DMA Flow Control Interface (Ports: dma_req, dma_term, and dma_done) will be ignored. This should be set before using the DMA channel in Firmware Flow Control mode."/>
            <edc:SFRFieldDef edc:cname="TRANS_SIZE" edc:nzwidth="0x3" edc:desc="This is the transfer size in Bytes of each Data Packet transfer.                  Note: The transfer size must be a legal AMBA transfer size. Valid sizes are 1, 2 and 4 Bytes."/>
            <edc:AdjustPoint edc:offset="0x1"/>
            <edc:SFRFieldDef edc:cname="TRANS_GO" edc:nzwidth="0x1" edc:desc="This is used for the Firmware Flow Control DMA transfer."/>
            <edc:SFRFieldDef edc:cname="TRANS_ABORT" edc:nzwidth="0x1" edc:desc="This is used to abort the current transfer on this DMA Channel. The aborted transfer will be forced to terminate immediately."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="DMA_CHAN06" edc:cname="ISTS" edc:nzwidth="0x8" edc:access="-----nnn" edc:por="00000000" edc:mclr="00000000" edc:impl="0x7" edc:_addr="0x400025D4">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="DMA_CHAN06">
            <edc:SFRFieldDef edc:cname="BUS_ERR" edc:nzwidth="0x1" edc:desc="This is an interrupt source register. This flags when there is an Error detected over the internal 32-bit Bus.                  1: Error detected. (R/WC)"/>
            <edc:SFRFieldDef edc:cname="FLOW_CTRL" edc:nzwidth="0x1" edc:desc="This is an interrupt source register. This flags when the DMA Channel has encountered a Hardware Flow Control Request     after the DMA Channel has completed the transfer. This means the Master Device is attempting to overflow the DMA.                  1=Hardware Flow Control is requesting after the transfer has completed                  0=No Hardware Flow Control event"/>
            <edc:SFRFieldDef edc:cname="DONE" edc:nzwidth="0x1" edc:desc="This is an interrupt source register. This flags when the DMA Channel has completed a transfer successfully on its side.     A completed transfer is defined as when the DMA Channel reaches its limit; Memory Start Address equals Memory End Address.     A completion due to a Hardware Flow Control Terminate will not flag this interrupt.                  1=Memory Start Address equals Memory End Address                  0=Memory Start Address does not equal Memory End Address"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:AdjustPoint edc:offset="0x3" edc:_addr="0x400025D5"/>
      <edc:SFRDef ltx:memberofperipheral="DMA_CHAN06" edc:cname="IEN" edc:nzwidth="0x8" edc:access="-----nnn" edc:por="00000000" edc:mclr="00000000" edc:impl="0x7" edc:_addr="0x400025D8">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="DMA_CHAN06">
            <edc:SFRFieldDef edc:cname="STS_EN_BUS_ERR" edc:nzwidth="0x1" edc:desc="This is an interrupt enable for DMA Channel Interrupt:Status Bus Error.                  1=Enable Interrupt                  0=Disable Interrupt"/>
            <edc:SFRFieldDef edc:cname="STS_EN_FLOW_CTRL" edc:nzwidth="0x1" edc:desc="This is an interrupt enable for DMA Channel Interrupt:Status Flow Control Error.                  1=Enable Interrupt                  0=Disable Interrupt"/>
            <edc:SFRFieldDef edc:cname="STS_EN_DONE" edc:nzwidth="0x1" edc:desc="This is an interrupt enable for DMA Channel Interrupt:Status Done.                  1=Enable Interrupt                  0=Disable Interrupt"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:AdjustPoint edc:offset="0x27" edc:_addr="0x400025D9"/>
      <edc:SFRDef ltx:memberofperipheral="DMA_CHAN07" edc:cname="ACTIVATE" edc:nzwidth="0x8" edc:access="-------n" edc:por="00000000" edc:mclr="00000000" edc:impl="0x1" edc:_addr="0x40002600">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="DMA_CHAN07">
            <edc:SFRFieldDef edc:cname="CHN" edc:nzwidth="0x1" edc:desc="Enable this channel for operation. The DMA Main Control:Activate must also be enabled for this channel to be operational.                  1=Enable channel(block). Each individual channel must be enabled separately.                  0=Disable channel(block)."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:AdjustPoint edc:offset="0x3" edc:_addr="0x40002601"/>
      <edc:SFRDef ltx:memberofperipheral="DMA_CHAN07" edc:cname="MSTART" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x40002604"/>
      <edc:SFRDef ltx:memberofperipheral="DMA_CHAN07" edc:cname="MEND" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x40002608"/>
      <edc:SFRDef ltx:memberofperipheral="DMA_CHAN07" edc:cname="DSTART" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x4000260C"/>
      <edc:SFRDef ltx:memberofperipheral="DMA_CHAN07" edc:cname="CTRL" edc:nzwidth="0x20" edc:access="------nn-nnnnnnnnnnnnnnn--nnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x37FFF3F" edc:_addr="0x40002610">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="DMA_CHAN07">
            <edc:SFRFieldDef edc:cname="RUN" edc:nzwidth="0x1" edc:desc="This is a control field. Note: This bit only applies to Hardware Flow Control mode.                  1= This channel is enabled and will service transfer requests                  0=This channel is disabled. All transfer requests are ignored."/>
            <edc:SFRFieldDef edc:cname="REQ" edc:nzwidth="0x1" edc:desc="This is a status field.                  1= There is a transfer request from the Master Device                  0= There is no transfer request from the Master Device"/>
            <edc:SFRFieldDef edc:cname="DONE" edc:nzwidth="0x1" edc:desc="This is a status signal. It is only valid while DMA Channel Control: Run is Enabled.                   This is the inverse of the DMA Channel Control: Busy field, except this is qualified with the DMA Channel Control:Run field.                  1=Channel is done                  0=Channel is not done or it is OFF"/>
            <edc:SFRFieldDef edc:cname="STS" edc:nzwidth="0x2" edc:desc="This is a status signal. The status decode is listed in priority order with the highest priority first.                  3: Error detected by the DMA                  2: The DMA Channel is externally done, in that the Device has terminated the transfer over the Hardware Flow Control through the Port dma_term                  1: The DMA Channel is locally done, in that Memory Start Address equals Memory End Address                  0: DMA Channel Control:Run is Disabled (0x0)">
              <edc:SFRFieldSemantic edc:cname="ERROR" edc:desc="3: Error detected by the DMA" edc:when="(field &amp; 0x3) == 0x03"/>
              <edc:SFRFieldSemantic edc:cname="EXT_DONE" edc:desc="2: The DMA Channel is externally done, in that the Device has terminated the transfer over the Hardware Flow Control through the Port dma_term" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="LOC_DONE" edc:desc="1: The DMA Channel is locally done, in that Memory Start Address equals Memory End Address" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="DIS" edc:desc="0: DMA Channel Control:Run is Disabled (0x0)" edc:when="(field &amp; 0x3) == 0x00"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="BUSY" edc:nzwidth="0x1" edc:desc="This is a status signal.                  1=The DMA Channel is busy (FSM is not IDLE)                  0=The DMA Channel is not busy (FSM is IDLE)"/>
            <edc:AdjustPoint edc:offset="0x2"/>
            <edc:SFRFieldDef edc:cname="TX_DIR" edc:nzwidth="0x1" edc:desc="This determines the direction of the DMA Transfer.                  1=Data Packet Read from Memory Start Address followed by Data Packet Write to Device Address                  0=Data Packet Read from Device Address followed by Data Packet Write to Memory Start Address"/>
            <edc:SFRFieldDef edc:cname="HW_FLOW_CTRL_DEV" edc:nzwidth="0x7" edc:desc="This is the device that is connected to this channel as its Hardware Flow Control master.                  The Flow Control Interface is a bus with each master concatenated onto it.                  This selects which bus index of the concatenated Flow Control Interface bus is targeted towards this channel.                  The Flow Control Interface Port list is dma_req, dma_term, and dma_done."/>
            <edc:SFRFieldDef edc:cname="INC_MEM_ADDR" edc:nzwidth="0x1" edc:desc="This will enable an auto-increment to the DMA Channel Memory Address.                  1=Increment the DMA Channel Memory Address by DMA Channel Control:Transfer Size after every Data Packet transfer                  0=Do nothing"/>
            <edc:SFRFieldDef edc:cname="INC_DEV_ADDR" edc:nzwidth="0x1" edc:desc="This will enable an auto-increment to the DMA Channel Device Address.                  1: Increment the DMA Channel Device Address by DMA Channel Control:Transfer Size after every Data Packet transfer                  0: Do nothing"/>
            <edc:SFRFieldDef edc:cname="LOCK" edc:nzwidth="0x1" edc:desc="This is used to lock the arbitration of the Channel Arbiter on this channel once this channel is granted. Once this is locked, it will remain on the arbiter until it has completed it transfer (either the Transfer Aborted, Transfer Done or Transfer Terminated conditions)."/>
            <edc:SFRFieldDef edc:cname="DIS_HW_FLOW_CTRL" edc:nzwidth="0x1" edc:desc="This will Disable the Hardware Flow Control. When disabled, any DMA Master device attempting to communicate to the DMA over the DMA Flow Control Interface (Ports: dma_req, dma_term, and dma_done) will be ignored. This should be set before using the DMA channel in Firmware Flow Control mode."/>
            <edc:SFRFieldDef edc:cname="TRANS_SIZE" edc:nzwidth="0x3" edc:desc="This is the transfer size in Bytes of each Data Packet transfer.                  Note: The transfer size must be a legal AMBA transfer size. Valid sizes are 1, 2 and 4 Bytes."/>
            <edc:AdjustPoint edc:offset="0x1"/>
            <edc:SFRFieldDef edc:cname="TRANS_GO" edc:nzwidth="0x1" edc:desc="This is used for the Firmware Flow Control DMA transfer."/>
            <edc:SFRFieldDef edc:cname="TRANS_ABORT" edc:nzwidth="0x1" edc:desc="This is used to abort the current transfer on this DMA Channel. The aborted transfer will be forced to terminate immediately."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="DMA_CHAN07" edc:cname="ISTS" edc:nzwidth="0x8" edc:access="-----nnn" edc:por="00000000" edc:mclr="00000000" edc:impl="0x7" edc:_addr="0x40002614">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="DMA_CHAN07">
            <edc:SFRFieldDef edc:cname="BUS_ERR" edc:nzwidth="0x1" edc:desc="This is an interrupt source register. This flags when there is an Error detected over the internal 32-bit Bus.                  1: Error detected. (R/WC)"/>
            <edc:SFRFieldDef edc:cname="FLOW_CTRL" edc:nzwidth="0x1" edc:desc="This is an interrupt source register. This flags when the DMA Channel has encountered a Hardware Flow Control Request     after the DMA Channel has completed the transfer. This means the Master Device is attempting to overflow the DMA.                  1=Hardware Flow Control is requesting after the transfer has completed                  0=No Hardware Flow Control event"/>
            <edc:SFRFieldDef edc:cname="DONE" edc:nzwidth="0x1" edc:desc="This is an interrupt source register. This flags when the DMA Channel has completed a transfer successfully on its side.     A completed transfer is defined as when the DMA Channel reaches its limit; Memory Start Address equals Memory End Address.     A completion due to a Hardware Flow Control Terminate will not flag this interrupt.                  1=Memory Start Address equals Memory End Address                  0=Memory Start Address does not equal Memory End Address"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:AdjustPoint edc:offset="0x3" edc:_addr="0x40002615"/>
      <edc:SFRDef ltx:memberofperipheral="DMA_CHAN07" edc:cname="IEN" edc:nzwidth="0x8" edc:access="-----nnn" edc:por="00000000" edc:mclr="00000000" edc:impl="0x7" edc:_addr="0x40002618">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="DMA_CHAN07">
            <edc:SFRFieldDef edc:cname="STS_EN_BUS_ERR" edc:nzwidth="0x1" edc:desc="This is an interrupt enable for DMA Channel Interrupt:Status Bus Error.                  1=Enable Interrupt                  0=Disable Interrupt"/>
            <edc:SFRFieldDef edc:cname="STS_EN_FLOW_CTRL" edc:nzwidth="0x1" edc:desc="This is an interrupt enable for DMA Channel Interrupt:Status Flow Control Error.                  1=Enable Interrupt                  0=Disable Interrupt"/>
            <edc:SFRFieldDef edc:cname="STS_EN_DONE" edc:nzwidth="0x1" edc:desc="This is an interrupt enable for DMA Channel Interrupt:Status Done.                  1=Enable Interrupt                  0=Disable Interrupt"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:AdjustPoint edc:offset="0x27" edc:_addr="0x40002619"/>
      <edc:SFRDef ltx:memberofperipheral="DMA_CHAN08" edc:cname="ACTIVATE" edc:nzwidth="0x8" edc:access="-------n" edc:por="00000000" edc:mclr="00000000" edc:impl="0x1" edc:_addr="0x40002640">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="DMA_CHAN08">
            <edc:SFRFieldDef edc:cname="CHN" edc:nzwidth="0x1" edc:desc="Enable this channel for operation. The DMA Main Control:Activate must also be enabled for this channel to be operational.                  1=Enable channel(block). Each individual channel must be enabled separately.                  0=Disable channel(block)."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:AdjustPoint edc:offset="0x3" edc:_addr="0x40002641"/>
      <edc:SFRDef ltx:memberofperipheral="DMA_CHAN08" edc:cname="MSTART" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x40002644"/>
      <edc:SFRDef ltx:memberofperipheral="DMA_CHAN08" edc:cname="MEND" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x40002648"/>
      <edc:SFRDef ltx:memberofperipheral="DMA_CHAN08" edc:cname="DSTART" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x4000264C"/>
      <edc:SFRDef ltx:memberofperipheral="DMA_CHAN08" edc:cname="CTRL" edc:nzwidth="0x20" edc:access="------nn-nnnnnnnnnnnnnnn--nnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x37FFF3F" edc:_addr="0x40002650">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="DMA_CHAN08">
            <edc:SFRFieldDef edc:cname="RUN" edc:nzwidth="0x1" edc:desc="This is a control field. Note: This bit only applies to Hardware Flow Control mode.                  1= This channel is enabled and will service transfer requests                  0=This channel is disabled. All transfer requests are ignored."/>
            <edc:SFRFieldDef edc:cname="REQ" edc:nzwidth="0x1" edc:desc="This is a status field.                  1= There is a transfer request from the Master Device                  0= There is no transfer request from the Master Device"/>
            <edc:SFRFieldDef edc:cname="DONE" edc:nzwidth="0x1" edc:desc="This is a status signal. It is only valid while DMA Channel Control: Run is Enabled.                   This is the inverse of the DMA Channel Control: Busy field, except this is qualified with the DMA Channel Control:Run field.                  1=Channel is done                  0=Channel is not done or it is OFF"/>
            <edc:SFRFieldDef edc:cname="STS" edc:nzwidth="0x2" edc:desc="This is a status signal. The status decode is listed in priority order with the highest priority first.                  3: Error detected by the DMA                  2: The DMA Channel is externally done, in that the Device has terminated the transfer over the Hardware Flow Control through the Port dma_term                  1: The DMA Channel is locally done, in that Memory Start Address equals Memory End Address                  0: DMA Channel Control:Run is Disabled (0x0)">
              <edc:SFRFieldSemantic edc:cname="ERROR" edc:desc="3: Error detected by the DMA" edc:when="(field &amp; 0x3) == 0x03"/>
              <edc:SFRFieldSemantic edc:cname="EXT_DONE" edc:desc="2: The DMA Channel is externally done, in that the Device has terminated the transfer over the Hardware Flow Control through the Port dma_term" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="LOC_DONE" edc:desc="1: The DMA Channel is locally done, in that Memory Start Address equals Memory End Address" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="DIS" edc:desc="0: DMA Channel Control:Run is Disabled (0x0)" edc:when="(field &amp; 0x3) == 0x00"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="BUSY" edc:nzwidth="0x1" edc:desc="This is a status signal.                  1=The DMA Channel is busy (FSM is not IDLE)                  0=The DMA Channel is not busy (FSM is IDLE)"/>
            <edc:AdjustPoint edc:offset="0x2"/>
            <edc:SFRFieldDef edc:cname="TX_DIR" edc:nzwidth="0x1" edc:desc="This determines the direction of the DMA Transfer.                  1=Data Packet Read from Memory Start Address followed by Data Packet Write to Device Address                  0=Data Packet Read from Device Address followed by Data Packet Write to Memory Start Address"/>
            <edc:SFRFieldDef edc:cname="HW_FLOW_CTRL_DEV" edc:nzwidth="0x7" edc:desc="This is the device that is connected to this channel as its Hardware Flow Control master.                  The Flow Control Interface is a bus with each master concatenated onto it.                  This selects which bus index of the concatenated Flow Control Interface bus is targeted towards this channel.                  The Flow Control Interface Port list is dma_req, dma_term, and dma_done."/>
            <edc:SFRFieldDef edc:cname="INC_MEM_ADDR" edc:nzwidth="0x1" edc:desc="This will enable an auto-increment to the DMA Channel Memory Address.                  1=Increment the DMA Channel Memory Address by DMA Channel Control:Transfer Size after every Data Packet transfer                  0=Do nothing"/>
            <edc:SFRFieldDef edc:cname="INC_DEV_ADDR" edc:nzwidth="0x1" edc:desc="This will enable an auto-increment to the DMA Channel Device Address.                  1: Increment the DMA Channel Device Address by DMA Channel Control:Transfer Size after every Data Packet transfer                  0: Do nothing"/>
            <edc:SFRFieldDef edc:cname="LOCK" edc:nzwidth="0x1" edc:desc="This is used to lock the arbitration of the Channel Arbiter on this channel once this channel is granted. Once this is locked, it will remain on the arbiter until it has completed it transfer (either the Transfer Aborted, Transfer Done or Transfer Terminated conditions)."/>
            <edc:SFRFieldDef edc:cname="DIS_HW_FLOW_CTRL" edc:nzwidth="0x1" edc:desc="This will Disable the Hardware Flow Control. When disabled, any DMA Master device attempting to communicate to the DMA over the DMA Flow Control Interface (Ports: dma_req, dma_term, and dma_done) will be ignored. This should be set before using the DMA channel in Firmware Flow Control mode."/>
            <edc:SFRFieldDef edc:cname="TRANS_SIZE" edc:nzwidth="0x3" edc:desc="This is the transfer size in Bytes of each Data Packet transfer.                  Note: The transfer size must be a legal AMBA transfer size. Valid sizes are 1, 2 and 4 Bytes."/>
            <edc:AdjustPoint edc:offset="0x1"/>
            <edc:SFRFieldDef edc:cname="TRANS_GO" edc:nzwidth="0x1" edc:desc="This is used for the Firmware Flow Control DMA transfer."/>
            <edc:SFRFieldDef edc:cname="TRANS_ABORT" edc:nzwidth="0x1" edc:desc="This is used to abort the current transfer on this DMA Channel. The aborted transfer will be forced to terminate immediately."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="DMA_CHAN08" edc:cname="ISTS" edc:nzwidth="0x8" edc:access="-----nnn" edc:por="00000000" edc:mclr="00000000" edc:impl="0x7" edc:_addr="0x40002654">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="DMA_CHAN08">
            <edc:SFRFieldDef edc:cname="BUS_ERR" edc:nzwidth="0x1" edc:desc="This is an interrupt source register. This flags when there is an Error detected over the internal 32-bit Bus.                  1: Error detected. (R/WC)"/>
            <edc:SFRFieldDef edc:cname="FLOW_CTRL" edc:nzwidth="0x1" edc:desc="This is an interrupt source register. This flags when the DMA Channel has encountered a Hardware Flow Control Request     after the DMA Channel has completed the transfer. This means the Master Device is attempting to overflow the DMA.                  1=Hardware Flow Control is requesting after the transfer has completed                  0=No Hardware Flow Control event"/>
            <edc:SFRFieldDef edc:cname="DONE" edc:nzwidth="0x1" edc:desc="This is an interrupt source register. This flags when the DMA Channel has completed a transfer successfully on its side.     A completed transfer is defined as when the DMA Channel reaches its limit; Memory Start Address equals Memory End Address.     A completion due to a Hardware Flow Control Terminate will not flag this interrupt.                  1=Memory Start Address equals Memory End Address                  0=Memory Start Address does not equal Memory End Address"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:AdjustPoint edc:offset="0x3" edc:_addr="0x40002655"/>
      <edc:SFRDef ltx:memberofperipheral="DMA_CHAN08" edc:cname="IEN" edc:nzwidth="0x8" edc:access="-----nnn" edc:por="00000000" edc:mclr="00000000" edc:impl="0x7" edc:_addr="0x40002658">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="DMA_CHAN08">
            <edc:SFRFieldDef edc:cname="STS_EN_BUS_ERR" edc:nzwidth="0x1" edc:desc="This is an interrupt enable for DMA Channel Interrupt:Status Bus Error.                  1=Enable Interrupt                  0=Disable Interrupt"/>
            <edc:SFRFieldDef edc:cname="STS_EN_FLOW_CTRL" edc:nzwidth="0x1" edc:desc="This is an interrupt enable for DMA Channel Interrupt:Status Flow Control Error.                  1=Enable Interrupt                  0=Disable Interrupt"/>
            <edc:SFRFieldDef edc:cname="STS_EN_DONE" edc:nzwidth="0x1" edc:desc="This is an interrupt enable for DMA Channel Interrupt:Status Done.                  1=Enable Interrupt                  0=Disable Interrupt"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:AdjustPoint edc:offset="0x27" edc:_addr="0x40002659"/>
      <edc:SFRDef ltx:memberofperipheral="DMA_CHAN09" edc:cname="ACTIVATE" edc:nzwidth="0x8" edc:access="-------n" edc:por="00000000" edc:mclr="00000000" edc:impl="0x1" edc:_addr="0x40002680">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="DMA_CHAN09">
            <edc:SFRFieldDef edc:cname="CHN" edc:nzwidth="0x1" edc:desc="Enable this channel for operation. The DMA Main Control:Activate must also be enabled for this channel to be operational.                  1=Enable channel(block). Each individual channel must be enabled separately.                  0=Disable channel(block)."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:AdjustPoint edc:offset="0x3" edc:_addr="0x40002681"/>
      <edc:SFRDef ltx:memberofperipheral="DMA_CHAN09" edc:cname="MSTART" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x40002684"/>
      <edc:SFRDef ltx:memberofperipheral="DMA_CHAN09" edc:cname="MEND" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x40002688"/>
      <edc:SFRDef ltx:memberofperipheral="DMA_CHAN09" edc:cname="DSTART" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x4000268C"/>
      <edc:SFRDef ltx:memberofperipheral="DMA_CHAN09" edc:cname="CTRL" edc:nzwidth="0x20" edc:access="------nn-nnnnnnnnnnnnnnn--nnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x37FFF3F" edc:_addr="0x40002690">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="DMA_CHAN09">
            <edc:SFRFieldDef edc:cname="RUN" edc:nzwidth="0x1" edc:desc="This is a control field. Note: This bit only applies to Hardware Flow Control mode.                  1= This channel is enabled and will service transfer requests                  0=This channel is disabled. All transfer requests are ignored."/>
            <edc:SFRFieldDef edc:cname="REQ" edc:nzwidth="0x1" edc:desc="This is a status field.                  1= There is a transfer request from the Master Device                  0= There is no transfer request from the Master Device"/>
            <edc:SFRFieldDef edc:cname="DONE" edc:nzwidth="0x1" edc:desc="This is a status signal. It is only valid while DMA Channel Control: Run is Enabled.                   This is the inverse of the DMA Channel Control: Busy field, except this is qualified with the DMA Channel Control:Run field.                  1=Channel is done                  0=Channel is not done or it is OFF"/>
            <edc:SFRFieldDef edc:cname="STS" edc:nzwidth="0x2" edc:desc="This is a status signal. The status decode is listed in priority order with the highest priority first.                  3: Error detected by the DMA                  2: The DMA Channel is externally done, in that the Device has terminated the transfer over the Hardware Flow Control through the Port dma_term                  1: The DMA Channel is locally done, in that Memory Start Address equals Memory End Address                  0: DMA Channel Control:Run is Disabled (0x0)">
              <edc:SFRFieldSemantic edc:cname="ERROR" edc:desc="3: Error detected by the DMA" edc:when="(field &amp; 0x3) == 0x03"/>
              <edc:SFRFieldSemantic edc:cname="EXT_DONE" edc:desc="2: The DMA Channel is externally done, in that the Device has terminated the transfer over the Hardware Flow Control through the Port dma_term" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="LOC_DONE" edc:desc="1: The DMA Channel is locally done, in that Memory Start Address equals Memory End Address" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="DIS" edc:desc="0: DMA Channel Control:Run is Disabled (0x0)" edc:when="(field &amp; 0x3) == 0x00"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="BUSY" edc:nzwidth="0x1" edc:desc="This is a status signal.                  1=The DMA Channel is busy (FSM is not IDLE)                  0=The DMA Channel is not busy (FSM is IDLE)"/>
            <edc:AdjustPoint edc:offset="0x2"/>
            <edc:SFRFieldDef edc:cname="TX_DIR" edc:nzwidth="0x1" edc:desc="This determines the direction of the DMA Transfer.                  1=Data Packet Read from Memory Start Address followed by Data Packet Write to Device Address                  0=Data Packet Read from Device Address followed by Data Packet Write to Memory Start Address"/>
            <edc:SFRFieldDef edc:cname="HW_FLOW_CTRL_DEV" edc:nzwidth="0x7" edc:desc="This is the device that is connected to this channel as its Hardware Flow Control master.                  The Flow Control Interface is a bus with each master concatenated onto it.                  This selects which bus index of the concatenated Flow Control Interface bus is targeted towards this channel.                  The Flow Control Interface Port list is dma_req, dma_term, and dma_done."/>
            <edc:SFRFieldDef edc:cname="INC_MEM_ADDR" edc:nzwidth="0x1" edc:desc="This will enable an auto-increment to the DMA Channel Memory Address.                  1=Increment the DMA Channel Memory Address by DMA Channel Control:Transfer Size after every Data Packet transfer                  0=Do nothing"/>
            <edc:SFRFieldDef edc:cname="INC_DEV_ADDR" edc:nzwidth="0x1" edc:desc="This will enable an auto-increment to the DMA Channel Device Address.                  1: Increment the DMA Channel Device Address by DMA Channel Control:Transfer Size after every Data Packet transfer                  0: Do nothing"/>
            <edc:SFRFieldDef edc:cname="LOCK" edc:nzwidth="0x1" edc:desc="This is used to lock the arbitration of the Channel Arbiter on this channel once this channel is granted. Once this is locked, it will remain on the arbiter until it has completed it transfer (either the Transfer Aborted, Transfer Done or Transfer Terminated conditions)."/>
            <edc:SFRFieldDef edc:cname="DIS_HW_FLOW_CTRL" edc:nzwidth="0x1" edc:desc="This will Disable the Hardware Flow Control. When disabled, any DMA Master device attempting to communicate to the DMA over the DMA Flow Control Interface (Ports: dma_req, dma_term, and dma_done) will be ignored. This should be set before using the DMA channel in Firmware Flow Control mode."/>
            <edc:SFRFieldDef edc:cname="TRANS_SIZE" edc:nzwidth="0x3" edc:desc="This is the transfer size in Bytes of each Data Packet transfer.                  Note: The transfer size must be a legal AMBA transfer size. Valid sizes are 1, 2 and 4 Bytes."/>
            <edc:AdjustPoint edc:offset="0x1"/>
            <edc:SFRFieldDef edc:cname="TRANS_GO" edc:nzwidth="0x1" edc:desc="This is used for the Firmware Flow Control DMA transfer."/>
            <edc:SFRFieldDef edc:cname="TRANS_ABORT" edc:nzwidth="0x1" edc:desc="This is used to abort the current transfer on this DMA Channel. The aborted transfer will be forced to terminate immediately."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="DMA_CHAN09" edc:cname="ISTS" edc:nzwidth="0x8" edc:access="-----nnn" edc:por="00000000" edc:mclr="00000000" edc:impl="0x7" edc:_addr="0x40002694">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="DMA_CHAN09">
            <edc:SFRFieldDef edc:cname="BUS_ERR" edc:nzwidth="0x1" edc:desc="This is an interrupt source register. This flags when there is an Error detected over the internal 32-bit Bus.                  1: Error detected. (R/WC)"/>
            <edc:SFRFieldDef edc:cname="FLOW_CTRL" edc:nzwidth="0x1" edc:desc="This is an interrupt source register. This flags when the DMA Channel has encountered a Hardware Flow Control Request     after the DMA Channel has completed the transfer. This means the Master Device is attempting to overflow the DMA.                  1=Hardware Flow Control is requesting after the transfer has completed                  0=No Hardware Flow Control event"/>
            <edc:SFRFieldDef edc:cname="DONE" edc:nzwidth="0x1" edc:desc="This is an interrupt source register. This flags when the DMA Channel has completed a transfer successfully on its side.     A completed transfer is defined as when the DMA Channel reaches its limit; Memory Start Address equals Memory End Address.     A completion due to a Hardware Flow Control Terminate will not flag this interrupt.                  1=Memory Start Address equals Memory End Address                  0=Memory Start Address does not equal Memory End Address"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:AdjustPoint edc:offset="0x3" edc:_addr="0x40002695"/>
      <edc:SFRDef ltx:memberofperipheral="DMA_CHAN09" edc:cname="IEN" edc:nzwidth="0x8" edc:access="-----nnn" edc:por="00000000" edc:mclr="00000000" edc:impl="0x7" edc:_addr="0x40002698">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="DMA_CHAN09">
            <edc:SFRFieldDef edc:cname="STS_EN_BUS_ERR" edc:nzwidth="0x1" edc:desc="This is an interrupt enable for DMA Channel Interrupt:Status Bus Error.                  1=Enable Interrupt                  0=Disable Interrupt"/>
            <edc:SFRFieldDef edc:cname="STS_EN_FLOW_CTRL" edc:nzwidth="0x1" edc:desc="This is an interrupt enable for DMA Channel Interrupt:Status Flow Control Error.                  1=Enable Interrupt                  0=Disable Interrupt"/>
            <edc:SFRFieldDef edc:cname="STS_EN_DONE" edc:nzwidth="0x1" edc:desc="This is an interrupt enable for DMA Channel Interrupt:Status Done.                  1=Enable Interrupt                  0=Disable Interrupt"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:AdjustPoint edc:offset="0x1967" edc:_addr="0x40002699"/>
      <edc:MuxedSFRDef edc:nzwidth="0x20" edc:_addr="0x40004000">
        <edc:SelectSFR>
          <edc:SFRDef ltx:memberofperipheral="SMB0" edc:cname="WCTRL" edc:nzwidth="0x20" edc:access="------------------------ww--wwww" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0xCF" edc:_addr="0x40004000">
            <edc:SFRModeList>
              <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SMB0">
                <edc:SFRFieldDef edc:cname="ACK" edc:nzwidth="0x1" edc:desc="The Acknowledge bit (ACK) must normally be asserted ('1'). This causes the controller to send an acknowledge automatically after each byte (this occurs during the 9th clock pulse). The ACK bit must not be asserted ('0') when the controller is operating in master/receiver mode and requires no further data to be sent from the slave transmitter. This causes a negative acknowledge on the I2C bus, which halts further transmission from the slave device."/>
                <edc:SFRFieldDef edc:cname="STO" edc:nzwidth="0x1" edc:desc="See STA description"/>
                <edc:SFRFieldDef edc:cname="STA" edc:nzwidth="0x1" edc:desc="The STA and STO bits control the generation of the I2C Start condition and the transmission of the Slave Address and R/nW bit (from the Data Register), generation of repeated Start condition, and generation of the Stop condition"/>
                <edc:SFRFieldDef edc:cname="ENI" edc:nzwidth="0x1" edc:desc="Enable Interrupt bit (ENI) controls the Interrupt Interface"/>
                <edc:AdjustPoint edc:offset="0x2"/>
                <edc:SFRFieldDef edc:cname="ESO" edc:nzwidth="0x1" edc:desc="The Enable Serial Output bit (ESO) enables and disables the SMB Controller Core serial data output (SDAT)"/>
                <edc:SFRFieldDef edc:cname="PIN" edc:nzwidth="0x1" edc:desc="The Pending Interrupt Not (PIN) bit serves as a software reset function. Writing the PIN bit to a logic '1' de-asserts all status bits except for the nBB bit which is not affected by the PIN bit. The PIN bit is a self-clearing bit. Writing this bit to a logic '0' has no effect."/>
              </edc:SFRMode>
            </edc:SFRModeList>
          </edc:SFRDef>
        </edc:SelectSFR>
        <edc:SelectSFR>
          <edc:SFRDef ltx:memberofperipheral="SMB0" edc:cname="RSTS" edc:nzwidth="0x20" edc:access="------------------------rrrrrrrr" edc:por="00000000000000000000000010000001" edc:mclr="00000000000000000000000010000001" edc:impl="0xFF" edc:_addr="0x40004000">
            <edc:SFRModeList>
              <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SMB0">
                <edc:SFRFieldDef edc:cname="NBB" edc:nzwidth="0x1" edc:desc="The Bus Busy bit (NBB) is a read-only flag indicating when the bus is in use. A zero indicates that the bus is busy and access is not possible."/>
                <edc:SFRFieldDef edc:cname="LAB" edc:nzwidth="0x1" edc:desc="The Lost Arbitration Bit (LAB) is set when, in multi-master operation, arbitration is lost to another master on the bus"/>
                <edc:SFRFieldDef edc:cname="AAS" edc:nzwidth="0x1" edc:desc="The Addressed As Slave bit (AAS) is valid only when PIN is asserted ('0'). When acting as slave, AAS is set when an incoming address over the bus matches the value in the Own Address Register or if the 'general call' address (00h) has been received"/>
                <edc:SFRFieldDef edc:cname="LRB_AD0" edc:nzwidth="0x1" edc:desc="The Last Received Bit  or Address 0 (general call) bit (LRB/AD0) serves a dual function and is valid only while the PIN bit is asserted ('0').                When the AAS bit is not asserted ('0') (i.e., not addressed as a slave), the LRB/AD0 holds the value of the last received bit over the bus.                When the AAS bit is asserted ('1') (i.e., addressed as slave), the SMB Controller Core has been addressed as a slave."/>
                <edc:SFRFieldDef edc:cname="BER" edc:nzwidth="0x1" edc:desc="When Bus Error (BER) is asserted, a misplaced START or STOP condition or Bus Time-Outs have been detected."/>
                <edc:SFRFieldDef edc:cname="STS" edc:nzwidth="0x1" edc:desc="When in slave receiver mode, STS is asserted ('1') when an externally generated STOP condition is detected. Note that STS is used only in slave receiver mode."/>
                <edc:SFRFieldDef edc:cname="SAD" edc:nzwidth="0x1" edc:desc="SMBus Address Decoded (SAD)"/>
                <edc:SFRFieldDef edc:cname="PIN" edc:nzwidth="0x1" edc:desc="Pending Interrupt bit"/>
              </edc:SFRMode>
            </edc:SFRModeList>
          </edc:SFRDef>
        </edc:SelectSFR>
      </edc:MuxedSFRDef>
      <edc:SFRDef ltx:memberofperipheral="SMB0" edc:cname="OWN_ADDR" edc:nzwidth="0x20" edc:access="-----------------nnnnnnn-nnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x7F7F" edc:_addr="0x40004004">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SMB0">
            <edc:SFRFieldDef edc:cname="ADDR1" edc:nzwidth="0x7" edc:desc="The Own Address 1 bits configure one of the two addresses to which the SMB Controller Core will respond when addressed as a slave."/>
            <edc:AdjustPoint edc:offset="0x1"/>
            <edc:SFRFieldDef edc:cname="ADDR2" edc:nzwidth="0x7" edc:desc="The Own Address 2 bits configure one of the two addresses to which the SMB Controller Core will respond when addressed as a slave."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SMB0" edc:cname="I2CDATA" edc:nzwidth="0x8" edc:access="nnnnnnnn" edc:por="00000000" edc:mclr="00000000" edc:_addr="0x40004008"/>
      <edc:SFRDef ltx:memberofperipheral="SMB0" edc:cname="RSVD10" edc:nzwidth="0x8" edc:access="rrrrrrrr" edc:por="00000000" edc:mclr="00000000" edc:_addr="0x40004009"/>
      <edc:SFRDef ltx:memberofperipheral="SMB0" edc:cname="RSVD11" edc:nzwidth="0x8" edc:access="rrrrrrrr" edc:por="00000000" edc:mclr="00000000" edc:_addr="0x4000400A"/>
      <edc:SFRDef ltx:memberofperipheral="SMB0" edc:cname="RSVD12" edc:nzwidth="0x8" edc:access="rrrrrrrr" edc:por="00000000" edc:mclr="00000000" edc:_addr="0x4000400B"/>
      <edc:SFRDef ltx:memberofperipheral="SMB0" edc:cname="MCMD0" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnn--nnnnnn------nn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0xFFFF3F03" edc:_addr="0x4000400C">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SMB0">
            <edc:SFRFieldDef edc:cname="MRUN" edc:nzwidth="0x1" edc:desc="While this bit is 1, transfer bytes over SMBus. As long as WriteCount is non-zero, a byte from the Master Transmit Buffer is transmitted to the slave device and WriteCount is decremented."/>
            <edc:SFRFieldDef edc:cname="MPROCEED" edc:nzwidth="0x1" edc:desc="When this bit is 0, the Master State Machine does not transition out of the IDLE or PAUSE states. When this bit is 1, the Master State Machine immediately transitions to the WAIT-BUSBUSY and MRUN-RECEIVE states, respectively."/>
            <edc:AdjustPoint edc:offset="0x6"/>
            <edc:SFRFieldDef edc:cname="START0" edc:nzwidth="0x1" edc:desc="If this bit is 1, send a Start bit on the SMBus before the first byte of the WriteCount is sent to the SMBus transmitter."/>
            <edc:SFRFieldDef edc:cname="STARTN" edc:nzwidth="0x1" edc:desc="If this bit is 1, send a Start bit just before the last byte of the WriteCount is sent to the SMBus transmitter."/>
            <edc:SFRFieldDef edc:cname="STOP" edc:nzwidth="0x1" edc:desc="If this bit is 1, send a Stop bit after the transaction completes."/>
            <edc:SFRFieldDef edc:cname="PEC_TERM" edc:nzwidth="0x1" edc:desc="If this bit is 1, a copy of the PEC register is transmitted when WriteCount is 0. After the PEC register is read, both the PEC register and this bit are cleared to 0."/>
            <edc:SFRFieldDef edc:cname="READM" edc:nzwidth="0x1" edc:desc="If this bit is 1, then the ReadCount field is replaced by the byte that is read from the SMBus when ReadCount[7:0] is 1. After ReadCount[7:0] is updated, this bit is cleared to 0."/>
            <edc:SFRFieldDef edc:cname="READ_PEC" edc:nzwidth="0x1" edc:desc="If this bit is 0, reading from the SMBus stops when ReadCount reaches 0. If this bit is 1, reading continues when ReadCount is 0 for one more byte."/>
            <edc:AdjustPoint edc:offset="0x2"/>
            <edc:SFRFieldDef edc:cname="WR_CNT" edc:nzwidth="0x8" edc:desc="This field is a count of the number of bytes to transmit to the SMBus from the SMBus Master Transmit Buffer Register It is decremented by 1 for each byte written to the SMBus from the SMBus Master Transmit Buffer Register."/>
            <edc:SFRFieldDef edc:cname="RD_CNT" edc:nzwidth="0x8" edc:desc="This field is a count of the number of bytes to read in from the SMBus to the SMBus Master Receive Buffer Register and must be greater than 0 in order for the Master State Machine to initiate a read phase. It is decremented by 1 for each byte read from the SMBus into the SMBus Master Receive Buffer Register. It can be overwritten by the first byte read in from the SMBus."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SMB0" edc:cname="SCMD0" edc:nzwidth="0x20" edc:access="--------nnnnnnnnnnnnnnnn-----nnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0xFFFF07" edc:_addr="0x40004010">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SMB0">
            <edc:SFRFieldDef edc:cname="SRUN" edc:nzwidth="0x1" edc:desc="Setting this bit to 1 enables the Slave State Machine to operate."/>
            <edc:SFRFieldDef edc:cname="SPROCEED" edc:nzwidth="0x1" edc:desc="When this bit is 0, the Slave State Machine does not transition out of the IDLE, REPEAT_START_WRITE or REPEAT_START_READ states. When this bit is 1, the Slave State Machine immediately transitions to the START_WAIT, RECEIVE and TRANSMIT states, respectively."/>
            <edc:SFRFieldDef edc:cname="PEC" edc:nzwidth="0x1" edc:desc="If Slave_WriteCount is 0 and Slave_PEC is 1 when the Master requests data, the PEC Register is copied to the DATA register. After the PEC Register is copied to the SMBus, the PEC Register is cleared and Slave_PEC is set to 0."/>
            <edc:AdjustPoint edc:offset="0x5"/>
            <edc:SFRFieldDef edc:cname="WR_CNT" edc:nzwidth="0x8" edc:desc="This field is set to the number of bytes software expects to send to the Master."/>
            <edc:SFRFieldDef edc:cname="RD_CNT" edc:nzwidth="0x8" edc:desc="This field is decremented each time a byte is copied from DATA to the SMBus Slave Receive Buffer Register."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SMB0" edc:cname="PEC" edc:nzwidth="0x20" edc:access="------------------------nnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0xFF" edc:_addr="0x40004014">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SMB0">
            <edc:SFRFieldDef edc:cname="PEC" edc:nzwidth="0x8" edc:desc="The SMBus Packet Error Check (PEC) byte."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SMB0" edc:cname="RSHTM" edc:nzwidth="0x20" edc:access="------------------------nnnnnnnn" edc:por="00000000000000000000000001001101" edc:mclr="00000000000000000000000001001101" edc:impl="0xFF" edc:_addr="0x40004018">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SMB0">
            <edc:SFRFieldDef edc:cname="RSHTM" edc:nzwidth="0x8" edc:desc="This is the value of the timing requirement tHd:Sta in the I2C specification for a repeated START bit. This is used to hold      the clock until the Hold Time for the repeated Start Bit has been satisfied."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SMB0" edc:cname="EXTND_LEN" edc:nzwidth="0x20" edc:access="------------------------rrrrrrrr" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0xFF" edc:_addr="0x4000401C">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SMB0">
            <edc:SFRFieldDef edc:cname="EXTND_LEN" edc:nzwidth="0x8" edc:desc="Extended Length Register adds 8 MSB bits to the SMBUS Master/Slave Tx/Rx Length fields."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SMB0" edc:cname="COMPL0" edc:nzwidth="0x20" edc:access="nnn---nn--nnn-nn-nnnnnnn-nnnnn--" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0xE33B7F7C" edc:_addr="0x40004020">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SMB0">
            <edc:AdjustPoint edc:offset="0x2"/>
            <edc:SFRFieldDef edc:cname="DTEN" edc:nzwidth="0x1" edc:desc="When DTEN is asserted ('1'), Device Time-out checking is enabled. When DTEN is not asserted ('0'), Device Time-out checking is disabled."/>
            <edc:SFRFieldDef edc:cname="MCEN" edc:nzwidth="0x1" edc:desc="When MCEN is asserted ('1'), Master Cumulative Time-Out checking is enabled. When MCEN is not asserted ('0'), Master Cumulative Time-Out checking is disabled."/>
            <edc:SFRFieldDef edc:cname="SCEN" edc:nzwidth="0x1" edc:desc="When SCEN is asserted ('1'), Slave Cumulative Time-Out checking is enabled. When SCEN is not asserted ('0'), Slave Cumulative Time-Out checking is disabled."/>
            <edc:SFRFieldDef edc:cname="BIDEN" edc:nzwidth="0x1" edc:desc="When BIDEN is asserted ('1'), Bus Idle Detect Time-Out checking is enabled. When BIDEN is not asserted ('0'), Bus Idle Detect Time-Out checking is disabled."/>
            <edc:SFRFieldDef edc:cname="TIMERR" edc:nzwidth="0x1" edc:desc="The Time-out Error Detected bit (TIMERR) is asserted ('1') whenever any of the enabled time-out error detect status bits (CHDH, CHDL, SCTO, MCTO and DTO) are asserted."/>
            <edc:AdjustPoint edc:offset="0x1"/>
            <edc:SFRFieldDef edc:cname="DTO" edc:nzwidth="0x1" edc:desc="DTO is the Device Time-out bit. (R/WC)"/>
            <edc:SFRFieldDef edc:cname="MCTO" edc:nzwidth="0x1" edc:desc="MCTO is the Master Cumulative Time-out bit. (R/WC)"/>
            <edc:SFRFieldDef edc:cname="SCTO" edc:nzwidth="0x1" edc:desc="SCTO is the Slave Cumulative Time-out bit(R/WC)"/>
            <edc:SFRFieldDef edc:cname="CHDL" edc:nzwidth="0x1" edc:desc="CHDL is the clock high time-out detect bit(R/WC)"/>
            <edc:SFRFieldDef edc:cname="CHDH" edc:nzwidth="0x1" edc:desc="CHDH is the bus idle time-out detect bit(R/WC)"/>
            <edc:SFRFieldDef edc:cname="BER" edc:nzwidth="0x1" edc:desc="If this bit is 1, the BER bit in the Status register was set while either the Slave state machine or the Master state machine was not in the Idle state.(R/WC)"/>
            <edc:SFRFieldDef edc:cname="LAB" edc:nzwidth="0x1" edc:desc="If this bit is 1, the LAB bit in the Status register was set while either the Slave state machine or the Master state machine was not in the Idle state.(R/WC)"/>
            <edc:AdjustPoint edc:offset="0x1"/>
            <edc:SFRFieldDef edc:cname="SNAKR" edc:nzwidth="0x1" edc:desc="If this bit is 1, the Slave state machine sent a NACK to the transmitting Master while the Slave was receiving data from the SMBus interface."/>
            <edc:SFRFieldDef edc:cname="STR" edc:nzwidth="0x1" edc:desc="0: Slave has just finished the receive phase of a transaction.                 1: Slave has just finished the transmit phase of a transaction."/>
            <edc:AdjustPoint edc:offset="0x1"/>
            <edc:SFRFieldDef edc:cname="SPROT" edc:nzwidth="0x1" edc:desc="If this bit is 1, the WriteCount[7:0] counter in the Slave state machine either counted down to 0 before the Master sent a NACK signal, or the Slave received a NACK signal before the counter reached 0."/>
            <edc:SFRFieldDef edc:cname="REP_RD" edc:nzwidth="0x1" edc:desc="If this bit is 1, the Slave State Machine stopped because it detected a Repeat Start bit, with bit[0] of the byte containing the slave address equal to 1, indicating that the Master requested a Read operation."/>
            <edc:SFRFieldDef edc:cname="REP_WR" edc:nzwidth="0x1" edc:desc="If this bit is 1, the Slave State Machine stopped because it detected a Repeat Start bit, with bit[0] of the byte containing the slave address equal to 0, indicating that the Master requested a Write operation."/>
            <edc:AdjustPoint edc:offset="0x2"/>
            <edc:SFRFieldDef edc:cname="MNAKX" edc:nzwidth="0x1" edc:desc="If this bit is 1, the Master state machine received a NACK from the receiving Slave while the Master was transmitting data over the SMBus interface. (R/WC)"/>
            <edc:SFRFieldDef edc:cname="MTR" edc:nzwidth="0x1" edc:desc="0: Master has just finished the receive phase of a transaction.                 1: Master has just finished the transmit phase of a transaction."/>
            <edc:AdjustPoint edc:offset="0x3"/>
            <edc:SFRFieldDef edc:cname="IDLE" edc:nzwidth="0x1" edc:desc="This bit is set when the I2C bus becomes idle (on the rising edge of nBB). (R/WC)"/>
            <edc:SFRFieldDef edc:cname="MDONE" edc:nzwidth="0x1" edc:desc="If this bit is 1, Master State machine completed operation and returned to the Idle state. It is cleared when written with a 1. Writes of a 0 have no effect. (R/WC)"/>
            <edc:SFRFieldDef edc:cname="SDONE" edc:nzwidth="0x1" edc:desc="If this bit is 1, Slave State machine completed operation and returned to the Idle state. It is cleared when written with a 1. Writes of a 0 have no effect.(R/WC)"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SMB0" edc:cname="IDLSC" edc:nzwidth="0x20" edc:access="----nnnnnnnnnnnn----nnnnnnnnnnnn" edc:por="00000001111111000000000111101101" edc:mclr="00000001111111000000000111101101" edc:impl="0xFFF0FFF" edc:_addr="0x40004024">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SMB0">
            <edc:SFRFieldDef edc:cname="FAIR_BUS_IDL_MIN" edc:nzwidth="0xC" edc:desc="This field defines the number of ticks of the baud clock required to satisfy the fairness protocol. The default value for this field sets the idle window to 31us, which is the appropriate value for a 100 KHz bus"/>
            <edc:AdjustPoint edc:offset="0x4"/>
            <edc:SFRFieldDef edc:cname="FAIR_IDL_DLY" edc:nzwidth="0xC" edc:desc="This field defines the number of ticks of the baud clock required to program the delay. The default value for this field sets the delay period to 32us, which is the appropriate value for a 100 KHz bus"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SMB0" edc:cname="CFG0" edc:nzwidth="0x20" edc:access="nnnn--------nnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0xF00FFFFF" edc:_addr="0x40004028">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SMB0">
            <edc:SFRFieldDef edc:cname="PORT_SEL" edc:nzwidth="0x4" edc:desc="The PORT SEL [3:0] bits determine which one of 16 possible bus ports apply to the active 2-wire SDAT and SCLK bus pair."/>
            <edc:SFRFieldDef edc:cname="TCEN" edc:nzwidth="0x1" edc:desc="When the Timing Check Enable bit (TCEN) is asserted ('1'), Bus Time-Outs are enabled"/>
            <edc:SFRFieldDef edc:cname="SLOW_CLK" edc:nzwidth="0x1" edc:desc="When this bit is 1, the base period for the Bus Clock Register is multiplied by 4, and thus the frequency is divided by 4."/>
            <edc:SFRFieldDef edc:cname="TEST" edc:nzwidth="0x1" edc:desc="Must be always written with 0."/>
            <edc:SFRFieldDef edc:cname="PECEN" edc:nzwidth="0x1" edc:desc="When the PEC Enable bit (PECEN) is asserted ('1'), Hardware PEC Support is enabled"/>
            <edc:SFRFieldDef edc:cname="FEN" edc:nzwidth="0x1" edc:desc="Input filtering enable. Input filtering is required by the I2C specification if external filtering is not available.      1=Input filtering is enabled; 0=Input filtering is disabled."/>
            <edc:SFRFieldDef edc:cname="RST" edc:nzwidth="0x1" edc:desc="When RESET is asserted ('1'), all logic and registers except for the RESET bit itself are initialized to the power-on default state."/>
            <edc:SFRFieldDef edc:cname="EN" edc:nzwidth="0x1" edc:desc="When ENAB (Enable) is not asserted ('0') (default), the SMB Controller Core is disabled and in the lowest power consumption state (Disabled State).                The ENAB bit must be asserted ('1') for normal operation."/>
            <edc:SFRFieldDef edc:cname="DSA" edc:nzwidth="0x1" edc:desc="0: Slave Address I2C Compatibility Mode (default). 1: SMBus Address Decode Mode"/>
            <edc:SFRFieldDef edc:cname="FAIR" edc:nzwidth="0x1" edc:desc="If this bit is 1, the MCTP Fairness protocol is in effect."/>
            <edc:SFRFieldDef edc:cname="TEST0" edc:nzwidth="0x1" edc:desc="Must be always written with 0."/>
            <edc:SFRFieldDef edc:cname="GC_DIS" edc:nzwidth="0x1" edc:desc="This is the General Call Disable bit.                0: the response to the General Call address as a slave is enabled                1: the response to the General Call address as a slave is disabled."/>
            <edc:SFRFieldDef edc:cname="CFG_PROMIS" edc:nzwidth="0x1" edc:desc="This bit define the Mode of SM Bus Controler Mode of operation.         0= Normal Operation.         1=  Promiscuous Mode Enable."/>
            <edc:SFRFieldDef edc:cname="FLUSH_SXBUF" edc:nzwidth="0x1" edc:desc="A write of a 1 to this bit forces the SMBus Slave Transmit Buffer Register to be marked empty. A write of 0 has no effect. This is a self-clearing bit."/>
            <edc:SFRFieldDef edc:cname="FLUSH_SRBUF" edc:nzwidth="0x1" edc:desc="A write of a 1 to this bit forces the SMBus Slave Receive Buffer Register to be marked empty. A write of 0 has no effect. This is a self-clearing bit."/>
            <edc:SFRFieldDef edc:cname="FLUSH_MXBUF" edc:nzwidth="0x1" edc:desc="A write of a 1 to this bit forces the SMBus Master Transmit Buffer Register to be marked empty. A write of 0 has no effect. This is a self-clearing bit."/>
            <edc:SFRFieldDef edc:cname="FLUSH_MRBUF" edc:nzwidth="0x1" edc:desc="A write of a 1 to this bit forces the SMBus Master Receive Buffer Register to be marked empty. A write of 0 has no effect. This is a self-clearing bit."/>
            <edc:AdjustPoint edc:offset="0x8"/>
            <edc:SFRFieldDef edc:cname="EN_AAS" edc:nzwidth="0x1" edc:desc="0: Disable the AAS, 1: Enable the AAS Interrupt"/>
            <edc:SFRFieldDef edc:cname="ENIDI" edc:nzwidth="0x1" edc:desc="If this bit is 1, the Idle interrupt is enabled. If this bit is 0, the Idle interrupt is disabled."/>
            <edc:SFRFieldDef edc:cname="ENMI" edc:nzwidth="0x1" edc:desc="If this bit is 1, the Master Done interrupt is enabled. If this bit is 0, the Master Done interrupt is disabled."/>
            <edc:SFRFieldDef edc:cname="ENSI" edc:nzwidth="0x1" edc:desc="If this bit is 1, the Slave Done interrupt is enabled. If this bit is 0, the Slave Done interrupt is disabled"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SMB0" edc:cname="BUSCLK" edc:nzwidth="0x20" edc:access="----------------nnnnnnnnnnnnnnnn" edc:por="00000000000000000100111101001111" edc:mclr="00000000000000000100111101001111" edc:impl="0xFFFF" edc:_addr="0x4000402C">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SMB0">
            <edc:SFRFieldDef edc:cname="LOW_PER" edc:nzwidth="0x8" edc:desc="This field defines the number of I2C Baud Clock periods that make up the low phase of the I2C/SMBus bus clock."/>
            <edc:SFRFieldDef edc:cname="HIGH_PER" edc:nzwidth="0x8" edc:desc="This field defines the number of I2C Baud Clock periods that make up the high phase of the I2C/SMBus bus clock."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SMB0" edc:cname="BLKID" edc:nzwidth="0x8" edc:access="rrrrrrrr" edc:por="00010001" edc:mclr="00010001" edc:_addr="0x40004030">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SMB0">
            <edc:SFRFieldDef edc:cname="ID" edc:nzwidth="0x8" edc:desc="Block ID."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:AdjustPoint edc:offset="0x3" edc:_addr="0x40004031"/>
      <edc:SFRDef ltx:memberofperipheral="SMB0" edc:cname="BLKREV" edc:nzwidth="0x8" edc:access="rrrrrrrr" edc:por="00000000" edc:mclr="00000000" edc:_addr="0x40004034">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SMB0">
            <edc:SFRFieldDef edc:cname="REV" edc:nzwidth="0x8" edc:desc="Block Revision Number"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:AdjustPoint edc:offset="0x3" edc:_addr="0x40004035"/>
      <edc:SFRDef ltx:memberofperipheral="SMB0" edc:cname="BBCTRL" edc:nzwidth="0x20" edc:access="-------------------------nnnnnnn" edc:por="00000000000000000000000001100000" edc:mclr="00000000000000000000000001100000" edc:impl="0x7F" edc:_addr="0x40004038">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SMB0">
            <edc:SFRFieldDef edc:cname="BBEN" edc:nzwidth="0x1" edc:desc="Bit-Bang Mode Enable. 0 - Bit Bang Mode Disabled. 1 - Bit Bang Mode Enabled"/>
            <edc:SFRFieldDef edc:cname="CLDIR" edc:nzwidth="0x1" edc:desc="Bit-Bang Clock Direction. The CLDIR bit controls the direction of SCLK. 0 - Input, 1 - Output"/>
            <edc:SFRFieldDef edc:cname="DADIR" edc:nzwidth="0x1" edc:desc="Bit-Bang Data Direction. The DADIR bit controls the direction of SDAT. 0 - Input. 1 - Output"/>
            <edc:SFRFieldDef edc:cname="BBCLK" edc:nzwidth="0x1" edc:desc="Bit-Bang Clock. The BBCLK bit controls the state of SCLK when BBEN = and CLDIR = '1'"/>
            <edc:SFRFieldDef edc:cname="BBDAT" edc:nzwidth="0x1" edc:desc="Bit-Bang Data. The BBDAT bit controls the state of SDAT when BBEN = and DADIR = '1'"/>
            <edc:SFRFieldDef edc:cname="BBCLKI" edc:nzwidth="0x1" edc:desc="Bit-Bang Clock In. The BBCLKI bit always returns the state of SCLK."/>
            <edc:SFRFieldDef edc:cname="BBDATI" edc:nzwidth="0x1" edc:desc="Bit-Bang Data In. The BBDATI bit always returns the state of SDAT"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SMB0" edc:cname="TEST" edc:nzwidth="0x8" edc:access="rrrrrrrr" edc:por="00000101" edc:mclr="00000101" edc:_addr="0x4000403C">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SMB0">
            <edc:SFRFieldDef edc:cname="TEST" edc:nzwidth="0x8" edc:desc="This register must not be written, or undesirable results may occur."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:AdjustPoint edc:offset="0x3" edc:_addr="0x4000403D"/>
      <edc:SFRDef ltx:memberofperipheral="SMB0" edc:cname="DATATM" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00001100010011010101000000000110" edc:mclr="00001100010011010101000000000110" edc:_addr="0x40004040">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SMB0">
            <edc:SFRFieldDef edc:cname="DATA_HOLD" edc:nzwidth="0x8" edc:desc="The Data Hold [7:0] timer determines the SDAT hold time following SCLK driven low."/>
            <edc:SFRFieldDef edc:cname="RESTART_SETUP" edc:nzwidth="0x8" edc:desc="The Restart Setup [7:0] timer determines the SDAT setup time from the rising edge of SCLK for a repeated START condition."/>
            <edc:SFRFieldDef edc:cname="STOP_SETUP" edc:nzwidth="0x8" edc:desc="The Stop Setup [7:0] timer determines the SDAT setup time from the rising edge of SCLK for a STOP condition."/>
            <edc:SFRFieldDef edc:cname="FIRST_START_HOLD" edc:nzwidth="0x8" edc:desc="This field determines the SCL hold time following SDA driven low during the first START bit in a transfer. It is the parameter      THD:STA in the I2C Specification for an initial START bit. Repeated START hold time is determined by the Repeated START Hold Time Register."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SMB0" edc:cname="TMOUTSC" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="01001011100111001100001011000111" edc:mclr="01001011100111001100001011000111" edc:_addr="0x40004044">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SMB0">
            <edc:SFRFieldDef edc:cname="CLK_HIGH_TIM_OUT" edc:nzwidth="0x8" edc:desc="Clock High time out period = Clock High Time-Out [7:0] x Baud_Clock_Period x 2"/>
            <edc:SFRFieldDef edc:cname="SLV_CUM_TIM_OUT" edc:nzwidth="0x8" edc:desc="Slave Cumulative Time-Out duration = Slave Cum Time-Out [7:0] x Baud_Clock_Period x 1024"/>
            <edc:SFRFieldDef edc:cname="MAST_CUM_TIM_OUT" edc:nzwidth="0x8" edc:desc="Master Cumulative Time-Out duration = Master Cum Time-Out [7:0] x Baud_Clock_Period x 512"/>
            <edc:SFRFieldDef edc:cname="BUS_IDLE_MIN" edc:nzwidth="0x8" edc:desc="Bus Idle Minimum time = Bus Idle Min [7:0] x Baud_Clock_Period"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SMB0" edc:cname="SLV_TXB" edc:nzwidth="0x20" edc:access="------------------------nnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0xFF" edc:_addr="0x40004048">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SMB0">
            <edc:SFRFieldDef edc:cname="STXB" edc:nzwidth="0x8" edc:desc="SLAVE_TRANSMIT_BUFFER"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SMB0" edc:cname="SLV_RXB" edc:nzwidth="0x20" edc:access="------------------------nnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0xFF" edc:_addr="0x4000404C">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SMB0">
            <edc:SFRFieldDef edc:cname="SRXB" edc:nzwidth="0x8" edc:desc="SLAVE_RECEIVE_BUFFER"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SMB0" edc:cname="MTR_TXB" edc:nzwidth="0x20" edc:access="------------------------nnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0xFF" edc:_addr="0x40004050">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SMB0">
            <edc:SFRFieldDef edc:cname="MTXB" edc:nzwidth="0x8" edc:desc="MASTER_TRANSMIT_BUFFER"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SMB0" edc:cname="MTR_RXB" edc:nzwidth="0x20" edc:access="------------------------nnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0xFF" edc:_addr="0x40004054">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SMB0">
            <edc:SFRFieldDef edc:cname="MRXB" edc:nzwidth="0x8" edc:desc="MASTER_RECEIVE_BUFFER"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:AdjustPoint edc:offset="0x8" edc:_addr="0x40004058"/>
      <edc:SFRDef ltx:memberofperipheral="SMB0" edc:cname="WAKE_STS" edc:nzwidth="0x20" edc:access="-------------------------------n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x1" edc:_addr="0x40004060">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SMB0">
            <edc:SFRFieldDef edc:cname="START_BIT_DET" edc:nzwidth="0x1" edc:desc="This bit is set to '1' when a START bit is detected while the controller is enabled. This bit is cleared to '0' when      written with a '1'. Writes of '0' have no effect. (R/WC)"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SMB0" edc:cname="WAKE_EN" edc:nzwidth="0x20" edc:access="-------------------------------n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x1" edc:_addr="0x40004064">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SMB0">
            <edc:SFRFieldDef edc:cname="START_DET_INT_EN" edc:nzwidth="0x1" edc:desc="Enable Start Bit Detection Interrupt. The Start Bit Detection Interrupt is wake-capable.      1=Start Bit Detection Interrupt enabled; 0=Start Bit Detection Interrupt disabled"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:AdjustPoint edc:offset="0x4" edc:_addr="0x40004068"/>
      <edc:SFRDef ltx:memberofperipheral="SMB0" edc:cname="SLV_ADDR" edc:nzwidth="0x8" edc:access="nnnnnnnn" edc:por="00000000" edc:mclr="00000000" edc:_addr="0x4000406C">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SMB0">
            <edc:SFRFieldDef edc:cname="SADDR" edc:nzwidth="0x8" edc:desc="This register stores value of address + LSB direction after the 8th clock of the Address Byte."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:AdjustPoint edc:offset="0x3" edc:_addr="0x4000406D"/>
      <edc:SFRDef ltx:memberofperipheral="SMB0" edc:cname="PRM_STS" edc:nzwidth="0x8" edc:access="-------n" edc:por="00000000" edc:mclr="00000000" edc:impl="0x1" edc:_addr="0x40004070">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SMB0">
            <edc:SFRFieldDef edc:cname="ADDR_INTR" edc:nzwidth="0x1" edc:desc="This is the Promiscuous Address Status interrupt and is set on the 8th clock of the I2C Address.         This bit will hold the Clock line low till this register bit is cleared. This is Write 1 to clear.         R/W1C."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:AdjustPoint edc:offset="0x3" edc:_addr="0x40004071"/>
      <edc:SFRDef ltx:memberofperipheral="SMB0" edc:cname="PRM_IEN" edc:nzwidth="0x8" edc:access="-------n" edc:por="00000000" edc:mclr="00000000" edc:impl="0x1" edc:_addr="0x40004074">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SMB0">
            <edc:SFRFieldDef edc:cname="ADDR" edc:nzwidth="0x1" edc:desc="This is the Promiscuous interrupt enable register.         1= Interrupt Enable.          0= Interrupt Disabled. "/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:AdjustPoint edc:offset="0x3" edc:_addr="0x40004075"/>
      <edc:SFRDef ltx:memberofperipheral="SMB0" edc:cname="PRM_CTRL" edc:nzwidth="0x8" edc:access="-------n" edc:por="00000000" edc:mclr="00000000" edc:impl="0x1" edc:_addr="0x40004078">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SMB0">
            <edc:SFRFieldDef edc:cname="ACK_NAK" edc:nzwidth="0x1" edc:desc="This is the Promiscuous ACK / NAK response register.         1= ACK.          0= NAK. "/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:AdjustPoint edc:offset="0x3" edc:_addr="0x40004079"/>
      <edc:SFRDef ltx:memberofperipheral="SMB0" edc:cname="SHDW_DATA" edc:nzwidth="0x8" edc:access="nnnnnnnn" edc:por="00000000" edc:mclr="00000000" edc:_addr="0x4000407C">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SMB0">
            <edc:SFRFieldDef edc:cname="SHDW_DATA" edc:nzwidth="0x8" edc:desc="This is the I2C Shadow Data Register"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:AdjustPoint edc:offset="0x383" edc:_addr="0x4000407D"/>
      <edc:MuxedSFRDef edc:nzwidth="0x20" edc:_addr="0x40004400">
        <edc:SelectSFR>
          <edc:SFRDef ltx:memberofperipheral="SMB1" edc:cname="WCTRL" edc:nzwidth="0x20" edc:access="------------------------ww--wwww" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0xCF" edc:_addr="0x40004400">
            <edc:SFRModeList>
              <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SMB1">
                <edc:SFRFieldDef edc:cname="ACK" edc:nzwidth="0x1" edc:desc="The Acknowledge bit (ACK) must normally be asserted ('1'). This causes the controller to send an acknowledge automatically after each byte (this occurs during the 9th clock pulse). The ACK bit must not be asserted ('0') when the controller is operating in master/receiver mode and requires no further data to be sent from the slave transmitter. This causes a negative acknowledge on the I2C bus, which halts further transmission from the slave device."/>
                <edc:SFRFieldDef edc:cname="STO" edc:nzwidth="0x1" edc:desc="See STA description"/>
                <edc:SFRFieldDef edc:cname="STA" edc:nzwidth="0x1" edc:desc="The STA and STO bits control the generation of the I2C Start condition and the transmission of the Slave Address and R/nW bit (from the Data Register), generation of repeated Start condition, and generation of the Stop condition"/>
                <edc:SFRFieldDef edc:cname="ENI" edc:nzwidth="0x1" edc:desc="Enable Interrupt bit (ENI) controls the Interrupt Interface"/>
                <edc:AdjustPoint edc:offset="0x2"/>
                <edc:SFRFieldDef edc:cname="ESO" edc:nzwidth="0x1" edc:desc="The Enable Serial Output bit (ESO) enables and disables the SMB Controller Core serial data output (SDAT)"/>
                <edc:SFRFieldDef edc:cname="PIN" edc:nzwidth="0x1" edc:desc="The Pending Interrupt Not (PIN) bit serves as a software reset function. Writing the PIN bit to a logic '1' de-asserts all status bits except for the nBB bit which is not affected by the PIN bit. The PIN bit is a self-clearing bit. Writing this bit to a logic '0' has no effect."/>
              </edc:SFRMode>
            </edc:SFRModeList>
          </edc:SFRDef>
        </edc:SelectSFR>
        <edc:SelectSFR>
          <edc:SFRDef ltx:memberofperipheral="SMB1" edc:cname="RSTS" edc:nzwidth="0x20" edc:access="------------------------rrrrrrrr" edc:por="00000000000000000000000010000001" edc:mclr="00000000000000000000000010000001" edc:impl="0xFF" edc:_addr="0x40004400">
            <edc:SFRModeList>
              <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SMB1">
                <edc:SFRFieldDef edc:cname="NBB" edc:nzwidth="0x1" edc:desc="The Bus Busy bit (NBB) is a read-only flag indicating when the bus is in use. A zero indicates that the bus is busy and access is not possible."/>
                <edc:SFRFieldDef edc:cname="LAB" edc:nzwidth="0x1" edc:desc="The Lost Arbitration Bit (LAB) is set when, in multi-master operation, arbitration is lost to another master on the bus"/>
                <edc:SFRFieldDef edc:cname="AAS" edc:nzwidth="0x1" edc:desc="The Addressed As Slave bit (AAS) is valid only when PIN is asserted ('0'). When acting as slave, AAS is set when an incoming address over the bus matches the value in the Own Address Register or if the 'general call' address (00h) has been received"/>
                <edc:SFRFieldDef edc:cname="LRB_AD0" edc:nzwidth="0x1" edc:desc="The Last Received Bit  or Address 0 (general call) bit (LRB/AD0) serves a dual function and is valid only while the PIN bit is asserted ('0').                When the AAS bit is not asserted ('0') (i.e., not addressed as a slave), the LRB/AD0 holds the value of the last received bit over the bus.                When the AAS bit is asserted ('1') (i.e., addressed as slave), the SMB Controller Core has been addressed as a slave."/>
                <edc:SFRFieldDef edc:cname="BER" edc:nzwidth="0x1" edc:desc="When Bus Error (BER) is asserted, a misplaced START or STOP condition or Bus Time-Outs have been detected."/>
                <edc:SFRFieldDef edc:cname="STS" edc:nzwidth="0x1" edc:desc="When in slave receiver mode, STS is asserted ('1') when an externally generated STOP condition is detected. Note that STS is used only in slave receiver mode."/>
                <edc:SFRFieldDef edc:cname="SAD" edc:nzwidth="0x1" edc:desc="SMBus Address Decoded (SAD)"/>
                <edc:SFRFieldDef edc:cname="PIN" edc:nzwidth="0x1" edc:desc="Pending Interrupt bit"/>
              </edc:SFRMode>
            </edc:SFRModeList>
          </edc:SFRDef>
        </edc:SelectSFR>
      </edc:MuxedSFRDef>
      <edc:SFRDef ltx:memberofperipheral="SMB1" edc:cname="OWN_ADDR" edc:nzwidth="0x20" edc:access="-----------------nnnnnnn-nnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x7F7F" edc:_addr="0x40004404">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SMB1">
            <edc:SFRFieldDef edc:cname="ADDR1" edc:nzwidth="0x7" edc:desc="The Own Address 1 bits configure one of the two addresses to which the SMB Controller Core will respond when addressed as a slave."/>
            <edc:AdjustPoint edc:offset="0x1"/>
            <edc:SFRFieldDef edc:cname="ADDR2" edc:nzwidth="0x7" edc:desc="The Own Address 2 bits configure one of the two addresses to which the SMB Controller Core will respond when addressed as a slave."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SMB1" edc:cname="I2CDATA" edc:nzwidth="0x8" edc:access="nnnnnnnn" edc:por="00000000" edc:mclr="00000000" edc:_addr="0x40004408"/>
      <edc:SFRDef ltx:memberofperipheral="SMB1" edc:cname="RSVD10" edc:nzwidth="0x8" edc:access="rrrrrrrr" edc:por="00000000" edc:mclr="00000000" edc:_addr="0x40004409"/>
      <edc:SFRDef ltx:memberofperipheral="SMB1" edc:cname="RSVD11" edc:nzwidth="0x8" edc:access="rrrrrrrr" edc:por="00000000" edc:mclr="00000000" edc:_addr="0x4000440A"/>
      <edc:SFRDef ltx:memberofperipheral="SMB1" edc:cname="RSVD12" edc:nzwidth="0x8" edc:access="rrrrrrrr" edc:por="00000000" edc:mclr="00000000" edc:_addr="0x4000440B"/>
      <edc:SFRDef ltx:memberofperipheral="SMB1" edc:cname="MCMD0" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnn--nnnnnn------nn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0xFFFF3F03" edc:_addr="0x4000440C">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SMB1">
            <edc:SFRFieldDef edc:cname="MRUN" edc:nzwidth="0x1" edc:desc="While this bit is 1, transfer bytes over SMBus. As long as WriteCount is non-zero, a byte from the Master Transmit Buffer is transmitted to the slave device and WriteCount is decremented."/>
            <edc:SFRFieldDef edc:cname="MPROCEED" edc:nzwidth="0x1" edc:desc="When this bit is 0, the Master State Machine does not transition out of the IDLE or PAUSE states. When this bit is 1, the Master State Machine immediately transitions to the WAIT-BUSBUSY and MRUN-RECEIVE states, respectively."/>
            <edc:AdjustPoint edc:offset="0x6"/>
            <edc:SFRFieldDef edc:cname="START0" edc:nzwidth="0x1" edc:desc="If this bit is 1, send a Start bit on the SMBus before the first byte of the WriteCount is sent to the SMBus transmitter."/>
            <edc:SFRFieldDef edc:cname="STARTN" edc:nzwidth="0x1" edc:desc="If this bit is 1, send a Start bit just before the last byte of the WriteCount is sent to the SMBus transmitter."/>
            <edc:SFRFieldDef edc:cname="STOP" edc:nzwidth="0x1" edc:desc="If this bit is 1, send a Stop bit after the transaction completes."/>
            <edc:SFRFieldDef edc:cname="PEC_TERM" edc:nzwidth="0x1" edc:desc="If this bit is 1, a copy of the PEC register is transmitted when WriteCount is 0. After the PEC register is read, both the PEC register and this bit are cleared to 0."/>
            <edc:SFRFieldDef edc:cname="READM" edc:nzwidth="0x1" edc:desc="If this bit is 1, then the ReadCount field is replaced by the byte that is read from the SMBus when ReadCount[7:0] is 1. After ReadCount[7:0] is updated, this bit is cleared to 0."/>
            <edc:SFRFieldDef edc:cname="READ_PEC" edc:nzwidth="0x1" edc:desc="If this bit is 0, reading from the SMBus stops when ReadCount reaches 0. If this bit is 1, reading continues when ReadCount is 0 for one more byte."/>
            <edc:AdjustPoint edc:offset="0x2"/>
            <edc:SFRFieldDef edc:cname="WR_CNT" edc:nzwidth="0x8" edc:desc="This field is a count of the number of bytes to transmit to the SMBus from the SMBus Master Transmit Buffer Register It is decremented by 1 for each byte written to the SMBus from the SMBus Master Transmit Buffer Register."/>
            <edc:SFRFieldDef edc:cname="RD_CNT" edc:nzwidth="0x8" edc:desc="This field is a count of the number of bytes to read in from the SMBus to the SMBus Master Receive Buffer Register and must be greater than 0 in order for the Master State Machine to initiate a read phase. It is decremented by 1 for each byte read from the SMBus into the SMBus Master Receive Buffer Register. It can be overwritten by the first byte read in from the SMBus."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SMB1" edc:cname="SCMD0" edc:nzwidth="0x20" edc:access="--------nnnnnnnnnnnnnnnn-----nnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0xFFFF07" edc:_addr="0x40004410">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SMB1">
            <edc:SFRFieldDef edc:cname="SRUN" edc:nzwidth="0x1" edc:desc="Setting this bit to 1 enables the Slave State Machine to operate."/>
            <edc:SFRFieldDef edc:cname="SPROCEED" edc:nzwidth="0x1" edc:desc="When this bit is 0, the Slave State Machine does not transition out of the IDLE, REPEAT_START_WRITE or REPEAT_START_READ states. When this bit is 1, the Slave State Machine immediately transitions to the START_WAIT, RECEIVE and TRANSMIT states, respectively."/>
            <edc:SFRFieldDef edc:cname="PEC" edc:nzwidth="0x1" edc:desc="If Slave_WriteCount is 0 and Slave_PEC is 1 when the Master requests data, the PEC Register is copied to the DATA register. After the PEC Register is copied to the SMBus, the PEC Register is cleared and Slave_PEC is set to 0."/>
            <edc:AdjustPoint edc:offset="0x5"/>
            <edc:SFRFieldDef edc:cname="WR_CNT" edc:nzwidth="0x8" edc:desc="This field is set to the number of bytes software expects to send to the Master."/>
            <edc:SFRFieldDef edc:cname="RD_CNT" edc:nzwidth="0x8" edc:desc="This field is decremented each time a byte is copied from DATA to the SMBus Slave Receive Buffer Register."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SMB1" edc:cname="PEC" edc:nzwidth="0x20" edc:access="------------------------nnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0xFF" edc:_addr="0x40004414">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SMB1">
            <edc:SFRFieldDef edc:cname="PEC" edc:nzwidth="0x8" edc:desc="The SMBus Packet Error Check (PEC) byte."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SMB1" edc:cname="RSHTM" edc:nzwidth="0x20" edc:access="------------------------nnnnnnnn" edc:por="00000000000000000000000001001101" edc:mclr="00000000000000000000000001001101" edc:impl="0xFF" edc:_addr="0x40004418">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SMB1">
            <edc:SFRFieldDef edc:cname="RSHTM" edc:nzwidth="0x8" edc:desc="This is the value of the timing requirement tHd:Sta in the I2C specification for a repeated START bit. This is used to hold      the clock until the Hold Time for the repeated Start Bit has been satisfied."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SMB1" edc:cname="EXTND_LEN" edc:nzwidth="0x20" edc:access="------------------------rrrrrrrr" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0xFF" edc:_addr="0x4000441C">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SMB1">
            <edc:SFRFieldDef edc:cname="EXTND_LEN" edc:nzwidth="0x8" edc:desc="Extended Length Register adds 8 MSB bits to the SMBUS Master/Slave Tx/Rx Length fields."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SMB1" edc:cname="COMPL0" edc:nzwidth="0x20" edc:access="nnn---nn--nnn-nn-nnnnnnn-nnnnn--" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0xE33B7F7C" edc:_addr="0x40004420">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SMB1">
            <edc:AdjustPoint edc:offset="0x2"/>
            <edc:SFRFieldDef edc:cname="DTEN" edc:nzwidth="0x1" edc:desc="When DTEN is asserted ('1'), Device Time-out checking is enabled. When DTEN is not asserted ('0'), Device Time-out checking is disabled."/>
            <edc:SFRFieldDef edc:cname="MCEN" edc:nzwidth="0x1" edc:desc="When MCEN is asserted ('1'), Master Cumulative Time-Out checking is enabled. When MCEN is not asserted ('0'), Master Cumulative Time-Out checking is disabled."/>
            <edc:SFRFieldDef edc:cname="SCEN" edc:nzwidth="0x1" edc:desc="When SCEN is asserted ('1'), Slave Cumulative Time-Out checking is enabled. When SCEN is not asserted ('0'), Slave Cumulative Time-Out checking is disabled."/>
            <edc:SFRFieldDef edc:cname="BIDEN" edc:nzwidth="0x1" edc:desc="When BIDEN is asserted ('1'), Bus Idle Detect Time-Out checking is enabled. When BIDEN is not asserted ('0'), Bus Idle Detect Time-Out checking is disabled."/>
            <edc:SFRFieldDef edc:cname="TIMERR" edc:nzwidth="0x1" edc:desc="The Time-out Error Detected bit (TIMERR) is asserted ('1') whenever any of the enabled time-out error detect status bits (CHDH, CHDL, SCTO, MCTO and DTO) are asserted."/>
            <edc:AdjustPoint edc:offset="0x1"/>
            <edc:SFRFieldDef edc:cname="DTO" edc:nzwidth="0x1" edc:desc="DTO is the Device Time-out bit. (R/WC)"/>
            <edc:SFRFieldDef edc:cname="MCTO" edc:nzwidth="0x1" edc:desc="MCTO is the Master Cumulative Time-out bit. (R/WC)"/>
            <edc:SFRFieldDef edc:cname="SCTO" edc:nzwidth="0x1" edc:desc="SCTO is the Slave Cumulative Time-out bit(R/WC)"/>
            <edc:SFRFieldDef edc:cname="CHDL" edc:nzwidth="0x1" edc:desc="CHDL is the clock high time-out detect bit(R/WC)"/>
            <edc:SFRFieldDef edc:cname="CHDH" edc:nzwidth="0x1" edc:desc="CHDH is the bus idle time-out detect bit(R/WC)"/>
            <edc:SFRFieldDef edc:cname="BER" edc:nzwidth="0x1" edc:desc="If this bit is 1, the BER bit in the Status register was set while either the Slave state machine or the Master state machine was not in the Idle state.(R/WC)"/>
            <edc:SFRFieldDef edc:cname="LAB" edc:nzwidth="0x1" edc:desc="If this bit is 1, the LAB bit in the Status register was set while either the Slave state machine or the Master state machine was not in the Idle state.(R/WC)"/>
            <edc:AdjustPoint edc:offset="0x1"/>
            <edc:SFRFieldDef edc:cname="SNAKR" edc:nzwidth="0x1" edc:desc="If this bit is 1, the Slave state machine sent a NACK to the transmitting Master while the Slave was receiving data from the SMBus interface."/>
            <edc:SFRFieldDef edc:cname="STR" edc:nzwidth="0x1" edc:desc="0: Slave has just finished the receive phase of a transaction.                 1: Slave has just finished the transmit phase of a transaction."/>
            <edc:AdjustPoint edc:offset="0x1"/>
            <edc:SFRFieldDef edc:cname="SPROT" edc:nzwidth="0x1" edc:desc="If this bit is 1, the WriteCount[7:0] counter in the Slave state machine either counted down to 0 before the Master sent a NACK signal, or the Slave received a NACK signal before the counter reached 0."/>
            <edc:SFRFieldDef edc:cname="REP_RD" edc:nzwidth="0x1" edc:desc="If this bit is 1, the Slave State Machine stopped because it detected a Repeat Start bit, with bit[0] of the byte containing the slave address equal to 1, indicating that the Master requested a Read operation."/>
            <edc:SFRFieldDef edc:cname="REP_WR" edc:nzwidth="0x1" edc:desc="If this bit is 1, the Slave State Machine stopped because it detected a Repeat Start bit, with bit[0] of the byte containing the slave address equal to 0, indicating that the Master requested a Write operation."/>
            <edc:AdjustPoint edc:offset="0x2"/>
            <edc:SFRFieldDef edc:cname="MNAKX" edc:nzwidth="0x1" edc:desc="If this bit is 1, the Master state machine received a NACK from the receiving Slave while the Master was transmitting data over the SMBus interface. (R/WC)"/>
            <edc:SFRFieldDef edc:cname="MTR" edc:nzwidth="0x1" edc:desc="0: Master has just finished the receive phase of a transaction.                 1: Master has just finished the transmit phase of a transaction."/>
            <edc:AdjustPoint edc:offset="0x3"/>
            <edc:SFRFieldDef edc:cname="IDLE" edc:nzwidth="0x1" edc:desc="This bit is set when the I2C bus becomes idle (on the rising edge of nBB). (R/WC)"/>
            <edc:SFRFieldDef edc:cname="MDONE" edc:nzwidth="0x1" edc:desc="If this bit is 1, Master State machine completed operation and returned to the Idle state. It is cleared when written with a 1. Writes of a 0 have no effect. (R/WC)"/>
            <edc:SFRFieldDef edc:cname="SDONE" edc:nzwidth="0x1" edc:desc="If this bit is 1, Slave State machine completed operation and returned to the Idle state. It is cleared when written with a 1. Writes of a 0 have no effect.(R/WC)"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SMB1" edc:cname="IDLSC" edc:nzwidth="0x20" edc:access="----nnnnnnnnnnnn----nnnnnnnnnnnn" edc:por="00000001111111000000000111101101" edc:mclr="00000001111111000000000111101101" edc:impl="0xFFF0FFF" edc:_addr="0x40004424">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SMB1">
            <edc:SFRFieldDef edc:cname="FAIR_BUS_IDL_MIN" edc:nzwidth="0xC" edc:desc="This field defines the number of ticks of the baud clock required to satisfy the fairness protocol. The default value for this field sets the idle window to 31us, which is the appropriate value for a 100 KHz bus"/>
            <edc:AdjustPoint edc:offset="0x4"/>
            <edc:SFRFieldDef edc:cname="FAIR_IDL_DLY" edc:nzwidth="0xC" edc:desc="This field defines the number of ticks of the baud clock required to program the delay. The default value for this field sets the delay period to 32us, which is the appropriate value for a 100 KHz bus"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SMB1" edc:cname="CFG0" edc:nzwidth="0x20" edc:access="nnnn--------nnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0xF00FFFFF" edc:_addr="0x40004428">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SMB1">
            <edc:SFRFieldDef edc:cname="PORT_SEL" edc:nzwidth="0x4" edc:desc="The PORT SEL [3:0] bits determine which one of 16 possible bus ports apply to the active 2-wire SDAT and SCLK bus pair."/>
            <edc:SFRFieldDef edc:cname="TCEN" edc:nzwidth="0x1" edc:desc="When the Timing Check Enable bit (TCEN) is asserted ('1'), Bus Time-Outs are enabled"/>
            <edc:SFRFieldDef edc:cname="SLOW_CLK" edc:nzwidth="0x1" edc:desc="When this bit is 1, the base period for the Bus Clock Register is multiplied by 4, and thus the frequency is divided by 4."/>
            <edc:SFRFieldDef edc:cname="TEST" edc:nzwidth="0x1" edc:desc="Must be always written with 0."/>
            <edc:SFRFieldDef edc:cname="PECEN" edc:nzwidth="0x1" edc:desc="When the PEC Enable bit (PECEN) is asserted ('1'), Hardware PEC Support is enabled"/>
            <edc:SFRFieldDef edc:cname="FEN" edc:nzwidth="0x1" edc:desc="Input filtering enable. Input filtering is required by the I2C specification if external filtering is not available.      1=Input filtering is enabled; 0=Input filtering is disabled."/>
            <edc:SFRFieldDef edc:cname="RST" edc:nzwidth="0x1" edc:desc="When RESET is asserted ('1'), all logic and registers except for the RESET bit itself are initialized to the power-on default state."/>
            <edc:SFRFieldDef edc:cname="EN" edc:nzwidth="0x1" edc:desc="When ENAB (Enable) is not asserted ('0') (default), the SMB Controller Core is disabled and in the lowest power consumption state (Disabled State).                The ENAB bit must be asserted ('1') for normal operation."/>
            <edc:SFRFieldDef edc:cname="DSA" edc:nzwidth="0x1" edc:desc="0: Slave Address I2C Compatibility Mode (default). 1: SMBus Address Decode Mode"/>
            <edc:SFRFieldDef edc:cname="FAIR" edc:nzwidth="0x1" edc:desc="If this bit is 1, the MCTP Fairness protocol is in effect."/>
            <edc:SFRFieldDef edc:cname="TEST0" edc:nzwidth="0x1" edc:desc="Must be always written with 0."/>
            <edc:SFRFieldDef edc:cname="GC_DIS" edc:nzwidth="0x1" edc:desc="This is the General Call Disable bit.                0: the response to the General Call address as a slave is enabled                1: the response to the General Call address as a slave is disabled."/>
            <edc:SFRFieldDef edc:cname="CFG_PROMIS" edc:nzwidth="0x1" edc:desc="This bit define the Mode of SM Bus Controler Mode of operation.         0= Normal Operation.         1=  Promiscuous Mode Enable."/>
            <edc:SFRFieldDef edc:cname="FLUSH_SXBUF" edc:nzwidth="0x1" edc:desc="A write of a 1 to this bit forces the SMBus Slave Transmit Buffer Register to be marked empty. A write of 0 has no effect. This is a self-clearing bit."/>
            <edc:SFRFieldDef edc:cname="FLUSH_SRBUF" edc:nzwidth="0x1" edc:desc="A write of a 1 to this bit forces the SMBus Slave Receive Buffer Register to be marked empty. A write of 0 has no effect. This is a self-clearing bit."/>
            <edc:SFRFieldDef edc:cname="FLUSH_MXBUF" edc:nzwidth="0x1" edc:desc="A write of a 1 to this bit forces the SMBus Master Transmit Buffer Register to be marked empty. A write of 0 has no effect. This is a self-clearing bit."/>
            <edc:SFRFieldDef edc:cname="FLUSH_MRBUF" edc:nzwidth="0x1" edc:desc="A write of a 1 to this bit forces the SMBus Master Receive Buffer Register to be marked empty. A write of 0 has no effect. This is a self-clearing bit."/>
            <edc:AdjustPoint edc:offset="0x8"/>
            <edc:SFRFieldDef edc:cname="EN_AAS" edc:nzwidth="0x1" edc:desc="0: Disable the AAS, 1: Enable the AAS Interrupt"/>
            <edc:SFRFieldDef edc:cname="ENIDI" edc:nzwidth="0x1" edc:desc="If this bit is 1, the Idle interrupt is enabled. If this bit is 0, the Idle interrupt is disabled."/>
            <edc:SFRFieldDef edc:cname="ENMI" edc:nzwidth="0x1" edc:desc="If this bit is 1, the Master Done interrupt is enabled. If this bit is 0, the Master Done interrupt is disabled."/>
            <edc:SFRFieldDef edc:cname="ENSI" edc:nzwidth="0x1" edc:desc="If this bit is 1, the Slave Done interrupt is enabled. If this bit is 0, the Slave Done interrupt is disabled"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SMB1" edc:cname="BUSCLK" edc:nzwidth="0x20" edc:access="----------------nnnnnnnnnnnnnnnn" edc:por="00000000000000000100111101001111" edc:mclr="00000000000000000100111101001111" edc:impl="0xFFFF" edc:_addr="0x4000442C">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SMB1">
            <edc:SFRFieldDef edc:cname="LOW_PER" edc:nzwidth="0x8" edc:desc="This field defines the number of I2C Baud Clock periods that make up the low phase of the I2C/SMBus bus clock."/>
            <edc:SFRFieldDef edc:cname="HIGH_PER" edc:nzwidth="0x8" edc:desc="This field defines the number of I2C Baud Clock periods that make up the high phase of the I2C/SMBus bus clock."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SMB1" edc:cname="BLKID" edc:nzwidth="0x8" edc:access="rrrrrrrr" edc:por="00010001" edc:mclr="00010001" edc:_addr="0x40004430">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SMB1">
            <edc:SFRFieldDef edc:cname="ID" edc:nzwidth="0x8" edc:desc="Block ID."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:AdjustPoint edc:offset="0x3" edc:_addr="0x40004431"/>
      <edc:SFRDef ltx:memberofperipheral="SMB1" edc:cname="BLKREV" edc:nzwidth="0x8" edc:access="rrrrrrrr" edc:por="00000000" edc:mclr="00000000" edc:_addr="0x40004434">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SMB1">
            <edc:SFRFieldDef edc:cname="REV" edc:nzwidth="0x8" edc:desc="Block Revision Number"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:AdjustPoint edc:offset="0x3" edc:_addr="0x40004435"/>
      <edc:SFRDef ltx:memberofperipheral="SMB1" edc:cname="BBCTRL" edc:nzwidth="0x20" edc:access="-------------------------nnnnnnn" edc:por="00000000000000000000000001100000" edc:mclr="00000000000000000000000001100000" edc:impl="0x7F" edc:_addr="0x40004438">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SMB1">
            <edc:SFRFieldDef edc:cname="BBEN" edc:nzwidth="0x1" edc:desc="Bit-Bang Mode Enable. 0 - Bit Bang Mode Disabled. 1 - Bit Bang Mode Enabled"/>
            <edc:SFRFieldDef edc:cname="CLDIR" edc:nzwidth="0x1" edc:desc="Bit-Bang Clock Direction. The CLDIR bit controls the direction of SCLK. 0 - Input, 1 - Output"/>
            <edc:SFRFieldDef edc:cname="DADIR" edc:nzwidth="0x1" edc:desc="Bit-Bang Data Direction. The DADIR bit controls the direction of SDAT. 0 - Input. 1 - Output"/>
            <edc:SFRFieldDef edc:cname="BBCLK" edc:nzwidth="0x1" edc:desc="Bit-Bang Clock. The BBCLK bit controls the state of SCLK when BBEN = and CLDIR = '1'"/>
            <edc:SFRFieldDef edc:cname="BBDAT" edc:nzwidth="0x1" edc:desc="Bit-Bang Data. The BBDAT bit controls the state of SDAT when BBEN = and DADIR = '1'"/>
            <edc:SFRFieldDef edc:cname="BBCLKI" edc:nzwidth="0x1" edc:desc="Bit-Bang Clock In. The BBCLKI bit always returns the state of SCLK."/>
            <edc:SFRFieldDef edc:cname="BBDATI" edc:nzwidth="0x1" edc:desc="Bit-Bang Data In. The BBDATI bit always returns the state of SDAT"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SMB1" edc:cname="TEST" edc:nzwidth="0x8" edc:access="rrrrrrrr" edc:por="00000101" edc:mclr="00000101" edc:_addr="0x4000443C">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SMB1">
            <edc:SFRFieldDef edc:cname="TEST" edc:nzwidth="0x8" edc:desc="This register must not be written, or undesirable results may occur."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:AdjustPoint edc:offset="0x3" edc:_addr="0x4000443D"/>
      <edc:SFRDef ltx:memberofperipheral="SMB1" edc:cname="DATATM" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00001100010011010101000000000110" edc:mclr="00001100010011010101000000000110" edc:_addr="0x40004440">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SMB1">
            <edc:SFRFieldDef edc:cname="DATA_HOLD" edc:nzwidth="0x8" edc:desc="The Data Hold [7:0] timer determines the SDAT hold time following SCLK driven low."/>
            <edc:SFRFieldDef edc:cname="RESTART_SETUP" edc:nzwidth="0x8" edc:desc="The Restart Setup [7:0] timer determines the SDAT setup time from the rising edge of SCLK for a repeated START condition."/>
            <edc:SFRFieldDef edc:cname="STOP_SETUP" edc:nzwidth="0x8" edc:desc="The Stop Setup [7:0] timer determines the SDAT setup time from the rising edge of SCLK for a STOP condition."/>
            <edc:SFRFieldDef edc:cname="FIRST_START_HOLD" edc:nzwidth="0x8" edc:desc="This field determines the SCL hold time following SDA driven low during the first START bit in a transfer. It is the parameter      THD:STA in the I2C Specification for an initial START bit. Repeated START hold time is determined by the Repeated START Hold Time Register."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SMB1" edc:cname="TMOUTSC" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="01001011100111001100001011000111" edc:mclr="01001011100111001100001011000111" edc:_addr="0x40004444">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SMB1">
            <edc:SFRFieldDef edc:cname="CLK_HIGH_TIM_OUT" edc:nzwidth="0x8" edc:desc="Clock High time out period = Clock High Time-Out [7:0] x Baud_Clock_Period x 2"/>
            <edc:SFRFieldDef edc:cname="SLV_CUM_TIM_OUT" edc:nzwidth="0x8" edc:desc="Slave Cumulative Time-Out duration = Slave Cum Time-Out [7:0] x Baud_Clock_Period x 1024"/>
            <edc:SFRFieldDef edc:cname="MAST_CUM_TIM_OUT" edc:nzwidth="0x8" edc:desc="Master Cumulative Time-Out duration = Master Cum Time-Out [7:0] x Baud_Clock_Period x 512"/>
            <edc:SFRFieldDef edc:cname="BUS_IDLE_MIN" edc:nzwidth="0x8" edc:desc="Bus Idle Minimum time = Bus Idle Min [7:0] x Baud_Clock_Period"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SMB1" edc:cname="SLV_TXB" edc:nzwidth="0x20" edc:access="------------------------nnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0xFF" edc:_addr="0x40004448">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SMB1">
            <edc:SFRFieldDef edc:cname="STXB" edc:nzwidth="0x8" edc:desc="SLAVE_TRANSMIT_BUFFER"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SMB1" edc:cname="SLV_RXB" edc:nzwidth="0x20" edc:access="------------------------nnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0xFF" edc:_addr="0x4000444C">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SMB1">
            <edc:SFRFieldDef edc:cname="SRXB" edc:nzwidth="0x8" edc:desc="SLAVE_RECEIVE_BUFFER"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SMB1" edc:cname="MTR_TXB" edc:nzwidth="0x20" edc:access="------------------------nnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0xFF" edc:_addr="0x40004450">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SMB1">
            <edc:SFRFieldDef edc:cname="MTXB" edc:nzwidth="0x8" edc:desc="MASTER_TRANSMIT_BUFFER"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SMB1" edc:cname="MTR_RXB" edc:nzwidth="0x20" edc:access="------------------------nnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0xFF" edc:_addr="0x40004454">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SMB1">
            <edc:SFRFieldDef edc:cname="MRXB" edc:nzwidth="0x8" edc:desc="MASTER_RECEIVE_BUFFER"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:AdjustPoint edc:offset="0x8" edc:_addr="0x40004458"/>
      <edc:SFRDef ltx:memberofperipheral="SMB1" edc:cname="WAKE_STS" edc:nzwidth="0x20" edc:access="-------------------------------n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x1" edc:_addr="0x40004460">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SMB1">
            <edc:SFRFieldDef edc:cname="START_BIT_DET" edc:nzwidth="0x1" edc:desc="This bit is set to '1' when a START bit is detected while the controller is enabled. This bit is cleared to '0' when      written with a '1'. Writes of '0' have no effect. (R/WC)"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SMB1" edc:cname="WAKE_EN" edc:nzwidth="0x20" edc:access="-------------------------------n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x1" edc:_addr="0x40004464">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SMB1">
            <edc:SFRFieldDef edc:cname="START_DET_INT_EN" edc:nzwidth="0x1" edc:desc="Enable Start Bit Detection Interrupt. The Start Bit Detection Interrupt is wake-capable.      1=Start Bit Detection Interrupt enabled; 0=Start Bit Detection Interrupt disabled"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:AdjustPoint edc:offset="0x4" edc:_addr="0x40004468"/>
      <edc:SFRDef ltx:memberofperipheral="SMB1" edc:cname="SLV_ADDR" edc:nzwidth="0x8" edc:access="nnnnnnnn" edc:por="00000000" edc:mclr="00000000" edc:_addr="0x4000446C">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SMB1">
            <edc:SFRFieldDef edc:cname="SADDR" edc:nzwidth="0x8" edc:desc="This register stores value of address + LSB direction after the 8th clock of the Address Byte."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:AdjustPoint edc:offset="0x3" edc:_addr="0x4000446D"/>
      <edc:SFRDef ltx:memberofperipheral="SMB1" edc:cname="PRM_STS" edc:nzwidth="0x8" edc:access="-------n" edc:por="00000000" edc:mclr="00000000" edc:impl="0x1" edc:_addr="0x40004470">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SMB1">
            <edc:SFRFieldDef edc:cname="ADDR_INTR" edc:nzwidth="0x1" edc:desc="This is the Promiscuous Address Status interrupt and is set on the 8th clock of the I2C Address.         This bit will hold the Clock line low till this register bit is cleared. This is Write 1 to clear.         R/W1C."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:AdjustPoint edc:offset="0x3" edc:_addr="0x40004471"/>
      <edc:SFRDef ltx:memberofperipheral="SMB1" edc:cname="PRM_IEN" edc:nzwidth="0x8" edc:access="-------n" edc:por="00000000" edc:mclr="00000000" edc:impl="0x1" edc:_addr="0x40004474">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SMB1">
            <edc:SFRFieldDef edc:cname="ADDR" edc:nzwidth="0x1" edc:desc="This is the Promiscuous interrupt enable register.         1= Interrupt Enable.          0= Interrupt Disabled. "/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:AdjustPoint edc:offset="0x3" edc:_addr="0x40004475"/>
      <edc:SFRDef ltx:memberofperipheral="SMB1" edc:cname="PRM_CTRL" edc:nzwidth="0x8" edc:access="-------n" edc:por="00000000" edc:mclr="00000000" edc:impl="0x1" edc:_addr="0x40004478">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SMB1">
            <edc:SFRFieldDef edc:cname="ACK_NAK" edc:nzwidth="0x1" edc:desc="This is the Promiscuous ACK / NAK response register.         1= ACK.          0= NAK. "/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:AdjustPoint edc:offset="0x3" edc:_addr="0x40004479"/>
      <edc:SFRDef ltx:memberofperipheral="SMB1" edc:cname="SHDW_DATA" edc:nzwidth="0x8" edc:access="nnnnnnnn" edc:por="00000000" edc:mclr="00000000" edc:_addr="0x4000447C">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SMB1">
            <edc:SFRFieldDef edc:cname="SHDW_DATA" edc:nzwidth="0x8" edc:desc="This is the I2C Shadow Data Register"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:AdjustPoint edc:offset="0x383" edc:_addr="0x4000447D"/>
      <edc:MuxedSFRDef edc:nzwidth="0x20" edc:_addr="0x40004800">
        <edc:SelectSFR>
          <edc:SFRDef ltx:memberofperipheral="SMB2" edc:cname="WCTRL" edc:nzwidth="0x20" edc:access="------------------------ww--wwww" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0xCF" edc:_addr="0x40004800">
            <edc:SFRModeList>
              <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SMB2">
                <edc:SFRFieldDef edc:cname="ACK" edc:nzwidth="0x1" edc:desc="The Acknowledge bit (ACK) must normally be asserted ('1'). This causes the controller to send an acknowledge automatically after each byte (this occurs during the 9th clock pulse). The ACK bit must not be asserted ('0') when the controller is operating in master/receiver mode and requires no further data to be sent from the slave transmitter. This causes a negative acknowledge on the I2C bus, which halts further transmission from the slave device."/>
                <edc:SFRFieldDef edc:cname="STO" edc:nzwidth="0x1" edc:desc="See STA description"/>
                <edc:SFRFieldDef edc:cname="STA" edc:nzwidth="0x1" edc:desc="The STA and STO bits control the generation of the I2C Start condition and the transmission of the Slave Address and R/nW bit (from the Data Register), generation of repeated Start condition, and generation of the Stop condition"/>
                <edc:SFRFieldDef edc:cname="ENI" edc:nzwidth="0x1" edc:desc="Enable Interrupt bit (ENI) controls the Interrupt Interface"/>
                <edc:AdjustPoint edc:offset="0x2"/>
                <edc:SFRFieldDef edc:cname="ESO" edc:nzwidth="0x1" edc:desc="The Enable Serial Output bit (ESO) enables and disables the SMB Controller Core serial data output (SDAT)"/>
                <edc:SFRFieldDef edc:cname="PIN" edc:nzwidth="0x1" edc:desc="The Pending Interrupt Not (PIN) bit serves as a software reset function. Writing the PIN bit to a logic '1' de-asserts all status bits except for the nBB bit which is not affected by the PIN bit. The PIN bit is a self-clearing bit. Writing this bit to a logic '0' has no effect."/>
              </edc:SFRMode>
            </edc:SFRModeList>
          </edc:SFRDef>
        </edc:SelectSFR>
        <edc:SelectSFR>
          <edc:SFRDef ltx:memberofperipheral="SMB2" edc:cname="RSTS" edc:nzwidth="0x20" edc:access="------------------------rrrrrrrr" edc:por="00000000000000000000000010000001" edc:mclr="00000000000000000000000010000001" edc:impl="0xFF" edc:_addr="0x40004800">
            <edc:SFRModeList>
              <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SMB2">
                <edc:SFRFieldDef edc:cname="NBB" edc:nzwidth="0x1" edc:desc="The Bus Busy bit (NBB) is a read-only flag indicating when the bus is in use. A zero indicates that the bus is busy and access is not possible."/>
                <edc:SFRFieldDef edc:cname="LAB" edc:nzwidth="0x1" edc:desc="The Lost Arbitration Bit (LAB) is set when, in multi-master operation, arbitration is lost to another master on the bus"/>
                <edc:SFRFieldDef edc:cname="AAS" edc:nzwidth="0x1" edc:desc="The Addressed As Slave bit (AAS) is valid only when PIN is asserted ('0'). When acting as slave, AAS is set when an incoming address over the bus matches the value in the Own Address Register or if the 'general call' address (00h) has been received"/>
                <edc:SFRFieldDef edc:cname="LRB_AD0" edc:nzwidth="0x1" edc:desc="The Last Received Bit  or Address 0 (general call) bit (LRB/AD0) serves a dual function and is valid only while the PIN bit is asserted ('0').                When the AAS bit is not asserted ('0') (i.e., not addressed as a slave), the LRB/AD0 holds the value of the last received bit over the bus.                When the AAS bit is asserted ('1') (i.e., addressed as slave), the SMB Controller Core has been addressed as a slave."/>
                <edc:SFRFieldDef edc:cname="BER" edc:nzwidth="0x1" edc:desc="When Bus Error (BER) is asserted, a misplaced START or STOP condition or Bus Time-Outs have been detected."/>
                <edc:SFRFieldDef edc:cname="STS" edc:nzwidth="0x1" edc:desc="When in slave receiver mode, STS is asserted ('1') when an externally generated STOP condition is detected. Note that STS is used only in slave receiver mode."/>
                <edc:SFRFieldDef edc:cname="SAD" edc:nzwidth="0x1" edc:desc="SMBus Address Decoded (SAD)"/>
                <edc:SFRFieldDef edc:cname="PIN" edc:nzwidth="0x1" edc:desc="Pending Interrupt bit"/>
              </edc:SFRMode>
            </edc:SFRModeList>
          </edc:SFRDef>
        </edc:SelectSFR>
      </edc:MuxedSFRDef>
      <edc:SFRDef ltx:memberofperipheral="SMB2" edc:cname="OWN_ADDR" edc:nzwidth="0x20" edc:access="-----------------nnnnnnn-nnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x7F7F" edc:_addr="0x40004804">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SMB2">
            <edc:SFRFieldDef edc:cname="ADDR1" edc:nzwidth="0x7" edc:desc="The Own Address 1 bits configure one of the two addresses to which the SMB Controller Core will respond when addressed as a slave."/>
            <edc:AdjustPoint edc:offset="0x1"/>
            <edc:SFRFieldDef edc:cname="ADDR2" edc:nzwidth="0x7" edc:desc="The Own Address 2 bits configure one of the two addresses to which the SMB Controller Core will respond when addressed as a slave."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SMB2" edc:cname="I2CDATA" edc:nzwidth="0x8" edc:access="nnnnnnnn" edc:por="00000000" edc:mclr="00000000" edc:_addr="0x40004808"/>
      <edc:SFRDef ltx:memberofperipheral="SMB2" edc:cname="RSVD10" edc:nzwidth="0x8" edc:access="rrrrrrrr" edc:por="00000000" edc:mclr="00000000" edc:_addr="0x40004809"/>
      <edc:SFRDef ltx:memberofperipheral="SMB2" edc:cname="RSVD11" edc:nzwidth="0x8" edc:access="rrrrrrrr" edc:por="00000000" edc:mclr="00000000" edc:_addr="0x4000480A"/>
      <edc:SFRDef ltx:memberofperipheral="SMB2" edc:cname="RSVD12" edc:nzwidth="0x8" edc:access="rrrrrrrr" edc:por="00000000" edc:mclr="00000000" edc:_addr="0x4000480B"/>
      <edc:SFRDef ltx:memberofperipheral="SMB2" edc:cname="MCMD0" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnn--nnnnnn------nn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0xFFFF3F03" edc:_addr="0x4000480C">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SMB2">
            <edc:SFRFieldDef edc:cname="MRUN" edc:nzwidth="0x1" edc:desc="While this bit is 1, transfer bytes over SMBus. As long as WriteCount is non-zero, a byte from the Master Transmit Buffer is transmitted to the slave device and WriteCount is decremented."/>
            <edc:SFRFieldDef edc:cname="MPROCEED" edc:nzwidth="0x1" edc:desc="When this bit is 0, the Master State Machine does not transition out of the IDLE or PAUSE states. When this bit is 1, the Master State Machine immediately transitions to the WAIT-BUSBUSY and MRUN-RECEIVE states, respectively."/>
            <edc:AdjustPoint edc:offset="0x6"/>
            <edc:SFRFieldDef edc:cname="START0" edc:nzwidth="0x1" edc:desc="If this bit is 1, send a Start bit on the SMBus before the first byte of the WriteCount is sent to the SMBus transmitter."/>
            <edc:SFRFieldDef edc:cname="STARTN" edc:nzwidth="0x1" edc:desc="If this bit is 1, send a Start bit just before the last byte of the WriteCount is sent to the SMBus transmitter."/>
            <edc:SFRFieldDef edc:cname="STOP" edc:nzwidth="0x1" edc:desc="If this bit is 1, send a Stop bit after the transaction completes."/>
            <edc:SFRFieldDef edc:cname="PEC_TERM" edc:nzwidth="0x1" edc:desc="If this bit is 1, a copy of the PEC register is transmitted when WriteCount is 0. After the PEC register is read, both the PEC register and this bit are cleared to 0."/>
            <edc:SFRFieldDef edc:cname="READM" edc:nzwidth="0x1" edc:desc="If this bit is 1, then the ReadCount field is replaced by the byte that is read from the SMBus when ReadCount[7:0] is 1. After ReadCount[7:0] is updated, this bit is cleared to 0."/>
            <edc:SFRFieldDef edc:cname="READ_PEC" edc:nzwidth="0x1" edc:desc="If this bit is 0, reading from the SMBus stops when ReadCount reaches 0. If this bit is 1, reading continues when ReadCount is 0 for one more byte."/>
            <edc:AdjustPoint edc:offset="0x2"/>
            <edc:SFRFieldDef edc:cname="WR_CNT" edc:nzwidth="0x8" edc:desc="This field is a count of the number of bytes to transmit to the SMBus from the SMBus Master Transmit Buffer Register It is decremented by 1 for each byte written to the SMBus from the SMBus Master Transmit Buffer Register."/>
            <edc:SFRFieldDef edc:cname="RD_CNT" edc:nzwidth="0x8" edc:desc="This field is a count of the number of bytes to read in from the SMBus to the SMBus Master Receive Buffer Register and must be greater than 0 in order for the Master State Machine to initiate a read phase. It is decremented by 1 for each byte read from the SMBus into the SMBus Master Receive Buffer Register. It can be overwritten by the first byte read in from the SMBus."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SMB2" edc:cname="SCMD0" edc:nzwidth="0x20" edc:access="--------nnnnnnnnnnnnnnnn-----nnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0xFFFF07" edc:_addr="0x40004810">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SMB2">
            <edc:SFRFieldDef edc:cname="SRUN" edc:nzwidth="0x1" edc:desc="Setting this bit to 1 enables the Slave State Machine to operate."/>
            <edc:SFRFieldDef edc:cname="SPROCEED" edc:nzwidth="0x1" edc:desc="When this bit is 0, the Slave State Machine does not transition out of the IDLE, REPEAT_START_WRITE or REPEAT_START_READ states. When this bit is 1, the Slave State Machine immediately transitions to the START_WAIT, RECEIVE and TRANSMIT states, respectively."/>
            <edc:SFRFieldDef edc:cname="PEC" edc:nzwidth="0x1" edc:desc="If Slave_WriteCount is 0 and Slave_PEC is 1 when the Master requests data, the PEC Register is copied to the DATA register. After the PEC Register is copied to the SMBus, the PEC Register is cleared and Slave_PEC is set to 0."/>
            <edc:AdjustPoint edc:offset="0x5"/>
            <edc:SFRFieldDef edc:cname="WR_CNT" edc:nzwidth="0x8" edc:desc="This field is set to the number of bytes software expects to send to the Master."/>
            <edc:SFRFieldDef edc:cname="RD_CNT" edc:nzwidth="0x8" edc:desc="This field is decremented each time a byte is copied from DATA to the SMBus Slave Receive Buffer Register."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SMB2" edc:cname="PEC" edc:nzwidth="0x20" edc:access="------------------------nnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0xFF" edc:_addr="0x40004814">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SMB2">
            <edc:SFRFieldDef edc:cname="PEC" edc:nzwidth="0x8" edc:desc="The SMBus Packet Error Check (PEC) byte."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SMB2" edc:cname="RSHTM" edc:nzwidth="0x20" edc:access="------------------------nnnnnnnn" edc:por="00000000000000000000000001001101" edc:mclr="00000000000000000000000001001101" edc:impl="0xFF" edc:_addr="0x40004818">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SMB2">
            <edc:SFRFieldDef edc:cname="RSHTM" edc:nzwidth="0x8" edc:desc="This is the value of the timing requirement tHd:Sta in the I2C specification for a repeated START bit. This is used to hold      the clock until the Hold Time for the repeated Start Bit has been satisfied."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SMB2" edc:cname="EXTND_LEN" edc:nzwidth="0x20" edc:access="------------------------rrrrrrrr" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0xFF" edc:_addr="0x4000481C">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SMB2">
            <edc:SFRFieldDef edc:cname="EXTND_LEN" edc:nzwidth="0x8" edc:desc="Extended Length Register adds 8 MSB bits to the SMBUS Master/Slave Tx/Rx Length fields."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SMB2" edc:cname="COMPL0" edc:nzwidth="0x20" edc:access="nnn---nn--nnn-nn-nnnnnnn-nnnnn--" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0xE33B7F7C" edc:_addr="0x40004820">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SMB2">
            <edc:AdjustPoint edc:offset="0x2"/>
            <edc:SFRFieldDef edc:cname="DTEN" edc:nzwidth="0x1" edc:desc="When DTEN is asserted ('1'), Device Time-out checking is enabled. When DTEN is not asserted ('0'), Device Time-out checking is disabled."/>
            <edc:SFRFieldDef edc:cname="MCEN" edc:nzwidth="0x1" edc:desc="When MCEN is asserted ('1'), Master Cumulative Time-Out checking is enabled. When MCEN is not asserted ('0'), Master Cumulative Time-Out checking is disabled."/>
            <edc:SFRFieldDef edc:cname="SCEN" edc:nzwidth="0x1" edc:desc="When SCEN is asserted ('1'), Slave Cumulative Time-Out checking is enabled. When SCEN is not asserted ('0'), Slave Cumulative Time-Out checking is disabled."/>
            <edc:SFRFieldDef edc:cname="BIDEN" edc:nzwidth="0x1" edc:desc="When BIDEN is asserted ('1'), Bus Idle Detect Time-Out checking is enabled. When BIDEN is not asserted ('0'), Bus Idle Detect Time-Out checking is disabled."/>
            <edc:SFRFieldDef edc:cname="TIMERR" edc:nzwidth="0x1" edc:desc="The Time-out Error Detected bit (TIMERR) is asserted ('1') whenever any of the enabled time-out error detect status bits (CHDH, CHDL, SCTO, MCTO and DTO) are asserted."/>
            <edc:AdjustPoint edc:offset="0x1"/>
            <edc:SFRFieldDef edc:cname="DTO" edc:nzwidth="0x1" edc:desc="DTO is the Device Time-out bit. (R/WC)"/>
            <edc:SFRFieldDef edc:cname="MCTO" edc:nzwidth="0x1" edc:desc="MCTO is the Master Cumulative Time-out bit. (R/WC)"/>
            <edc:SFRFieldDef edc:cname="SCTO" edc:nzwidth="0x1" edc:desc="SCTO is the Slave Cumulative Time-out bit(R/WC)"/>
            <edc:SFRFieldDef edc:cname="CHDL" edc:nzwidth="0x1" edc:desc="CHDL is the clock high time-out detect bit(R/WC)"/>
            <edc:SFRFieldDef edc:cname="CHDH" edc:nzwidth="0x1" edc:desc="CHDH is the bus idle time-out detect bit(R/WC)"/>
            <edc:SFRFieldDef edc:cname="BER" edc:nzwidth="0x1" edc:desc="If this bit is 1, the BER bit in the Status register was set while either the Slave state machine or the Master state machine was not in the Idle state.(R/WC)"/>
            <edc:SFRFieldDef edc:cname="LAB" edc:nzwidth="0x1" edc:desc="If this bit is 1, the LAB bit in the Status register was set while either the Slave state machine or the Master state machine was not in the Idle state.(R/WC)"/>
            <edc:AdjustPoint edc:offset="0x1"/>
            <edc:SFRFieldDef edc:cname="SNAKR" edc:nzwidth="0x1" edc:desc="If this bit is 1, the Slave state machine sent a NACK to the transmitting Master while the Slave was receiving data from the SMBus interface."/>
            <edc:SFRFieldDef edc:cname="STR" edc:nzwidth="0x1" edc:desc="0: Slave has just finished the receive phase of a transaction.                 1: Slave has just finished the transmit phase of a transaction."/>
            <edc:AdjustPoint edc:offset="0x1"/>
            <edc:SFRFieldDef edc:cname="SPROT" edc:nzwidth="0x1" edc:desc="If this bit is 1, the WriteCount[7:0] counter in the Slave state machine either counted down to 0 before the Master sent a NACK signal, or the Slave received a NACK signal before the counter reached 0."/>
            <edc:SFRFieldDef edc:cname="REP_RD" edc:nzwidth="0x1" edc:desc="If this bit is 1, the Slave State Machine stopped because it detected a Repeat Start bit, with bit[0] of the byte containing the slave address equal to 1, indicating that the Master requested a Read operation."/>
            <edc:SFRFieldDef edc:cname="REP_WR" edc:nzwidth="0x1" edc:desc="If this bit is 1, the Slave State Machine stopped because it detected a Repeat Start bit, with bit[0] of the byte containing the slave address equal to 0, indicating that the Master requested a Write operation."/>
            <edc:AdjustPoint edc:offset="0x2"/>
            <edc:SFRFieldDef edc:cname="MNAKX" edc:nzwidth="0x1" edc:desc="If this bit is 1, the Master state machine received a NACK from the receiving Slave while the Master was transmitting data over the SMBus interface. (R/WC)"/>
            <edc:SFRFieldDef edc:cname="MTR" edc:nzwidth="0x1" edc:desc="0: Master has just finished the receive phase of a transaction.                 1: Master has just finished the transmit phase of a transaction."/>
            <edc:AdjustPoint edc:offset="0x3"/>
            <edc:SFRFieldDef edc:cname="IDLE" edc:nzwidth="0x1" edc:desc="This bit is set when the I2C bus becomes idle (on the rising edge of nBB). (R/WC)"/>
            <edc:SFRFieldDef edc:cname="MDONE" edc:nzwidth="0x1" edc:desc="If this bit is 1, Master State machine completed operation and returned to the Idle state. It is cleared when written with a 1. Writes of a 0 have no effect. (R/WC)"/>
            <edc:SFRFieldDef edc:cname="SDONE" edc:nzwidth="0x1" edc:desc="If this bit is 1, Slave State machine completed operation and returned to the Idle state. It is cleared when written with a 1. Writes of a 0 have no effect.(R/WC)"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SMB2" edc:cname="IDLSC" edc:nzwidth="0x20" edc:access="----nnnnnnnnnnnn----nnnnnnnnnnnn" edc:por="00000001111111000000000111101101" edc:mclr="00000001111111000000000111101101" edc:impl="0xFFF0FFF" edc:_addr="0x40004824">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SMB2">
            <edc:SFRFieldDef edc:cname="FAIR_BUS_IDL_MIN" edc:nzwidth="0xC" edc:desc="This field defines the number of ticks of the baud clock required to satisfy the fairness protocol. The default value for this field sets the idle window to 31us, which is the appropriate value for a 100 KHz bus"/>
            <edc:AdjustPoint edc:offset="0x4"/>
            <edc:SFRFieldDef edc:cname="FAIR_IDL_DLY" edc:nzwidth="0xC" edc:desc="This field defines the number of ticks of the baud clock required to program the delay. The default value for this field sets the delay period to 32us, which is the appropriate value for a 100 KHz bus"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SMB2" edc:cname="CFG0" edc:nzwidth="0x20" edc:access="nnnn--------nnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0xF00FFFFF" edc:_addr="0x40004828">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SMB2">
            <edc:SFRFieldDef edc:cname="PORT_SEL" edc:nzwidth="0x4" edc:desc="The PORT SEL [3:0] bits determine which one of 16 possible bus ports apply to the active 2-wire SDAT and SCLK bus pair."/>
            <edc:SFRFieldDef edc:cname="TCEN" edc:nzwidth="0x1" edc:desc="When the Timing Check Enable bit (TCEN) is asserted ('1'), Bus Time-Outs are enabled"/>
            <edc:SFRFieldDef edc:cname="SLOW_CLK" edc:nzwidth="0x1" edc:desc="When this bit is 1, the base period for the Bus Clock Register is multiplied by 4, and thus the frequency is divided by 4."/>
            <edc:SFRFieldDef edc:cname="TEST" edc:nzwidth="0x1" edc:desc="Must be always written with 0."/>
            <edc:SFRFieldDef edc:cname="PECEN" edc:nzwidth="0x1" edc:desc="When the PEC Enable bit (PECEN) is asserted ('1'), Hardware PEC Support is enabled"/>
            <edc:SFRFieldDef edc:cname="FEN" edc:nzwidth="0x1" edc:desc="Input filtering enable. Input filtering is required by the I2C specification if external filtering is not available.      1=Input filtering is enabled; 0=Input filtering is disabled."/>
            <edc:SFRFieldDef edc:cname="RST" edc:nzwidth="0x1" edc:desc="When RESET is asserted ('1'), all logic and registers except for the RESET bit itself are initialized to the power-on default state."/>
            <edc:SFRFieldDef edc:cname="EN" edc:nzwidth="0x1" edc:desc="When ENAB (Enable) is not asserted ('0') (default), the SMB Controller Core is disabled and in the lowest power consumption state (Disabled State).                The ENAB bit must be asserted ('1') for normal operation."/>
            <edc:SFRFieldDef edc:cname="DSA" edc:nzwidth="0x1" edc:desc="0: Slave Address I2C Compatibility Mode (default). 1: SMBus Address Decode Mode"/>
            <edc:SFRFieldDef edc:cname="FAIR" edc:nzwidth="0x1" edc:desc="If this bit is 1, the MCTP Fairness protocol is in effect."/>
            <edc:SFRFieldDef edc:cname="TEST0" edc:nzwidth="0x1" edc:desc="Must be always written with 0."/>
            <edc:SFRFieldDef edc:cname="GC_DIS" edc:nzwidth="0x1" edc:desc="This is the General Call Disable bit.                0: the response to the General Call address as a slave is enabled                1: the response to the General Call address as a slave is disabled."/>
            <edc:SFRFieldDef edc:cname="CFG_PROMIS" edc:nzwidth="0x1" edc:desc="This bit define the Mode of SM Bus Controler Mode of operation.         0= Normal Operation.         1=  Promiscuous Mode Enable."/>
            <edc:SFRFieldDef edc:cname="FLUSH_SXBUF" edc:nzwidth="0x1" edc:desc="A write of a 1 to this bit forces the SMBus Slave Transmit Buffer Register to be marked empty. A write of 0 has no effect. This is a self-clearing bit."/>
            <edc:SFRFieldDef edc:cname="FLUSH_SRBUF" edc:nzwidth="0x1" edc:desc="A write of a 1 to this bit forces the SMBus Slave Receive Buffer Register to be marked empty. A write of 0 has no effect. This is a self-clearing bit."/>
            <edc:SFRFieldDef edc:cname="FLUSH_MXBUF" edc:nzwidth="0x1" edc:desc="A write of a 1 to this bit forces the SMBus Master Transmit Buffer Register to be marked empty. A write of 0 has no effect. This is a self-clearing bit."/>
            <edc:SFRFieldDef edc:cname="FLUSH_MRBUF" edc:nzwidth="0x1" edc:desc="A write of a 1 to this bit forces the SMBus Master Receive Buffer Register to be marked empty. A write of 0 has no effect. This is a self-clearing bit."/>
            <edc:AdjustPoint edc:offset="0x8"/>
            <edc:SFRFieldDef edc:cname="EN_AAS" edc:nzwidth="0x1" edc:desc="0: Disable the AAS, 1: Enable the AAS Interrupt"/>
            <edc:SFRFieldDef edc:cname="ENIDI" edc:nzwidth="0x1" edc:desc="If this bit is 1, the Idle interrupt is enabled. If this bit is 0, the Idle interrupt is disabled."/>
            <edc:SFRFieldDef edc:cname="ENMI" edc:nzwidth="0x1" edc:desc="If this bit is 1, the Master Done interrupt is enabled. If this bit is 0, the Master Done interrupt is disabled."/>
            <edc:SFRFieldDef edc:cname="ENSI" edc:nzwidth="0x1" edc:desc="If this bit is 1, the Slave Done interrupt is enabled. If this bit is 0, the Slave Done interrupt is disabled"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SMB2" edc:cname="BUSCLK" edc:nzwidth="0x20" edc:access="----------------nnnnnnnnnnnnnnnn" edc:por="00000000000000000100111101001111" edc:mclr="00000000000000000100111101001111" edc:impl="0xFFFF" edc:_addr="0x4000482C">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SMB2">
            <edc:SFRFieldDef edc:cname="LOW_PER" edc:nzwidth="0x8" edc:desc="This field defines the number of I2C Baud Clock periods that make up the low phase of the I2C/SMBus bus clock."/>
            <edc:SFRFieldDef edc:cname="HIGH_PER" edc:nzwidth="0x8" edc:desc="This field defines the number of I2C Baud Clock periods that make up the high phase of the I2C/SMBus bus clock."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SMB2" edc:cname="BLKID" edc:nzwidth="0x8" edc:access="rrrrrrrr" edc:por="00010001" edc:mclr="00010001" edc:_addr="0x40004830">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SMB2">
            <edc:SFRFieldDef edc:cname="ID" edc:nzwidth="0x8" edc:desc="Block ID."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:AdjustPoint edc:offset="0x3" edc:_addr="0x40004831"/>
      <edc:SFRDef ltx:memberofperipheral="SMB2" edc:cname="BLKREV" edc:nzwidth="0x8" edc:access="rrrrrrrr" edc:por="00000000" edc:mclr="00000000" edc:_addr="0x40004834">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SMB2">
            <edc:SFRFieldDef edc:cname="REV" edc:nzwidth="0x8" edc:desc="Block Revision Number"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:AdjustPoint edc:offset="0x3" edc:_addr="0x40004835"/>
      <edc:SFRDef ltx:memberofperipheral="SMB2" edc:cname="BBCTRL" edc:nzwidth="0x20" edc:access="-------------------------nnnnnnn" edc:por="00000000000000000000000001100000" edc:mclr="00000000000000000000000001100000" edc:impl="0x7F" edc:_addr="0x40004838">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SMB2">
            <edc:SFRFieldDef edc:cname="BBEN" edc:nzwidth="0x1" edc:desc="Bit-Bang Mode Enable. 0 - Bit Bang Mode Disabled. 1 - Bit Bang Mode Enabled"/>
            <edc:SFRFieldDef edc:cname="CLDIR" edc:nzwidth="0x1" edc:desc="Bit-Bang Clock Direction. The CLDIR bit controls the direction of SCLK. 0 - Input, 1 - Output"/>
            <edc:SFRFieldDef edc:cname="DADIR" edc:nzwidth="0x1" edc:desc="Bit-Bang Data Direction. The DADIR bit controls the direction of SDAT. 0 - Input. 1 - Output"/>
            <edc:SFRFieldDef edc:cname="BBCLK" edc:nzwidth="0x1" edc:desc="Bit-Bang Clock. The BBCLK bit controls the state of SCLK when BBEN = and CLDIR = '1'"/>
            <edc:SFRFieldDef edc:cname="BBDAT" edc:nzwidth="0x1" edc:desc="Bit-Bang Data. The BBDAT bit controls the state of SDAT when BBEN = and DADIR = '1'"/>
            <edc:SFRFieldDef edc:cname="BBCLKI" edc:nzwidth="0x1" edc:desc="Bit-Bang Clock In. The BBCLKI bit always returns the state of SCLK."/>
            <edc:SFRFieldDef edc:cname="BBDATI" edc:nzwidth="0x1" edc:desc="Bit-Bang Data In. The BBDATI bit always returns the state of SDAT"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SMB2" edc:cname="TEST" edc:nzwidth="0x8" edc:access="rrrrrrrr" edc:por="00000101" edc:mclr="00000101" edc:_addr="0x4000483C">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SMB2">
            <edc:SFRFieldDef edc:cname="TEST" edc:nzwidth="0x8" edc:desc="This register must not be written, or undesirable results may occur."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:AdjustPoint edc:offset="0x3" edc:_addr="0x4000483D"/>
      <edc:SFRDef ltx:memberofperipheral="SMB2" edc:cname="DATATM" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00001100010011010101000000000110" edc:mclr="00001100010011010101000000000110" edc:_addr="0x40004840">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SMB2">
            <edc:SFRFieldDef edc:cname="DATA_HOLD" edc:nzwidth="0x8" edc:desc="The Data Hold [7:0] timer determines the SDAT hold time following SCLK driven low."/>
            <edc:SFRFieldDef edc:cname="RESTART_SETUP" edc:nzwidth="0x8" edc:desc="The Restart Setup [7:0] timer determines the SDAT setup time from the rising edge of SCLK for a repeated START condition."/>
            <edc:SFRFieldDef edc:cname="STOP_SETUP" edc:nzwidth="0x8" edc:desc="The Stop Setup [7:0] timer determines the SDAT setup time from the rising edge of SCLK for a STOP condition."/>
            <edc:SFRFieldDef edc:cname="FIRST_START_HOLD" edc:nzwidth="0x8" edc:desc="This field determines the SCL hold time following SDA driven low during the first START bit in a transfer. It is the parameter      THD:STA in the I2C Specification for an initial START bit. Repeated START hold time is determined by the Repeated START Hold Time Register."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SMB2" edc:cname="TMOUTSC" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="01001011100111001100001011000111" edc:mclr="01001011100111001100001011000111" edc:_addr="0x40004844">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SMB2">
            <edc:SFRFieldDef edc:cname="CLK_HIGH_TIM_OUT" edc:nzwidth="0x8" edc:desc="Clock High time out period = Clock High Time-Out [7:0] x Baud_Clock_Period x 2"/>
            <edc:SFRFieldDef edc:cname="SLV_CUM_TIM_OUT" edc:nzwidth="0x8" edc:desc="Slave Cumulative Time-Out duration = Slave Cum Time-Out [7:0] x Baud_Clock_Period x 1024"/>
            <edc:SFRFieldDef edc:cname="MAST_CUM_TIM_OUT" edc:nzwidth="0x8" edc:desc="Master Cumulative Time-Out duration = Master Cum Time-Out [7:0] x Baud_Clock_Period x 512"/>
            <edc:SFRFieldDef edc:cname="BUS_IDLE_MIN" edc:nzwidth="0x8" edc:desc="Bus Idle Minimum time = Bus Idle Min [7:0] x Baud_Clock_Period"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SMB2" edc:cname="SLV_TXB" edc:nzwidth="0x20" edc:access="------------------------nnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0xFF" edc:_addr="0x40004848">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SMB2">
            <edc:SFRFieldDef edc:cname="STXB" edc:nzwidth="0x8" edc:desc="SLAVE_TRANSMIT_BUFFER"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SMB2" edc:cname="SLV_RXB" edc:nzwidth="0x20" edc:access="------------------------nnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0xFF" edc:_addr="0x4000484C">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SMB2">
            <edc:SFRFieldDef edc:cname="SRXB" edc:nzwidth="0x8" edc:desc="SLAVE_RECEIVE_BUFFER"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SMB2" edc:cname="MTR_TXB" edc:nzwidth="0x20" edc:access="------------------------nnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0xFF" edc:_addr="0x40004850">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SMB2">
            <edc:SFRFieldDef edc:cname="MTXB" edc:nzwidth="0x8" edc:desc="MASTER_TRANSMIT_BUFFER"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SMB2" edc:cname="MTR_RXB" edc:nzwidth="0x20" edc:access="------------------------nnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0xFF" edc:_addr="0x40004854">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SMB2">
            <edc:SFRFieldDef edc:cname="MRXB" edc:nzwidth="0x8" edc:desc="MASTER_RECEIVE_BUFFER"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:AdjustPoint edc:offset="0x8" edc:_addr="0x40004858"/>
      <edc:SFRDef ltx:memberofperipheral="SMB2" edc:cname="WAKE_STS" edc:nzwidth="0x20" edc:access="-------------------------------n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x1" edc:_addr="0x40004860">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SMB2">
            <edc:SFRFieldDef edc:cname="START_BIT_DET" edc:nzwidth="0x1" edc:desc="This bit is set to '1' when a START bit is detected while the controller is enabled. This bit is cleared to '0' when      written with a '1'. Writes of '0' have no effect. (R/WC)"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SMB2" edc:cname="WAKE_EN" edc:nzwidth="0x20" edc:access="-------------------------------n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x1" edc:_addr="0x40004864">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SMB2">
            <edc:SFRFieldDef edc:cname="START_DET_INT_EN" edc:nzwidth="0x1" edc:desc="Enable Start Bit Detection Interrupt. The Start Bit Detection Interrupt is wake-capable.      1=Start Bit Detection Interrupt enabled; 0=Start Bit Detection Interrupt disabled"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:AdjustPoint edc:offset="0x4" edc:_addr="0x40004868"/>
      <edc:SFRDef ltx:memberofperipheral="SMB2" edc:cname="SLV_ADDR" edc:nzwidth="0x8" edc:access="nnnnnnnn" edc:por="00000000" edc:mclr="00000000" edc:_addr="0x4000486C">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SMB2">
            <edc:SFRFieldDef edc:cname="SADDR" edc:nzwidth="0x8" edc:desc="This register stores value of address + LSB direction after the 8th clock of the Address Byte."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:AdjustPoint edc:offset="0x3" edc:_addr="0x4000486D"/>
      <edc:SFRDef ltx:memberofperipheral="SMB2" edc:cname="PRM_STS" edc:nzwidth="0x8" edc:access="-------n" edc:por="00000000" edc:mclr="00000000" edc:impl="0x1" edc:_addr="0x40004870">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SMB2">
            <edc:SFRFieldDef edc:cname="ADDR_INTR" edc:nzwidth="0x1" edc:desc="This is the Promiscuous Address Status interrupt and is set on the 8th clock of the I2C Address.         This bit will hold the Clock line low till this register bit is cleared. This is Write 1 to clear.         R/W1C."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:AdjustPoint edc:offset="0x3" edc:_addr="0x40004871"/>
      <edc:SFRDef ltx:memberofperipheral="SMB2" edc:cname="PRM_IEN" edc:nzwidth="0x8" edc:access="-------n" edc:por="00000000" edc:mclr="00000000" edc:impl="0x1" edc:_addr="0x40004874">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SMB2">
            <edc:SFRFieldDef edc:cname="ADDR" edc:nzwidth="0x1" edc:desc="This is the Promiscuous interrupt enable register.         1= Interrupt Enable.          0= Interrupt Disabled. "/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:AdjustPoint edc:offset="0x3" edc:_addr="0x40004875"/>
      <edc:SFRDef ltx:memberofperipheral="SMB2" edc:cname="PRM_CTRL" edc:nzwidth="0x8" edc:access="-------n" edc:por="00000000" edc:mclr="00000000" edc:impl="0x1" edc:_addr="0x40004878">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SMB2">
            <edc:SFRFieldDef edc:cname="ACK_NAK" edc:nzwidth="0x1" edc:desc="This is the Promiscuous ACK / NAK response register.         1= ACK.          0= NAK. "/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:AdjustPoint edc:offset="0x3" edc:_addr="0x40004879"/>
      <edc:SFRDef ltx:memberofperipheral="SMB2" edc:cname="SHDW_DATA" edc:nzwidth="0x8" edc:access="nnnnnnnn" edc:por="00000000" edc:mclr="00000000" edc:_addr="0x4000487C">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SMB2">
            <edc:SFRFieldDef edc:cname="SHDW_DATA" edc:nzwidth="0x8" edc:desc="This is the I2C Shadow Data Register"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:AdjustPoint edc:offset="0x383" edc:_addr="0x4000487D"/>
      <edc:MuxedSFRDef edc:nzwidth="0x20" edc:_addr="0x40004C00">
        <edc:SelectSFR>
          <edc:SFRDef ltx:memberofperipheral="SMB3" edc:cname="WCTRL" edc:nzwidth="0x20" edc:access="------------------------ww--wwww" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0xCF" edc:_addr="0x40004C00">
            <edc:SFRModeList>
              <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SMB3">
                <edc:SFRFieldDef edc:cname="ACK" edc:nzwidth="0x1" edc:desc="The Acknowledge bit (ACK) must normally be asserted ('1'). This causes the controller to send an acknowledge automatically after each byte (this occurs during the 9th clock pulse). The ACK bit must not be asserted ('0') when the controller is operating in master/receiver mode and requires no further data to be sent from the slave transmitter. This causes a negative acknowledge on the I2C bus, which halts further transmission from the slave device."/>
                <edc:SFRFieldDef edc:cname="STO" edc:nzwidth="0x1" edc:desc="See STA description"/>
                <edc:SFRFieldDef edc:cname="STA" edc:nzwidth="0x1" edc:desc="The STA and STO bits control the generation of the I2C Start condition and the transmission of the Slave Address and R/nW bit (from the Data Register), generation of repeated Start condition, and generation of the Stop condition"/>
                <edc:SFRFieldDef edc:cname="ENI" edc:nzwidth="0x1" edc:desc="Enable Interrupt bit (ENI) controls the Interrupt Interface"/>
                <edc:AdjustPoint edc:offset="0x2"/>
                <edc:SFRFieldDef edc:cname="ESO" edc:nzwidth="0x1" edc:desc="The Enable Serial Output bit (ESO) enables and disables the SMB Controller Core serial data output (SDAT)"/>
                <edc:SFRFieldDef edc:cname="PIN" edc:nzwidth="0x1" edc:desc="The Pending Interrupt Not (PIN) bit serves as a software reset function. Writing the PIN bit to a logic '1' de-asserts all status bits except for the nBB bit which is not affected by the PIN bit. The PIN bit is a self-clearing bit. Writing this bit to a logic '0' has no effect."/>
              </edc:SFRMode>
            </edc:SFRModeList>
          </edc:SFRDef>
        </edc:SelectSFR>
        <edc:SelectSFR>
          <edc:SFRDef ltx:memberofperipheral="SMB3" edc:cname="RSTS" edc:nzwidth="0x20" edc:access="------------------------rrrrrrrr" edc:por="00000000000000000000000010000001" edc:mclr="00000000000000000000000010000001" edc:impl="0xFF" edc:_addr="0x40004C00">
            <edc:SFRModeList>
              <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SMB3">
                <edc:SFRFieldDef edc:cname="NBB" edc:nzwidth="0x1" edc:desc="The Bus Busy bit (NBB) is a read-only flag indicating when the bus is in use. A zero indicates that the bus is busy and access is not possible."/>
                <edc:SFRFieldDef edc:cname="LAB" edc:nzwidth="0x1" edc:desc="The Lost Arbitration Bit (LAB) is set when, in multi-master operation, arbitration is lost to another master on the bus"/>
                <edc:SFRFieldDef edc:cname="AAS" edc:nzwidth="0x1" edc:desc="The Addressed As Slave bit (AAS) is valid only when PIN is asserted ('0'). When acting as slave, AAS is set when an incoming address over the bus matches the value in the Own Address Register or if the 'general call' address (00h) has been received"/>
                <edc:SFRFieldDef edc:cname="LRB_AD0" edc:nzwidth="0x1" edc:desc="The Last Received Bit  or Address 0 (general call) bit (LRB/AD0) serves a dual function and is valid only while the PIN bit is asserted ('0').                When the AAS bit is not asserted ('0') (i.e., not addressed as a slave), the LRB/AD0 holds the value of the last received bit over the bus.                When the AAS bit is asserted ('1') (i.e., addressed as slave), the SMB Controller Core has been addressed as a slave."/>
                <edc:SFRFieldDef edc:cname="BER" edc:nzwidth="0x1" edc:desc="When Bus Error (BER) is asserted, a misplaced START or STOP condition or Bus Time-Outs have been detected."/>
                <edc:SFRFieldDef edc:cname="STS" edc:nzwidth="0x1" edc:desc="When in slave receiver mode, STS is asserted ('1') when an externally generated STOP condition is detected. Note that STS is used only in slave receiver mode."/>
                <edc:SFRFieldDef edc:cname="SAD" edc:nzwidth="0x1" edc:desc="SMBus Address Decoded (SAD)"/>
                <edc:SFRFieldDef edc:cname="PIN" edc:nzwidth="0x1" edc:desc="Pending Interrupt bit"/>
              </edc:SFRMode>
            </edc:SFRModeList>
          </edc:SFRDef>
        </edc:SelectSFR>
      </edc:MuxedSFRDef>
      <edc:SFRDef ltx:memberofperipheral="SMB3" edc:cname="OWN_ADDR" edc:nzwidth="0x20" edc:access="-----------------nnnnnnn-nnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x7F7F" edc:_addr="0x40004C04">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SMB3">
            <edc:SFRFieldDef edc:cname="ADDR1" edc:nzwidth="0x7" edc:desc="The Own Address 1 bits configure one of the two addresses to which the SMB Controller Core will respond when addressed as a slave."/>
            <edc:AdjustPoint edc:offset="0x1"/>
            <edc:SFRFieldDef edc:cname="ADDR2" edc:nzwidth="0x7" edc:desc="The Own Address 2 bits configure one of the two addresses to which the SMB Controller Core will respond when addressed as a slave."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SMB3" edc:cname="I2CDATA" edc:nzwidth="0x8" edc:access="nnnnnnnn" edc:por="00000000" edc:mclr="00000000" edc:_addr="0x40004C08"/>
      <edc:SFRDef ltx:memberofperipheral="SMB3" edc:cname="RSVD10" edc:nzwidth="0x8" edc:access="rrrrrrrr" edc:por="00000000" edc:mclr="00000000" edc:_addr="0x40004C09"/>
      <edc:SFRDef ltx:memberofperipheral="SMB3" edc:cname="RSVD11" edc:nzwidth="0x8" edc:access="rrrrrrrr" edc:por="00000000" edc:mclr="00000000" edc:_addr="0x40004C0A"/>
      <edc:SFRDef ltx:memberofperipheral="SMB3" edc:cname="RSVD12" edc:nzwidth="0x8" edc:access="rrrrrrrr" edc:por="00000000" edc:mclr="00000000" edc:_addr="0x40004C0B"/>
      <edc:SFRDef ltx:memberofperipheral="SMB3" edc:cname="MCMD0" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnn--nnnnnn------nn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0xFFFF3F03" edc:_addr="0x40004C0C">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SMB3">
            <edc:SFRFieldDef edc:cname="MRUN" edc:nzwidth="0x1" edc:desc="While this bit is 1, transfer bytes over SMBus. As long as WriteCount is non-zero, a byte from the Master Transmit Buffer is transmitted to the slave device and WriteCount is decremented."/>
            <edc:SFRFieldDef edc:cname="MPROCEED" edc:nzwidth="0x1" edc:desc="When this bit is 0, the Master State Machine does not transition out of the IDLE or PAUSE states. When this bit is 1, the Master State Machine immediately transitions to the WAIT-BUSBUSY and MRUN-RECEIVE states, respectively."/>
            <edc:AdjustPoint edc:offset="0x6"/>
            <edc:SFRFieldDef edc:cname="START0" edc:nzwidth="0x1" edc:desc="If this bit is 1, send a Start bit on the SMBus before the first byte of the WriteCount is sent to the SMBus transmitter."/>
            <edc:SFRFieldDef edc:cname="STARTN" edc:nzwidth="0x1" edc:desc="If this bit is 1, send a Start bit just before the last byte of the WriteCount is sent to the SMBus transmitter."/>
            <edc:SFRFieldDef edc:cname="STOP" edc:nzwidth="0x1" edc:desc="If this bit is 1, send a Stop bit after the transaction completes."/>
            <edc:SFRFieldDef edc:cname="PEC_TERM" edc:nzwidth="0x1" edc:desc="If this bit is 1, a copy of the PEC register is transmitted when WriteCount is 0. After the PEC register is read, both the PEC register and this bit are cleared to 0."/>
            <edc:SFRFieldDef edc:cname="READM" edc:nzwidth="0x1" edc:desc="If this bit is 1, then the ReadCount field is replaced by the byte that is read from the SMBus when ReadCount[7:0] is 1. After ReadCount[7:0] is updated, this bit is cleared to 0."/>
            <edc:SFRFieldDef edc:cname="READ_PEC" edc:nzwidth="0x1" edc:desc="If this bit is 0, reading from the SMBus stops when ReadCount reaches 0. If this bit is 1, reading continues when ReadCount is 0 for one more byte."/>
            <edc:AdjustPoint edc:offset="0x2"/>
            <edc:SFRFieldDef edc:cname="WR_CNT" edc:nzwidth="0x8" edc:desc="This field is a count of the number of bytes to transmit to the SMBus from the SMBus Master Transmit Buffer Register It is decremented by 1 for each byte written to the SMBus from the SMBus Master Transmit Buffer Register."/>
            <edc:SFRFieldDef edc:cname="RD_CNT" edc:nzwidth="0x8" edc:desc="This field is a count of the number of bytes to read in from the SMBus to the SMBus Master Receive Buffer Register and must be greater than 0 in order for the Master State Machine to initiate a read phase. It is decremented by 1 for each byte read from the SMBus into the SMBus Master Receive Buffer Register. It can be overwritten by the first byte read in from the SMBus."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SMB3" edc:cname="SCMD0" edc:nzwidth="0x20" edc:access="--------nnnnnnnnnnnnnnnn-----nnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0xFFFF07" edc:_addr="0x40004C10">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SMB3">
            <edc:SFRFieldDef edc:cname="SRUN" edc:nzwidth="0x1" edc:desc="Setting this bit to 1 enables the Slave State Machine to operate."/>
            <edc:SFRFieldDef edc:cname="SPROCEED" edc:nzwidth="0x1" edc:desc="When this bit is 0, the Slave State Machine does not transition out of the IDLE, REPEAT_START_WRITE or REPEAT_START_READ states. When this bit is 1, the Slave State Machine immediately transitions to the START_WAIT, RECEIVE and TRANSMIT states, respectively."/>
            <edc:SFRFieldDef edc:cname="PEC" edc:nzwidth="0x1" edc:desc="If Slave_WriteCount is 0 and Slave_PEC is 1 when the Master requests data, the PEC Register is copied to the DATA register. After the PEC Register is copied to the SMBus, the PEC Register is cleared and Slave_PEC is set to 0."/>
            <edc:AdjustPoint edc:offset="0x5"/>
            <edc:SFRFieldDef edc:cname="WR_CNT" edc:nzwidth="0x8" edc:desc="This field is set to the number of bytes software expects to send to the Master."/>
            <edc:SFRFieldDef edc:cname="RD_CNT" edc:nzwidth="0x8" edc:desc="This field is decremented each time a byte is copied from DATA to the SMBus Slave Receive Buffer Register."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SMB3" edc:cname="PEC" edc:nzwidth="0x20" edc:access="------------------------nnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0xFF" edc:_addr="0x40004C14">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SMB3">
            <edc:SFRFieldDef edc:cname="PEC" edc:nzwidth="0x8" edc:desc="The SMBus Packet Error Check (PEC) byte."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SMB3" edc:cname="RSHTM" edc:nzwidth="0x20" edc:access="------------------------nnnnnnnn" edc:por="00000000000000000000000001001101" edc:mclr="00000000000000000000000001001101" edc:impl="0xFF" edc:_addr="0x40004C18">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SMB3">
            <edc:SFRFieldDef edc:cname="RSHTM" edc:nzwidth="0x8" edc:desc="This is the value of the timing requirement tHd:Sta in the I2C specification for a repeated START bit. This is used to hold      the clock until the Hold Time for the repeated Start Bit has been satisfied."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SMB3" edc:cname="EXTND_LEN" edc:nzwidth="0x20" edc:access="------------------------rrrrrrrr" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0xFF" edc:_addr="0x40004C1C">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SMB3">
            <edc:SFRFieldDef edc:cname="EXTND_LEN" edc:nzwidth="0x8" edc:desc="Extended Length Register adds 8 MSB bits to the SMBUS Master/Slave Tx/Rx Length fields."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SMB3" edc:cname="COMPL0" edc:nzwidth="0x20" edc:access="nnn---nn--nnn-nn-nnnnnnn-nnnnn--" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0xE33B7F7C" edc:_addr="0x40004C20">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SMB3">
            <edc:AdjustPoint edc:offset="0x2"/>
            <edc:SFRFieldDef edc:cname="DTEN" edc:nzwidth="0x1" edc:desc="When DTEN is asserted ('1'), Device Time-out checking is enabled. When DTEN is not asserted ('0'), Device Time-out checking is disabled."/>
            <edc:SFRFieldDef edc:cname="MCEN" edc:nzwidth="0x1" edc:desc="When MCEN is asserted ('1'), Master Cumulative Time-Out checking is enabled. When MCEN is not asserted ('0'), Master Cumulative Time-Out checking is disabled."/>
            <edc:SFRFieldDef edc:cname="SCEN" edc:nzwidth="0x1" edc:desc="When SCEN is asserted ('1'), Slave Cumulative Time-Out checking is enabled. When SCEN is not asserted ('0'), Slave Cumulative Time-Out checking is disabled."/>
            <edc:SFRFieldDef edc:cname="BIDEN" edc:nzwidth="0x1" edc:desc="When BIDEN is asserted ('1'), Bus Idle Detect Time-Out checking is enabled. When BIDEN is not asserted ('0'), Bus Idle Detect Time-Out checking is disabled."/>
            <edc:SFRFieldDef edc:cname="TIMERR" edc:nzwidth="0x1" edc:desc="The Time-out Error Detected bit (TIMERR) is asserted ('1') whenever any of the enabled time-out error detect status bits (CHDH, CHDL, SCTO, MCTO and DTO) are asserted."/>
            <edc:AdjustPoint edc:offset="0x1"/>
            <edc:SFRFieldDef edc:cname="DTO" edc:nzwidth="0x1" edc:desc="DTO is the Device Time-out bit. (R/WC)"/>
            <edc:SFRFieldDef edc:cname="MCTO" edc:nzwidth="0x1" edc:desc="MCTO is the Master Cumulative Time-out bit. (R/WC)"/>
            <edc:SFRFieldDef edc:cname="SCTO" edc:nzwidth="0x1" edc:desc="SCTO is the Slave Cumulative Time-out bit(R/WC)"/>
            <edc:SFRFieldDef edc:cname="CHDL" edc:nzwidth="0x1" edc:desc="CHDL is the clock high time-out detect bit(R/WC)"/>
            <edc:SFRFieldDef edc:cname="CHDH" edc:nzwidth="0x1" edc:desc="CHDH is the bus idle time-out detect bit(R/WC)"/>
            <edc:SFRFieldDef edc:cname="BER" edc:nzwidth="0x1" edc:desc="If this bit is 1, the BER bit in the Status register was set while either the Slave state machine or the Master state machine was not in the Idle state.(R/WC)"/>
            <edc:SFRFieldDef edc:cname="LAB" edc:nzwidth="0x1" edc:desc="If this bit is 1, the LAB bit in the Status register was set while either the Slave state machine or the Master state machine was not in the Idle state.(R/WC)"/>
            <edc:AdjustPoint edc:offset="0x1"/>
            <edc:SFRFieldDef edc:cname="SNAKR" edc:nzwidth="0x1" edc:desc="If this bit is 1, the Slave state machine sent a NACK to the transmitting Master while the Slave was receiving data from the SMBus interface."/>
            <edc:SFRFieldDef edc:cname="STR" edc:nzwidth="0x1" edc:desc="0: Slave has just finished the receive phase of a transaction.                 1: Slave has just finished the transmit phase of a transaction."/>
            <edc:AdjustPoint edc:offset="0x1"/>
            <edc:SFRFieldDef edc:cname="SPROT" edc:nzwidth="0x1" edc:desc="If this bit is 1, the WriteCount[7:0] counter in the Slave state machine either counted down to 0 before the Master sent a NACK signal, or the Slave received a NACK signal before the counter reached 0."/>
            <edc:SFRFieldDef edc:cname="REP_RD" edc:nzwidth="0x1" edc:desc="If this bit is 1, the Slave State Machine stopped because it detected a Repeat Start bit, with bit[0] of the byte containing the slave address equal to 1, indicating that the Master requested a Read operation."/>
            <edc:SFRFieldDef edc:cname="REP_WR" edc:nzwidth="0x1" edc:desc="If this bit is 1, the Slave State Machine stopped because it detected a Repeat Start bit, with bit[0] of the byte containing the slave address equal to 0, indicating that the Master requested a Write operation."/>
            <edc:AdjustPoint edc:offset="0x2"/>
            <edc:SFRFieldDef edc:cname="MNAKX" edc:nzwidth="0x1" edc:desc="If this bit is 1, the Master state machine received a NACK from the receiving Slave while the Master was transmitting data over the SMBus interface. (R/WC)"/>
            <edc:SFRFieldDef edc:cname="MTR" edc:nzwidth="0x1" edc:desc="0: Master has just finished the receive phase of a transaction.                 1: Master has just finished the transmit phase of a transaction."/>
            <edc:AdjustPoint edc:offset="0x3"/>
            <edc:SFRFieldDef edc:cname="IDLE" edc:nzwidth="0x1" edc:desc="This bit is set when the I2C bus becomes idle (on the rising edge of nBB). (R/WC)"/>
            <edc:SFRFieldDef edc:cname="MDONE" edc:nzwidth="0x1" edc:desc="If this bit is 1, Master State machine completed operation and returned to the Idle state. It is cleared when written with a 1. Writes of a 0 have no effect. (R/WC)"/>
            <edc:SFRFieldDef edc:cname="SDONE" edc:nzwidth="0x1" edc:desc="If this bit is 1, Slave State machine completed operation and returned to the Idle state. It is cleared when written with a 1. Writes of a 0 have no effect.(R/WC)"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SMB3" edc:cname="IDLSC" edc:nzwidth="0x20" edc:access="----nnnnnnnnnnnn----nnnnnnnnnnnn" edc:por="00000001111111000000000111101101" edc:mclr="00000001111111000000000111101101" edc:impl="0xFFF0FFF" edc:_addr="0x40004C24">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SMB3">
            <edc:SFRFieldDef edc:cname="FAIR_BUS_IDL_MIN" edc:nzwidth="0xC" edc:desc="This field defines the number of ticks of the baud clock required to satisfy the fairness protocol. The default value for this field sets the idle window to 31us, which is the appropriate value for a 100 KHz bus"/>
            <edc:AdjustPoint edc:offset="0x4"/>
            <edc:SFRFieldDef edc:cname="FAIR_IDL_DLY" edc:nzwidth="0xC" edc:desc="This field defines the number of ticks of the baud clock required to program the delay. The default value for this field sets the delay period to 32us, which is the appropriate value for a 100 KHz bus"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SMB3" edc:cname="CFG0" edc:nzwidth="0x20" edc:access="nnnn--------nnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0xF00FFFFF" edc:_addr="0x40004C28">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SMB3">
            <edc:SFRFieldDef edc:cname="PORT_SEL" edc:nzwidth="0x4" edc:desc="The PORT SEL [3:0] bits determine which one of 16 possible bus ports apply to the active 2-wire SDAT and SCLK bus pair."/>
            <edc:SFRFieldDef edc:cname="TCEN" edc:nzwidth="0x1" edc:desc="When the Timing Check Enable bit (TCEN) is asserted ('1'), Bus Time-Outs are enabled"/>
            <edc:SFRFieldDef edc:cname="SLOW_CLK" edc:nzwidth="0x1" edc:desc="When this bit is 1, the base period for the Bus Clock Register is multiplied by 4, and thus the frequency is divided by 4."/>
            <edc:SFRFieldDef edc:cname="TEST" edc:nzwidth="0x1" edc:desc="Must be always written with 0."/>
            <edc:SFRFieldDef edc:cname="PECEN" edc:nzwidth="0x1" edc:desc="When the PEC Enable bit (PECEN) is asserted ('1'), Hardware PEC Support is enabled"/>
            <edc:SFRFieldDef edc:cname="FEN" edc:nzwidth="0x1" edc:desc="Input filtering enable. Input filtering is required by the I2C specification if external filtering is not available.      1=Input filtering is enabled; 0=Input filtering is disabled."/>
            <edc:SFRFieldDef edc:cname="RST" edc:nzwidth="0x1" edc:desc="When RESET is asserted ('1'), all logic and registers except for the RESET bit itself are initialized to the power-on default state."/>
            <edc:SFRFieldDef edc:cname="EN" edc:nzwidth="0x1" edc:desc="When ENAB (Enable) is not asserted ('0') (default), the SMB Controller Core is disabled and in the lowest power consumption state (Disabled State).                The ENAB bit must be asserted ('1') for normal operation."/>
            <edc:SFRFieldDef edc:cname="DSA" edc:nzwidth="0x1" edc:desc="0: Slave Address I2C Compatibility Mode (default). 1: SMBus Address Decode Mode"/>
            <edc:SFRFieldDef edc:cname="FAIR" edc:nzwidth="0x1" edc:desc="If this bit is 1, the MCTP Fairness protocol is in effect."/>
            <edc:SFRFieldDef edc:cname="TEST0" edc:nzwidth="0x1" edc:desc="Must be always written with 0."/>
            <edc:SFRFieldDef edc:cname="GC_DIS" edc:nzwidth="0x1" edc:desc="This is the General Call Disable bit.                0: the response to the General Call address as a slave is enabled                1: the response to the General Call address as a slave is disabled."/>
            <edc:SFRFieldDef edc:cname="CFG_PROMIS" edc:nzwidth="0x1" edc:desc="This bit define the Mode of SM Bus Controler Mode of operation.         0= Normal Operation.         1=  Promiscuous Mode Enable."/>
            <edc:SFRFieldDef edc:cname="FLUSH_SXBUF" edc:nzwidth="0x1" edc:desc="A write of a 1 to this bit forces the SMBus Slave Transmit Buffer Register to be marked empty. A write of 0 has no effect. This is a self-clearing bit."/>
            <edc:SFRFieldDef edc:cname="FLUSH_SRBUF" edc:nzwidth="0x1" edc:desc="A write of a 1 to this bit forces the SMBus Slave Receive Buffer Register to be marked empty. A write of 0 has no effect. This is a self-clearing bit."/>
            <edc:SFRFieldDef edc:cname="FLUSH_MXBUF" edc:nzwidth="0x1" edc:desc="A write of a 1 to this bit forces the SMBus Master Transmit Buffer Register to be marked empty. A write of 0 has no effect. This is a self-clearing bit."/>
            <edc:SFRFieldDef edc:cname="FLUSH_MRBUF" edc:nzwidth="0x1" edc:desc="A write of a 1 to this bit forces the SMBus Master Receive Buffer Register to be marked empty. A write of 0 has no effect. This is a self-clearing bit."/>
            <edc:AdjustPoint edc:offset="0x8"/>
            <edc:SFRFieldDef edc:cname="EN_AAS" edc:nzwidth="0x1" edc:desc="0: Disable the AAS, 1: Enable the AAS Interrupt"/>
            <edc:SFRFieldDef edc:cname="ENIDI" edc:nzwidth="0x1" edc:desc="If this bit is 1, the Idle interrupt is enabled. If this bit is 0, the Idle interrupt is disabled."/>
            <edc:SFRFieldDef edc:cname="ENMI" edc:nzwidth="0x1" edc:desc="If this bit is 1, the Master Done interrupt is enabled. If this bit is 0, the Master Done interrupt is disabled."/>
            <edc:SFRFieldDef edc:cname="ENSI" edc:nzwidth="0x1" edc:desc="If this bit is 1, the Slave Done interrupt is enabled. If this bit is 0, the Slave Done interrupt is disabled"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SMB3" edc:cname="BUSCLK" edc:nzwidth="0x20" edc:access="----------------nnnnnnnnnnnnnnnn" edc:por="00000000000000000100111101001111" edc:mclr="00000000000000000100111101001111" edc:impl="0xFFFF" edc:_addr="0x40004C2C">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SMB3">
            <edc:SFRFieldDef edc:cname="LOW_PER" edc:nzwidth="0x8" edc:desc="This field defines the number of I2C Baud Clock periods that make up the low phase of the I2C/SMBus bus clock."/>
            <edc:SFRFieldDef edc:cname="HIGH_PER" edc:nzwidth="0x8" edc:desc="This field defines the number of I2C Baud Clock periods that make up the high phase of the I2C/SMBus bus clock."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SMB3" edc:cname="BLKID" edc:nzwidth="0x8" edc:access="rrrrrrrr" edc:por="00010001" edc:mclr="00010001" edc:_addr="0x40004C30">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SMB3">
            <edc:SFRFieldDef edc:cname="ID" edc:nzwidth="0x8" edc:desc="Block ID."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:AdjustPoint edc:offset="0x3" edc:_addr="0x40004C31"/>
      <edc:SFRDef ltx:memberofperipheral="SMB3" edc:cname="BLKREV" edc:nzwidth="0x8" edc:access="rrrrrrrr" edc:por="00000000" edc:mclr="00000000" edc:_addr="0x40004C34">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SMB3">
            <edc:SFRFieldDef edc:cname="REV" edc:nzwidth="0x8" edc:desc="Block Revision Number"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:AdjustPoint edc:offset="0x3" edc:_addr="0x40004C35"/>
      <edc:SFRDef ltx:memberofperipheral="SMB3" edc:cname="BBCTRL" edc:nzwidth="0x20" edc:access="-------------------------nnnnnnn" edc:por="00000000000000000000000001100000" edc:mclr="00000000000000000000000001100000" edc:impl="0x7F" edc:_addr="0x40004C38">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SMB3">
            <edc:SFRFieldDef edc:cname="BBEN" edc:nzwidth="0x1" edc:desc="Bit-Bang Mode Enable. 0 - Bit Bang Mode Disabled. 1 - Bit Bang Mode Enabled"/>
            <edc:SFRFieldDef edc:cname="CLDIR" edc:nzwidth="0x1" edc:desc="Bit-Bang Clock Direction. The CLDIR bit controls the direction of SCLK. 0 - Input, 1 - Output"/>
            <edc:SFRFieldDef edc:cname="DADIR" edc:nzwidth="0x1" edc:desc="Bit-Bang Data Direction. The DADIR bit controls the direction of SDAT. 0 - Input. 1 - Output"/>
            <edc:SFRFieldDef edc:cname="BBCLK" edc:nzwidth="0x1" edc:desc="Bit-Bang Clock. The BBCLK bit controls the state of SCLK when BBEN = and CLDIR = '1'"/>
            <edc:SFRFieldDef edc:cname="BBDAT" edc:nzwidth="0x1" edc:desc="Bit-Bang Data. The BBDAT bit controls the state of SDAT when BBEN = and DADIR = '1'"/>
            <edc:SFRFieldDef edc:cname="BBCLKI" edc:nzwidth="0x1" edc:desc="Bit-Bang Clock In. The BBCLKI bit always returns the state of SCLK."/>
            <edc:SFRFieldDef edc:cname="BBDATI" edc:nzwidth="0x1" edc:desc="Bit-Bang Data In. The BBDATI bit always returns the state of SDAT"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SMB3" edc:cname="TEST" edc:nzwidth="0x8" edc:access="rrrrrrrr" edc:por="00000101" edc:mclr="00000101" edc:_addr="0x40004C3C">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SMB3">
            <edc:SFRFieldDef edc:cname="TEST" edc:nzwidth="0x8" edc:desc="This register must not be written, or undesirable results may occur."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:AdjustPoint edc:offset="0x3" edc:_addr="0x40004C3D"/>
      <edc:SFRDef ltx:memberofperipheral="SMB3" edc:cname="DATATM" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00001100010011010101000000000110" edc:mclr="00001100010011010101000000000110" edc:_addr="0x40004C40">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SMB3">
            <edc:SFRFieldDef edc:cname="DATA_HOLD" edc:nzwidth="0x8" edc:desc="The Data Hold [7:0] timer determines the SDAT hold time following SCLK driven low."/>
            <edc:SFRFieldDef edc:cname="RESTART_SETUP" edc:nzwidth="0x8" edc:desc="The Restart Setup [7:0] timer determines the SDAT setup time from the rising edge of SCLK for a repeated START condition."/>
            <edc:SFRFieldDef edc:cname="STOP_SETUP" edc:nzwidth="0x8" edc:desc="The Stop Setup [7:0] timer determines the SDAT setup time from the rising edge of SCLK for a STOP condition."/>
            <edc:SFRFieldDef edc:cname="FIRST_START_HOLD" edc:nzwidth="0x8" edc:desc="This field determines the SCL hold time following SDA driven low during the first START bit in a transfer. It is the parameter      THD:STA in the I2C Specification for an initial START bit. Repeated START hold time is determined by the Repeated START Hold Time Register."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SMB3" edc:cname="TMOUTSC" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="01001011100111001100001011000111" edc:mclr="01001011100111001100001011000111" edc:_addr="0x40004C44">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SMB3">
            <edc:SFRFieldDef edc:cname="CLK_HIGH_TIM_OUT" edc:nzwidth="0x8" edc:desc="Clock High time out period = Clock High Time-Out [7:0] x Baud_Clock_Period x 2"/>
            <edc:SFRFieldDef edc:cname="SLV_CUM_TIM_OUT" edc:nzwidth="0x8" edc:desc="Slave Cumulative Time-Out duration = Slave Cum Time-Out [7:0] x Baud_Clock_Period x 1024"/>
            <edc:SFRFieldDef edc:cname="MAST_CUM_TIM_OUT" edc:nzwidth="0x8" edc:desc="Master Cumulative Time-Out duration = Master Cum Time-Out [7:0] x Baud_Clock_Period x 512"/>
            <edc:SFRFieldDef edc:cname="BUS_IDLE_MIN" edc:nzwidth="0x8" edc:desc="Bus Idle Minimum time = Bus Idle Min [7:0] x Baud_Clock_Period"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SMB3" edc:cname="SLV_TXB" edc:nzwidth="0x20" edc:access="------------------------nnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0xFF" edc:_addr="0x40004C48">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SMB3">
            <edc:SFRFieldDef edc:cname="STXB" edc:nzwidth="0x8" edc:desc="SLAVE_TRANSMIT_BUFFER"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SMB3" edc:cname="SLV_RXB" edc:nzwidth="0x20" edc:access="------------------------nnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0xFF" edc:_addr="0x40004C4C">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SMB3">
            <edc:SFRFieldDef edc:cname="SRXB" edc:nzwidth="0x8" edc:desc="SLAVE_RECEIVE_BUFFER"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SMB3" edc:cname="MTR_TXB" edc:nzwidth="0x20" edc:access="------------------------nnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0xFF" edc:_addr="0x40004C50">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SMB3">
            <edc:SFRFieldDef edc:cname="MTXB" edc:nzwidth="0x8" edc:desc="MASTER_TRANSMIT_BUFFER"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SMB3" edc:cname="MTR_RXB" edc:nzwidth="0x20" edc:access="------------------------nnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0xFF" edc:_addr="0x40004C54">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SMB3">
            <edc:SFRFieldDef edc:cname="MRXB" edc:nzwidth="0x8" edc:desc="MASTER_RECEIVE_BUFFER"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:AdjustPoint edc:offset="0x8" edc:_addr="0x40004C58"/>
      <edc:SFRDef ltx:memberofperipheral="SMB3" edc:cname="WAKE_STS" edc:nzwidth="0x20" edc:access="-------------------------------n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x1" edc:_addr="0x40004C60">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SMB3">
            <edc:SFRFieldDef edc:cname="START_BIT_DET" edc:nzwidth="0x1" edc:desc="This bit is set to '1' when a START bit is detected while the controller is enabled. This bit is cleared to '0' when      written with a '1'. Writes of '0' have no effect. (R/WC)"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SMB3" edc:cname="WAKE_EN" edc:nzwidth="0x20" edc:access="-------------------------------n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x1" edc:_addr="0x40004C64">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SMB3">
            <edc:SFRFieldDef edc:cname="START_DET_INT_EN" edc:nzwidth="0x1" edc:desc="Enable Start Bit Detection Interrupt. The Start Bit Detection Interrupt is wake-capable.      1=Start Bit Detection Interrupt enabled; 0=Start Bit Detection Interrupt disabled"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:AdjustPoint edc:offset="0x4" edc:_addr="0x40004C68"/>
      <edc:SFRDef ltx:memberofperipheral="SMB3" edc:cname="SLV_ADDR" edc:nzwidth="0x8" edc:access="nnnnnnnn" edc:por="00000000" edc:mclr="00000000" edc:_addr="0x40004C6C">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SMB3">
            <edc:SFRFieldDef edc:cname="SADDR" edc:nzwidth="0x8" edc:desc="This register stores value of address + LSB direction after the 8th clock of the Address Byte."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:AdjustPoint edc:offset="0x3" edc:_addr="0x40004C6D"/>
      <edc:SFRDef ltx:memberofperipheral="SMB3" edc:cname="PRM_STS" edc:nzwidth="0x8" edc:access="-------n" edc:por="00000000" edc:mclr="00000000" edc:impl="0x1" edc:_addr="0x40004C70">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SMB3">
            <edc:SFRFieldDef edc:cname="ADDR_INTR" edc:nzwidth="0x1" edc:desc="This is the Promiscuous Address Status interrupt and is set on the 8th clock of the I2C Address.         This bit will hold the Clock line low till this register bit is cleared. This is Write 1 to clear.         R/W1C."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:AdjustPoint edc:offset="0x3" edc:_addr="0x40004C71"/>
      <edc:SFRDef ltx:memberofperipheral="SMB3" edc:cname="PRM_IEN" edc:nzwidth="0x8" edc:access="-------n" edc:por="00000000" edc:mclr="00000000" edc:impl="0x1" edc:_addr="0x40004C74">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SMB3">
            <edc:SFRFieldDef edc:cname="ADDR" edc:nzwidth="0x1" edc:desc="This is the Promiscuous interrupt enable register.         1= Interrupt Enable.          0= Interrupt Disabled. "/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:AdjustPoint edc:offset="0x3" edc:_addr="0x40004C75"/>
      <edc:SFRDef ltx:memberofperipheral="SMB3" edc:cname="PRM_CTRL" edc:nzwidth="0x8" edc:access="-------n" edc:por="00000000" edc:mclr="00000000" edc:impl="0x1" edc:_addr="0x40004C78">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SMB3">
            <edc:SFRFieldDef edc:cname="ACK_NAK" edc:nzwidth="0x1" edc:desc="This is the Promiscuous ACK / NAK response register.         1= ACK.          0= NAK. "/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:AdjustPoint edc:offset="0x3" edc:_addr="0x40004C79"/>
      <edc:SFRDef ltx:memberofperipheral="SMB3" edc:cname="SHDW_DATA" edc:nzwidth="0x8" edc:access="nnnnnnnn" edc:por="00000000" edc:mclr="00000000" edc:_addr="0x40004C7C">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SMB3">
            <edc:SFRFieldDef edc:cname="SHDW_DATA" edc:nzwidth="0x8" edc:desc="This is the I2C Shadow Data Register"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:AdjustPoint edc:offset="0x383" edc:_addr="0x40004C7D"/>
      <edc:MuxedSFRDef edc:nzwidth="0x20" edc:_addr="0x40005000">
        <edc:SelectSFR>
          <edc:SFRDef ltx:memberofperipheral="SMB4" edc:cname="WCTRL" edc:nzwidth="0x20" edc:access="------------------------ww--wwww" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0xCF" edc:_addr="0x40005000">
            <edc:SFRModeList>
              <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SMB4">
                <edc:SFRFieldDef edc:cname="ACK" edc:nzwidth="0x1" edc:desc="The Acknowledge bit (ACK) must normally be asserted ('1'). This causes the controller to send an acknowledge automatically after each byte (this occurs during the 9th clock pulse). The ACK bit must not be asserted ('0') when the controller is operating in master/receiver mode and requires no further data to be sent from the slave transmitter. This causes a negative acknowledge on the I2C bus, which halts further transmission from the slave device."/>
                <edc:SFRFieldDef edc:cname="STO" edc:nzwidth="0x1" edc:desc="See STA description"/>
                <edc:SFRFieldDef edc:cname="STA" edc:nzwidth="0x1" edc:desc="The STA and STO bits control the generation of the I2C Start condition and the transmission of the Slave Address and R/nW bit (from the Data Register), generation of repeated Start condition, and generation of the Stop condition"/>
                <edc:SFRFieldDef edc:cname="ENI" edc:nzwidth="0x1" edc:desc="Enable Interrupt bit (ENI) controls the Interrupt Interface"/>
                <edc:AdjustPoint edc:offset="0x2"/>
                <edc:SFRFieldDef edc:cname="ESO" edc:nzwidth="0x1" edc:desc="The Enable Serial Output bit (ESO) enables and disables the SMB Controller Core serial data output (SDAT)"/>
                <edc:SFRFieldDef edc:cname="PIN" edc:nzwidth="0x1" edc:desc="The Pending Interrupt Not (PIN) bit serves as a software reset function. Writing the PIN bit to a logic '1' de-asserts all status bits except for the nBB bit which is not affected by the PIN bit. The PIN bit is a self-clearing bit. Writing this bit to a logic '0' has no effect."/>
              </edc:SFRMode>
            </edc:SFRModeList>
          </edc:SFRDef>
        </edc:SelectSFR>
        <edc:SelectSFR>
          <edc:SFRDef ltx:memberofperipheral="SMB4" edc:cname="RSTS" edc:nzwidth="0x20" edc:access="------------------------rrrrrrrr" edc:por="00000000000000000000000010000001" edc:mclr="00000000000000000000000010000001" edc:impl="0xFF" edc:_addr="0x40005000">
            <edc:SFRModeList>
              <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SMB4">
                <edc:SFRFieldDef edc:cname="NBB" edc:nzwidth="0x1" edc:desc="The Bus Busy bit (NBB) is a read-only flag indicating when the bus is in use. A zero indicates that the bus is busy and access is not possible."/>
                <edc:SFRFieldDef edc:cname="LAB" edc:nzwidth="0x1" edc:desc="The Lost Arbitration Bit (LAB) is set when, in multi-master operation, arbitration is lost to another master on the bus"/>
                <edc:SFRFieldDef edc:cname="AAS" edc:nzwidth="0x1" edc:desc="The Addressed As Slave bit (AAS) is valid only when PIN is asserted ('0'). When acting as slave, AAS is set when an incoming address over the bus matches the value in the Own Address Register or if the 'general call' address (00h) has been received"/>
                <edc:SFRFieldDef edc:cname="LRB_AD0" edc:nzwidth="0x1" edc:desc="The Last Received Bit  or Address 0 (general call) bit (LRB/AD0) serves a dual function and is valid only while the PIN bit is asserted ('0').                When the AAS bit is not asserted ('0') (i.e., not addressed as a slave), the LRB/AD0 holds the value of the last received bit over the bus.                When the AAS bit is asserted ('1') (i.e., addressed as slave), the SMB Controller Core has been addressed as a slave."/>
                <edc:SFRFieldDef edc:cname="BER" edc:nzwidth="0x1" edc:desc="When Bus Error (BER) is asserted, a misplaced START or STOP condition or Bus Time-Outs have been detected."/>
                <edc:SFRFieldDef edc:cname="STS" edc:nzwidth="0x1" edc:desc="When in slave receiver mode, STS is asserted ('1') when an externally generated STOP condition is detected. Note that STS is used only in slave receiver mode."/>
                <edc:SFRFieldDef edc:cname="SAD" edc:nzwidth="0x1" edc:desc="SMBus Address Decoded (SAD)"/>
                <edc:SFRFieldDef edc:cname="PIN" edc:nzwidth="0x1" edc:desc="Pending Interrupt bit"/>
              </edc:SFRMode>
            </edc:SFRModeList>
          </edc:SFRDef>
        </edc:SelectSFR>
      </edc:MuxedSFRDef>
      <edc:SFRDef ltx:memberofperipheral="SMB4" edc:cname="OWN_ADDR" edc:nzwidth="0x20" edc:access="-----------------nnnnnnn-nnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x7F7F" edc:_addr="0x40005004">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SMB4">
            <edc:SFRFieldDef edc:cname="ADDR1" edc:nzwidth="0x7" edc:desc="The Own Address 1 bits configure one of the two addresses to which the SMB Controller Core will respond when addressed as a slave."/>
            <edc:AdjustPoint edc:offset="0x1"/>
            <edc:SFRFieldDef edc:cname="ADDR2" edc:nzwidth="0x7" edc:desc="The Own Address 2 bits configure one of the two addresses to which the SMB Controller Core will respond when addressed as a slave."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SMB4" edc:cname="I2CDATA" edc:nzwidth="0x8" edc:access="nnnnnnnn" edc:por="00000000" edc:mclr="00000000" edc:_addr="0x40005008"/>
      <edc:SFRDef ltx:memberofperipheral="SMB4" edc:cname="RSVD10" edc:nzwidth="0x8" edc:access="rrrrrrrr" edc:por="00000000" edc:mclr="00000000" edc:_addr="0x40005009"/>
      <edc:SFRDef ltx:memberofperipheral="SMB4" edc:cname="RSVD11" edc:nzwidth="0x8" edc:access="rrrrrrrr" edc:por="00000000" edc:mclr="00000000" edc:_addr="0x4000500A"/>
      <edc:SFRDef ltx:memberofperipheral="SMB4" edc:cname="RSVD12" edc:nzwidth="0x8" edc:access="rrrrrrrr" edc:por="00000000" edc:mclr="00000000" edc:_addr="0x4000500B"/>
      <edc:SFRDef ltx:memberofperipheral="SMB4" edc:cname="MCMD0" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnn--nnnnnn------nn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0xFFFF3F03" edc:_addr="0x4000500C">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SMB4">
            <edc:SFRFieldDef edc:cname="MRUN" edc:nzwidth="0x1" edc:desc="While this bit is 1, transfer bytes over SMBus. As long as WriteCount is non-zero, a byte from the Master Transmit Buffer is transmitted to the slave device and WriteCount is decremented."/>
            <edc:SFRFieldDef edc:cname="MPROCEED" edc:nzwidth="0x1" edc:desc="When this bit is 0, the Master State Machine does not transition out of the IDLE or PAUSE states. When this bit is 1, the Master State Machine immediately transitions to the WAIT-BUSBUSY and MRUN-RECEIVE states, respectively."/>
            <edc:AdjustPoint edc:offset="0x6"/>
            <edc:SFRFieldDef edc:cname="START0" edc:nzwidth="0x1" edc:desc="If this bit is 1, send a Start bit on the SMBus before the first byte of the WriteCount is sent to the SMBus transmitter."/>
            <edc:SFRFieldDef edc:cname="STARTN" edc:nzwidth="0x1" edc:desc="If this bit is 1, send a Start bit just before the last byte of the WriteCount is sent to the SMBus transmitter."/>
            <edc:SFRFieldDef edc:cname="STOP" edc:nzwidth="0x1" edc:desc="If this bit is 1, send a Stop bit after the transaction completes."/>
            <edc:SFRFieldDef edc:cname="PEC_TERM" edc:nzwidth="0x1" edc:desc="If this bit is 1, a copy of the PEC register is transmitted when WriteCount is 0. After the PEC register is read, both the PEC register and this bit are cleared to 0."/>
            <edc:SFRFieldDef edc:cname="READM" edc:nzwidth="0x1" edc:desc="If this bit is 1, then the ReadCount field is replaced by the byte that is read from the SMBus when ReadCount[7:0] is 1. After ReadCount[7:0] is updated, this bit is cleared to 0."/>
            <edc:SFRFieldDef edc:cname="READ_PEC" edc:nzwidth="0x1" edc:desc="If this bit is 0, reading from the SMBus stops when ReadCount reaches 0. If this bit is 1, reading continues when ReadCount is 0 for one more byte."/>
            <edc:AdjustPoint edc:offset="0x2"/>
            <edc:SFRFieldDef edc:cname="WR_CNT" edc:nzwidth="0x8" edc:desc="This field is a count of the number of bytes to transmit to the SMBus from the SMBus Master Transmit Buffer Register It is decremented by 1 for each byte written to the SMBus from the SMBus Master Transmit Buffer Register."/>
            <edc:SFRFieldDef edc:cname="RD_CNT" edc:nzwidth="0x8" edc:desc="This field is a count of the number of bytes to read in from the SMBus to the SMBus Master Receive Buffer Register and must be greater than 0 in order for the Master State Machine to initiate a read phase. It is decremented by 1 for each byte read from the SMBus into the SMBus Master Receive Buffer Register. It can be overwritten by the first byte read in from the SMBus."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SMB4" edc:cname="SCMD0" edc:nzwidth="0x20" edc:access="--------nnnnnnnnnnnnnnnn-----nnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0xFFFF07" edc:_addr="0x40005010">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SMB4">
            <edc:SFRFieldDef edc:cname="SRUN" edc:nzwidth="0x1" edc:desc="Setting this bit to 1 enables the Slave State Machine to operate."/>
            <edc:SFRFieldDef edc:cname="SPROCEED" edc:nzwidth="0x1" edc:desc="When this bit is 0, the Slave State Machine does not transition out of the IDLE, REPEAT_START_WRITE or REPEAT_START_READ states. When this bit is 1, the Slave State Machine immediately transitions to the START_WAIT, RECEIVE and TRANSMIT states, respectively."/>
            <edc:SFRFieldDef edc:cname="PEC" edc:nzwidth="0x1" edc:desc="If Slave_WriteCount is 0 and Slave_PEC is 1 when the Master requests data, the PEC Register is copied to the DATA register. After the PEC Register is copied to the SMBus, the PEC Register is cleared and Slave_PEC is set to 0."/>
            <edc:AdjustPoint edc:offset="0x5"/>
            <edc:SFRFieldDef edc:cname="WR_CNT" edc:nzwidth="0x8" edc:desc="This field is set to the number of bytes software expects to send to the Master."/>
            <edc:SFRFieldDef edc:cname="RD_CNT" edc:nzwidth="0x8" edc:desc="This field is decremented each time a byte is copied from DATA to the SMBus Slave Receive Buffer Register."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SMB4" edc:cname="PEC" edc:nzwidth="0x20" edc:access="------------------------nnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0xFF" edc:_addr="0x40005014">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SMB4">
            <edc:SFRFieldDef edc:cname="PEC" edc:nzwidth="0x8" edc:desc="The SMBus Packet Error Check (PEC) byte."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SMB4" edc:cname="RSHTM" edc:nzwidth="0x20" edc:access="------------------------nnnnnnnn" edc:por="00000000000000000000000001001101" edc:mclr="00000000000000000000000001001101" edc:impl="0xFF" edc:_addr="0x40005018">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SMB4">
            <edc:SFRFieldDef edc:cname="RSHTM" edc:nzwidth="0x8" edc:desc="This is the value of the timing requirement tHd:Sta in the I2C specification for a repeated START bit. This is used to hold      the clock until the Hold Time for the repeated Start Bit has been satisfied."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SMB4" edc:cname="EXTND_LEN" edc:nzwidth="0x20" edc:access="------------------------rrrrrrrr" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0xFF" edc:_addr="0x4000501C">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SMB4">
            <edc:SFRFieldDef edc:cname="EXTND_LEN" edc:nzwidth="0x8" edc:desc="Extended Length Register adds 8 MSB bits to the SMBUS Master/Slave Tx/Rx Length fields."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SMB4" edc:cname="COMPL0" edc:nzwidth="0x20" edc:access="nnn---nn--nnn-nn-nnnnnnn-nnnnn--" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0xE33B7F7C" edc:_addr="0x40005020">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SMB4">
            <edc:AdjustPoint edc:offset="0x2"/>
            <edc:SFRFieldDef edc:cname="DTEN" edc:nzwidth="0x1" edc:desc="When DTEN is asserted ('1'), Device Time-out checking is enabled. When DTEN is not asserted ('0'), Device Time-out checking is disabled."/>
            <edc:SFRFieldDef edc:cname="MCEN" edc:nzwidth="0x1" edc:desc="When MCEN is asserted ('1'), Master Cumulative Time-Out checking is enabled. When MCEN is not asserted ('0'), Master Cumulative Time-Out checking is disabled."/>
            <edc:SFRFieldDef edc:cname="SCEN" edc:nzwidth="0x1" edc:desc="When SCEN is asserted ('1'), Slave Cumulative Time-Out checking is enabled. When SCEN is not asserted ('0'), Slave Cumulative Time-Out checking is disabled."/>
            <edc:SFRFieldDef edc:cname="BIDEN" edc:nzwidth="0x1" edc:desc="When BIDEN is asserted ('1'), Bus Idle Detect Time-Out checking is enabled. When BIDEN is not asserted ('0'), Bus Idle Detect Time-Out checking is disabled."/>
            <edc:SFRFieldDef edc:cname="TIMERR" edc:nzwidth="0x1" edc:desc="The Time-out Error Detected bit (TIMERR) is asserted ('1') whenever any of the enabled time-out error detect status bits (CHDH, CHDL, SCTO, MCTO and DTO) are asserted."/>
            <edc:AdjustPoint edc:offset="0x1"/>
            <edc:SFRFieldDef edc:cname="DTO" edc:nzwidth="0x1" edc:desc="DTO is the Device Time-out bit. (R/WC)"/>
            <edc:SFRFieldDef edc:cname="MCTO" edc:nzwidth="0x1" edc:desc="MCTO is the Master Cumulative Time-out bit. (R/WC)"/>
            <edc:SFRFieldDef edc:cname="SCTO" edc:nzwidth="0x1" edc:desc="SCTO is the Slave Cumulative Time-out bit(R/WC)"/>
            <edc:SFRFieldDef edc:cname="CHDL" edc:nzwidth="0x1" edc:desc="CHDL is the clock high time-out detect bit(R/WC)"/>
            <edc:SFRFieldDef edc:cname="CHDH" edc:nzwidth="0x1" edc:desc="CHDH is the bus idle time-out detect bit(R/WC)"/>
            <edc:SFRFieldDef edc:cname="BER" edc:nzwidth="0x1" edc:desc="If this bit is 1, the BER bit in the Status register was set while either the Slave state machine or the Master state machine was not in the Idle state.(R/WC)"/>
            <edc:SFRFieldDef edc:cname="LAB" edc:nzwidth="0x1" edc:desc="If this bit is 1, the LAB bit in the Status register was set while either the Slave state machine or the Master state machine was not in the Idle state.(R/WC)"/>
            <edc:AdjustPoint edc:offset="0x1"/>
            <edc:SFRFieldDef edc:cname="SNAKR" edc:nzwidth="0x1" edc:desc="If this bit is 1, the Slave state machine sent a NACK to the transmitting Master while the Slave was receiving data from the SMBus interface."/>
            <edc:SFRFieldDef edc:cname="STR" edc:nzwidth="0x1" edc:desc="0: Slave has just finished the receive phase of a transaction.                 1: Slave has just finished the transmit phase of a transaction."/>
            <edc:AdjustPoint edc:offset="0x1"/>
            <edc:SFRFieldDef edc:cname="SPROT" edc:nzwidth="0x1" edc:desc="If this bit is 1, the WriteCount[7:0] counter in the Slave state machine either counted down to 0 before the Master sent a NACK signal, or the Slave received a NACK signal before the counter reached 0."/>
            <edc:SFRFieldDef edc:cname="REP_RD" edc:nzwidth="0x1" edc:desc="If this bit is 1, the Slave State Machine stopped because it detected a Repeat Start bit, with bit[0] of the byte containing the slave address equal to 1, indicating that the Master requested a Read operation."/>
            <edc:SFRFieldDef edc:cname="REP_WR" edc:nzwidth="0x1" edc:desc="If this bit is 1, the Slave State Machine stopped because it detected a Repeat Start bit, with bit[0] of the byte containing the slave address equal to 0, indicating that the Master requested a Write operation."/>
            <edc:AdjustPoint edc:offset="0x2"/>
            <edc:SFRFieldDef edc:cname="MNAKX" edc:nzwidth="0x1" edc:desc="If this bit is 1, the Master state machine received a NACK from the receiving Slave while the Master was transmitting data over the SMBus interface. (R/WC)"/>
            <edc:SFRFieldDef edc:cname="MTR" edc:nzwidth="0x1" edc:desc="0: Master has just finished the receive phase of a transaction.                 1: Master has just finished the transmit phase of a transaction."/>
            <edc:AdjustPoint edc:offset="0x3"/>
            <edc:SFRFieldDef edc:cname="IDLE" edc:nzwidth="0x1" edc:desc="This bit is set when the I2C bus becomes idle (on the rising edge of nBB). (R/WC)"/>
            <edc:SFRFieldDef edc:cname="MDONE" edc:nzwidth="0x1" edc:desc="If this bit is 1, Master State machine completed operation and returned to the Idle state. It is cleared when written with a 1. Writes of a 0 have no effect. (R/WC)"/>
            <edc:SFRFieldDef edc:cname="SDONE" edc:nzwidth="0x1" edc:desc="If this bit is 1, Slave State machine completed operation and returned to the Idle state. It is cleared when written with a 1. Writes of a 0 have no effect.(R/WC)"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SMB4" edc:cname="IDLSC" edc:nzwidth="0x20" edc:access="----nnnnnnnnnnnn----nnnnnnnnnnnn" edc:por="00000001111111000000000111101101" edc:mclr="00000001111111000000000111101101" edc:impl="0xFFF0FFF" edc:_addr="0x40005024">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SMB4">
            <edc:SFRFieldDef edc:cname="FAIR_BUS_IDL_MIN" edc:nzwidth="0xC" edc:desc="This field defines the number of ticks of the baud clock required to satisfy the fairness protocol. The default value for this field sets the idle window to 31us, which is the appropriate value for a 100 KHz bus"/>
            <edc:AdjustPoint edc:offset="0x4"/>
            <edc:SFRFieldDef edc:cname="FAIR_IDL_DLY" edc:nzwidth="0xC" edc:desc="This field defines the number of ticks of the baud clock required to program the delay. The default value for this field sets the delay period to 32us, which is the appropriate value for a 100 KHz bus"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SMB4" edc:cname="CFG0" edc:nzwidth="0x20" edc:access="nnnn--------nnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0xF00FFFFF" edc:_addr="0x40005028">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SMB4">
            <edc:SFRFieldDef edc:cname="PORT_SEL" edc:nzwidth="0x4" edc:desc="The PORT SEL [3:0] bits determine which one of 16 possible bus ports apply to the active 2-wire SDAT and SCLK bus pair."/>
            <edc:SFRFieldDef edc:cname="TCEN" edc:nzwidth="0x1" edc:desc="When the Timing Check Enable bit (TCEN) is asserted ('1'), Bus Time-Outs are enabled"/>
            <edc:SFRFieldDef edc:cname="SLOW_CLK" edc:nzwidth="0x1" edc:desc="When this bit is 1, the base period for the Bus Clock Register is multiplied by 4, and thus the frequency is divided by 4."/>
            <edc:SFRFieldDef edc:cname="TEST" edc:nzwidth="0x1" edc:desc="Must be always written with 0."/>
            <edc:SFRFieldDef edc:cname="PECEN" edc:nzwidth="0x1" edc:desc="When the PEC Enable bit (PECEN) is asserted ('1'), Hardware PEC Support is enabled"/>
            <edc:SFRFieldDef edc:cname="FEN" edc:nzwidth="0x1" edc:desc="Input filtering enable. Input filtering is required by the I2C specification if external filtering is not available.      1=Input filtering is enabled; 0=Input filtering is disabled."/>
            <edc:SFRFieldDef edc:cname="RST" edc:nzwidth="0x1" edc:desc="When RESET is asserted ('1'), all logic and registers except for the RESET bit itself are initialized to the power-on default state."/>
            <edc:SFRFieldDef edc:cname="EN" edc:nzwidth="0x1" edc:desc="When ENAB (Enable) is not asserted ('0') (default), the SMB Controller Core is disabled and in the lowest power consumption state (Disabled State).                The ENAB bit must be asserted ('1') for normal operation."/>
            <edc:SFRFieldDef edc:cname="DSA" edc:nzwidth="0x1" edc:desc="0: Slave Address I2C Compatibility Mode (default). 1: SMBus Address Decode Mode"/>
            <edc:SFRFieldDef edc:cname="FAIR" edc:nzwidth="0x1" edc:desc="If this bit is 1, the MCTP Fairness protocol is in effect."/>
            <edc:SFRFieldDef edc:cname="TEST0" edc:nzwidth="0x1" edc:desc="Must be always written with 0."/>
            <edc:SFRFieldDef edc:cname="GC_DIS" edc:nzwidth="0x1" edc:desc="This is the General Call Disable bit.                0: the response to the General Call address as a slave is enabled                1: the response to the General Call address as a slave is disabled."/>
            <edc:SFRFieldDef edc:cname="CFG_PROMIS" edc:nzwidth="0x1" edc:desc="This bit define the Mode of SM Bus Controler Mode of operation.         0= Normal Operation.         1=  Promiscuous Mode Enable."/>
            <edc:SFRFieldDef edc:cname="FLUSH_SXBUF" edc:nzwidth="0x1" edc:desc="A write of a 1 to this bit forces the SMBus Slave Transmit Buffer Register to be marked empty. A write of 0 has no effect. This is a self-clearing bit."/>
            <edc:SFRFieldDef edc:cname="FLUSH_SRBUF" edc:nzwidth="0x1" edc:desc="A write of a 1 to this bit forces the SMBus Slave Receive Buffer Register to be marked empty. A write of 0 has no effect. This is a self-clearing bit."/>
            <edc:SFRFieldDef edc:cname="FLUSH_MXBUF" edc:nzwidth="0x1" edc:desc="A write of a 1 to this bit forces the SMBus Master Transmit Buffer Register to be marked empty. A write of 0 has no effect. This is a self-clearing bit."/>
            <edc:SFRFieldDef edc:cname="FLUSH_MRBUF" edc:nzwidth="0x1" edc:desc="A write of a 1 to this bit forces the SMBus Master Receive Buffer Register to be marked empty. A write of 0 has no effect. This is a self-clearing bit."/>
            <edc:AdjustPoint edc:offset="0x8"/>
            <edc:SFRFieldDef edc:cname="EN_AAS" edc:nzwidth="0x1" edc:desc="0: Disable the AAS, 1: Enable the AAS Interrupt"/>
            <edc:SFRFieldDef edc:cname="ENIDI" edc:nzwidth="0x1" edc:desc="If this bit is 1, the Idle interrupt is enabled. If this bit is 0, the Idle interrupt is disabled."/>
            <edc:SFRFieldDef edc:cname="ENMI" edc:nzwidth="0x1" edc:desc="If this bit is 1, the Master Done interrupt is enabled. If this bit is 0, the Master Done interrupt is disabled."/>
            <edc:SFRFieldDef edc:cname="ENSI" edc:nzwidth="0x1" edc:desc="If this bit is 1, the Slave Done interrupt is enabled. If this bit is 0, the Slave Done interrupt is disabled"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SMB4" edc:cname="BUSCLK" edc:nzwidth="0x20" edc:access="----------------nnnnnnnnnnnnnnnn" edc:por="00000000000000000100111101001111" edc:mclr="00000000000000000100111101001111" edc:impl="0xFFFF" edc:_addr="0x4000502C">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SMB4">
            <edc:SFRFieldDef edc:cname="LOW_PER" edc:nzwidth="0x8" edc:desc="This field defines the number of I2C Baud Clock periods that make up the low phase of the I2C/SMBus bus clock."/>
            <edc:SFRFieldDef edc:cname="HIGH_PER" edc:nzwidth="0x8" edc:desc="This field defines the number of I2C Baud Clock periods that make up the high phase of the I2C/SMBus bus clock."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SMB4" edc:cname="BLKID" edc:nzwidth="0x8" edc:access="rrrrrrrr" edc:por="00010001" edc:mclr="00010001" edc:_addr="0x40005030">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SMB4">
            <edc:SFRFieldDef edc:cname="ID" edc:nzwidth="0x8" edc:desc="Block ID."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:AdjustPoint edc:offset="0x3" edc:_addr="0x40005031"/>
      <edc:SFRDef ltx:memberofperipheral="SMB4" edc:cname="BLKREV" edc:nzwidth="0x8" edc:access="rrrrrrrr" edc:por="00000000" edc:mclr="00000000" edc:_addr="0x40005034">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SMB4">
            <edc:SFRFieldDef edc:cname="REV" edc:nzwidth="0x8" edc:desc="Block Revision Number"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:AdjustPoint edc:offset="0x3" edc:_addr="0x40005035"/>
      <edc:SFRDef ltx:memberofperipheral="SMB4" edc:cname="BBCTRL" edc:nzwidth="0x20" edc:access="-------------------------nnnnnnn" edc:por="00000000000000000000000001100000" edc:mclr="00000000000000000000000001100000" edc:impl="0x7F" edc:_addr="0x40005038">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SMB4">
            <edc:SFRFieldDef edc:cname="BBEN" edc:nzwidth="0x1" edc:desc="Bit-Bang Mode Enable. 0 - Bit Bang Mode Disabled. 1 - Bit Bang Mode Enabled"/>
            <edc:SFRFieldDef edc:cname="CLDIR" edc:nzwidth="0x1" edc:desc="Bit-Bang Clock Direction. The CLDIR bit controls the direction of SCLK. 0 - Input, 1 - Output"/>
            <edc:SFRFieldDef edc:cname="DADIR" edc:nzwidth="0x1" edc:desc="Bit-Bang Data Direction. The DADIR bit controls the direction of SDAT. 0 - Input. 1 - Output"/>
            <edc:SFRFieldDef edc:cname="BBCLK" edc:nzwidth="0x1" edc:desc="Bit-Bang Clock. The BBCLK bit controls the state of SCLK when BBEN = and CLDIR = '1'"/>
            <edc:SFRFieldDef edc:cname="BBDAT" edc:nzwidth="0x1" edc:desc="Bit-Bang Data. The BBDAT bit controls the state of SDAT when BBEN = and DADIR = '1'"/>
            <edc:SFRFieldDef edc:cname="BBCLKI" edc:nzwidth="0x1" edc:desc="Bit-Bang Clock In. The BBCLKI bit always returns the state of SCLK."/>
            <edc:SFRFieldDef edc:cname="BBDATI" edc:nzwidth="0x1" edc:desc="Bit-Bang Data In. The BBDATI bit always returns the state of SDAT"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SMB4" edc:cname="TEST" edc:nzwidth="0x8" edc:access="rrrrrrrr" edc:por="00000101" edc:mclr="00000101" edc:_addr="0x4000503C">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SMB4">
            <edc:SFRFieldDef edc:cname="TEST" edc:nzwidth="0x8" edc:desc="This register must not be written, or undesirable results may occur."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:AdjustPoint edc:offset="0x3" edc:_addr="0x4000503D"/>
      <edc:SFRDef ltx:memberofperipheral="SMB4" edc:cname="DATATM" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00001100010011010101000000000110" edc:mclr="00001100010011010101000000000110" edc:_addr="0x40005040">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SMB4">
            <edc:SFRFieldDef edc:cname="DATA_HOLD" edc:nzwidth="0x8" edc:desc="The Data Hold [7:0] timer determines the SDAT hold time following SCLK driven low."/>
            <edc:SFRFieldDef edc:cname="RESTART_SETUP" edc:nzwidth="0x8" edc:desc="The Restart Setup [7:0] timer determines the SDAT setup time from the rising edge of SCLK for a repeated START condition."/>
            <edc:SFRFieldDef edc:cname="STOP_SETUP" edc:nzwidth="0x8" edc:desc="The Stop Setup [7:0] timer determines the SDAT setup time from the rising edge of SCLK for a STOP condition."/>
            <edc:SFRFieldDef edc:cname="FIRST_START_HOLD" edc:nzwidth="0x8" edc:desc="This field determines the SCL hold time following SDA driven low during the first START bit in a transfer. It is the parameter      THD:STA in the I2C Specification for an initial START bit. Repeated START hold time is determined by the Repeated START Hold Time Register."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SMB4" edc:cname="TMOUTSC" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="01001011100111001100001011000111" edc:mclr="01001011100111001100001011000111" edc:_addr="0x40005044">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SMB4">
            <edc:SFRFieldDef edc:cname="CLK_HIGH_TIM_OUT" edc:nzwidth="0x8" edc:desc="Clock High time out period = Clock High Time-Out [7:0] x Baud_Clock_Period x 2"/>
            <edc:SFRFieldDef edc:cname="SLV_CUM_TIM_OUT" edc:nzwidth="0x8" edc:desc="Slave Cumulative Time-Out duration = Slave Cum Time-Out [7:0] x Baud_Clock_Period x 1024"/>
            <edc:SFRFieldDef edc:cname="MAST_CUM_TIM_OUT" edc:nzwidth="0x8" edc:desc="Master Cumulative Time-Out duration = Master Cum Time-Out [7:0] x Baud_Clock_Period x 512"/>
            <edc:SFRFieldDef edc:cname="BUS_IDLE_MIN" edc:nzwidth="0x8" edc:desc="Bus Idle Minimum time = Bus Idle Min [7:0] x Baud_Clock_Period"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SMB4" edc:cname="SLV_TXB" edc:nzwidth="0x20" edc:access="------------------------nnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0xFF" edc:_addr="0x40005048">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SMB4">
            <edc:SFRFieldDef edc:cname="STXB" edc:nzwidth="0x8" edc:desc="SLAVE_TRANSMIT_BUFFER"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SMB4" edc:cname="SLV_RXB" edc:nzwidth="0x20" edc:access="------------------------nnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0xFF" edc:_addr="0x4000504C">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SMB4">
            <edc:SFRFieldDef edc:cname="SRXB" edc:nzwidth="0x8" edc:desc="SLAVE_RECEIVE_BUFFER"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SMB4" edc:cname="MTR_TXB" edc:nzwidth="0x20" edc:access="------------------------nnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0xFF" edc:_addr="0x40005050">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SMB4">
            <edc:SFRFieldDef edc:cname="MTXB" edc:nzwidth="0x8" edc:desc="MASTER_TRANSMIT_BUFFER"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SMB4" edc:cname="MTR_RXB" edc:nzwidth="0x20" edc:access="------------------------nnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0xFF" edc:_addr="0x40005054">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SMB4">
            <edc:SFRFieldDef edc:cname="MRXB" edc:nzwidth="0x8" edc:desc="MASTER_RECEIVE_BUFFER"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:AdjustPoint edc:offset="0x8" edc:_addr="0x40005058"/>
      <edc:SFRDef ltx:memberofperipheral="SMB4" edc:cname="WAKE_STS" edc:nzwidth="0x20" edc:access="-------------------------------n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x1" edc:_addr="0x40005060">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SMB4">
            <edc:SFRFieldDef edc:cname="START_BIT_DET" edc:nzwidth="0x1" edc:desc="This bit is set to '1' when a START bit is detected while the controller is enabled. This bit is cleared to '0' when      written with a '1'. Writes of '0' have no effect. (R/WC)"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SMB4" edc:cname="WAKE_EN" edc:nzwidth="0x20" edc:access="-------------------------------n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x1" edc:_addr="0x40005064">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SMB4">
            <edc:SFRFieldDef edc:cname="START_DET_INT_EN" edc:nzwidth="0x1" edc:desc="Enable Start Bit Detection Interrupt. The Start Bit Detection Interrupt is wake-capable.      1=Start Bit Detection Interrupt enabled; 0=Start Bit Detection Interrupt disabled"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:AdjustPoint edc:offset="0x4" edc:_addr="0x40005068"/>
      <edc:SFRDef ltx:memberofperipheral="SMB4" edc:cname="SLV_ADDR" edc:nzwidth="0x8" edc:access="nnnnnnnn" edc:por="00000000" edc:mclr="00000000" edc:_addr="0x4000506C">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SMB4">
            <edc:SFRFieldDef edc:cname="SADDR" edc:nzwidth="0x8" edc:desc="This register stores value of address + LSB direction after the 8th clock of the Address Byte."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:AdjustPoint edc:offset="0x3" edc:_addr="0x4000506D"/>
      <edc:SFRDef ltx:memberofperipheral="SMB4" edc:cname="PRM_STS" edc:nzwidth="0x8" edc:access="-------n" edc:por="00000000" edc:mclr="00000000" edc:impl="0x1" edc:_addr="0x40005070">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SMB4">
            <edc:SFRFieldDef edc:cname="ADDR_INTR" edc:nzwidth="0x1" edc:desc="This is the Promiscuous Address Status interrupt and is set on the 8th clock of the I2C Address.         This bit will hold the Clock line low till this register bit is cleared. This is Write 1 to clear.         R/W1C."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:AdjustPoint edc:offset="0x3" edc:_addr="0x40005071"/>
      <edc:SFRDef ltx:memberofperipheral="SMB4" edc:cname="PRM_IEN" edc:nzwidth="0x8" edc:access="-------n" edc:por="00000000" edc:mclr="00000000" edc:impl="0x1" edc:_addr="0x40005074">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SMB4">
            <edc:SFRFieldDef edc:cname="ADDR" edc:nzwidth="0x1" edc:desc="This is the Promiscuous interrupt enable register.         1= Interrupt Enable.          0= Interrupt Disabled. "/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:AdjustPoint edc:offset="0x3" edc:_addr="0x40005075"/>
      <edc:SFRDef ltx:memberofperipheral="SMB4" edc:cname="PRM_CTRL" edc:nzwidth="0x8" edc:access="-------n" edc:por="00000000" edc:mclr="00000000" edc:impl="0x1" edc:_addr="0x40005078">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SMB4">
            <edc:SFRFieldDef edc:cname="ACK_NAK" edc:nzwidth="0x1" edc:desc="This is the Promiscuous ACK / NAK response register.         1= ACK.          0= NAK. "/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:AdjustPoint edc:offset="0x3" edc:_addr="0x40005079"/>
      <edc:SFRDef ltx:memberofperipheral="SMB4" edc:cname="SHDW_DATA" edc:nzwidth="0x8" edc:access="nnnnnnnn" edc:por="00000000" edc:mclr="00000000" edc:_addr="0x4000507C">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SMB4">
            <edc:SFRFieldDef edc:cname="SHDW_DATA" edc:nzwidth="0x8" edc:desc="This is the I2C Shadow Data Register"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:AdjustPoint edc:offset="0x783" edc:_addr="0x4000507D"/>
      <edc:SFRDef ltx:memberofperipheral="PWM0" edc:cname="CNT_ON" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x40005800"/>
      <edc:SFRDef ltx:memberofperipheral="PWM0" edc:cname="CNT_OFF" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000001111111111111111" edc:mclr="00000000000000001111111111111111" edc:_addr="0x40005804"/>
      <edc:SFRDef ltx:memberofperipheral="PWM0" edc:cname="CFG" edc:nzwidth="0x20" edc:access="-------------------------nnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x7F" edc:_addr="0x40005808">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="PWM0">
            <edc:SFRFieldDef edc:cname="PWM_EN" edc:nzwidth="0x1" edc:desc="When the PWM_ENABLE is set to 0 the internal counters are reset and the internal state machine is set to the OFF state.     In addition, the PWM_OUTPUT signal is set to the inactive state as determined by the Invert bit. The PWMx Counter ON Time Register     and PWMx Counter OFF Time Register are not affected by the PWM_ENABLE bit and may be read and written while the PWM enable bit is 0.     1=Enabled (default); 0=Disabled (gates clocks to save power)."/>
            <edc:SFRFieldDef edc:cname="CLK_SEL" edc:nzwidth="0x1" edc:desc="This bit determines the clock source used by the PWM duty cycle and frequency control logic.                    1=CLOCK_LOW                    0=CLOCK_HIGH"/>
            <edc:SFRFieldDef edc:cname="INV" edc:nzwidth="0x1" edc:desc="1= PWM_OUTPUT ON State is active low; 0=PWM_OUTPUT ON State is active high."/>
            <edc:SFRFieldDef edc:cname="CLK_PRE_DIV" edc:nzwidth="0x4" edc:desc="The Clock source for the 16-bit down counter (see PWMx Counter ON Time Register and PWMx Counter OFF Time Register)     is determined by bit D1 of this register. The Clock source is then divided by the value of Pre-Divider+1 and the resulting     signal determines the rate at which the down counter will be decremented. For example, a Pre-Divider value of 1 divides     the input clock by 2 and a value of 2 divides the input clock by 3. A Pre-Divider of 0 will disable the Pre-Divider option."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:AdjustPoint edc:offset="0x13F4" edc:_addr="0x4000580C"/>
      <edc:SFRDef ltx:memberofperipheral="SPT1" edc:cname="SPI_CFG" edc:nzwidth="0x20" edc:access="--------nnnnnnnn-----nnn-------n" edc:por="00000000000001000000000000000000" edc:mclr="00000000000001000000000000000000" edc:impl="0xFF0701" edc:_addr="0x40006C00">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPT1">
            <edc:SFRFieldDef edc:cname="SNG_QUD_SEL" edc:nzwidth="0x1" edc:desc="This field defines the Single / Quad Wire mode of operation for SPI Peripheral Target block.         0 = Single Wire Slave SPI block operation.         1 = Quad Wire Slave SPI block operation."/>
            <edc:AdjustPoint edc:offset="0x7"/>
            <edc:SFRFieldDef edc:cname="TAR_TIM_SEL" edc:nzwidth="0x3" edc:desc="Turn Around Time select for Quad wire mode.         0h = 1 cycle.         1h = 2 cycles.         2h = 4 cycles.         3h = 8 cycles.         Other values are reserved.">
              <edc:SFRFieldSemantic edc:cname="TAR_TIME_1_CYCLE" edc:desc="1 cycle" edc:when="(field &amp; 0x7) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="TAR_TIME_2_CYCLE" edc:desc="2 cycle" edc:when="(field &amp; 0x7) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="TAR_TIME_4_CYCLE" edc:desc="4 cycle" edc:when="(field &amp; 0x7) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="TAR_TIME_8_CYCLE" edc:desc="8 cycle" edc:when="(field &amp; 0x7) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:AdjustPoint edc:offset="0x5"/>
            <edc:SFRFieldDef edc:cname="WAIT_TIME" edc:nzwidth="0x8" edc:desc="These bits set the amount of wait time in cycles before transmitting data back to master.         During this wait time status bits will be transmitted"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPT1" edc:cname="SPI_STS" edc:nzwidth="0x20" edc:access="---nnnnnnnnnnnnnnnn-nnnn-nnnn-nn" edc:por="00000000000000000000010100000000" edc:mclr="00000000000000000000010100000000" edc:impl="0x1FFFEF7B" edc:_addr="0x40006C04">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPT1">
            <edc:SFRFieldDef edc:cname="MEM_WR_DONE" edc:nzwidth="0x1" edc:desc="When the ARM BUS side has fully finished the last transaction from the FIFO to write the data to         Memory for Posted Writes . Clear with new Write request."/>
            <edc:SFRFieldDef edc:cname="MEM_RD_DONE" edc:nzwidth="0x1" edc:desc="When the ARM BUS side has fully finished writing the last written DWord to the FIFO for a set of data         read from Memory for Posted Reads. - cleared with new Read request."/>
            <edc:AdjustPoint edc:offset="0x1"/>
            <edc:SFRFieldDef edc:cname="MEM_WR_BUSY" edc:nzwidth="0x1" edc:desc="When an Memory Write transaction is currently being processed."/>
            <edc:SFRFieldDef edc:cname="MEM_RD_BUSY" edc:nzwidth="0x1" edc:desc="When an Memory Read transaction is currently being processed."/>
            <edc:SFRFieldDef edc:cname="SREG_TRANS" edc:nzwidth="0x1" edc:desc="When an SREG transaction is currently being processed."/>
            <edc:SFRFieldDef edc:cname="POLL_HIGH" edc:nzwidth="0x1" edc:desc="If this bit is set, then something in the high 16-bit of status register is set and needs to be checked.         SPI Master should take action to clear this."/>
            <edc:AdjustPoint edc:offset="0x1"/>
            <edc:SFRFieldDef edc:cname="RXF_EMP" edc:nzwidth="0x1" edc:desc="Signifies all Memory write transactions for the SPI Masters requested size have been performed.         New transactions are allowed."/>
            <edc:SFRFieldDef edc:cname="RXF_FUL" edc:nzwidth="0x1" edc:desc="The RX FIFO is full of data to be written to Memory."/>
            <edc:SFRFieldDef edc:cname="TXF_EMP" edc:nzwidth="0x1" edc:desc="Signifies SPI Master has read the data requested from Memory. Can be used to show there is data         the SPI Master has requested and not been read yet. New read transactions will be aligned."/>
            <edc:SFRFieldDef edc:cname="TXF_FUL" edc:nzwidth="0x1" edc:desc="The TX FIFO is full of data that was read from Memory."/>
            <edc:AdjustPoint edc:offset="0x1"/>
            <edc:SFRFieldDef edc:cname="TMCLK_CNT_ERR" edc:nzwidth="0x1" edc:desc="This bit is set when the SPI Clock Count Test Mode is set and there is an uneven amount of clocks."/>
            <edc:SFRFieldDef edc:cname="IBF_FLG" edc:nzwidth="0x1" edc:desc="Set when the Host writes to the Input Buffer signaling there is data for the EC to read."/>
            <edc:SFRFieldDef edc:cname="OBF_FLG" edc:nzwidth="0x1" edc:desc="Set when the EC writes to the Output Buffer signaling there is data for the Host to read."/>
            <edc:SFRFieldDef edc:cname="SPIM_RST_REQ" edc:nzwidth="0x1" edc:desc="Set when the SPI Master Requested a Configuration Reset."/>
            <edc:SFRFieldDef edc:cname="RXF_RST_DN" edc:nzwidth="0x1" edc:desc="Set after the SPI Master initiates a RX FIFO reset and the reset has been processed. FIFO is cleared."/>
            <edc:SFRFieldDef edc:cname="TXF_RST_DN" edc:nzwidth="0x1" edc:desc="Set after the SPI Master initiates a TX FIFO reset and the reset has been processed. FIFO is cleared."/>
            <edc:SFRFieldDef edc:cname="OOL0_ERR" edc:nzwidth="0x1" edc:desc="This flag is set with the transfer address requested by the master is out of Limit 0 range or when the BAR is disabled."/>
            <edc:SFRFieldDef edc:cname="OOL1_ERR" edc:nzwidth="0x1" edc:desc="This flag is set with the transfer address requested by the master is out of Limit 1 range or when the BAR is disabled."/>
            <edc:SFRFieldDef edc:cname="ARMBUS_ERR" edc:nzwidth="0x1" edc:desc="ARM Bus Error returned for the curren data transfer."/>
            <edc:SFRFieldDef edc:cname="UNDEF_CMD_ERR" edc:nzwidth="0x1" edc:desc="Undefined Command Error: The command received from the master isn't defined."/>
            <edc:SFRFieldDef edc:cname="DV_BUSY" edc:nzwidth="0x1" edc:desc="If the Master requested a transaction whose destination is busy the request is ignored.         Should use the poll or wait for interrupts."/>
            <edc:SFRFieldDef edc:cname="RXF_SIZE_ERR" edc:nzwidth="0x1" edc:desc="If size requested is more than what Master provided and the Master terminates early error flag         shut down request signal to ARM Bus. Size requested is less than what Master provided -- ignored and         continue transaction, may be taking in garbage."/>
            <edc:SFRFieldDef edc:cname="TXF_UNFLW" edc:nzwidth="0x1" edc:desc="If Master reads more than what is in FIFO, FIFO will flag an underflow error and the data returned         will just be the last valid pointer value."/>
            <edc:SFRFieldDef edc:cname="TXF_OVRFLW" edc:nzwidth="0x1" edc:desc="If Master doesn't read all of the data it requested from the posted read block cycle, than data         will still be left in the FIFO. This will cause misalignment with the following transactions and a new         read cycle can cause overflow."/>
            <edc:SFRFieldDef edc:cname="RXF_UNFLW" edc:nzwidth="0x1" edc:desc="If the SPI Peripheral Target reads RX FIFO when it is empty, RX FIFO Underflow flag will be set. This condition         will never happen under normal situation."/>
            <edc:SFRFieldDef edc:cname="RXF_OVRFLW" edc:nzwidth="0x1" edc:desc="If SPI Master writes more than the space in the FIFO, the FIFO will flag an overflow error and data         will not be stored."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPT1" edc:cname="SPI_EC_STS" edc:nzwidth="0x20" edc:access="---nnnnnnnnnnnnnnnn-nnnn-nnnn-nn" edc:por="00000000000000000000010100000000" edc:mclr="00000000000000000000010100000000" edc:impl="0x1FFFEF7B" edc:_addr="0x40006C08">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPT1">
            <edc:SFRFieldDef edc:cname="MEM_WR_DONE" edc:nzwidth="0x1" edc:desc="When the ARM BUS side has fully finished the last transaction from the FIFO to write the data to         Memory for Posted Writes .- clear with new Write request."/>
            <edc:SFRFieldDef edc:cname="MEM_RD_DONE" edc:nzwidth="0x1" edc:desc="When the ARM BUS side has fully finished writing the last written DWord to the FIFO for a set of data         read from Memory for Posted Reads. - cleared with new Read request."/>
            <edc:AdjustPoint edc:offset="0x1"/>
            <edc:SFRFieldDef edc:cname="MEM_WR_BUSY" edc:nzwidth="0x1" edc:desc="When an Memory Write transaction is currently being processed."/>
            <edc:SFRFieldDef edc:cname="MEM_RD_BUSY" edc:nzwidth="0x1" edc:desc="When an Memory Read transaction is currently being processed."/>
            <edc:SFRFieldDef edc:cname="SREG_TRANS" edc:nzwidth="0x1" edc:desc="When an SREG transaction is currently being processed."/>
            <edc:SFRFieldDef edc:cname="POLL_HI" edc:nzwidth="0x1" edc:desc="If this bit is set, then something in the high 16-bit of status register is set and needs to be checked.         SPI Master should take action to clear this."/>
            <edc:AdjustPoint edc:offset="0x1"/>
            <edc:SFRFieldDef edc:cname="RXF_EMP" edc:nzwidth="0x1" edc:desc="Signifies all Memory write transactions for the SPI Masters requested size have been performed.         New transactions are allowed."/>
            <edc:SFRFieldDef edc:cname="RXF_FUL" edc:nzwidth="0x1" edc:desc="The RX FIFO is full of data to be written to Memory."/>
            <edc:SFRFieldDef edc:cname="TXF_EMP" edc:nzwidth="0x1" edc:desc="Signifies SPI Master has read the data requested from Memory. Can be used to show there is data         the SPI Master has requested and not been read yet. New read transactions will be aligned."/>
            <edc:SFRFieldDef edc:cname="TXF_FUL" edc:nzwidth="0x1" edc:desc="The TX FIFO is full of data that was read from Memory."/>
            <edc:AdjustPoint edc:offset="0x1"/>
            <edc:SFRFieldDef edc:cname="TMCLK_CNT_ERR" edc:nzwidth="0x1" edc:desc="This bit is set when the SPI Clock Count Test Mode is set and there is an uneven amount of clocks."/>
            <edc:SFRFieldDef edc:cname="IBF_FLG" edc:nzwidth="0x1" edc:desc="Set when the Host writes to the Input Buffer signaling there is data for the EC to read."/>
            <edc:SFRFieldDef edc:cname="OBF_FLG" edc:nzwidth="0x1" edc:desc="Set when the EC writes to the Output Buffer signaling there is data for the Host to read."/>
            <edc:SFRFieldDef edc:cname="SPIM_RST_REQ" edc:nzwidth="0x1" edc:desc="Set when the SPI Master Requested a Configuration Reset."/>
            <edc:SFRFieldDef edc:cname="RXF_RST_DN" edc:nzwidth="0x1" edc:desc="Set after the SPI Master initiates a RX FIFO reset and the reset has been processed. FIFO is cleared."/>
            <edc:SFRFieldDef edc:cname="TXF_RST_DN" edc:nzwidth="0x1" edc:desc="Set after the SPI Master initiates a TX FIFO reset and the reset has been processed. FIFO is cleared."/>
            <edc:SFRFieldDef edc:cname="OOL0_ERR" edc:nzwidth="0x1" edc:desc="This flag is set with the transfer address requested by the master is out of Limit 0 range or when the BAR is disabled."/>
            <edc:SFRFieldDef edc:cname="OOL1_ERR" edc:nzwidth="0x1" edc:desc="This flag is set with the transfer address requested by the master is out of Limit 1 range or when the BAR is disabled."/>
            <edc:SFRFieldDef edc:cname="ARMBUS_ERR" edc:nzwidth="0x1" edc:desc="ARM Bus Error returned for the curren data transfer."/>
            <edc:SFRFieldDef edc:cname="UNDEF_CMD_ERR" edc:nzwidth="0x1" edc:desc="Undefined Command Error: The command received from the master isn't defined."/>
            <edc:SFRFieldDef edc:cname="DV_BUSY" edc:nzwidth="0x1" edc:desc="If the Master requested a transaction whose destination is busy the request is ignored.         Should use the poll or wait for interrupts."/>
            <edc:SFRFieldDef edc:cname="RXF_SIZE_ERR" edc:nzwidth="0x1" edc:desc="If size requested is more than what Master provided and the Master terminates early error flag         shut down request signal to ARM Bus. Size requested is less than what Master provided -- ignored and         continue transaction, may be taking in garbage."/>
            <edc:SFRFieldDef edc:cname="TXF_UNFLW" edc:nzwidth="0x1" edc:desc="If Master reads more than what is in FIFO, FIFO will flag an underflow error and the data returned         will just be the last valid pointer value."/>
            <edc:SFRFieldDef edc:cname="TXF_OVRFLW" edc:nzwidth="0x1" edc:desc="If Master doesn't read all of the data it requested from the posted read block cycle, than data         will still be left in the FIFO. This will cause misalignment with the following transactions and a new         read cycle can cause overflow."/>
            <edc:SFRFieldDef edc:cname="RXF_UNFLW" edc:nzwidth="0x1" edc:desc="If the SPI Peripheral Target reads RX FIFO when it is empty, RX FIFO Underflow flag will be set. This condition         will never happen under normal situation."/>
            <edc:SFRFieldDef edc:cname="RXF_OVRFLW" edc:nzwidth="0x1" edc:desc="If SPI Master writes more than the space in the FIFO, the FIFO will flag an overflow error and data         will not be stored."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPT1" edc:cname="SPI_IEN" edc:nzwidth="0x20" edc:access="---nnnnnnnnnnnnnnnn-nnnn-nnnn-nn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x1FFFEF7B" edc:_addr="0x40006C0C">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPT1">
            <edc:SFRFieldDef edc:cname="MEM_WR_DONE" edc:nzwidth="0x1" edc:desc="Enable Memory Write Done Interrupt to SPI Master."/>
            <edc:SFRFieldDef edc:cname="MEM_RD_DONE" edc:nzwidth="0x1" edc:desc="Enable Memory Read Done Interrupt to SPI Master."/>
            <edc:AdjustPoint edc:offset="0x1"/>
            <edc:SFRFieldDef edc:cname="MEM_WR_BUSY" edc:nzwidth="0x1" edc:desc="Enable Memory Write Busy Interrupt to SPI Master."/>
            <edc:SFRFieldDef edc:cname="MEM_RD_BUSY" edc:nzwidth="0x1" edc:desc="Enable Memory Read Busy Interrupt to SPI Master."/>
            <edc:SFRFieldDef edc:cname="SREG_TRANS" edc:nzwidth="0x1" edc:desc="Enable SREG Trans Busy Interrupt to SPI Master."/>
            <edc:SFRFieldDef edc:cname="POLL_HI" edc:nzwidth="0x1" edc:desc="Enable Poll High Request Interrupt to SPI Master."/>
            <edc:AdjustPoint edc:offset="0x1"/>
            <edc:SFRFieldDef edc:cname="RXF_EMP" edc:nzwidth="0x1" edc:desc="Enable SREG RX FIFO Empty Interrupt to SPI Master."/>
            <edc:SFRFieldDef edc:cname="RXF_FUL" edc:nzwidth="0x1" edc:desc="Enable RX FIFO Full Interrupt to SPI Master."/>
            <edc:SFRFieldDef edc:cname="TXF_EMP" edc:nzwidth="0x1" edc:desc="Enable TX FIFO Empty Interrupt to SPI Master."/>
            <edc:SFRFieldDef edc:cname="TXF_FUL" edc:nzwidth="0x1" edc:desc="Enable TX FIFI FULL Interrupt to SPI Master."/>
            <edc:AdjustPoint edc:offset="0x1"/>
            <edc:SFRFieldDef edc:cname="TMCLK_CNT_ERR" edc:nzwidth="0x1" edc:desc="Enable Test Mode SPI Clock Count Error Interrupt to SPI Master."/>
            <edc:SFRFieldDef edc:cname="IBF_FLG" edc:nzwidth="0x1" edc:desc="Enable Input Buffer Signaling Interrupt to SPI Master."/>
            <edc:SFRFieldDef edc:cname="OBF_FLG" edc:nzwidth="0x1" edc:desc="Enable Output Buffer signaling Interrupt to SPI Master."/>
            <edc:SFRFieldDef edc:cname="SPIM_RST_REQ" edc:nzwidth="0x1" edc:desc="Enable SPI Master Request Reset Interrupt to SPI Master."/>
            <edc:SFRFieldDef edc:cname="RXF_RST_DN" edc:nzwidth="0x1" edc:desc="Enable RX FIFO Reset Done Interrupt to SPI Master."/>
            <edc:SFRFieldDef edc:cname="TXF_RST_DN" edc:nzwidth="0x1" edc:desc="Enable TX FIFO Reset Done Interrupt to SPI Master."/>
            <edc:SFRFieldDef edc:cname="OOL0_ERR" edc:nzwidth="0x1" edc:desc="Enable Out Of Limit 0 Error Interrupt to SPI Master."/>
            <edc:SFRFieldDef edc:cname="OOL1_ERR" edc:nzwidth="0x1" edc:desc="Enable Out Of Limit 1 Error Interrupt to SPI Master."/>
            <edc:SFRFieldDef edc:cname="ARMBUS_ERR" edc:nzwidth="0x1" edc:desc="Enable AHB BUS Error Interrupt to SPI Master."/>
            <edc:SFRFieldDef edc:cname="UNDEF_CMD_ERR" edc:nzwidth="0x1" edc:desc="Enable Undefined Command Error Interrupt to SPI Master."/>
            <edc:SFRFieldDef edc:cname="DV_BUSY" edc:nzwidth="0x1" edc:desc="Enable Device Busy Interrupt to SPI Master."/>
            <edc:SFRFieldDef edc:cname="RXF_SIZE_ERR" edc:nzwidth="0x1" edc:desc="Enable RX FIFO SIZE Error Interrupt to SPI Master."/>
            <edc:SFRFieldDef edc:cname="TXF_UNFLW" edc:nzwidth="0x1" edc:desc="Enable TX FIFO Underflow Interrupt to SPI Master."/>
            <edc:SFRFieldDef edc:cname="TXF_OVRFLOW" edc:nzwidth="0x1" edc:desc="Enable TX FIFO Overflow Interrupt to SPI Master."/>
            <edc:SFRFieldDef edc:cname="RXF_UNFLW" edc:nzwidth="0x1" edc:desc="Enable RX FIFO Underflow Interrupt to SPI Master."/>
            <edc:SFRFieldDef edc:cname="RXF_OVRFLW" edc:nzwidth="0x1" edc:desc="Enable RX FIFO Overflow Interrupt to SPI Master."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPT1" edc:cname="EC_IEN" edc:nzwidth="0x20" edc:access="---nnnnnnnnnnnnnnnn-nnnn-nnnn-nn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x1FFFEF7B" edc:_addr="0x40006C10">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPT1">
            <edc:SFRFieldDef edc:cname="MEM_WR_DONE" edc:nzwidth="0x1" edc:desc="Enable Memory Write Done Interrupt to EC."/>
            <edc:SFRFieldDef edc:cname="MEM_RD_DONE" edc:nzwidth="0x1" edc:desc="Enable Memory Read Done Interrupt to EC."/>
            <edc:AdjustPoint edc:offset="0x1"/>
            <edc:SFRFieldDef edc:cname="MEM_WR_BUSY" edc:nzwidth="0x1" edc:desc="Enable Memory Write Busy Interrupt to EC."/>
            <edc:SFRFieldDef edc:cname="MEM_RD_BUSY" edc:nzwidth="0x1" edc:desc="Enable Memory Read Busy Interrupt to EC."/>
            <edc:SFRFieldDef edc:cname="SREG_TRANS" edc:nzwidth="0x1" edc:desc="Enable SREG Trans Busy Interrupt to EC."/>
            <edc:SFRFieldDef edc:cname="POLL_HI" edc:nzwidth="0x1" edc:desc="Enable Poll High Request Interrupt to EC."/>
            <edc:AdjustPoint edc:offset="0x1"/>
            <edc:SFRFieldDef edc:cname="RXF_EMP" edc:nzwidth="0x1" edc:desc="Enable SREG RX FIFO Empty Interrupt to EC."/>
            <edc:SFRFieldDef edc:cname="RXF_FUL" edc:nzwidth="0x1" edc:desc="Enable RX FIFO Full Interrupt to EC."/>
            <edc:SFRFieldDef edc:cname="TXF_EMP" edc:nzwidth="0x1" edc:desc="Enable TX FIFO Empty Interrupt to EC."/>
            <edc:SFRFieldDef edc:cname="TXF_FUL" edc:nzwidth="0x1" edc:desc="Enable TX FIFI FULL Interrupt to EC."/>
            <edc:AdjustPoint edc:offset="0x1"/>
            <edc:SFRFieldDef edc:cname="TMCLK_CNT_ERR" edc:nzwidth="0x1" edc:desc="Enable Test Mode SPI Clock Count Error Interrupt to EC."/>
            <edc:SFRFieldDef edc:cname="IBF_FLG" edc:nzwidth="0x1" edc:desc="Enable Input Buffer Signaling Interrupt to EC."/>
            <edc:SFRFieldDef edc:cname="OBF_FLG" edc:nzwidth="0x1" edc:desc="Enable Output Buffer signaling Interrupt to EC."/>
            <edc:SFRFieldDef edc:cname="SPIM_RST_REQ" edc:nzwidth="0x1" edc:desc="Enable SPI Master Request Reset Interrupt to EC."/>
            <edc:SFRFieldDef edc:cname="RXF_RST_DN" edc:nzwidth="0x1" edc:desc="Enable RX FIFO Reset Done Interrupt to EC."/>
            <edc:SFRFieldDef edc:cname="TXF_RST_DN" edc:nzwidth="0x1" edc:desc="Enable TX FIFO Reset Done Interrupt to EC."/>
            <edc:SFRFieldDef edc:cname="OOL0_ERR" edc:nzwidth="0x1" edc:desc="Enable Out Of Limit 0 Error Interrupt to EC."/>
            <edc:SFRFieldDef edc:cname="OOL1_ERR" edc:nzwidth="0x1" edc:desc="Enable Out Of Limit 1 Error Interrupt to EC."/>
            <edc:SFRFieldDef edc:cname="ARMBUS_ERR" edc:nzwidth="0x1" edc:desc="Enable AHB BUS Error Interrupt to EC."/>
            <edc:SFRFieldDef edc:cname="UNDEF_CMD_ERR" edc:nzwidth="0x1" edc:desc="Enable Undefined Command Error Interrupt to EC."/>
            <edc:SFRFieldDef edc:cname="DV_BUSY" edc:nzwidth="0x1" edc:desc="Enable Device Busy Interrupt to EC."/>
            <edc:SFRFieldDef edc:cname="RXF_SIZE_ERR" edc:nzwidth="0x1" edc:desc="Enable RX FIFO SIZE Error Interrupt to EC."/>
            <edc:SFRFieldDef edc:cname="TXF_UNFLW" edc:nzwidth="0x1" edc:desc="Enable TX FIFO Underflow Interrupt to EC."/>
            <edc:SFRFieldDef edc:cname="TXF_OVRFLW" edc:nzwidth="0x1" edc:desc="Enable TX FIFO Overflow Interrupt to EC."/>
            <edc:SFRFieldDef edc:cname="RXF_UNFLW" edc:nzwidth="0x1" edc:desc="Enable RX FIFO Underflow Interrupt to EC."/>
            <edc:SFRFieldDef edc:cname="RXF_OVRFLW" edc:nzwidth="0x1" edc:desc="Enable RX FIFO Overflow Interrupt to EC."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPT1" edc:cname="MEM_CFG" edc:nzwidth="0x20" edc:access="------------------------------nn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x3" edc:_addr="0x40006C14">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPT1">
            <edc:SFRFieldDef edc:cname="BAR_EN0_SEL" edc:nzwidth="0x1" edc:desc="Enables Region 0 operation.         0 = Disable Region 0.         1 = Enable Region 0."/>
            <edc:SFRFieldDef edc:cname="BAR_EN1_SEL" edc:nzwidth="0x1" edc:desc="Enables Region 1 operation.         0 = Disable Region 1.         1 = Enable Region 1."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPT1" edc:cname="MEM_BAR0" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x40006C18">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPT1">
            <edc:SFRFieldDef edc:cname="BAS_ADD0" edc:nzwidth="0x20" edc:desc="Base Address for Region 0."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPT1" edc:cname="MEM_WR_LIM0" edc:nzwidth="0x20" edc:access="-----------------nnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x7FFF" edc:_addr="0x40006C1C">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPT1">
            <edc:SFRFieldDef edc:cname="LMT0" edc:nzwidth="0xF" edc:desc="Write Limit for Region 0."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPT1" edc:cname="MEM_RD_LIM0" edc:nzwidth="0x20" edc:access="-----------------nnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x7FFF" edc:_addr="0x40006C20">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPT1">
            <edc:SFRFieldDef edc:cname="LMT0" edc:nzwidth="0xF" edc:desc="Read Limit for Region 0."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPT1" edc:cname="MEM_BAR1" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x40006C24">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPT1">
            <edc:SFRFieldDef edc:cname="ADD1" edc:nzwidth="0x20" edc:desc="Base Address for Region 1."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPT1" edc:cname="MEM_WR_LIM1" edc:nzwidth="0x20" edc:access="-----------------nnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x7FFF" edc:_addr="0x40006C28">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPT1">
            <edc:SFRFieldDef edc:cname="LMT1" edc:nzwidth="0xF" edc:desc="Write Limit for Region 1."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPT1" edc:cname="MEM_RD_LIM1" edc:nzwidth="0x20" edc:access="-----------------nnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x7FFF" edc:_addr="0x40006C2C">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPT1">
            <edc:SFRFieldDef edc:cname="LMT1" edc:nzwidth="0xF" edc:desc="Read Limit for Region 1."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPT1" edc:cname="RXF_HOST_BAR" edc:nzwidth="0x20" edc:access="----------------rrrrrrrrrrrrrrrr" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0xFFFF" edc:_addr="0x40006C30">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPT1">
            <edc:SFRFieldDef edc:cname="BAR" edc:nzwidth="0x10" edc:desc="RX FIFO Host Bar Register."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPT1" edc:cname="RXF_BYTE_CNT" edc:nzwidth="0x20" edc:access="-----------------rrrrrrrrrrrrrrr" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x7FFF" edc:_addr="0x40006C34">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPT1">
            <edc:SFRFieldDef edc:cname="BCNT" edc:nzwidth="0xF" edc:desc="RX FIFO Byte Count Register."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPT1" edc:cname="TXF_HOST_BAR" edc:nzwidth="0x20" edc:access="----------------rrrrrrrrrrrrrrrr" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0xFFFF" edc:_addr="0x40006C38">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPT1">
            <edc:SFRFieldDef edc:cname="BAR" edc:nzwidth="0x10" edc:desc="TX FIFO Host Bar Register."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPT1" edc:cname="TXF_BYTE_CNT" edc:nzwidth="0x20" edc:access="-----------------rrrrrrrrrrrrrrr" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x7FFF" edc:_addr="0x40006C3C">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPT1">
            <edc:SFRFieldDef edc:cname="BCNT" edc:nzwidth="0xF" edc:desc="TX FIFO Byte Count Register."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPT1" edc:cname="SYS_CFG" edc:nzwidth="0x20" edc:access="------------nnnn-----n--nnnnnnnn" edc:por="00000000000000000000010011000000" edc:mclr="00000000000000000000010011000000" edc:impl="0xF04FF" edc:_addr="0x40006C40">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPT1">
            <edc:SFRFieldDef edc:cname="SOFT_RST" edc:nzwidth="0x1" edc:desc="Soft reset for entire SPI Peripheral Target Block. This bit is self clearing."/>
            <edc:SFRFieldDef edc:cname="LOCK_QUAD_SNGL_WRMOD" edc:nzwidth="0x1" edc:desc="Lock Quad / Single Write Mode bit, write access from SPI Master."/>
            <edc:SFRFieldDef edc:cname="LOCK_TAR_TIME" edc:nzwidth="0x1" edc:desc="Lock Tar Time bit, write access from SPI Master."/>
            <edc:SFRFieldDef edc:cname="LOCK_WAIT_CYCL" edc:nzwidth="0x1" edc:desc="Lock Wait Cycle bits, write access from SPI Master."/>
            <edc:SFRFieldDef edc:cname="LOCK_MEM_CFG" edc:nzwidth="0x1" edc:desc="Lock Memory Configuration register, write access from SPI Master."/>
            <edc:SFRFieldDef edc:cname="LOCK_SPIINT_EN" edc:nzwidth="0x1" edc:desc="Lock SPI Interrupt Enable register, write access from SPI Master."/>
            <edc:SFRFieldDef edc:cname="LOCK_MEM_BAR0" edc:nzwidth="0x1" edc:desc="Lock Memory Bar 0 register, write access from SPI Master."/>
            <edc:SFRFieldDef edc:cname="LOCK_MEM_BAR1" edc:nzwidth="0x1" edc:desc="Lock Memory Bar 1 register, write access from SPI Master."/>
            <edc:AdjustPoint edc:offset="0x2"/>
            <edc:SFRFieldDef edc:cname="LOCK_TEST_MODE" edc:nzwidth="0x1" edc:desc="Lock TEST Mode register, write access from SPI Master."/>
            <edc:AdjustPoint edc:offset="0x5"/>
            <edc:SFRFieldDef edc:cname="SPI_SLV_EN" edc:nzwidth="0x1" edc:desc="Enable / Disable SPI Peripheral Target Block.         0 = Disable SPI Peripheral Target module.         1 = Enable SPI Peripheral Target module."/>
            <edc:SFRFieldDef edc:cname="MAS_ECREG" edc:nzwidth="0x1" edc:desc="Fixed in hardware to 1"/>
            <edc:SFRFieldDef edc:cname="SIM_EN" edc:nzwidth="0x1" edc:desc="Enable SPI Peripheral Target Simple Mode operation."/>
            <edc:SFRFieldDef edc:cname="ECDATL" edc:nzwidth="0x1" edc:desc="Notification to TX FIFO Engine that data is available for AHB Transfer. This register         but is cleared by Hardware at the end of the transaction, with SPI_CS_N de-assertion.         (R/WC)."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPT1" edc:cname="SPIM2EC_MBX" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x40006C44">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPT1">
            <edc:SFRFieldDef edc:cname="M2EC" edc:nzwidth="0x20" edc:desc="Write only register for the Host. When data is written to this register the IBF Flag         is set. EC can read the data and writes of 0xFFFF will clear this register. Any form of         read will clear the flag for this register."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPT1" edc:cname="EC2SPIM_MBX" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x40006C48">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPT1">
            <edc:SFRFieldDef edc:cname="EC2M" edc:nzwidth="0x20" edc:desc="Read only register for the Host. When data is written to this register the OBF Flag         is set. Host can read the data and writes of 0xFFFF_FFFF will clear this register, also         clearing the flag. Any form of read will clear the flag for this register"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:AdjustPoint edc:offset="0x3B4" edc:_addr="0x40006C4C"/>
      <edc:SFRDef ltx:memberofperipheral="SPT0" edc:cname="SPI_CFG" edc:nzwidth="0x20" edc:access="--------nnnnnnnn-----nnn-------n" edc:por="00000000000001000000000000000000" edc:mclr="00000000000001000000000000000000" edc:impl="0xFF0701" edc:_addr="0x40007000">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPT0">
            <edc:SFRFieldDef edc:cname="SNG_QUD_SEL" edc:nzwidth="0x1" edc:desc="This field defines the Single / Quad Wire mode of operation for SPI Peripheral Target block.         0 = Single Wire Slave SPI block operation.         1 = Quad Wire Slave SPI block operation."/>
            <edc:AdjustPoint edc:offset="0x7"/>
            <edc:SFRFieldDef edc:cname="TAR_TIM_SEL" edc:nzwidth="0x3" edc:desc="Turn Around Time select for Quad wire mode.         0h = 1 cycle.         1h = 2 cycles.         2h = 4 cycles.         3h = 8 cycles.         Other values are reserved.">
              <edc:SFRFieldSemantic edc:cname="TAR_TIME_1_CYCLE" edc:desc="1 cycle" edc:when="(field &amp; 0x7) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="TAR_TIME_2_CYCLE" edc:desc="2 cycle" edc:when="(field &amp; 0x7) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="TAR_TIME_4_CYCLE" edc:desc="4 cycle" edc:when="(field &amp; 0x7) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="TAR_TIME_8_CYCLE" edc:desc="8 cycle" edc:when="(field &amp; 0x7) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:AdjustPoint edc:offset="0x5"/>
            <edc:SFRFieldDef edc:cname="WAIT_TIME" edc:nzwidth="0x8" edc:desc="These bits set the amount of wait time in cycles before transmitting data back to master.         During this wait time status bits will be transmitted"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPT0" edc:cname="SPI_STS" edc:nzwidth="0x20" edc:access="---nnnnnnnnnnnnnnnn-nnnn-nnnn-nn" edc:por="00000000000000000000010100000000" edc:mclr="00000000000000000000010100000000" edc:impl="0x1FFFEF7B" edc:_addr="0x40007004">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPT0">
            <edc:SFRFieldDef edc:cname="MEM_WR_DONE" edc:nzwidth="0x1" edc:desc="When the ARM BUS side has fully finished the last transaction from the FIFO to write the data to         Memory for Posted Writes . Clear with new Write request."/>
            <edc:SFRFieldDef edc:cname="MEM_RD_DONE" edc:nzwidth="0x1" edc:desc="When the ARM BUS side has fully finished writing the last written DWord to the FIFO for a set of data         read from Memory for Posted Reads. - cleared with new Read request."/>
            <edc:AdjustPoint edc:offset="0x1"/>
            <edc:SFRFieldDef edc:cname="MEM_WR_BUSY" edc:nzwidth="0x1" edc:desc="When an Memory Write transaction is currently being processed."/>
            <edc:SFRFieldDef edc:cname="MEM_RD_BUSY" edc:nzwidth="0x1" edc:desc="When an Memory Read transaction is currently being processed."/>
            <edc:SFRFieldDef edc:cname="SREG_TRANS" edc:nzwidth="0x1" edc:desc="When an SREG transaction is currently being processed."/>
            <edc:SFRFieldDef edc:cname="POLL_HIGH" edc:nzwidth="0x1" edc:desc="If this bit is set, then something in the high 16-bit of status register is set and needs to be checked.         SPI Master should take action to clear this."/>
            <edc:AdjustPoint edc:offset="0x1"/>
            <edc:SFRFieldDef edc:cname="RXF_EMP" edc:nzwidth="0x1" edc:desc="Signifies all Memory write transactions for the SPI Masters requested size have been performed.         New transactions are allowed."/>
            <edc:SFRFieldDef edc:cname="RXF_FUL" edc:nzwidth="0x1" edc:desc="The RX FIFO is full of data to be written to Memory."/>
            <edc:SFRFieldDef edc:cname="TXF_EMP" edc:nzwidth="0x1" edc:desc="Signifies SPI Master has read the data requested from Memory. Can be used to show there is data         the SPI Master has requested and not been read yet. New read transactions will be aligned."/>
            <edc:SFRFieldDef edc:cname="TXF_FUL" edc:nzwidth="0x1" edc:desc="The TX FIFO is full of data that was read from Memory."/>
            <edc:AdjustPoint edc:offset="0x1"/>
            <edc:SFRFieldDef edc:cname="TMCLK_CNT_ERR" edc:nzwidth="0x1" edc:desc="This bit is set when the SPI Clock Count Test Mode is set and there is an uneven amount of clocks."/>
            <edc:SFRFieldDef edc:cname="IBF_FLG" edc:nzwidth="0x1" edc:desc="Set when the Host writes to the Input Buffer signaling there is data for the EC to read."/>
            <edc:SFRFieldDef edc:cname="OBF_FLG" edc:nzwidth="0x1" edc:desc="Set when the EC writes to the Output Buffer signaling there is data for the Host to read."/>
            <edc:SFRFieldDef edc:cname="SPIM_RST_REQ" edc:nzwidth="0x1" edc:desc="Set when the SPI Master Requested a Configuration Reset."/>
            <edc:SFRFieldDef edc:cname="RXF_RST_DN" edc:nzwidth="0x1" edc:desc="Set after the SPI Master initiates a RX FIFO reset and the reset has been processed. FIFO is cleared."/>
            <edc:SFRFieldDef edc:cname="TXF_RST_DN" edc:nzwidth="0x1" edc:desc="Set after the SPI Master initiates a TX FIFO reset and the reset has been processed. FIFO is cleared."/>
            <edc:SFRFieldDef edc:cname="OOL0_ERR" edc:nzwidth="0x1" edc:desc="This flag is set with the transfer address requested by the master is out of Limit 0 range or when the BAR is disabled."/>
            <edc:SFRFieldDef edc:cname="OOL1_ERR" edc:nzwidth="0x1" edc:desc="This flag is set with the transfer address requested by the master is out of Limit 1 range or when the BAR is disabled."/>
            <edc:SFRFieldDef edc:cname="ARMBUS_ERR" edc:nzwidth="0x1" edc:desc="ARM Bus Error returned for the curren data transfer."/>
            <edc:SFRFieldDef edc:cname="UNDEF_CMD_ERR" edc:nzwidth="0x1" edc:desc="Undefined Command Error: The command received from the master isn't defined."/>
            <edc:SFRFieldDef edc:cname="DV_BUSY" edc:nzwidth="0x1" edc:desc="If the Master requested a transaction whose destination is busy the request is ignored.         Should use the poll or wait for interrupts."/>
            <edc:SFRFieldDef edc:cname="RXF_SIZE_ERR" edc:nzwidth="0x1" edc:desc="If size requested is more than what Master provided and the Master terminates early error flag         shut down request signal to ARM Bus. Size requested is less than what Master provided -- ignored and         continue transaction, may be taking in garbage."/>
            <edc:SFRFieldDef edc:cname="TXF_UNFLW" edc:nzwidth="0x1" edc:desc="If Master reads more than what is in FIFO, FIFO will flag an underflow error and the data returned         will just be the last valid pointer value."/>
            <edc:SFRFieldDef edc:cname="TXF_OVRFLW" edc:nzwidth="0x1" edc:desc="If Master doesn't read all of the data it requested from the posted read block cycle, than data         will still be left in the FIFO. This will cause misalignment with the following transactions and a new         read cycle can cause overflow."/>
            <edc:SFRFieldDef edc:cname="RXF_UNFLW" edc:nzwidth="0x1" edc:desc="If the SPI Peripheral Target reads RX FIFO when it is empty, RX FIFO Underflow flag will be set. This condition         will never happen under normal situation."/>
            <edc:SFRFieldDef edc:cname="RXF_OVRFLW" edc:nzwidth="0x1" edc:desc="If SPI Master writes more than the space in the FIFO, the FIFO will flag an overflow error and data         will not be stored."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPT0" edc:cname="SPI_EC_STS" edc:nzwidth="0x20" edc:access="---nnnnnnnnnnnnnnnn-nnnn-nnnn-nn" edc:por="00000000000000000000010100000000" edc:mclr="00000000000000000000010100000000" edc:impl="0x1FFFEF7B" edc:_addr="0x40007008">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPT0">
            <edc:SFRFieldDef edc:cname="MEM_WR_DONE" edc:nzwidth="0x1" edc:desc="When the ARM BUS side has fully finished the last transaction from the FIFO to write the data to         Memory for Posted Writes .- clear with new Write request."/>
            <edc:SFRFieldDef edc:cname="MEM_RD_DONE" edc:nzwidth="0x1" edc:desc="When the ARM BUS side has fully finished writing the last written DWord to the FIFO for a set of data         read from Memory for Posted Reads. - cleared with new Read request."/>
            <edc:AdjustPoint edc:offset="0x1"/>
            <edc:SFRFieldDef edc:cname="MEM_WR_BUSY" edc:nzwidth="0x1" edc:desc="When an Memory Write transaction is currently being processed."/>
            <edc:SFRFieldDef edc:cname="MEM_RD_BUSY" edc:nzwidth="0x1" edc:desc="When an Memory Read transaction is currently being processed."/>
            <edc:SFRFieldDef edc:cname="SREG_TRANS" edc:nzwidth="0x1" edc:desc="When an SREG transaction is currently being processed."/>
            <edc:SFRFieldDef edc:cname="POLL_HI" edc:nzwidth="0x1" edc:desc="If this bit is set, then something in the high 16-bit of status register is set and needs to be checked.         SPI Master should take action to clear this."/>
            <edc:AdjustPoint edc:offset="0x1"/>
            <edc:SFRFieldDef edc:cname="RXF_EMP" edc:nzwidth="0x1" edc:desc="Signifies all Memory write transactions for the SPI Masters requested size have been performed.         New transactions are allowed."/>
            <edc:SFRFieldDef edc:cname="RXF_FUL" edc:nzwidth="0x1" edc:desc="The RX FIFO is full of data to be written to Memory."/>
            <edc:SFRFieldDef edc:cname="TXF_EMP" edc:nzwidth="0x1" edc:desc="Signifies SPI Master has read the data requested from Memory. Can be used to show there is data         the SPI Master has requested and not been read yet. New read transactions will be aligned."/>
            <edc:SFRFieldDef edc:cname="TXF_FUL" edc:nzwidth="0x1" edc:desc="The TX FIFO is full of data that was read from Memory."/>
            <edc:AdjustPoint edc:offset="0x1"/>
            <edc:SFRFieldDef edc:cname="TMCLK_CNT_ERR" edc:nzwidth="0x1" edc:desc="This bit is set when the SPI Clock Count Test Mode is set and there is an uneven amount of clocks."/>
            <edc:SFRFieldDef edc:cname="IBF_FLG" edc:nzwidth="0x1" edc:desc="Set when the Host writes to the Input Buffer signaling there is data for the EC to read."/>
            <edc:SFRFieldDef edc:cname="OBF_FLG" edc:nzwidth="0x1" edc:desc="Set when the EC writes to the Output Buffer signaling there is data for the Host to read."/>
            <edc:SFRFieldDef edc:cname="SPIM_RST_REQ" edc:nzwidth="0x1" edc:desc="Set when the SPI Master Requested a Configuration Reset."/>
            <edc:SFRFieldDef edc:cname="RXF_RST_DN" edc:nzwidth="0x1" edc:desc="Set after the SPI Master initiates a RX FIFO reset and the reset has been processed. FIFO is cleared."/>
            <edc:SFRFieldDef edc:cname="TXF_RST_DN" edc:nzwidth="0x1" edc:desc="Set after the SPI Master initiates a TX FIFO reset and the reset has been processed. FIFO is cleared."/>
            <edc:SFRFieldDef edc:cname="OOL0_ERR" edc:nzwidth="0x1" edc:desc="This flag is set with the transfer address requested by the master is out of Limit 0 range or when the BAR is disabled."/>
            <edc:SFRFieldDef edc:cname="OOL1_ERR" edc:nzwidth="0x1" edc:desc="This flag is set with the transfer address requested by the master is out of Limit 1 range or when the BAR is disabled."/>
            <edc:SFRFieldDef edc:cname="ARMBUS_ERR" edc:nzwidth="0x1" edc:desc="ARM Bus Error returned for the curren data transfer."/>
            <edc:SFRFieldDef edc:cname="UNDEF_CMD_ERR" edc:nzwidth="0x1" edc:desc="Undefined Command Error: The command received from the master isn't defined."/>
            <edc:SFRFieldDef edc:cname="DV_BUSY" edc:nzwidth="0x1" edc:desc="If the Master requested a transaction whose destination is busy the request is ignored.         Should use the poll or wait for interrupts."/>
            <edc:SFRFieldDef edc:cname="RXF_SIZE_ERR" edc:nzwidth="0x1" edc:desc="If size requested is more than what Master provided and the Master terminates early error flag         shut down request signal to ARM Bus. Size requested is less than what Master provided -- ignored and         continue transaction, may be taking in garbage."/>
            <edc:SFRFieldDef edc:cname="TXF_UNFLW" edc:nzwidth="0x1" edc:desc="If Master reads more than what is in FIFO, FIFO will flag an underflow error and the data returned         will just be the last valid pointer value."/>
            <edc:SFRFieldDef edc:cname="TXF_OVRFLW" edc:nzwidth="0x1" edc:desc="If Master doesn't read all of the data it requested from the posted read block cycle, than data         will still be left in the FIFO. This will cause misalignment with the following transactions and a new         read cycle can cause overflow."/>
            <edc:SFRFieldDef edc:cname="RXF_UNFLW" edc:nzwidth="0x1" edc:desc="If the SPI Peripheral Target reads RX FIFO when it is empty, RX FIFO Underflow flag will be set. This condition         will never happen under normal situation."/>
            <edc:SFRFieldDef edc:cname="RXF_OVRFLW" edc:nzwidth="0x1" edc:desc="If SPI Master writes more than the space in the FIFO, the FIFO will flag an overflow error and data         will not be stored."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPT0" edc:cname="SPI_IEN" edc:nzwidth="0x20" edc:access="---nnnnnnnnnnnnnnnn-nnnn-nnnn-nn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x1FFFEF7B" edc:_addr="0x4000700C">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPT0">
            <edc:SFRFieldDef edc:cname="MEM_WR_DONE" edc:nzwidth="0x1" edc:desc="Enable Memory Write Done Interrupt to SPI Master."/>
            <edc:SFRFieldDef edc:cname="MEM_RD_DONE" edc:nzwidth="0x1" edc:desc="Enable Memory Read Done Interrupt to SPI Master."/>
            <edc:AdjustPoint edc:offset="0x1"/>
            <edc:SFRFieldDef edc:cname="MEM_WR_BUSY" edc:nzwidth="0x1" edc:desc="Enable Memory Write Busy Interrupt to SPI Master."/>
            <edc:SFRFieldDef edc:cname="MEM_RD_BUSY" edc:nzwidth="0x1" edc:desc="Enable Memory Read Busy Interrupt to SPI Master."/>
            <edc:SFRFieldDef edc:cname="SREG_TRANS" edc:nzwidth="0x1" edc:desc="Enable SREG Trans Busy Interrupt to SPI Master."/>
            <edc:SFRFieldDef edc:cname="POLL_HI" edc:nzwidth="0x1" edc:desc="Enable Poll High Request Interrupt to SPI Master."/>
            <edc:AdjustPoint edc:offset="0x1"/>
            <edc:SFRFieldDef edc:cname="RXF_EMP" edc:nzwidth="0x1" edc:desc="Enable SREG RX FIFO Empty Interrupt to SPI Master."/>
            <edc:SFRFieldDef edc:cname="RXF_FUL" edc:nzwidth="0x1" edc:desc="Enable RX FIFO Full Interrupt to SPI Master."/>
            <edc:SFRFieldDef edc:cname="TXF_EMP" edc:nzwidth="0x1" edc:desc="Enable TX FIFO Empty Interrupt to SPI Master."/>
            <edc:SFRFieldDef edc:cname="TXF_FUL" edc:nzwidth="0x1" edc:desc="Enable TX FIFI FULL Interrupt to SPI Master."/>
            <edc:AdjustPoint edc:offset="0x1"/>
            <edc:SFRFieldDef edc:cname="TMCLK_CNT_ERR" edc:nzwidth="0x1" edc:desc="Enable Test Mode SPI Clock Count Error Interrupt to SPI Master."/>
            <edc:SFRFieldDef edc:cname="IBF_FLG" edc:nzwidth="0x1" edc:desc="Enable Input Buffer Signaling Interrupt to SPI Master."/>
            <edc:SFRFieldDef edc:cname="OBF_FLG" edc:nzwidth="0x1" edc:desc="Enable Output Buffer signaling Interrupt to SPI Master."/>
            <edc:SFRFieldDef edc:cname="SPIM_RST_REQ" edc:nzwidth="0x1" edc:desc="Enable SPI Master Request Reset Interrupt to SPI Master."/>
            <edc:SFRFieldDef edc:cname="RXF_RST_DN" edc:nzwidth="0x1" edc:desc="Enable RX FIFO Reset Done Interrupt to SPI Master."/>
            <edc:SFRFieldDef edc:cname="TXF_RST_DN" edc:nzwidth="0x1" edc:desc="Enable TX FIFO Reset Done Interrupt to SPI Master."/>
            <edc:SFRFieldDef edc:cname="OOL0_ERR" edc:nzwidth="0x1" edc:desc="Enable Out Of Limit 0 Error Interrupt to SPI Master."/>
            <edc:SFRFieldDef edc:cname="OOL1_ERR" edc:nzwidth="0x1" edc:desc="Enable Out Of Limit 1 Error Interrupt to SPI Master."/>
            <edc:SFRFieldDef edc:cname="ARMBUS_ERR" edc:nzwidth="0x1" edc:desc="Enable AHB BUS Error Interrupt to SPI Master."/>
            <edc:SFRFieldDef edc:cname="UNDEF_CMD_ERR" edc:nzwidth="0x1" edc:desc="Enable Undefined Command Error Interrupt to SPI Master."/>
            <edc:SFRFieldDef edc:cname="DV_BUSY" edc:nzwidth="0x1" edc:desc="Enable Device Busy Interrupt to SPI Master."/>
            <edc:SFRFieldDef edc:cname="RXF_SIZE_ERR" edc:nzwidth="0x1" edc:desc="Enable RX FIFO SIZE Error Interrupt to SPI Master."/>
            <edc:SFRFieldDef edc:cname="TXF_UNFLW" edc:nzwidth="0x1" edc:desc="Enable TX FIFO Underflow Interrupt to SPI Master."/>
            <edc:SFRFieldDef edc:cname="TXF_OVRFLOW" edc:nzwidth="0x1" edc:desc="Enable TX FIFO Overflow Interrupt to SPI Master."/>
            <edc:SFRFieldDef edc:cname="RXF_UNFLW" edc:nzwidth="0x1" edc:desc="Enable RX FIFO Underflow Interrupt to SPI Master."/>
            <edc:SFRFieldDef edc:cname="RXF_OVRFLW" edc:nzwidth="0x1" edc:desc="Enable RX FIFO Overflow Interrupt to SPI Master."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPT0" edc:cname="EC_IEN" edc:nzwidth="0x20" edc:access="---nnnnnnnnnnnnnnnn-nnnn-nnnn-nn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x1FFFEF7B" edc:_addr="0x40007010">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPT0">
            <edc:SFRFieldDef edc:cname="MEM_WR_DONE" edc:nzwidth="0x1" edc:desc="Enable Memory Write Done Interrupt to EC."/>
            <edc:SFRFieldDef edc:cname="MEM_RD_DONE" edc:nzwidth="0x1" edc:desc="Enable Memory Read Done Interrupt to EC."/>
            <edc:AdjustPoint edc:offset="0x1"/>
            <edc:SFRFieldDef edc:cname="MEM_WR_BUSY" edc:nzwidth="0x1" edc:desc="Enable Memory Write Busy Interrupt to EC."/>
            <edc:SFRFieldDef edc:cname="MEM_RD_BUSY" edc:nzwidth="0x1" edc:desc="Enable Memory Read Busy Interrupt to EC."/>
            <edc:SFRFieldDef edc:cname="SREG_TRANS" edc:nzwidth="0x1" edc:desc="Enable SREG Trans Busy Interrupt to EC."/>
            <edc:SFRFieldDef edc:cname="POLL_HI" edc:nzwidth="0x1" edc:desc="Enable Poll High Request Interrupt to EC."/>
            <edc:AdjustPoint edc:offset="0x1"/>
            <edc:SFRFieldDef edc:cname="RXF_EMP" edc:nzwidth="0x1" edc:desc="Enable SREG RX FIFO Empty Interrupt to EC."/>
            <edc:SFRFieldDef edc:cname="RXF_FUL" edc:nzwidth="0x1" edc:desc="Enable RX FIFO Full Interrupt to EC."/>
            <edc:SFRFieldDef edc:cname="TXF_EMP" edc:nzwidth="0x1" edc:desc="Enable TX FIFO Empty Interrupt to EC."/>
            <edc:SFRFieldDef edc:cname="TXF_FUL" edc:nzwidth="0x1" edc:desc="Enable TX FIFI FULL Interrupt to EC."/>
            <edc:AdjustPoint edc:offset="0x1"/>
            <edc:SFRFieldDef edc:cname="TMCLK_CNT_ERR" edc:nzwidth="0x1" edc:desc="Enable Test Mode SPI Clock Count Error Interrupt to EC."/>
            <edc:SFRFieldDef edc:cname="IBF_FLG" edc:nzwidth="0x1" edc:desc="Enable Input Buffer Signaling Interrupt to EC."/>
            <edc:SFRFieldDef edc:cname="OBF_FLG" edc:nzwidth="0x1" edc:desc="Enable Output Buffer signaling Interrupt to EC."/>
            <edc:SFRFieldDef edc:cname="SPIM_RST_REQ" edc:nzwidth="0x1" edc:desc="Enable SPI Master Request Reset Interrupt to EC."/>
            <edc:SFRFieldDef edc:cname="RXF_RST_DN" edc:nzwidth="0x1" edc:desc="Enable RX FIFO Reset Done Interrupt to EC."/>
            <edc:SFRFieldDef edc:cname="TXF_RST_DN" edc:nzwidth="0x1" edc:desc="Enable TX FIFO Reset Done Interrupt to EC."/>
            <edc:SFRFieldDef edc:cname="OOL0_ERR" edc:nzwidth="0x1" edc:desc="Enable Out Of Limit 0 Error Interrupt to EC."/>
            <edc:SFRFieldDef edc:cname="OOL1_ERR" edc:nzwidth="0x1" edc:desc="Enable Out Of Limit 1 Error Interrupt to EC."/>
            <edc:SFRFieldDef edc:cname="ARMBUS_ERR" edc:nzwidth="0x1" edc:desc="Enable AHB BUS Error Interrupt to EC."/>
            <edc:SFRFieldDef edc:cname="UNDEF_CMD_ERR" edc:nzwidth="0x1" edc:desc="Enable Undefined Command Error Interrupt to EC."/>
            <edc:SFRFieldDef edc:cname="DV_BUSY" edc:nzwidth="0x1" edc:desc="Enable Device Busy Interrupt to EC."/>
            <edc:SFRFieldDef edc:cname="RXF_SIZE_ERR" edc:nzwidth="0x1" edc:desc="Enable RX FIFO SIZE Error Interrupt to EC."/>
            <edc:SFRFieldDef edc:cname="TXF_UNFLW" edc:nzwidth="0x1" edc:desc="Enable TX FIFO Underflow Interrupt to EC."/>
            <edc:SFRFieldDef edc:cname="TXF_OVRFLW" edc:nzwidth="0x1" edc:desc="Enable TX FIFO Overflow Interrupt to EC."/>
            <edc:SFRFieldDef edc:cname="RXF_UNFLW" edc:nzwidth="0x1" edc:desc="Enable RX FIFO Underflow Interrupt to EC."/>
            <edc:SFRFieldDef edc:cname="RXF_OVRFLW" edc:nzwidth="0x1" edc:desc="Enable RX FIFO Overflow Interrupt to EC."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPT0" edc:cname="MEM_CFG" edc:nzwidth="0x20" edc:access="------------------------------nn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x3" edc:_addr="0x40007014">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPT0">
            <edc:SFRFieldDef edc:cname="BAR_EN0_SEL" edc:nzwidth="0x1" edc:desc="Enables Region 0 operation.         0 = Disable Region 0.         1 = Enable Region 0."/>
            <edc:SFRFieldDef edc:cname="BAR_EN1_SEL" edc:nzwidth="0x1" edc:desc="Enables Region 1 operation.         0 = Disable Region 1.         1 = Enable Region 1."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPT0" edc:cname="MEM_BAR0" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x40007018">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPT0">
            <edc:SFRFieldDef edc:cname="BAS_ADD0" edc:nzwidth="0x20" edc:desc="Base Address for Region 0."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPT0" edc:cname="MEM_WR_LIM0" edc:nzwidth="0x20" edc:access="-----------------nnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x7FFF" edc:_addr="0x4000701C">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPT0">
            <edc:SFRFieldDef edc:cname="LMT0" edc:nzwidth="0xF" edc:desc="Write Limit for Region 0."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPT0" edc:cname="MEM_RD_LIM0" edc:nzwidth="0x20" edc:access="-----------------nnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x7FFF" edc:_addr="0x40007020">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPT0">
            <edc:SFRFieldDef edc:cname="LMT0" edc:nzwidth="0xF" edc:desc="Read Limit for Region 0."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPT0" edc:cname="MEM_BAR1" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x40007024">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPT0">
            <edc:SFRFieldDef edc:cname="ADD1" edc:nzwidth="0x20" edc:desc="Base Address for Region 1."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPT0" edc:cname="MEM_WR_LIM1" edc:nzwidth="0x20" edc:access="-----------------nnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x7FFF" edc:_addr="0x40007028">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPT0">
            <edc:SFRFieldDef edc:cname="LMT1" edc:nzwidth="0xF" edc:desc="Write Limit for Region 1."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPT0" edc:cname="MEM_RD_LIM1" edc:nzwidth="0x20" edc:access="-----------------nnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x7FFF" edc:_addr="0x4000702C">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPT0">
            <edc:SFRFieldDef edc:cname="LMT1" edc:nzwidth="0xF" edc:desc="Read Limit for Region 1."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPT0" edc:cname="RXF_HOST_BAR" edc:nzwidth="0x20" edc:access="----------------rrrrrrrrrrrrrrrr" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0xFFFF" edc:_addr="0x40007030">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPT0">
            <edc:SFRFieldDef edc:cname="BAR" edc:nzwidth="0x10" edc:desc="RX FIFO Host Bar Register."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPT0" edc:cname="RXF_BYTE_CNT" edc:nzwidth="0x20" edc:access="-----------------rrrrrrrrrrrrrrr" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x7FFF" edc:_addr="0x40007034">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPT0">
            <edc:SFRFieldDef edc:cname="BCNT" edc:nzwidth="0xF" edc:desc="RX FIFO Byte Count Register."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPT0" edc:cname="TXF_HOST_BAR" edc:nzwidth="0x20" edc:access="----------------rrrrrrrrrrrrrrrr" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0xFFFF" edc:_addr="0x40007038">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPT0">
            <edc:SFRFieldDef edc:cname="BAR" edc:nzwidth="0x10" edc:desc="TX FIFO Host Bar Register."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPT0" edc:cname="TXF_BYTE_CNT" edc:nzwidth="0x20" edc:access="-----------------rrrrrrrrrrrrrrr" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x7FFF" edc:_addr="0x4000703C">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPT0">
            <edc:SFRFieldDef edc:cname="BCNT" edc:nzwidth="0xF" edc:desc="TX FIFO Byte Count Register."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPT0" edc:cname="SYS_CFG" edc:nzwidth="0x20" edc:access="------------nnnn-----n--nnnnnnnn" edc:por="00000000000000000000010011000000" edc:mclr="00000000000000000000010011000000" edc:impl="0xF04FF" edc:_addr="0x40007040">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPT0">
            <edc:SFRFieldDef edc:cname="SOFT_RST" edc:nzwidth="0x1" edc:desc="Soft reset for entire SPI Peripheral Target Block. This bit is self clearing."/>
            <edc:SFRFieldDef edc:cname="LOCK_QUAD_SNGL_WRMOD" edc:nzwidth="0x1" edc:desc="Lock Quad / Single Write Mode bit, write access from SPI Master."/>
            <edc:SFRFieldDef edc:cname="LOCK_TAR_TIME" edc:nzwidth="0x1" edc:desc="Lock Tar Time bit, write access from SPI Master."/>
            <edc:SFRFieldDef edc:cname="LOCK_WAIT_CYCL" edc:nzwidth="0x1" edc:desc="Lock Wait Cycle bits, write access from SPI Master."/>
            <edc:SFRFieldDef edc:cname="LOCK_MEM_CFG" edc:nzwidth="0x1" edc:desc="Lock Memory Configuration register, write access from SPI Master."/>
            <edc:SFRFieldDef edc:cname="LOCK_SPIINT_EN" edc:nzwidth="0x1" edc:desc="Lock SPI Interrupt Enable register, write access from SPI Master."/>
            <edc:SFRFieldDef edc:cname="LOCK_MEM_BAR0" edc:nzwidth="0x1" edc:desc="Lock Memory Bar 0 register, write access from SPI Master."/>
            <edc:SFRFieldDef edc:cname="LOCK_MEM_BAR1" edc:nzwidth="0x1" edc:desc="Lock Memory Bar 1 register, write access from SPI Master."/>
            <edc:AdjustPoint edc:offset="0x2"/>
            <edc:SFRFieldDef edc:cname="LOCK_TEST_MODE" edc:nzwidth="0x1" edc:desc="Lock TEST Mode register, write access from SPI Master."/>
            <edc:AdjustPoint edc:offset="0x5"/>
            <edc:SFRFieldDef edc:cname="SPI_SLV_EN" edc:nzwidth="0x1" edc:desc="Enable / Disable SPI Peripheral Target Block.         0 = Disable SPI Peripheral Target module.         1 = Enable SPI Peripheral Target module."/>
            <edc:SFRFieldDef edc:cname="MAS_ECREG" edc:nzwidth="0x1" edc:desc="Fixed in hardware to 1"/>
            <edc:SFRFieldDef edc:cname="SIM_EN" edc:nzwidth="0x1" edc:desc="Enable SPI Peripheral Target Simple Mode operation."/>
            <edc:SFRFieldDef edc:cname="ECDATL" edc:nzwidth="0x1" edc:desc="Notification to TX FIFO Engine that data is available for AHB Transfer. This register         but is cleared by Hardware at the end of the transaction, with SPI_CS_N de-assertion.         (R/WC)."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPT0" edc:cname="SPIM2EC_MBX" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x40007044">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPT0">
            <edc:SFRFieldDef edc:cname="M2EC" edc:nzwidth="0x20" edc:desc="Write only register for the Host. When data is written to this register the IBF Flag         is set. EC can read the data and writes of 0xFFFF will clear this register. Any form of         read will clear the flag for this register."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPT0" edc:cname="EC2SPIM_MBX" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x40007048">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPT0">
            <edc:SFRFieldDef edc:cname="EC2M" edc:nzwidth="0x20" edc:desc="Read only register for the Host. When data is written to this register the OBF Flag         is set. Host can read the data and writes of 0xFFFF_FFFF will clear this register, also         clearing the flag. Any form of read will clear the flag for this register"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:AdjustPoint edc:offset="0x3B4" edc:_addr="0x4000704C"/>
      <edc:SFRDef ltx:memberofperipheral="RTOS" edc:cname="CNT" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x40007400">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="RTOS">
            <edc:SFRFieldDef edc:cname="CNTR" edc:nzwidth="0x20" edc:desc="This register contains the current value of the RTOS Timer counter. This register should be read as a DWORD. There is no latching mechanism         of the upper bytes implemented if the register is accessed as a byte or word. Reading the register with byte or word operations may give incorrect results."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="RTOS" edc:cname="PRLD" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x40007404">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="RTOS">
            <edc:SFRFieldDef edc:cname="PRELOAD" edc:nzwidth="0x20" edc:desc="The this register is loaded into the RTOS Timer counter either when the TIMER_START bit is written with a 1, or when the timer counter counts down to 0 and the AUTO_RELOAD bit is 1.      This register must be programmed with a new count value before the TIMER_START bit is set to 1. If this register is updated while the counter is operating, the new count value will only take effect if      the counter transitions form 1 to 0 while the AUTO_RELOAD bit is set."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="RTOS" edc:cname="CTRL" edc:nzwidth="0x20" edc:access="---------------------------nnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x1F" edc:_addr="0x40007408">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="RTOS">
            <edc:SFRFieldDef edc:cname="BLK_EN" edc:nzwidth="0x1" edc:desc="1=RTOS timer counter is enabled     0=RTOS timer disabled. All register bits are reset to their default state"/>
            <edc:SFRFieldDef edc:cname="AU_RELOAD" edc:nzwidth="0x1" edc:desc="1=The the RTOS Timer Preload Register is loaded into the timer counter and the counter is restarted when the counter transitions from 1 to 0     0=The timer counter halts when it transitions from 1 to 0 and will not restart."/>
            <edc:SFRFieldDef edc:cname="TMR_STRT" edc:nzwidth="0x1" edc:desc="Writing a 1 to this bit will load the timer counter with the RTOS Timer Preload Register and start counting. If the Preload Register is 0, counting will not start and this bit will be cleared to 0.     Writing a 0 to this bit will halt the counter and clear its contents to 0. The RTOS timer interrupt will not be generated. This bit is automatically cleared if the AUTO_RELOAD bit is 0 and the     timer counter transitions from 1 to 0."/>
            <edc:SFRFieldDef edc:cname="EXT_HW_HALT_EN" edc:nzwidth="0x1" edc:desc="1=The timer counter is halted when the external HALT signal is asserted. Counting is always enabled if HALT is de-asserted.     0=The HALT signal does not affect the RTOS Timer"/>
            <edc:SFRFieldDef edc:cname="FW_TMR_HALT" edc:nzwidth="0x1" edc:desc="1=The timer counter is halted. If the counter was running, clearing this bit will restart the counter from the value at which it halted     0=The timer counter, if enabled, will continue to run"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="RTOS" edc:cname="SOFTIRQ" edc:nzwidth="0x20" edc:access="----------------------------wwww" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0xF" edc:_addr="0x4000740C">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="RTOS">
            <edc:SFRFieldDef edc:cname="SWI0" edc:nzwidth="0x1" edc:desc="Software Interrupt. A write of a '1' to this bit will generate an SWI interrupt to the EC.     Writes of a '0' have no effect. Reads return '0'."/>
            <edc:SFRFieldDef edc:cname="SWI1" edc:nzwidth="0x1" edc:desc="Software Interrupt. A write of a '1' to this bit will generate an SWI interrupt to the EC.     Writes of a '0' have no effect. Reads return '0'."/>
            <edc:SFRFieldDef edc:cname="SWI2" edc:nzwidth="0x1" edc:desc="Software Interrupt. A write of a '1' to this bit will generate an SWI interrupt to the EC.     Writes of a '0' have no effect. Reads return '0'."/>
            <edc:SFRFieldDef edc:cname="SWI3" edc:nzwidth="0x1" edc:desc="Software Interrupt. A write of a '1' to this bit will generate an SWI interrupt to the EC.     Writes of a '0' have no effect. Reads return '0'."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:AdjustPoint edc:offset="0x17F0" edc:_addr="0x40007410"/>
      <edc:SFRDef ltx:memberofperipheral="TFDP" edc:cname="MSDATA" edc:nzwidth="0x8" edc:access="nnnnnnnn" edc:por="00000000" edc:mclr="00000000" edc:_addr="0x40008C00"/>
      <edc:AdjustPoint edc:offset="0x3" edc:_addr="0x40008C01"/>
      <edc:SFRDef ltx:memberofperipheral="TFDP" edc:cname="CTRL" edc:nzwidth="0x8" edc:access="-nnnnnnn" edc:por="00000000" edc:mclr="00000000" edc:impl="0x7F" edc:_addr="0x40008C04">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="TFDP">
            <edc:SFRFieldDef edc:cname="EN" edc:nzwidth="0x1" edc:desc="Enable. 1=Clock enabled, 0=Clock is disabled (Default)"/>
            <edc:SFRFieldDef edc:cname="EDGE_SEL" edc:nzwidth="0x1" edc:desc="1= Data is shifted out on the falling edge of the debug clock, 0= Data is shifted out on the rising edge of the debug clock (Default)"/>
            <edc:SFRFieldDef edc:cname="DIVSEL" edc:nzwidth="0x2" edc:desc="Clock Divider Select."/>
            <edc:SFRFieldDef edc:cname="IP_DLY" edc:nzwidth="0x3" edc:desc="Inter-packet Delay. The delay is in terms of TFDP Debug output clocks."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:AdjustPoint edc:offset="0xBFB" edc:_addr="0x40008C05"/>
      <edc:SFRDef ltx:memberofperipheral="HTM0" edc:cname="PRLD" edc:nzwidth="0x10" edc:access="nnnnnnnnnnnnnnnn" edc:por="0000000000000000" edc:mclr="0000000000000000" edc:_addr="0x40009800"/>
      <edc:AdjustPoint edc:offset="0x2" edc:_addr="0x40009802"/>
      <edc:SFRDef ltx:memberofperipheral="HTM0" edc:cname="CTRL" edc:nzwidth="0x10" edc:access="---------------n" edc:por="0000000000000000" edc:mclr="0000000000000000" edc:impl="0x1" edc:_addr="0x40009804">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="HTM0">
            <edc:SFRFieldDef edc:cname="CTRL" edc:nzwidth="0x1" edc:desc="1= The Hibernation Timer has a resolution of 0.125s per LSB, which yields a maximum time in excess of 2 hours.     0= The Hibernation Timer has a resolution of 30.5us per LSB, which yields a maximum time of ~2seconds."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:AdjustPoint edc:offset="0x2" edc:_addr="0x40009806"/>
      <edc:SFRDef ltx:memberofperipheral="HTM0" edc:cname="CNT" edc:nzwidth="0x10" edc:access="rrrrrrrrrrrrrrrr" edc:por="0000000000000000" edc:mclr="0000000000000000" edc:_addr="0x40009808"/>
      <edc:AdjustPoint edc:offset="0x16" edc:_addr="0x4000980A"/>
      <edc:SFRDef ltx:memberofperipheral="HTM1" edc:cname="PRLD" edc:nzwidth="0x10" edc:access="nnnnnnnnnnnnnnnn" edc:por="0000000000000000" edc:mclr="0000000000000000" edc:_addr="0x40009820"/>
      <edc:AdjustPoint edc:offset="0x2" edc:_addr="0x40009822"/>
      <edc:SFRDef ltx:memberofperipheral="HTM1" edc:cname="CTRL" edc:nzwidth="0x10" edc:access="---------------n" edc:por="0000000000000000" edc:mclr="0000000000000000" edc:impl="0x1" edc:_addr="0x40009824">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="HTM1">
            <edc:SFRFieldDef edc:cname="CTRL" edc:nzwidth="0x1" edc:desc="1= The Hibernation Timer has a resolution of 0.125s per LSB, which yields a maximum time in excess of 2 hours.     0= The Hibernation Timer has a resolution of 30.5us per LSB, which yields a maximum time of ~2seconds."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:AdjustPoint edc:offset="0x2" edc:_addr="0x40009826"/>
      <edc:SFRDef ltx:memberofperipheral="HTM1" edc:cname="CNT" edc:nzwidth="0x10" edc:access="rrrrrrrrrrrrrrrr" edc:por="0000000000000000" edc:mclr="0000000000000000" edc:_addr="0x40009828"/>
      <edc:AdjustPoint edc:offset="0xBD6" edc:_addr="0x4000982A"/>
      <edc:SFRDef ltx:memberofperipheral="VTR_REG_BANK" edc:cname="PFRS" edc:nzwidth="0x20" edc:access="-------------------------nnn-n-n" edc:por="00000000000000000000000010000000" edc:mclr="00000000000000000000000010000000" edc:impl="0x75" edc:_addr="0x4000A400">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="VTR_REG_BANK">
            <edc:SFRFieldDef edc:cname="DET_32KHZ" edc:nzwidth="0x1" edc:desc="Detect 32KHz Clock Input (R/WC)"/>
            <edc:AdjustPoint edc:offset="0x1"/>
            <edc:SFRFieldDef edc:cname="SFT_RST" edc:nzwidth="0x1" edc:desc="This bit is set to '1b' if a was triggered by an assertion of the SOFT_SYS_RESET bit in the System Reset Register.      This bit is cleared to '0b' when written with a '1b'; writes of a '0b' have no effect. (R/WC)"/>
            <edc:AdjustPoint edc:offset="0x1"/>
            <edc:SFRFieldDef edc:cname="RSTI" edc:nzwidth="0x1" edc:desc="This bit is set to '1b' if a RESET_SYS was triggered by a low signal on the RESETI# input pin. This bit is      cleared to '0b' when written with a '1b'; writes of a '0b' have no effect. (R/WC)"/>
            <edc:SFRFieldDef edc:cname="WDT_EVT" edc:nzwidth="0x1" edc:desc="This bit is set to '1b' if a RESET_SYS was triggered by a Watchdog Timer event. This bit is cleared to '0b' when      written with a '1b'; writes of a '0b' have no effect. (R/WC)"/>
            <edc:SFRFieldDef edc:cname="SYS_RSTREQ" edc:nzwidth="0x1" edc:desc="This bit is set to '1b' if a RESET_SYS was triggered by an ARM SYSRESETREQ event. This bit is cleared to '0b' when      written with a '1b'; writes of a '0b' have no effect. (R/WC)"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:AdjustPoint edc:offset="0x13FC" edc:_addr="0x4000A404"/>
      <edc:SFRDef ltx:memberofperipheral="LED0" edc:cname="CFG" edc:nzwidth="0x20" edc:access="---------------nnnnnnnnnnnnnnnnn" edc:por="00000000000000000001010000000000" edc:mclr="00000000000000000001010000000000" edc:impl="0x1FFFF" edc:_addr="0x4000B800">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="LED0">
            <edc:SFRFieldDef edc:cname="CTRL" edc:nzwidth="0x2" edc:desc="CONTROL 3=PWM is always on                  2=LED blinking (standard PWM)                  1=LED breathing configuration                  0=PWM is always off. All internal registers and counters are reset to 0. Clocks are gated">
              <edc:SFRFieldSemantic edc:cname="PWM_ALWAYS_OFF" edc:desc="PWM is always off" edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="LED_BREATHING" edc:desc="LED Breathing" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="LED_BLINKING" edc:desc="LED Blinking" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="PWM_ALWAYS_ON" edc:desc="PWM is always on" edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="CLK_SRC" edc:nzwidth="0x1" edc:desc="1=Clock source is the 48 MHz clock, 0=Clock source is the 32.768 KHz clock">
              <edc:SFRFieldSemantic edc:cname="LED_CLK_SRC_32KHZ" edc:desc="32.768 KHz clock" edc:when="(field &amp; 0x1) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="LED_CLK_SRC_48MHZ" edc:desc="48 MHz clock" edc:when="(field &amp; 0x1) == 0x01"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="SYNCH" edc:nzwidth="0x1" edc:desc="SYNCHRONIZE  When this bit is '1', all counters for all LEDs are reset to their initial values. When this bit is '0' in the LED Configuration Register for all LEDs, then all counters for LEDs that are configured to blink or breathe will increment or decrement, as required."/>
            <edc:SFRFieldDef edc:cname="PWM_SIZE" edc:nzwidth="0x2" edc:desc="PWM_SIZE This bit controls the behavior of PWM:                  3=Reserved                  2=PWM is configured as a 6-bit PWM                  1=PWM is configured as a 7-bit PWM                  0=PWM is configured as an 8-bit PWM">
              <edc:SFRFieldSemantic edc:cname="PWM_SIZE_8BIT" edc:desc="PWM is configured as an 8-bit PWM" edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="PWM_SIZE_7BIT" edc:desc="PWM is configured as an 7-bit PWM" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="PWM_SIZE_6BIT" edc:desc="PWM is configured as an 6-bit PWM" edc:when="(field &amp; 0x3) == 0x02"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="EN_UPDATE" edc:nzwidth="0x1" edc:desc="ENABLE_UPDATE  This bit is set to 1 when written with a '1'. Writes of '0' have no effect. Hardware clears this bit to 0 when the breathing configuration registers are updated at the end of a PWM period. The current state of the bit is readable any time."/>
            <edc:SFRFieldDef edc:cname="RST" edc:nzwidth="0x1" edc:desc="RESET  Writes of '1' to this bit resets the PWM registers to their default values. This bit is self clearing. Writes of '0' to this bit have no effect."/>
            <edc:SFRFieldDef edc:cname="WDT_RELOAD" edc:nzwidth="0x8" edc:desc="WDT_RELOAD  The PWM Watchdog Timer counter reload value. On system reset, it defaults to 14h, which corresponds to a 4 second Watchdog timeout value."/>
            <edc:SFRFieldDef edc:cname="SYMMETRY" edc:nzwidth="0x1" edc:desc="SYMMETRY  1=The rising and falling ramp times are in Asymmetric mode.                  0=The rising and falling ramp times are in Symmetric mode."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="LED0" edc:cname="LIMIT" edc:nzwidth="0x20" edc:access="----------------nnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0xFFFF" edc:_addr="0x4000B804">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="LED0">
            <edc:SFRFieldDef edc:cname="MIN" edc:nzwidth="0x8" edc:desc="In breathing mode, when the current duty cycle is less than or equal to this value the breathing apparatus holds the current duty cycle for the period specified by the field LD in register LED_DELAY, then starts incrementing the current duty cycle In blinking mode, this field defines the duty cycle of the blink function."/>
            <edc:SFRFieldDef edc:cname="MAX" edc:nzwidth="0x8" edc:desc="In breathing mode, when the current duty cycle is greater than or equal to this value the breathing apparatus holds the current duty cycle for the period specified by the field HD in register LED_DELAY, then starts decrementing the current duty cycle"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="LED0" edc:cname="DLY" edc:nzwidth="0x20" edc:access="--------nnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0xFFFFFF" edc:_addr="0x4000B808">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="LED0">
            <edc:SFRFieldDef edc:cname="LOW_PULSE" edc:nzwidth="0xC" edc:desc="The number of PWM periods to wait before updating the current duty cycle when the current duty cycle is greater than or equal to the value MIN in register LED_LIMIT."/>
            <edc:SFRFieldDef edc:cname="HIGH_PULSE" edc:nzwidth="0xC" edc:desc="In breathing mode, the number of PWM periods to wait before updating the current duty cycle when the current duty cycle is greater than or equal to the value MAX in register LED_LIMIT."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="LED0" edc:cname="STEP" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x4000B80C">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="LED0">
            <edc:SFRFieldDef edc:cname="S0" edc:nzwidth="0x4" edc:desc="Amount the current duty cycle is adjusted at the end of every PWM period when the segment index is equal to 000."/>
            <edc:SFRFieldDef edc:cname="S1" edc:nzwidth="0x4" edc:desc="Amount the current duty cycle is adjusted at the end of every PWM period when the segment index is equal to 001."/>
            <edc:SFRFieldDef edc:cname="S2" edc:nzwidth="0x4" edc:desc="Amount the current duty cycle is adjusted at the end of every PWM period when the segment index is equal to 010."/>
            <edc:SFRFieldDef edc:cname="S3" edc:nzwidth="0x4" edc:desc="Amount the current duty cycle is adjusted at the end of every PWM period when the segment index is equal to 011."/>
            <edc:SFRFieldDef edc:cname="S4" edc:nzwidth="0x4" edc:desc="Amount the current duty cycle is adjusted at the end of every PWM period when the segment index is equal to 100."/>
            <edc:SFRFieldDef edc:cname="S5" edc:nzwidth="0x4" edc:desc="Amount the current duty cycle is adjusted at the end of every PWM period when the segment index is equal to 101"/>
            <edc:SFRFieldDef edc:cname="S6" edc:nzwidth="0x4" edc:desc="Amount the current duty cycle is adjusted at the end of every PWM period when the segment index is equal to 110."/>
            <edc:SFRFieldDef edc:cname="S7" edc:nzwidth="0x4" edc:desc="Amount the current duty cycle is adjusted at the end of every PWM period when the segment index is equal to 111."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="LED0" edc:cname="INTRVL" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x4000B810">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="LED0">
            <edc:SFRFieldDef edc:cname="I0" edc:nzwidth="0x4" edc:desc="The number of PWM periods between updates to current duty cycle when the segment index is equal to 000b."/>
            <edc:SFRFieldDef edc:cname="I1" edc:nzwidth="0x4" edc:desc="The number of PWM periods between updates to current duty cycle when the segment index is equal to 001b."/>
            <edc:SFRFieldDef edc:cname="I2" edc:nzwidth="0x4" edc:desc="The number of PWM periods between updates to current duty cycle when the segment index is equal to 010b."/>
            <edc:SFRFieldDef edc:cname="I3" edc:nzwidth="0x4" edc:desc="The number of PWM periods between updates to current duty cycle when the segment index is equal to 011b."/>
            <edc:SFRFieldDef edc:cname="I4" edc:nzwidth="0x4" edc:desc="The number of PWM periods between updates to current duty cycle when the segment index is equal to 100b."/>
            <edc:SFRFieldDef edc:cname="I5" edc:nzwidth="0x4" edc:desc="The number of PWM periods between updates to current duty cycle when the segment index is equal to 101b."/>
            <edc:SFRFieldDef edc:cname="I6" edc:nzwidth="0x4" edc:desc="The number of PWM periods between updates to current duty cycle when the segment index is equal to 110b."/>
            <edc:SFRFieldDef edc:cname="I7" edc:nzwidth="0x4" edc:desc="The number of PWM periods between updates to current duty cycle when the segment index is equal to 111b."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="LED0" edc:cname="OUTDLY" edc:nzwidth="0x20" edc:access="------------------------nnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0xFF" edc:_addr="0x4000B814">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="LED0">
            <edc:SFRFieldDef edc:cname="DELAY" edc:nzwidth="0x8" edc:desc="The delay, in counts of the clock defined in Clock Source (CLKSRC), in which output transitions are delayed.     When this field is 0, there is no added transition delay. When the LED is programmed to be Always On or Always Off, the     Output Delay field has no effect."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:AdjustPoint edc:offset="0xE8" edc:_addr="0x4000B818"/>
      <edc:SFRDef ltx:memberofperipheral="LED1" edc:cname="CFG" edc:nzwidth="0x20" edc:access="---------------nnnnnnnnnnnnnnnnn" edc:por="00000000000000000001010000000000" edc:mclr="00000000000000000001010000000000" edc:impl="0x1FFFF" edc:_addr="0x4000B900">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="LED1">
            <edc:SFRFieldDef edc:cname="CTRL" edc:nzwidth="0x2" edc:desc="CONTROL 3=PWM is always on                  2=LED blinking (standard PWM)                  1=LED breathing configuration                  0=PWM is always off. All internal registers and counters are reset to 0. Clocks are gated">
              <edc:SFRFieldSemantic edc:cname="PWM_ALWAYS_OFF" edc:desc="PWM is always off" edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="LED_BREATHING" edc:desc="LED Breathing" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="LED_BLINKING" edc:desc="LED Blinking" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="PWM_ALWAYS_ON" edc:desc="PWM is always on" edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="CLK_SRC" edc:nzwidth="0x1" edc:desc="1=Clock source is the 48 MHz clock, 0=Clock source is the 32.768 KHz clock">
              <edc:SFRFieldSemantic edc:cname="LED_CLK_SRC_32KHZ" edc:desc="32.768 KHz clock" edc:when="(field &amp; 0x1) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="LED_CLK_SRC_48MHZ" edc:desc="48 MHz clock" edc:when="(field &amp; 0x1) == 0x01"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="SYNCH" edc:nzwidth="0x1" edc:desc="SYNCHRONIZE  When this bit is '1', all counters for all LEDs are reset to their initial values. When this bit is '0' in the LED Configuration Register for all LEDs, then all counters for LEDs that are configured to blink or breathe will increment or decrement, as required."/>
            <edc:SFRFieldDef edc:cname="PWM_SIZE" edc:nzwidth="0x2" edc:desc="PWM_SIZE This bit controls the behavior of PWM:                  3=Reserved                  2=PWM is configured as a 6-bit PWM                  1=PWM is configured as a 7-bit PWM                  0=PWM is configured as an 8-bit PWM">
              <edc:SFRFieldSemantic edc:cname="PWM_SIZE_8BIT" edc:desc="PWM is configured as an 8-bit PWM" edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="PWM_SIZE_7BIT" edc:desc="PWM is configured as an 7-bit PWM" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="PWM_SIZE_6BIT" edc:desc="PWM is configured as an 6-bit PWM" edc:when="(field &amp; 0x3) == 0x02"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="EN_UPDATE" edc:nzwidth="0x1" edc:desc="ENABLE_UPDATE  This bit is set to 1 when written with a '1'. Writes of '0' have no effect. Hardware clears this bit to 0 when the breathing configuration registers are updated at the end of a PWM period. The current state of the bit is readable any time."/>
            <edc:SFRFieldDef edc:cname="RST" edc:nzwidth="0x1" edc:desc="RESET  Writes of '1' to this bit resets the PWM registers to their default values. This bit is self clearing. Writes of '0' to this bit have no effect."/>
            <edc:SFRFieldDef edc:cname="WDT_RELOAD" edc:nzwidth="0x8" edc:desc="WDT_RELOAD  The PWM Watchdog Timer counter reload value. On system reset, it defaults to 14h, which corresponds to a 4 second Watchdog timeout value."/>
            <edc:SFRFieldDef edc:cname="SYMMETRY" edc:nzwidth="0x1" edc:desc="SYMMETRY  1=The rising and falling ramp times are in Asymmetric mode.                  0=The rising and falling ramp times are in Symmetric mode."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="LED1" edc:cname="LIMIT" edc:nzwidth="0x20" edc:access="----------------nnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0xFFFF" edc:_addr="0x4000B904">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="LED1">
            <edc:SFRFieldDef edc:cname="MIN" edc:nzwidth="0x8" edc:desc="In breathing mode, when the current duty cycle is less than or equal to this value the breathing apparatus holds the current duty cycle for the period specified by the field LD in register LED_DELAY, then starts incrementing the current duty cycle In blinking mode, this field defines the duty cycle of the blink function."/>
            <edc:SFRFieldDef edc:cname="MAX" edc:nzwidth="0x8" edc:desc="In breathing mode, when the current duty cycle is greater than or equal to this value the breathing apparatus holds the current duty cycle for the period specified by the field HD in register LED_DELAY, then starts decrementing the current duty cycle"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="LED1" edc:cname="DLY" edc:nzwidth="0x20" edc:access="--------nnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0xFFFFFF" edc:_addr="0x4000B908">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="LED1">
            <edc:SFRFieldDef edc:cname="LOW_PULSE" edc:nzwidth="0xC" edc:desc="The number of PWM periods to wait before updating the current duty cycle when the current duty cycle is greater than or equal to the value MIN in register LED_LIMIT."/>
            <edc:SFRFieldDef edc:cname="HIGH_PULSE" edc:nzwidth="0xC" edc:desc="In breathing mode, the number of PWM periods to wait before updating the current duty cycle when the current duty cycle is greater than or equal to the value MAX in register LED_LIMIT."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="LED1" edc:cname="STEP" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x4000B90C">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="LED1">
            <edc:SFRFieldDef edc:cname="S0" edc:nzwidth="0x4" edc:desc="Amount the current duty cycle is adjusted at the end of every PWM period when the segment index is equal to 000."/>
            <edc:SFRFieldDef edc:cname="S1" edc:nzwidth="0x4" edc:desc="Amount the current duty cycle is adjusted at the end of every PWM period when the segment index is equal to 001."/>
            <edc:SFRFieldDef edc:cname="S2" edc:nzwidth="0x4" edc:desc="Amount the current duty cycle is adjusted at the end of every PWM period when the segment index is equal to 010."/>
            <edc:SFRFieldDef edc:cname="S3" edc:nzwidth="0x4" edc:desc="Amount the current duty cycle is adjusted at the end of every PWM period when the segment index is equal to 011."/>
            <edc:SFRFieldDef edc:cname="S4" edc:nzwidth="0x4" edc:desc="Amount the current duty cycle is adjusted at the end of every PWM period when the segment index is equal to 100."/>
            <edc:SFRFieldDef edc:cname="S5" edc:nzwidth="0x4" edc:desc="Amount the current duty cycle is adjusted at the end of every PWM period when the segment index is equal to 101"/>
            <edc:SFRFieldDef edc:cname="S6" edc:nzwidth="0x4" edc:desc="Amount the current duty cycle is adjusted at the end of every PWM period when the segment index is equal to 110."/>
            <edc:SFRFieldDef edc:cname="S7" edc:nzwidth="0x4" edc:desc="Amount the current duty cycle is adjusted at the end of every PWM period when the segment index is equal to 111."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="LED1" edc:cname="INTRVL" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x4000B910">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="LED1">
            <edc:SFRFieldDef edc:cname="I0" edc:nzwidth="0x4" edc:desc="The number of PWM periods between updates to current duty cycle when the segment index is equal to 000b."/>
            <edc:SFRFieldDef edc:cname="I1" edc:nzwidth="0x4" edc:desc="The number of PWM periods between updates to current duty cycle when the segment index is equal to 001b."/>
            <edc:SFRFieldDef edc:cname="I2" edc:nzwidth="0x4" edc:desc="The number of PWM periods between updates to current duty cycle when the segment index is equal to 010b."/>
            <edc:SFRFieldDef edc:cname="I3" edc:nzwidth="0x4" edc:desc="The number of PWM periods between updates to current duty cycle when the segment index is equal to 011b."/>
            <edc:SFRFieldDef edc:cname="I4" edc:nzwidth="0x4" edc:desc="The number of PWM periods between updates to current duty cycle when the segment index is equal to 100b."/>
            <edc:SFRFieldDef edc:cname="I5" edc:nzwidth="0x4" edc:desc="The number of PWM periods between updates to current duty cycle when the segment index is equal to 101b."/>
            <edc:SFRFieldDef edc:cname="I6" edc:nzwidth="0x4" edc:desc="The number of PWM periods between updates to current duty cycle when the segment index is equal to 110b."/>
            <edc:SFRFieldDef edc:cname="I7" edc:nzwidth="0x4" edc:desc="The number of PWM periods between updates to current duty cycle when the segment index is equal to 111b."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="LED1" edc:cname="OUTDLY" edc:nzwidth="0x20" edc:access="------------------------nnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0xFF" edc:_addr="0x4000B914">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="LED1">
            <edc:SFRFieldDef edc:cname="DELAY" edc:nzwidth="0x8" edc:desc="The delay, in counts of the clock defined in Clock Source (CLKSRC), in which output transitions are delayed.     When this field is 0, there is no added transition delay. When the LED is programmed to be Always On or Always Off, the     Output Delay field has no effect."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:AdjustPoint edc:offset="0x26E8" edc:_addr="0x4000B918"/>
      <edc:SFRDef ltx:memberofperipheral="ECIA" edc:cname="SRC8" edc:nzwidth="0x20" edc:access="------nn-nn-n---nn-----nnnnnn--n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x368C1F9" edc:_addr="0x4000E000">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="ECIA">
            <edc:SFRFieldDef edc:cname="GPIO140" edc:nzwidth="0x1" edc:desc="GPIO 140"/>
            <edc:AdjustPoint edc:offset="0x2"/>
            <edc:SFRFieldDef edc:cname="GPIO143" edc:nzwidth="0x1" edc:desc="GPIO 143"/>
            <edc:SFRFieldDef edc:cname="GPIO144" edc:nzwidth="0x1" edc:desc="GPIO 144"/>
            <edc:SFRFieldDef edc:cname="GPIO145" edc:nzwidth="0x1" edc:desc="GPIO 145"/>
            <edc:SFRFieldDef edc:cname="GPIO146" edc:nzwidth="0x1" edc:desc="GPIO 146"/>
            <edc:SFRFieldDef edc:cname="GPIO147" edc:nzwidth="0x1" edc:desc="GPIO 147"/>
            <edc:SFRFieldDef edc:cname="GPIO150" edc:nzwidth="0x1" edc:desc="GPIO 150"/>
            <edc:AdjustPoint edc:offset="0x5"/>
            <edc:SFRFieldDef edc:cname="GPIO156" edc:nzwidth="0x1" edc:desc="GPIO 156"/>
            <edc:SFRFieldDef edc:cname="GPIO157" edc:nzwidth="0x1" edc:desc="GPIO 157"/>
            <edc:AdjustPoint edc:offset="0x3"/>
            <edc:SFRFieldDef edc:cname="GPIO163" edc:nzwidth="0x1" edc:desc="GPIO 163"/>
            <edc:AdjustPoint edc:offset="0x1"/>
            <edc:SFRFieldDef edc:cname="GPIO165" edc:nzwidth="0x1" edc:desc="GPIO 165"/>
            <edc:SFRFieldDef edc:cname="GPIO166" edc:nzwidth="0x1" edc:desc="GPIO 166"/>
            <edc:AdjustPoint edc:offset="0x1"/>
            <edc:SFRFieldDef edc:cname="GPIO170" edc:nzwidth="0x1" edc:desc="GPIO 170"/>
            <edc:SFRFieldDef edc:cname="GPIO171" edc:nzwidth="0x1" edc:desc="GPIO 171"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="ECIA" edc:cname="EN_SET8" edc:nzwidth="0x20" edc:access="------nn-nn-n---nn-----nnnnnn--n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x368C1F9" edc:_addr="0x4000E004">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="ECIA">
            <edc:SFRFieldDef edc:cname="GPIO140" edc:nzwidth="0x1" edc:desc="GPIO 140"/>
            <edc:AdjustPoint edc:offset="0x2"/>
            <edc:SFRFieldDef edc:cname="GPIO143" edc:nzwidth="0x1" edc:desc="GPIO 143"/>
            <edc:SFRFieldDef edc:cname="GPIO144" edc:nzwidth="0x1" edc:desc="GPIO 144"/>
            <edc:SFRFieldDef edc:cname="GPIO145" edc:nzwidth="0x1" edc:desc="GPIO 145"/>
            <edc:SFRFieldDef edc:cname="GPIO146" edc:nzwidth="0x1" edc:desc="GPIO 146"/>
            <edc:SFRFieldDef edc:cname="GPIO147" edc:nzwidth="0x1" edc:desc="GPIO 147"/>
            <edc:SFRFieldDef edc:cname="GPIO150" edc:nzwidth="0x1" edc:desc="GPIO 150"/>
            <edc:AdjustPoint edc:offset="0x5"/>
            <edc:SFRFieldDef edc:cname="GPIO156" edc:nzwidth="0x1" edc:desc="GPIO 156"/>
            <edc:SFRFieldDef edc:cname="GPIO157" edc:nzwidth="0x1" edc:desc="GPIO 157"/>
            <edc:AdjustPoint edc:offset="0x3"/>
            <edc:SFRFieldDef edc:cname="GPIO163" edc:nzwidth="0x1" edc:desc="GPIO 163"/>
            <edc:AdjustPoint edc:offset="0x1"/>
            <edc:SFRFieldDef edc:cname="GPIO165" edc:nzwidth="0x1" edc:desc="GPIO 165"/>
            <edc:SFRFieldDef edc:cname="GPIO166" edc:nzwidth="0x1" edc:desc="GPIO 166"/>
            <edc:AdjustPoint edc:offset="0x1"/>
            <edc:SFRFieldDef edc:cname="GPIO170" edc:nzwidth="0x1" edc:desc="GPIO 170"/>
            <edc:SFRFieldDef edc:cname="GPIO171" edc:nzwidth="0x1" edc:desc="GPIO 171"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="ECIA" edc:cname="RESULT8" edc:nzwidth="0x20" edc:access="------rr-rr-r---rr-----rrrrrr--r" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x368C1F9" edc:_addr="0x4000E008">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="ECIA">
            <edc:SFRFieldDef edc:cname="GPIO140" edc:nzwidth="0x1" edc:desc="GPIO 140"/>
            <edc:AdjustPoint edc:offset="0x2"/>
            <edc:SFRFieldDef edc:cname="GPIO143" edc:nzwidth="0x1" edc:desc="GPIO 143"/>
            <edc:SFRFieldDef edc:cname="GPIO144" edc:nzwidth="0x1" edc:desc="GPIO 144"/>
            <edc:SFRFieldDef edc:cname="GPIO145" edc:nzwidth="0x1" edc:desc="GPIO 145"/>
            <edc:SFRFieldDef edc:cname="GPIO146" edc:nzwidth="0x1" edc:desc="GPIO 146"/>
            <edc:SFRFieldDef edc:cname="GPIO147" edc:nzwidth="0x1" edc:desc="GPIO 147"/>
            <edc:SFRFieldDef edc:cname="GPIO150" edc:nzwidth="0x1" edc:desc="GPIO 150"/>
            <edc:AdjustPoint edc:offset="0x5"/>
            <edc:SFRFieldDef edc:cname="GPIO156" edc:nzwidth="0x1" edc:desc="GPIO 156"/>
            <edc:SFRFieldDef edc:cname="GPIO157" edc:nzwidth="0x1" edc:desc="GPIO 157"/>
            <edc:AdjustPoint edc:offset="0x3"/>
            <edc:SFRFieldDef edc:cname="GPIO163" edc:nzwidth="0x1" edc:desc="GPIO 163"/>
            <edc:AdjustPoint edc:offset="0x1"/>
            <edc:SFRFieldDef edc:cname="GPIO165" edc:nzwidth="0x1" edc:desc="GPIO 165"/>
            <edc:SFRFieldDef edc:cname="GPIO166" edc:nzwidth="0x1" edc:desc="GPIO 166"/>
            <edc:AdjustPoint edc:offset="0x1"/>
            <edc:SFRFieldDef edc:cname="GPIO170" edc:nzwidth="0x1" edc:desc="GPIO 170"/>
            <edc:SFRFieldDef edc:cname="GPIO171" edc:nzwidth="0x1" edc:desc="GPIO 171"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="ECIA" edc:cname="EN_CLR8" edc:nzwidth="0x20" edc:access="------nn-nn-n---nn-----nnnnnn--n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x368C1F9" edc:_addr="0x4000E00C">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="ECIA">
            <edc:SFRFieldDef edc:cname="GPIO140" edc:nzwidth="0x1" edc:desc="GPIO 140"/>
            <edc:AdjustPoint edc:offset="0x2"/>
            <edc:SFRFieldDef edc:cname="GPIO143" edc:nzwidth="0x1" edc:desc="GPIO 143"/>
            <edc:SFRFieldDef edc:cname="GPIO144" edc:nzwidth="0x1" edc:desc="GPIO 144"/>
            <edc:SFRFieldDef edc:cname="GPIO145" edc:nzwidth="0x1" edc:desc="GPIO 145"/>
            <edc:SFRFieldDef edc:cname="GPIO146" edc:nzwidth="0x1" edc:desc="GPIO 146"/>
            <edc:SFRFieldDef edc:cname="GPIO147" edc:nzwidth="0x1" edc:desc="GPIO 147"/>
            <edc:SFRFieldDef edc:cname="GPIO150" edc:nzwidth="0x1" edc:desc="GPIO 150"/>
            <edc:AdjustPoint edc:offset="0x5"/>
            <edc:SFRFieldDef edc:cname="GPIO156" edc:nzwidth="0x1" edc:desc="GPIO 156"/>
            <edc:SFRFieldDef edc:cname="GPIO157" edc:nzwidth="0x1" edc:desc="GPIO 157"/>
            <edc:AdjustPoint edc:offset="0x3"/>
            <edc:SFRFieldDef edc:cname="GPIO163" edc:nzwidth="0x1" edc:desc="GPIO 163"/>
            <edc:AdjustPoint edc:offset="0x1"/>
            <edc:SFRFieldDef edc:cname="GPIO165" edc:nzwidth="0x1" edc:desc="GPIO 165"/>
            <edc:SFRFieldDef edc:cname="GPIO166" edc:nzwidth="0x1" edc:desc="GPIO 166"/>
            <edc:AdjustPoint edc:offset="0x1"/>
            <edc:SFRFieldDef edc:cname="GPIO170" edc:nzwidth="0x1" edc:desc="GPIO 170"/>
            <edc:SFRFieldDef edc:cname="GPIO171" edc:nzwidth="0x1" edc:desc="GPIO 171"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:AdjustPoint edc:offset="0x4" edc:_addr="0x4000E010"/>
      <edc:SFRDef ltx:memberofperipheral="ECIA" edc:cname="SRC9" edc:nzwidth="0x20" edc:access="-----nnnnnnnnnnn----nn--nnnn----" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x7FF0CF0" edc:_addr="0x4000E014">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="ECIA">
            <edc:AdjustPoint edc:offset="0x4"/>
            <edc:SFRFieldDef edc:cname="GPIO104" edc:nzwidth="0x1" edc:desc="GPIO 104"/>
            <edc:SFRFieldDef edc:cname="GPIO105" edc:nzwidth="0x1" edc:desc="GPIO 105"/>
            <edc:SFRFieldDef edc:cname="GPIO106" edc:nzwidth="0x1" edc:desc="GPIO 106"/>
            <edc:SFRFieldDef edc:cname="GPIO107" edc:nzwidth="0x1" edc:desc="GPIO 107"/>
            <edc:AdjustPoint edc:offset="0x2"/>
            <edc:SFRFieldDef edc:cname="GPIO112" edc:nzwidth="0x1" edc:desc="GPIO 112"/>
            <edc:SFRFieldDef edc:cname="GPIO113" edc:nzwidth="0x1" edc:desc="GPIO 113"/>
            <edc:AdjustPoint edc:offset="0x4"/>
            <edc:SFRFieldDef edc:cname="GPIO120" edc:nzwidth="0x1" edc:desc="GPIO 120"/>
            <edc:SFRFieldDef edc:cname="GPIO121" edc:nzwidth="0x1" edc:desc="GPIO 121"/>
            <edc:SFRFieldDef edc:cname="GPIO122" edc:nzwidth="0x1" edc:desc="GPIO 122"/>
            <edc:SFRFieldDef edc:cname="GPIO123" edc:nzwidth="0x1" edc:desc="GPIO 123"/>
            <edc:SFRFieldDef edc:cname="GPIO124" edc:nzwidth="0x1" edc:desc="GPIO 124"/>
            <edc:SFRFieldDef edc:cname="GPIO125" edc:nzwidth="0x1" edc:desc="GPIO 125"/>
            <edc:SFRFieldDef edc:cname="GPIO126" edc:nzwidth="0x1" edc:desc="GPIO 126"/>
            <edc:SFRFieldDef edc:cname="GPIO127" edc:nzwidth="0x1" edc:desc="GPIO 127"/>
            <edc:SFRFieldDef edc:cname="GPIO130" edc:nzwidth="0x1" edc:desc="GPIO 130"/>
            <edc:SFRFieldDef edc:cname="GPIO131" edc:nzwidth="0x1" edc:desc="GPIO 131"/>
            <edc:SFRFieldDef edc:cname="GPIO132" edc:nzwidth="0x1" edc:desc="GPIO 132"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="ECIA" edc:cname="EN_SET9" edc:nzwidth="0x20" edc:access="-----nnnnnnnnnnn----nn--nnnn----" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x7FF0CF0" edc:_addr="0x4000E018">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="ECIA">
            <edc:AdjustPoint edc:offset="0x4"/>
            <edc:SFRFieldDef edc:cname="GPIO104" edc:nzwidth="0x1" edc:desc="GPIO 104"/>
            <edc:SFRFieldDef edc:cname="GPIO105" edc:nzwidth="0x1" edc:desc="GPIO 105"/>
            <edc:SFRFieldDef edc:cname="GPIO106" edc:nzwidth="0x1" edc:desc="GPIO 106"/>
            <edc:SFRFieldDef edc:cname="GPIO107" edc:nzwidth="0x1" edc:desc="GPIO 107"/>
            <edc:AdjustPoint edc:offset="0x2"/>
            <edc:SFRFieldDef edc:cname="GPIO112" edc:nzwidth="0x1" edc:desc="GPIO 112"/>
            <edc:SFRFieldDef edc:cname="GPIO113" edc:nzwidth="0x1" edc:desc="GPIO 113"/>
            <edc:AdjustPoint edc:offset="0x4"/>
            <edc:SFRFieldDef edc:cname="GPIO120" edc:nzwidth="0x1" edc:desc="GPIO 120"/>
            <edc:SFRFieldDef edc:cname="GPIO121" edc:nzwidth="0x1" edc:desc="GPIO 121"/>
            <edc:SFRFieldDef edc:cname="GPIO122" edc:nzwidth="0x1" edc:desc="GPIO 122"/>
            <edc:SFRFieldDef edc:cname="GPIO123" edc:nzwidth="0x1" edc:desc="GPIO 123"/>
            <edc:SFRFieldDef edc:cname="GPIO124" edc:nzwidth="0x1" edc:desc="GPIO 124"/>
            <edc:SFRFieldDef edc:cname="GPIO125" edc:nzwidth="0x1" edc:desc="GPIO 125"/>
            <edc:SFRFieldDef edc:cname="GPIO126" edc:nzwidth="0x1" edc:desc="GPIO 126"/>
            <edc:SFRFieldDef edc:cname="GPIO127" edc:nzwidth="0x1" edc:desc="GPIO 127"/>
            <edc:SFRFieldDef edc:cname="GPIO130" edc:nzwidth="0x1" edc:desc="GPIO 130"/>
            <edc:SFRFieldDef edc:cname="GPIO131" edc:nzwidth="0x1" edc:desc="GPIO 131"/>
            <edc:SFRFieldDef edc:cname="GPIO132" edc:nzwidth="0x1" edc:desc="GPIO 132"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="ECIA" edc:cname="RESULT9" edc:nzwidth="0x20" edc:access="-----rrrrrrrrrrr----rr--rrrr----" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x7FF0CF0" edc:_addr="0x4000E01C">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="ECIA">
            <edc:AdjustPoint edc:offset="0x4"/>
            <edc:SFRFieldDef edc:cname="GPIO104" edc:nzwidth="0x1" edc:desc="GPIO 104"/>
            <edc:SFRFieldDef edc:cname="GPIO105" edc:nzwidth="0x1" edc:desc="GPIO 105"/>
            <edc:SFRFieldDef edc:cname="GPIO106" edc:nzwidth="0x1" edc:desc="GPIO 106"/>
            <edc:SFRFieldDef edc:cname="GPIO107" edc:nzwidth="0x1" edc:desc="GPIO 107"/>
            <edc:AdjustPoint edc:offset="0x2"/>
            <edc:SFRFieldDef edc:cname="GPIO112" edc:nzwidth="0x1" edc:desc="GPIO 112"/>
            <edc:SFRFieldDef edc:cname="GPIO113" edc:nzwidth="0x1" edc:desc="GPIO 113"/>
            <edc:AdjustPoint edc:offset="0x4"/>
            <edc:SFRFieldDef edc:cname="GPIO120" edc:nzwidth="0x1" edc:desc="GPIO 120"/>
            <edc:SFRFieldDef edc:cname="GPIO121" edc:nzwidth="0x1" edc:desc="GPIO 121"/>
            <edc:SFRFieldDef edc:cname="GPIO122" edc:nzwidth="0x1" edc:desc="GPIO 122"/>
            <edc:SFRFieldDef edc:cname="GPIO123" edc:nzwidth="0x1" edc:desc="GPIO 123"/>
            <edc:SFRFieldDef edc:cname="GPIO124" edc:nzwidth="0x1" edc:desc="GPIO 124"/>
            <edc:SFRFieldDef edc:cname="GPIO125" edc:nzwidth="0x1" edc:desc="GPIO 125"/>
            <edc:SFRFieldDef edc:cname="GPIO126" edc:nzwidth="0x1" edc:desc="GPIO 126"/>
            <edc:SFRFieldDef edc:cname="GPIO127" edc:nzwidth="0x1" edc:desc="GPIO 127"/>
            <edc:SFRFieldDef edc:cname="GPIO130" edc:nzwidth="0x1" edc:desc="GPIO 130"/>
            <edc:SFRFieldDef edc:cname="GPIO131" edc:nzwidth="0x1" edc:desc="GPIO 131"/>
            <edc:SFRFieldDef edc:cname="GPIO132" edc:nzwidth="0x1" edc:desc="GPIO 132"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="ECIA" edc:cname="EN_CLR9" edc:nzwidth="0x20" edc:access="-----nnnnnnnnnnn----nn--nnnn----" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x7FF0CF0" edc:_addr="0x4000E020">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="ECIA">
            <edc:AdjustPoint edc:offset="0x4"/>
            <edc:SFRFieldDef edc:cname="GPIO104" edc:nzwidth="0x1" edc:desc="GPIO 104"/>
            <edc:SFRFieldDef edc:cname="GPIO105" edc:nzwidth="0x1" edc:desc="GPIO 105"/>
            <edc:SFRFieldDef edc:cname="GPIO106" edc:nzwidth="0x1" edc:desc="GPIO 106"/>
            <edc:SFRFieldDef edc:cname="GPIO107" edc:nzwidth="0x1" edc:desc="GPIO 107"/>
            <edc:AdjustPoint edc:offset="0x2"/>
            <edc:SFRFieldDef edc:cname="GPIO112" edc:nzwidth="0x1" edc:desc="GPIO 112"/>
            <edc:SFRFieldDef edc:cname="GPIO113" edc:nzwidth="0x1" edc:desc="GPIO 113"/>
            <edc:AdjustPoint edc:offset="0x4"/>
            <edc:SFRFieldDef edc:cname="GPIO120" edc:nzwidth="0x1" edc:desc="GPIO 120"/>
            <edc:SFRFieldDef edc:cname="GPIO121" edc:nzwidth="0x1" edc:desc="GPIO 121"/>
            <edc:SFRFieldDef edc:cname="GPIO122" edc:nzwidth="0x1" edc:desc="GPIO 122"/>
            <edc:SFRFieldDef edc:cname="GPIO123" edc:nzwidth="0x1" edc:desc="GPIO 123"/>
            <edc:SFRFieldDef edc:cname="GPIO124" edc:nzwidth="0x1" edc:desc="GPIO 124"/>
            <edc:SFRFieldDef edc:cname="GPIO125" edc:nzwidth="0x1" edc:desc="GPIO 125"/>
            <edc:SFRFieldDef edc:cname="GPIO126" edc:nzwidth="0x1" edc:desc="GPIO 126"/>
            <edc:SFRFieldDef edc:cname="GPIO127" edc:nzwidth="0x1" edc:desc="GPIO 127"/>
            <edc:SFRFieldDef edc:cname="GPIO130" edc:nzwidth="0x1" edc:desc="GPIO 130"/>
            <edc:SFRFieldDef edc:cname="GPIO131" edc:nzwidth="0x1" edc:desc="GPIO 131"/>
            <edc:SFRFieldDef edc:cname="GPIO132" edc:nzwidth="0x1" edc:desc="GPIO 132"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:AdjustPoint edc:offset="0x4" edc:_addr="0x4000E024"/>
      <edc:SFRDef ltx:memberofperipheral="ECIA" edc:cname="SRC10" edc:nzwidth="0x20" edc:access="------nn----n---nnn-n--nnnn-----" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x308E9E0" edc:_addr="0x4000E028">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="ECIA">
            <edc:AdjustPoint edc:offset="0x5"/>
            <edc:SFRFieldDef edc:cname="GPIO045" edc:nzwidth="0x1" edc:desc="GPIO 045"/>
            <edc:SFRFieldDef edc:cname="GPIO046" edc:nzwidth="0x1" edc:desc="GPIO 046"/>
            <edc:SFRFieldDef edc:cname="GPIO047" edc:nzwidth="0x1" edc:desc="GPIO 047"/>
            <edc:SFRFieldDef edc:cname="GPIO050" edc:nzwidth="0x1" edc:desc="GPIO 050"/>
            <edc:AdjustPoint edc:offset="0x2"/>
            <edc:SFRFieldDef edc:cname="GPIO053" edc:nzwidth="0x1" edc:desc="GPIO 053"/>
            <edc:AdjustPoint edc:offset="0x1"/>
            <edc:SFRFieldDef edc:cname="GPIO055" edc:nzwidth="0x1" edc:desc="GPIO 055"/>
            <edc:SFRFieldDef edc:cname="GPIO056" edc:nzwidth="0x1" edc:desc="GPIO 056"/>
            <edc:SFRFieldDef edc:cname="GPIO057" edc:nzwidth="0x1" edc:desc="GPIO 057"/>
            <edc:AdjustPoint edc:offset="0x3"/>
            <edc:SFRFieldDef edc:cname="GPIO063" edc:nzwidth="0x1" edc:desc="GPIO 060"/>
            <edc:AdjustPoint edc:offset="0x4"/>
            <edc:SFRFieldDef edc:cname="GPIO070" edc:nzwidth="0x1" edc:desc="GPIO 070"/>
            <edc:SFRFieldDef edc:cname="GPIO071" edc:nzwidth="0x1" edc:desc="GPIO 071"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="ECIA" edc:cname="EN_SET10" edc:nzwidth="0x20" edc:access="------nn----n---nnn-n--nnnn-----" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x308E9E0" edc:_addr="0x4000E02C">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="ECIA">
            <edc:AdjustPoint edc:offset="0x5"/>
            <edc:SFRFieldDef edc:cname="GPIO045" edc:nzwidth="0x1" edc:desc="GPIO 045"/>
            <edc:SFRFieldDef edc:cname="GPIO046" edc:nzwidth="0x1" edc:desc="GPIO 046"/>
            <edc:SFRFieldDef edc:cname="GPIO047" edc:nzwidth="0x1" edc:desc="GPIO 047"/>
            <edc:SFRFieldDef edc:cname="GPIO050" edc:nzwidth="0x1" edc:desc="GPIO 050"/>
            <edc:AdjustPoint edc:offset="0x2"/>
            <edc:SFRFieldDef edc:cname="GPIO053" edc:nzwidth="0x1" edc:desc="GPIO 053"/>
            <edc:AdjustPoint edc:offset="0x1"/>
            <edc:SFRFieldDef edc:cname="GPIO055" edc:nzwidth="0x1" edc:desc="GPIO 055"/>
            <edc:SFRFieldDef edc:cname="GPIO056" edc:nzwidth="0x1" edc:desc="GPIO 056"/>
            <edc:SFRFieldDef edc:cname="GPIO057" edc:nzwidth="0x1" edc:desc="GPIO 057"/>
            <edc:AdjustPoint edc:offset="0x3"/>
            <edc:SFRFieldDef edc:cname="GPIO063" edc:nzwidth="0x1" edc:desc="GPIO 060"/>
            <edc:AdjustPoint edc:offset="0x4"/>
            <edc:SFRFieldDef edc:cname="GPIO070" edc:nzwidth="0x1" edc:desc="GPIO 070"/>
            <edc:SFRFieldDef edc:cname="GPIO071" edc:nzwidth="0x1" edc:desc="GPIO 071"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="ECIA" edc:cname="RESULT10" edc:nzwidth="0x20" edc:access="------rr----r---rrr-r--rrrr-----" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x308E9E0" edc:_addr="0x4000E030">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="ECIA">
            <edc:AdjustPoint edc:offset="0x5"/>
            <edc:SFRFieldDef edc:cname="GPIO045" edc:nzwidth="0x1" edc:desc="GPIO 045"/>
            <edc:SFRFieldDef edc:cname="GPIO046" edc:nzwidth="0x1" edc:desc="GPIO 046"/>
            <edc:SFRFieldDef edc:cname="GPIO047" edc:nzwidth="0x1" edc:desc="GPIO 047"/>
            <edc:SFRFieldDef edc:cname="GPIO050" edc:nzwidth="0x1" edc:desc="GPIO 050"/>
            <edc:AdjustPoint edc:offset="0x2"/>
            <edc:SFRFieldDef edc:cname="GPIO053" edc:nzwidth="0x1" edc:desc="GPIO 053"/>
            <edc:AdjustPoint edc:offset="0x1"/>
            <edc:SFRFieldDef edc:cname="GPIO055" edc:nzwidth="0x1" edc:desc="GPIO 055"/>
            <edc:SFRFieldDef edc:cname="GPIO056" edc:nzwidth="0x1" edc:desc="GPIO 056"/>
            <edc:SFRFieldDef edc:cname="GPIO057" edc:nzwidth="0x1" edc:desc="GPIO 057"/>
            <edc:AdjustPoint edc:offset="0x3"/>
            <edc:SFRFieldDef edc:cname="GPIO063" edc:nzwidth="0x1" edc:desc="GPIO 060"/>
            <edc:AdjustPoint edc:offset="0x4"/>
            <edc:SFRFieldDef edc:cname="GPIO070" edc:nzwidth="0x1" edc:desc="GPIO 070"/>
            <edc:SFRFieldDef edc:cname="GPIO071" edc:nzwidth="0x1" edc:desc="GPIO 071"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="ECIA" edc:cname="EN_CLR10" edc:nzwidth="0x20" edc:access="------nn----n---nnn-n--nnnn-----" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x308E9E0" edc:_addr="0x4000E034">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="ECIA">
            <edc:AdjustPoint edc:offset="0x5"/>
            <edc:SFRFieldDef edc:cname="GPIO045" edc:nzwidth="0x1" edc:desc="GPIO 045"/>
            <edc:SFRFieldDef edc:cname="GPIO046" edc:nzwidth="0x1" edc:desc="GPIO 046"/>
            <edc:SFRFieldDef edc:cname="GPIO047" edc:nzwidth="0x1" edc:desc="GPIO 047"/>
            <edc:SFRFieldDef edc:cname="GPIO050" edc:nzwidth="0x1" edc:desc="GPIO 050"/>
            <edc:AdjustPoint edc:offset="0x2"/>
            <edc:SFRFieldDef edc:cname="GPIO053" edc:nzwidth="0x1" edc:desc="GPIO 053"/>
            <edc:AdjustPoint edc:offset="0x1"/>
            <edc:SFRFieldDef edc:cname="GPIO055" edc:nzwidth="0x1" edc:desc="GPIO 055"/>
            <edc:SFRFieldDef edc:cname="GPIO056" edc:nzwidth="0x1" edc:desc="GPIO 056"/>
            <edc:SFRFieldDef edc:cname="GPIO057" edc:nzwidth="0x1" edc:desc="GPIO 057"/>
            <edc:AdjustPoint edc:offset="0x3"/>
            <edc:SFRFieldDef edc:cname="GPIO063" edc:nzwidth="0x1" edc:desc="GPIO 060"/>
            <edc:AdjustPoint edc:offset="0x4"/>
            <edc:SFRFieldDef edc:cname="GPIO070" edc:nzwidth="0x1" edc:desc="GPIO 070"/>
            <edc:SFRFieldDef edc:cname="GPIO071" edc:nzwidth="0x1" edc:desc="GPIO 071"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:AdjustPoint edc:offset="0x4" edc:_addr="0x4000E038"/>
      <edc:SFRDef ltx:memberofperipheral="ECIA" edc:cname="SRC11" edc:nzwidth="0x20" edc:access="---nnnnnnn-nnnnn-nn-nn-----nnn-n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x1FDF6C1D" edc:_addr="0x4000E03C">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="ECIA">
            <edc:SFRFieldDef edc:cname="GPIO000" edc:nzwidth="0x1" edc:desc="GPIO 000"/>
            <edc:AdjustPoint edc:offset="0x1"/>
            <edc:SFRFieldDef edc:cname="GPIO002" edc:nzwidth="0x1" edc:desc="GPIO 002"/>
            <edc:SFRFieldDef edc:cname="GPIO003" edc:nzwidth="0x1" edc:desc="GPIO 003"/>
            <edc:SFRFieldDef edc:cname="GPIO004" edc:nzwidth="0x1" edc:desc="GPIO 004"/>
            <edc:AdjustPoint edc:offset="0x5"/>
            <edc:SFRFieldDef edc:cname="GPIO012" edc:nzwidth="0x1" edc:desc="GPIO 012"/>
            <edc:SFRFieldDef edc:cname="GPIO013" edc:nzwidth="0x1" edc:desc="GPIO 013"/>
            <edc:AdjustPoint edc:offset="0x1"/>
            <edc:SFRFieldDef edc:cname="GPIO015" edc:nzwidth="0x1" edc:desc="GPIO 015"/>
            <edc:SFRFieldDef edc:cname="GPIO016" edc:nzwidth="0x1" edc:desc="GPIO 016"/>
            <edc:AdjustPoint edc:offset="0x1"/>
            <edc:SFRFieldDef edc:cname="GPIO020" edc:nzwidth="0x1" edc:desc="GPIO 020"/>
            <edc:SFRFieldDef edc:cname="GPIO021" edc:nzwidth="0x1" edc:desc="GPIO 021"/>
            <edc:SFRFieldDef edc:cname="GPIO022" edc:nzwidth="0x1" edc:desc="GPIO 022"/>
            <edc:SFRFieldDef edc:cname="GPIO023" edc:nzwidth="0x1" edc:desc="GPIO 023"/>
            <edc:SFRFieldDef edc:cname="GPIO024" edc:nzwidth="0x1" edc:desc="GPIO 024"/>
            <edc:AdjustPoint edc:offset="0x1"/>
            <edc:SFRFieldDef edc:cname="GPIO026" edc:nzwidth="0x1" edc:desc="GPIO 026"/>
            <edc:SFRFieldDef edc:cname="GPIO027" edc:nzwidth="0x1" edc:desc="GPIO 027"/>
            <edc:SFRFieldDef edc:cname="GPIO030" edc:nzwidth="0x1" edc:desc="GPIO 030"/>
            <edc:SFRFieldDef edc:cname="GPIO031" edc:nzwidth="0x1" edc:desc="GPIO 031"/>
            <edc:SFRFieldDef edc:cname="GPIO032" edc:nzwidth="0x1" edc:desc="GPIO 032"/>
            <edc:SFRFieldDef edc:cname="GPIO033" edc:nzwidth="0x1" edc:desc="GPIO 033"/>
            <edc:SFRFieldDef edc:cname="GPIO034" edc:nzwidth="0x1" edc:desc="GPIO 034"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="ECIA" edc:cname="EN_SET11" edc:nzwidth="0x20" edc:access="---nnnnnnn-nnnnn-nn-nn-----nnn-n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x1FDF6C1D" edc:_addr="0x4000E040">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="ECIA">
            <edc:SFRFieldDef edc:cname="GPIO000" edc:nzwidth="0x1" edc:desc="GPIO 000"/>
            <edc:AdjustPoint edc:offset="0x1"/>
            <edc:SFRFieldDef edc:cname="GPIO002" edc:nzwidth="0x1" edc:desc="GPIO 002"/>
            <edc:SFRFieldDef edc:cname="GPIO003" edc:nzwidth="0x1" edc:desc="GPIO 003"/>
            <edc:SFRFieldDef edc:cname="GPIO004" edc:nzwidth="0x1" edc:desc="GPIO 004"/>
            <edc:AdjustPoint edc:offset="0x5"/>
            <edc:SFRFieldDef edc:cname="GPIO012" edc:nzwidth="0x1" edc:desc="GPIO 012"/>
            <edc:SFRFieldDef edc:cname="GPIO013" edc:nzwidth="0x1" edc:desc="GPIO 013"/>
            <edc:AdjustPoint edc:offset="0x1"/>
            <edc:SFRFieldDef edc:cname="GPIO015" edc:nzwidth="0x1" edc:desc="GPIO 015"/>
            <edc:SFRFieldDef edc:cname="GPIO016" edc:nzwidth="0x1" edc:desc="GPIO 016"/>
            <edc:AdjustPoint edc:offset="0x1"/>
            <edc:SFRFieldDef edc:cname="GPIO020" edc:nzwidth="0x1" edc:desc="GPIO 020"/>
            <edc:SFRFieldDef edc:cname="GPIO021" edc:nzwidth="0x1" edc:desc="GPIO 021"/>
            <edc:SFRFieldDef edc:cname="GPIO022" edc:nzwidth="0x1" edc:desc="GPIO 022"/>
            <edc:SFRFieldDef edc:cname="GPIO023" edc:nzwidth="0x1" edc:desc="GPIO 023"/>
            <edc:SFRFieldDef edc:cname="GPIO024" edc:nzwidth="0x1" edc:desc="GPIO 024"/>
            <edc:AdjustPoint edc:offset="0x1"/>
            <edc:SFRFieldDef edc:cname="GPIO026" edc:nzwidth="0x1" edc:desc="GPIO 026"/>
            <edc:SFRFieldDef edc:cname="GPIO027" edc:nzwidth="0x1" edc:desc="GPIO 027"/>
            <edc:SFRFieldDef edc:cname="GPIO030" edc:nzwidth="0x1" edc:desc="GPIO 030"/>
            <edc:SFRFieldDef edc:cname="GPIO031" edc:nzwidth="0x1" edc:desc="GPIO 031"/>
            <edc:SFRFieldDef edc:cname="GPIO032" edc:nzwidth="0x1" edc:desc="GPIO 032"/>
            <edc:SFRFieldDef edc:cname="GPIO033" edc:nzwidth="0x1" edc:desc="GPIO 033"/>
            <edc:SFRFieldDef edc:cname="GPIO034" edc:nzwidth="0x1" edc:desc="GPIO 034"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="ECIA" edc:cname="RESULT11" edc:nzwidth="0x20" edc:access="---rrrrrrr-rrrrr-rr-rr-----rrr-r" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x1FDF6C1D" edc:_addr="0x4000E044">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="ECIA">
            <edc:SFRFieldDef edc:cname="GPIO000" edc:nzwidth="0x1" edc:desc="GPIO 000"/>
            <edc:AdjustPoint edc:offset="0x1"/>
            <edc:SFRFieldDef edc:cname="GPIO002" edc:nzwidth="0x1" edc:desc="GPIO 002"/>
            <edc:SFRFieldDef edc:cname="GPIO003" edc:nzwidth="0x1" edc:desc="GPIO 003"/>
            <edc:SFRFieldDef edc:cname="GPIO004" edc:nzwidth="0x1" edc:desc="GPIO 004"/>
            <edc:AdjustPoint edc:offset="0x5"/>
            <edc:SFRFieldDef edc:cname="GPIO012" edc:nzwidth="0x1" edc:desc="GPIO 012"/>
            <edc:SFRFieldDef edc:cname="GPIO013" edc:nzwidth="0x1" edc:desc="GPIO 013"/>
            <edc:AdjustPoint edc:offset="0x1"/>
            <edc:SFRFieldDef edc:cname="GPIO015" edc:nzwidth="0x1" edc:desc="GPIO 015"/>
            <edc:SFRFieldDef edc:cname="GPIO016" edc:nzwidth="0x1" edc:desc="GPIO 016"/>
            <edc:AdjustPoint edc:offset="0x1"/>
            <edc:SFRFieldDef edc:cname="GPIO020" edc:nzwidth="0x1" edc:desc="GPIO 020"/>
            <edc:SFRFieldDef edc:cname="GPIO021" edc:nzwidth="0x1" edc:desc="GPIO 021"/>
            <edc:SFRFieldDef edc:cname="GPIO022" edc:nzwidth="0x1" edc:desc="GPIO 022"/>
            <edc:SFRFieldDef edc:cname="GPIO023" edc:nzwidth="0x1" edc:desc="GPIO 023"/>
            <edc:SFRFieldDef edc:cname="GPIO024" edc:nzwidth="0x1" edc:desc="GPIO 024"/>
            <edc:AdjustPoint edc:offset="0x1"/>
            <edc:SFRFieldDef edc:cname="GPIO026" edc:nzwidth="0x1" edc:desc="GPIO 026"/>
            <edc:SFRFieldDef edc:cname="GPIO027" edc:nzwidth="0x1" edc:desc="GPIO 027"/>
            <edc:SFRFieldDef edc:cname="GPIO030" edc:nzwidth="0x1" edc:desc="GPIO 030"/>
            <edc:SFRFieldDef edc:cname="GPIO031" edc:nzwidth="0x1" edc:desc="GPIO 031"/>
            <edc:SFRFieldDef edc:cname="GPIO032" edc:nzwidth="0x1" edc:desc="GPIO 032"/>
            <edc:SFRFieldDef edc:cname="GPIO033" edc:nzwidth="0x1" edc:desc="GPIO 033"/>
            <edc:SFRFieldDef edc:cname="GPIO034" edc:nzwidth="0x1" edc:desc="GPIO 034"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="ECIA" edc:cname="EN_CLR11" edc:nzwidth="0x20" edc:access="---nnnnnnn-nnnnn-nn-nn-----nnn-n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x1FDF6C1D" edc:_addr="0x4000E048">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="ECIA">
            <edc:SFRFieldDef edc:cname="GPIO000" edc:nzwidth="0x1" edc:desc="GPIO 000"/>
            <edc:AdjustPoint edc:offset="0x1"/>
            <edc:SFRFieldDef edc:cname="GPIO002" edc:nzwidth="0x1" edc:desc="GPIO 002"/>
            <edc:SFRFieldDef edc:cname="GPIO003" edc:nzwidth="0x1" edc:desc="GPIO 003"/>
            <edc:SFRFieldDef edc:cname="GPIO004" edc:nzwidth="0x1" edc:desc="GPIO 004"/>
            <edc:AdjustPoint edc:offset="0x5"/>
            <edc:SFRFieldDef edc:cname="GPIO012" edc:nzwidth="0x1" edc:desc="GPIO 012"/>
            <edc:SFRFieldDef edc:cname="GPIO013" edc:nzwidth="0x1" edc:desc="GPIO 013"/>
            <edc:AdjustPoint edc:offset="0x1"/>
            <edc:SFRFieldDef edc:cname="GPIO015" edc:nzwidth="0x1" edc:desc="GPIO 015"/>
            <edc:SFRFieldDef edc:cname="GPIO016" edc:nzwidth="0x1" edc:desc="GPIO 016"/>
            <edc:AdjustPoint edc:offset="0x1"/>
            <edc:SFRFieldDef edc:cname="GPIO020" edc:nzwidth="0x1" edc:desc="GPIO 020"/>
            <edc:SFRFieldDef edc:cname="GPIO021" edc:nzwidth="0x1" edc:desc="GPIO 021"/>
            <edc:SFRFieldDef edc:cname="GPIO022" edc:nzwidth="0x1" edc:desc="GPIO 022"/>
            <edc:SFRFieldDef edc:cname="GPIO023" edc:nzwidth="0x1" edc:desc="GPIO 023"/>
            <edc:SFRFieldDef edc:cname="GPIO024" edc:nzwidth="0x1" edc:desc="GPIO 024"/>
            <edc:AdjustPoint edc:offset="0x1"/>
            <edc:SFRFieldDef edc:cname="GPIO026" edc:nzwidth="0x1" edc:desc="GPIO 026"/>
            <edc:SFRFieldDef edc:cname="GPIO027" edc:nzwidth="0x1" edc:desc="GPIO 027"/>
            <edc:SFRFieldDef edc:cname="GPIO030" edc:nzwidth="0x1" edc:desc="GPIO 030"/>
            <edc:SFRFieldDef edc:cname="GPIO031" edc:nzwidth="0x1" edc:desc="GPIO 031"/>
            <edc:SFRFieldDef edc:cname="GPIO032" edc:nzwidth="0x1" edc:desc="GPIO 032"/>
            <edc:SFRFieldDef edc:cname="GPIO033" edc:nzwidth="0x1" edc:desc="GPIO 033"/>
            <edc:SFRFieldDef edc:cname="GPIO034" edc:nzwidth="0x1" edc:desc="GPIO 034"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:AdjustPoint edc:offset="0x4" edc:_addr="0x4000E04C"/>
      <edc:SFRDef ltx:memberofperipheral="ECIA" edc:cname="SRC12" edc:nzwidth="0x20" edc:access="--------n--nn--------------nnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x98001F" edc:_addr="0x4000E050">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="ECIA">
            <edc:SFRFieldDef edc:cname="GPIO200" edc:nzwidth="0x1" edc:desc="GPIO 200"/>
            <edc:SFRFieldDef edc:cname="GPIO201" edc:nzwidth="0x1" edc:desc="GPIO 201"/>
            <edc:SFRFieldDef edc:cname="GPIO202" edc:nzwidth="0x1" edc:desc="GPIO 202"/>
            <edc:SFRFieldDef edc:cname="GPIO203" edc:nzwidth="0x1" edc:desc="GPIO 203"/>
            <edc:SFRFieldDef edc:cname="GPIO204" edc:nzwidth="0x1" edc:desc="GPIO 204"/>
            <edc:AdjustPoint edc:offset="0xE"/>
            <edc:SFRFieldDef edc:cname="GPIO223" edc:nzwidth="0x1" edc:desc="GPIO 223"/>
            <edc:SFRFieldDef edc:cname="GPIO224" edc:nzwidth="0x1" edc:desc="GPIO 224"/>
            <edc:AdjustPoint edc:offset="0x2"/>
            <edc:SFRFieldDef edc:cname="GPIO227" edc:nzwidth="0x1" edc:desc="GPIO 227"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="ECIA" edc:cname="EN_SET12" edc:nzwidth="0x20" edc:access="--------n--nn--------------nnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x98001F" edc:_addr="0x4000E054">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="ECIA">
            <edc:SFRFieldDef edc:cname="GPIO200" edc:nzwidth="0x1" edc:desc="GPIO 200"/>
            <edc:SFRFieldDef edc:cname="GPIO201" edc:nzwidth="0x1" edc:desc="GPIO 201"/>
            <edc:SFRFieldDef edc:cname="GPIO202" edc:nzwidth="0x1" edc:desc="GPIO 202"/>
            <edc:SFRFieldDef edc:cname="GPIO203" edc:nzwidth="0x1" edc:desc="GPIO 203"/>
            <edc:SFRFieldDef edc:cname="GPIO204" edc:nzwidth="0x1" edc:desc="GPIO 204"/>
            <edc:AdjustPoint edc:offset="0xE"/>
            <edc:SFRFieldDef edc:cname="GPIO223" edc:nzwidth="0x1" edc:desc="GPIO 223"/>
            <edc:SFRFieldDef edc:cname="GPIO224" edc:nzwidth="0x1" edc:desc="GPIO 224"/>
            <edc:AdjustPoint edc:offset="0x2"/>
            <edc:SFRFieldDef edc:cname="GPIO227" edc:nzwidth="0x1" edc:desc="GPIO 227"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="ECIA" edc:cname="RESULT12" edc:nzwidth="0x20" edc:access="--------r--rr--------------rrrrr" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x98001F" edc:_addr="0x4000E058">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="ECIA">
            <edc:SFRFieldDef edc:cname="GPIO200" edc:nzwidth="0x1" edc:desc="GPIO 200"/>
            <edc:SFRFieldDef edc:cname="GPIO201" edc:nzwidth="0x1" edc:desc="GPIO 201"/>
            <edc:SFRFieldDef edc:cname="GPIO202" edc:nzwidth="0x1" edc:desc="GPIO 202"/>
            <edc:SFRFieldDef edc:cname="GPIO203" edc:nzwidth="0x1" edc:desc="GPIO 203"/>
            <edc:SFRFieldDef edc:cname="GPIO204" edc:nzwidth="0x1" edc:desc="GPIO 204"/>
            <edc:AdjustPoint edc:offset="0xE"/>
            <edc:SFRFieldDef edc:cname="GPIO223" edc:nzwidth="0x1" edc:desc="GPIO 223"/>
            <edc:SFRFieldDef edc:cname="GPIO224" edc:nzwidth="0x1" edc:desc="GPIO 224"/>
            <edc:AdjustPoint edc:offset="0x2"/>
            <edc:SFRFieldDef edc:cname="GPIO227" edc:nzwidth="0x1" edc:desc="GPIO 227"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="ECIA" edc:cname="EN_CLR12" edc:nzwidth="0x20" edc:access="--------n--nn--------------nnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x98001F" edc:_addr="0x4000E05C">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="ECIA">
            <edc:SFRFieldDef edc:cname="GPIO200" edc:nzwidth="0x1" edc:desc="GPIO 200"/>
            <edc:SFRFieldDef edc:cname="GPIO201" edc:nzwidth="0x1" edc:desc="GPIO 201"/>
            <edc:SFRFieldDef edc:cname="GPIO202" edc:nzwidth="0x1" edc:desc="GPIO 202"/>
            <edc:SFRFieldDef edc:cname="GPIO203" edc:nzwidth="0x1" edc:desc="GPIO 203"/>
            <edc:SFRFieldDef edc:cname="GPIO204" edc:nzwidth="0x1" edc:desc="GPIO 204"/>
            <edc:AdjustPoint edc:offset="0xE"/>
            <edc:SFRFieldDef edc:cname="GPIO223" edc:nzwidth="0x1" edc:desc="GPIO 223"/>
            <edc:SFRFieldDef edc:cname="GPIO224" edc:nzwidth="0x1" edc:desc="GPIO 224"/>
            <edc:AdjustPoint edc:offset="0x2"/>
            <edc:SFRFieldDef edc:cname="GPIO227" edc:nzwidth="0x1" edc:desc="GPIO 227"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:AdjustPoint edc:offset="0x4" edc:_addr="0x4000E060"/>
      <edc:SFRDef ltx:memberofperipheral="ECIA" edc:cname="SRC13" edc:nzwidth="0x20" edc:access="---------------------------nnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x1F" edc:_addr="0x4000E064">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="ECIA">
            <edc:SFRFieldDef edc:cname="I2CSMB0" edc:nzwidth="0x1" edc:desc="I2CSMB0"/>
            <edc:SFRFieldDef edc:cname="I2CSMB1" edc:nzwidth="0x1" edc:desc="I2CSMB1"/>
            <edc:SFRFieldDef edc:cname="I2CSMB2" edc:nzwidth="0x1" edc:desc="I2CSMB2"/>
            <edc:SFRFieldDef edc:cname="I2CSMB3" edc:nzwidth="0x1" edc:desc="I2CSMB3"/>
            <edc:SFRFieldDef edc:cname="I2CSMB4" edc:nzwidth="0x1" edc:desc="I2CSMB4"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="ECIA" edc:cname="EN_SET13" edc:nzwidth="0x20" edc:access="---------------------------nnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x1F" edc:_addr="0x4000E068">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="ECIA">
            <edc:SFRFieldDef edc:cname="I2CSMB0" edc:nzwidth="0x1" edc:desc="I2CSMB0"/>
            <edc:SFRFieldDef edc:cname="I2CSMB1" edc:nzwidth="0x1" edc:desc="I2CSMB1"/>
            <edc:SFRFieldDef edc:cname="I2CSMB2" edc:nzwidth="0x1" edc:desc="I2CSMB2"/>
            <edc:SFRFieldDef edc:cname="I2CSMB3" edc:nzwidth="0x1" edc:desc="I2CSMB3"/>
            <edc:SFRFieldDef edc:cname="I2CSMB4" edc:nzwidth="0x1" edc:desc="I2CSMB4"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="ECIA" edc:cname="RESULT13" edc:nzwidth="0x20" edc:access="---------------------------rrrrr" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x1F" edc:_addr="0x4000E06C">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="ECIA">
            <edc:SFRFieldDef edc:cname="I2CSMB0" edc:nzwidth="0x1" edc:desc="I2CSMB0"/>
            <edc:SFRFieldDef edc:cname="I2CSMB1" edc:nzwidth="0x1" edc:desc="I2CSMB1"/>
            <edc:SFRFieldDef edc:cname="I2CSMB2" edc:nzwidth="0x1" edc:desc="I2CSMB2"/>
            <edc:SFRFieldDef edc:cname="I2CSMB3" edc:nzwidth="0x1" edc:desc="I2CSMB3"/>
            <edc:SFRFieldDef edc:cname="I2CSMB4" edc:nzwidth="0x1" edc:desc="I2CSMB4"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="ECIA" edc:cname="EN_CLR13" edc:nzwidth="0x20" edc:access="---------------------------nnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x1F" edc:_addr="0x4000E070">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="ECIA">
            <edc:SFRFieldDef edc:cname="I2CSMB0" edc:nzwidth="0x1" edc:desc="I2CSMB0"/>
            <edc:SFRFieldDef edc:cname="I2CSMB1" edc:nzwidth="0x1" edc:desc="I2CSMB1"/>
            <edc:SFRFieldDef edc:cname="I2CSMB2" edc:nzwidth="0x1" edc:desc="I2CSMB2"/>
            <edc:SFRFieldDef edc:cname="I2CSMB3" edc:nzwidth="0x1" edc:desc="I2CSMB3"/>
            <edc:SFRFieldDef edc:cname="I2CSMB4" edc:nzwidth="0x1" edc:desc="I2CSMB4"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:AdjustPoint edc:offset="0x4" edc:_addr="0x4000E074"/>
      <edc:SFRDef ltx:memberofperipheral="ECIA" edc:cname="SRC14" edc:nzwidth="0x20" edc:access="----------------------nnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x3FF" edc:_addr="0x4000E078">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="ECIA">
            <edc:SFRFieldDef edc:cname="DMA_CH00" edc:nzwidth="0x1" edc:desc="DMA CH00"/>
            <edc:SFRFieldDef edc:cname="DMA_CH01" edc:nzwidth="0x1" edc:desc="DMA CH01"/>
            <edc:SFRFieldDef edc:cname="DMA_CH02" edc:nzwidth="0x1" edc:desc="DMA CH02"/>
            <edc:SFRFieldDef edc:cname="DMA_CH03" edc:nzwidth="0x1" edc:desc="DMA CH03"/>
            <edc:SFRFieldDef edc:cname="DMA_CH04" edc:nzwidth="0x1" edc:desc="DMA CH04"/>
            <edc:SFRFieldDef edc:cname="DMA_CH05" edc:nzwidth="0x1" edc:desc="DMA CH05"/>
            <edc:SFRFieldDef edc:cname="DMA_CH06" edc:nzwidth="0x1" edc:desc="DMA CH06"/>
            <edc:SFRFieldDef edc:cname="DMA_CH07" edc:nzwidth="0x1" edc:desc="DMA CH07"/>
            <edc:SFRFieldDef edc:cname="DMA_CH08" edc:nzwidth="0x1" edc:desc="DMA CH08"/>
            <edc:SFRFieldDef edc:cname="DMA_CH09" edc:nzwidth="0x1" edc:desc="DMA CH09"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="ECIA" edc:cname="EN_SET14" edc:nzwidth="0x20" edc:access="----------------------nnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x3FF" edc:_addr="0x4000E07C">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="ECIA">
            <edc:SFRFieldDef edc:cname="DMA_CH00" edc:nzwidth="0x1" edc:desc="DMA CH00"/>
            <edc:SFRFieldDef edc:cname="DMA_CH01" edc:nzwidth="0x1" edc:desc="DMA CH01"/>
            <edc:SFRFieldDef edc:cname="DMA_CH02" edc:nzwidth="0x1" edc:desc="DMA CH02"/>
            <edc:SFRFieldDef edc:cname="DMA_CH03" edc:nzwidth="0x1" edc:desc="DMA CH03"/>
            <edc:SFRFieldDef edc:cname="DMA_CH04" edc:nzwidth="0x1" edc:desc="DMA CH04"/>
            <edc:SFRFieldDef edc:cname="DMA_CH05" edc:nzwidth="0x1" edc:desc="DMA CH05"/>
            <edc:SFRFieldDef edc:cname="DMA_CH06" edc:nzwidth="0x1" edc:desc="DMA CH06"/>
            <edc:SFRFieldDef edc:cname="DMA_CH07" edc:nzwidth="0x1" edc:desc="DMA CH07"/>
            <edc:SFRFieldDef edc:cname="DMA_CH08" edc:nzwidth="0x1" edc:desc="DMA CH08"/>
            <edc:SFRFieldDef edc:cname="DMA_CH09" edc:nzwidth="0x1" edc:desc="DMA CH09"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="ECIA" edc:cname="RESULT14" edc:nzwidth="0x20" edc:access="----------------------rrrrrrrrrr" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x3FF" edc:_addr="0x4000E080">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="ECIA">
            <edc:SFRFieldDef edc:cname="DMA_CH00" edc:nzwidth="0x1" edc:desc="DMA CH00"/>
            <edc:SFRFieldDef edc:cname="DMA_CH01" edc:nzwidth="0x1" edc:desc="DMA CH01"/>
            <edc:SFRFieldDef edc:cname="DMA_CH02" edc:nzwidth="0x1" edc:desc="DMA CH02"/>
            <edc:SFRFieldDef edc:cname="DMA_CH03" edc:nzwidth="0x1" edc:desc="DMA CH03"/>
            <edc:SFRFieldDef edc:cname="DMA_CH04" edc:nzwidth="0x1" edc:desc="DMA CH04"/>
            <edc:SFRFieldDef edc:cname="DMA_CH05" edc:nzwidth="0x1" edc:desc="DMA CH05"/>
            <edc:SFRFieldDef edc:cname="DMA_CH06" edc:nzwidth="0x1" edc:desc="DMA CH06"/>
            <edc:SFRFieldDef edc:cname="DMA_CH07" edc:nzwidth="0x1" edc:desc="DMA CH07"/>
            <edc:SFRFieldDef edc:cname="DMA_CH08" edc:nzwidth="0x1" edc:desc="DMA CH08"/>
            <edc:SFRFieldDef edc:cname="DMA_CH09" edc:nzwidth="0x1" edc:desc="DMA CH09"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="ECIA" edc:cname="EN_CLR14" edc:nzwidth="0x20" edc:access="----------------------nnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x3FF" edc:_addr="0x4000E084">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="ECIA">
            <edc:SFRFieldDef edc:cname="DMA_CH00" edc:nzwidth="0x1" edc:desc="DMA CH00"/>
            <edc:SFRFieldDef edc:cname="DMA_CH01" edc:nzwidth="0x1" edc:desc="DMA CH01"/>
            <edc:SFRFieldDef edc:cname="DMA_CH02" edc:nzwidth="0x1" edc:desc="DMA CH02"/>
            <edc:SFRFieldDef edc:cname="DMA_CH03" edc:nzwidth="0x1" edc:desc="DMA CH03"/>
            <edc:SFRFieldDef edc:cname="DMA_CH04" edc:nzwidth="0x1" edc:desc="DMA CH04"/>
            <edc:SFRFieldDef edc:cname="DMA_CH05" edc:nzwidth="0x1" edc:desc="DMA CH05"/>
            <edc:SFRFieldDef edc:cname="DMA_CH06" edc:nzwidth="0x1" edc:desc="DMA CH06"/>
            <edc:SFRFieldDef edc:cname="DMA_CH07" edc:nzwidth="0x1" edc:desc="DMA CH07"/>
            <edc:SFRFieldDef edc:cname="DMA_CH08" edc:nzwidth="0x1" edc:desc="DMA CH08"/>
            <edc:SFRFieldDef edc:cname="DMA_CH09" edc:nzwidth="0x1" edc:desc="DMA CH09"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:AdjustPoint edc:offset="0x4" edc:_addr="0x4000E088"/>
      <edc:SFRDef ltx:memberofperipheral="ECIA" edc:cname="SRC15" edc:nzwidth="0x20" edc:access="-------------------------------n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x1" edc:_addr="0x4000E08C">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="ECIA">
            <edc:SFRFieldDef edc:cname="UART0" edc:nzwidth="0x1" edc:desc="UART0"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="ECIA" edc:cname="EN_SET15" edc:nzwidth="0x20" edc:access="-------------------------------n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x1" edc:_addr="0x4000E090">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="ECIA">
            <edc:SFRFieldDef edc:cname="UART0" edc:nzwidth="0x1" edc:desc="UART0"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="ECIA" edc:cname="RESULT15" edc:nzwidth="0x20" edc:access="-------------------------------r" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x1" edc:_addr="0x4000E094">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="ECIA">
            <edc:SFRFieldDef edc:cname="UART0" edc:nzwidth="0x1" edc:desc="UART0"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="ECIA" edc:cname="EN_CLR15" edc:nzwidth="0x20" edc:access="-------------------------------n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x1" edc:_addr="0x4000E098">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="ECIA">
            <edc:SFRFieldDef edc:cname="UART0" edc:nzwidth="0x1" edc:desc="UART0"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:AdjustPoint edc:offset="0x4" edc:_addr="0x4000E09C"/>
      <edc:SFRDef ltx:memberofperipheral="ECIA" edc:cname="SRC16" edc:nzwidth="0x20" edc:access="---------------------------nnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x1F" edc:_addr="0x4000E0A0">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="ECIA">
            <edc:SFRFieldDef edc:cname="PKE_ERR" edc:nzwidth="0x1" edc:desc="PKE ERR"/>
            <edc:SFRFieldDef edc:cname="PKE_END" edc:nzwidth="0x1" edc:desc="PKE END"/>
            <edc:SFRFieldDef edc:cname="RNG" edc:nzwidth="0x1" edc:desc="RNG"/>
            <edc:SFRFieldDef edc:cname="AES" edc:nzwidth="0x1" edc:desc="AES"/>
            <edc:SFRFieldDef edc:cname="HASH" edc:nzwidth="0x1" edc:desc="HASH"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="ECIA" edc:cname="EN_SET16" edc:nzwidth="0x20" edc:access="---------------------------nnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x1F" edc:_addr="0x4000E0A4">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="ECIA">
            <edc:SFRFieldDef edc:cname="PKE_ERR" edc:nzwidth="0x1" edc:desc="PKE ERR"/>
            <edc:SFRFieldDef edc:cname="PKE_END" edc:nzwidth="0x1" edc:desc="PKE END"/>
            <edc:SFRFieldDef edc:cname="RNG" edc:nzwidth="0x1" edc:desc="RNG"/>
            <edc:SFRFieldDef edc:cname="AES" edc:nzwidth="0x1" edc:desc="AES"/>
            <edc:SFRFieldDef edc:cname="HASH" edc:nzwidth="0x1" edc:desc="HASH"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="ECIA" edc:cname="RESULT16" edc:nzwidth="0x20" edc:access="---------------------------rrrrr" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x1F" edc:_addr="0x4000E0A8">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="ECIA">
            <edc:SFRFieldDef edc:cname="PKE_ERR" edc:nzwidth="0x1" edc:desc="PKE ERR"/>
            <edc:SFRFieldDef edc:cname="PKE_END" edc:nzwidth="0x1" edc:desc="PKE END"/>
            <edc:SFRFieldDef edc:cname="RNG" edc:nzwidth="0x1" edc:desc="RNG"/>
            <edc:SFRFieldDef edc:cname="AES" edc:nzwidth="0x1" edc:desc="AES"/>
            <edc:SFRFieldDef edc:cname="HASH" edc:nzwidth="0x1" edc:desc="HASH"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="ECIA" edc:cname="EN_CLR16" edc:nzwidth="0x20" edc:access="---------------------------nnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x1F" edc:_addr="0x4000E0AC">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="ECIA">
            <edc:SFRFieldDef edc:cname="PKE_ERR" edc:nzwidth="0x1" edc:desc="PKE ERR"/>
            <edc:SFRFieldDef edc:cname="PKE_END" edc:nzwidth="0x1" edc:desc="PKE END"/>
            <edc:SFRFieldDef edc:cname="RNG" edc:nzwidth="0x1" edc:desc="RNG"/>
            <edc:SFRFieldDef edc:cname="AES" edc:nzwidth="0x1" edc:desc="AES"/>
            <edc:SFRFieldDef edc:cname="HASH" edc:nzwidth="0x1" edc:desc="HASH"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:AdjustPoint edc:offset="0x4" edc:_addr="0x4000E0B0"/>
      <edc:SFRDef ltx:memberofperipheral="ECIA" edc:cname="SRC17" edc:nzwidth="0x20" edc:access="-----------------nn-------------" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x6000" edc:_addr="0x4000E0B4">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="ECIA">
            <edc:AdjustPoint edc:offset="0xD"/>
            <edc:SFRFieldDef edc:cname="LED0" edc:nzwidth="0x1" edc:desc="Breating LED0"/>
            <edc:SFRFieldDef edc:cname="LED1" edc:nzwidth="0x1" edc:desc="Breating LED1"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="ECIA" edc:cname="EN_SET17" edc:nzwidth="0x20" edc:access="-----------------nn-------------" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x6000" edc:_addr="0x4000E0B8">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="ECIA">
            <edc:AdjustPoint edc:offset="0xD"/>
            <edc:SFRFieldDef edc:cname="LED0" edc:nzwidth="0x1" edc:desc="Breating LED0"/>
            <edc:SFRFieldDef edc:cname="LED1" edc:nzwidth="0x1" edc:desc="Breating LED1"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="ECIA" edc:cname="RESULT17" edc:nzwidth="0x20" edc:access="-----------------rr-------------" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x6000" edc:_addr="0x4000E0BC">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="ECIA">
            <edc:AdjustPoint edc:offset="0xD"/>
            <edc:SFRFieldDef edc:cname="LED0" edc:nzwidth="0x1" edc:desc="Breating LED0"/>
            <edc:SFRFieldDef edc:cname="LED1" edc:nzwidth="0x1" edc:desc="Breating LED1"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="ECIA" edc:cname="EN_CLR17" edc:nzwidth="0x20" edc:access="-----------------nn-------------" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x6000" edc:_addr="0x4000E0C0">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="ECIA">
            <edc:AdjustPoint edc:offset="0xD"/>
            <edc:SFRFieldDef edc:cname="LED0" edc:nzwidth="0x1" edc:desc="Breating LED0"/>
            <edc:SFRFieldDef edc:cname="LED1" edc:nzwidth="0x1" edc:desc="Breating LED1"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:AdjustPoint edc:offset="0x4" edc:_addr="0x4000E0C4"/>
      <edc:SFRDef ltx:memberofperipheral="ECIA" edc:cname="SRC18" edc:nzwidth="0x20" edc:access="---nnnnnnnnn-n---------------nnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x1FF40007" edc:_addr="0x4000E0C8">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="ECIA">
            <edc:SFRFieldDef edc:cname="SPT0" edc:nzwidth="0x1" edc:desc="SPT0"/>
            <edc:SFRFieldDef edc:cname="QMSPI0" edc:nzwidth="0x1" edc:desc="QMSPI0"/>
            <edc:SFRFieldDef edc:cname="QMSPI1" edc:nzwidth="0x1" edc:desc="QMSPI1"/>
            <edc:AdjustPoint edc:offset="0xF"/>
            <edc:SFRFieldDef edc:cname="SPT1" edc:nzwidth="0x1" edc:desc="SPT1"/>
            <edc:AdjustPoint edc:offset="0x1"/>
            <edc:SFRFieldDef edc:cname="CCT" edc:nzwidth="0x1" edc:desc="CCT"/>
            <edc:SFRFieldDef edc:cname="CCT_CAP0" edc:nzwidth="0x1" edc:desc="CCT_CAP0"/>
            <edc:SFRFieldDef edc:cname="CCT_CAP1" edc:nzwidth="0x1" edc:desc="CCT_CAP1"/>
            <edc:SFRFieldDef edc:cname="CCT_CAP2" edc:nzwidth="0x1" edc:desc="CCT_CAP2"/>
            <edc:SFRFieldDef edc:cname="CCT_CAP3" edc:nzwidth="0x1" edc:desc="CCT_CAP3"/>
            <edc:SFRFieldDef edc:cname="CCT_CAP4" edc:nzwidth="0x1" edc:desc="CCT_CAP4"/>
            <edc:SFRFieldDef edc:cname="CCT_CAP5" edc:nzwidth="0x1" edc:desc="CCT_CAP5"/>
            <edc:SFRFieldDef edc:cname="CCT_CMP0" edc:nzwidth="0x1" edc:desc="CCT_CMP0"/>
            <edc:SFRFieldDef edc:cname="CCT_CMP1" edc:nzwidth="0x1" edc:desc="CCT_CMP1"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="ECIA" edc:cname="EN_SET18" edc:nzwidth="0x20" edc:access="---nnnnnnnnn-n---------------nnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x1FF40007" edc:_addr="0x4000E0CC">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="ECIA">
            <edc:SFRFieldDef edc:cname="SPT0" edc:nzwidth="0x1" edc:desc="SPT0"/>
            <edc:SFRFieldDef edc:cname="QMSPI0" edc:nzwidth="0x1" edc:desc="QMSPI0"/>
            <edc:SFRFieldDef edc:cname="QMSPI1" edc:nzwidth="0x1" edc:desc="QMSPI1"/>
            <edc:AdjustPoint edc:offset="0xF"/>
            <edc:SFRFieldDef edc:cname="SPT1" edc:nzwidth="0x1" edc:desc="SPT1"/>
            <edc:AdjustPoint edc:offset="0x1"/>
            <edc:SFRFieldDef edc:cname="CCT" edc:nzwidth="0x1" edc:desc="CCT"/>
            <edc:SFRFieldDef edc:cname="CCT_CAP0" edc:nzwidth="0x1" edc:desc="CCT_CAP0"/>
            <edc:SFRFieldDef edc:cname="CCT_CAP1" edc:nzwidth="0x1" edc:desc="CCT_CAP1"/>
            <edc:SFRFieldDef edc:cname="CCT_CAP2" edc:nzwidth="0x1" edc:desc="CCT_CAP2"/>
            <edc:SFRFieldDef edc:cname="CCT_CAP3" edc:nzwidth="0x1" edc:desc="CCT_CAP3"/>
            <edc:SFRFieldDef edc:cname="CCT_CAP4" edc:nzwidth="0x1" edc:desc="CCT_CAP4"/>
            <edc:SFRFieldDef edc:cname="CCT_CAP5" edc:nzwidth="0x1" edc:desc="CCT_CAP5"/>
            <edc:SFRFieldDef edc:cname="CCT_CMP0" edc:nzwidth="0x1" edc:desc="CCT_CMP0"/>
            <edc:SFRFieldDef edc:cname="CCT_CMP1" edc:nzwidth="0x1" edc:desc="CCT_CMP1"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="ECIA" edc:cname="RESULT18" edc:nzwidth="0x20" edc:access="---rrrrrrrrr-r---------------rrr" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x1FF40007" edc:_addr="0x4000E0D0">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="ECIA">
            <edc:SFRFieldDef edc:cname="SPT0" edc:nzwidth="0x1" edc:desc="SPT0"/>
            <edc:SFRFieldDef edc:cname="QMSPI0" edc:nzwidth="0x1" edc:desc="QMSPI0"/>
            <edc:SFRFieldDef edc:cname="QMSPI1" edc:nzwidth="0x1" edc:desc="QMSPI1"/>
            <edc:AdjustPoint edc:offset="0xF"/>
            <edc:SFRFieldDef edc:cname="SPT1" edc:nzwidth="0x1" edc:desc="SPT1"/>
            <edc:AdjustPoint edc:offset="0x1"/>
            <edc:SFRFieldDef edc:cname="CCT" edc:nzwidth="0x1" edc:desc="CCT"/>
            <edc:SFRFieldDef edc:cname="CCT_CAP0" edc:nzwidth="0x1" edc:desc="CCT_CAP0"/>
            <edc:SFRFieldDef edc:cname="CCT_CAP1" edc:nzwidth="0x1" edc:desc="CCT_CAP1"/>
            <edc:SFRFieldDef edc:cname="CCT_CAP2" edc:nzwidth="0x1" edc:desc="CCT_CAP2"/>
            <edc:SFRFieldDef edc:cname="CCT_CAP3" edc:nzwidth="0x1" edc:desc="CCT_CAP3"/>
            <edc:SFRFieldDef edc:cname="CCT_CAP4" edc:nzwidth="0x1" edc:desc="CCT_CAP4"/>
            <edc:SFRFieldDef edc:cname="CCT_CAP5" edc:nzwidth="0x1" edc:desc="CCT_CAP5"/>
            <edc:SFRFieldDef edc:cname="CCT_CMP0" edc:nzwidth="0x1" edc:desc="CCT_CMP0"/>
            <edc:SFRFieldDef edc:cname="CCT_CMP1" edc:nzwidth="0x1" edc:desc="CCT_CMP1"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="ECIA" edc:cname="EN_CLR18" edc:nzwidth="0x20" edc:access="---nnnnnnnnn-n---------------nnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x1FF40007" edc:_addr="0x4000E0D4">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="ECIA">
            <edc:SFRFieldDef edc:cname="SPT0" edc:nzwidth="0x1" edc:desc="SPT0"/>
            <edc:SFRFieldDef edc:cname="QMSPI0" edc:nzwidth="0x1" edc:desc="QMSPI0"/>
            <edc:SFRFieldDef edc:cname="QMSPI1" edc:nzwidth="0x1" edc:desc="QMSPI1"/>
            <edc:AdjustPoint edc:offset="0xF"/>
            <edc:SFRFieldDef edc:cname="SPT1" edc:nzwidth="0x1" edc:desc="SPT1"/>
            <edc:AdjustPoint edc:offset="0x1"/>
            <edc:SFRFieldDef edc:cname="CCT" edc:nzwidth="0x1" edc:desc="CCT"/>
            <edc:SFRFieldDef edc:cname="CCT_CAP0" edc:nzwidth="0x1" edc:desc="CCT_CAP0"/>
            <edc:SFRFieldDef edc:cname="CCT_CAP1" edc:nzwidth="0x1" edc:desc="CCT_CAP1"/>
            <edc:SFRFieldDef edc:cname="CCT_CAP2" edc:nzwidth="0x1" edc:desc="CCT_CAP2"/>
            <edc:SFRFieldDef edc:cname="CCT_CAP3" edc:nzwidth="0x1" edc:desc="CCT_CAP3"/>
            <edc:SFRFieldDef edc:cname="CCT_CAP4" edc:nzwidth="0x1" edc:desc="CCT_CAP4"/>
            <edc:SFRFieldDef edc:cname="CCT_CAP5" edc:nzwidth="0x1" edc:desc="CCT_CAP5"/>
            <edc:SFRFieldDef edc:cname="CCT_CMP0" edc:nzwidth="0x1" edc:desc="CCT_CMP0"/>
            <edc:SFRFieldDef edc:cname="CCT_CMP1" edc:nzwidth="0x1" edc:desc="CCT_CMP1"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:AdjustPoint edc:offset="0x4" edc:_addr="0x4000E0D8"/>
      <edc:SFRDef ltx:memberofperipheral="ECIA" edc:cname="SRC19" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x4000E0DC"/>
      <edc:SFRDef ltx:memberofperipheral="ECIA" edc:cname="EN_SET19" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x4000E0E0"/>
      <edc:SFRDef ltx:memberofperipheral="ECIA" edc:cname="RESULT19" edc:nzwidth="0x20" edc:access="rrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrr" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x4000E0E4"/>
      <edc:SFRDef ltx:memberofperipheral="ECIA" edc:cname="EN_CLR19" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x4000E0E8"/>
      <edc:AdjustPoint edc:offset="0x4" edc:_addr="0x4000E0EC"/>
      <edc:SFRDef ltx:memberofperipheral="ECIA" edc:cname="SRC20" edc:nzwidth="0x20" edc:access="--------------------nnnn--------" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0xF00" edc:_addr="0x4000E0F0">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="ECIA">
            <edc:AdjustPoint edc:offset="0x8"/>
            <edc:SFRFieldDef edc:cname="IMSPI" edc:nzwidth="0x1" edc:desc="IMSPI"/>
            <edc:SFRFieldDef edc:cname="CLK_MON" edc:nzwidth="0x1" edc:desc="CLK_MON"/>
            <edc:SFRFieldDef edc:cname="VTR1_PAD_MON" edc:nzwidth="0x1" edc:desc="VTR1_PAD_MON"/>
            <edc:SFRFieldDef edc:cname="VTR2_PAD_MON" edc:nzwidth="0x1" edc:desc="VTR2_PAD_MON"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="ECIA" edc:cname="EN_SET20" edc:nzwidth="0x20" edc:access="--------------------nnnn--------" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0xF00" edc:_addr="0x4000E0F4">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="ECIA">
            <edc:AdjustPoint edc:offset="0x8"/>
            <edc:SFRFieldDef edc:cname="IMSPI" edc:nzwidth="0x1" edc:desc="IMSPI"/>
            <edc:SFRFieldDef edc:cname="CLK_MON" edc:nzwidth="0x1" edc:desc="CLK_MON"/>
            <edc:SFRFieldDef edc:cname="VTR1_PAD_MON" edc:nzwidth="0x1" edc:desc="VTR1_PAD_MON"/>
            <edc:SFRFieldDef edc:cname="VTR2_PAD_MON" edc:nzwidth="0x1" edc:desc="VTR2_PAD_MON"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="ECIA" edc:cname="RESULT20" edc:nzwidth="0x20" edc:access="--------------------rrrr--------" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0xF00" edc:_addr="0x4000E0F8">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="ECIA">
            <edc:AdjustPoint edc:offset="0x8"/>
            <edc:SFRFieldDef edc:cname="IMSPI" edc:nzwidth="0x1" edc:desc="IMSPI"/>
            <edc:SFRFieldDef edc:cname="CLK_MON" edc:nzwidth="0x1" edc:desc="CLK_MON"/>
            <edc:SFRFieldDef edc:cname="VTR1_PAD_MON" edc:nzwidth="0x1" edc:desc="VTR1_PAD_MON"/>
            <edc:SFRFieldDef edc:cname="VTR2_PAD_MON" edc:nzwidth="0x1" edc:desc="VTR2_PAD_MON"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="ECIA" edc:cname="EN_CLR20" edc:nzwidth="0x20" edc:access="--------------------nnnn--------" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0xF00" edc:_addr="0x4000E0FC">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="ECIA">
            <edc:AdjustPoint edc:offset="0x8"/>
            <edc:SFRFieldDef edc:cname="IMSPI" edc:nzwidth="0x1" edc:desc="IMSPI"/>
            <edc:SFRFieldDef edc:cname="CLK_MON" edc:nzwidth="0x1" edc:desc="CLK_MON"/>
            <edc:SFRFieldDef edc:cname="VTR1_PAD_MON" edc:nzwidth="0x1" edc:desc="VTR1_PAD_MON"/>
            <edc:SFRFieldDef edc:cname="VTR2_PAD_MON" edc:nzwidth="0x1" edc:desc="VTR2_PAD_MON"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:AdjustPoint edc:offset="0x4" edc:_addr="0x4000E100"/>
      <edc:SFRDef ltx:memberofperipheral="ECIA" edc:cname="SRC21" edc:nzwidth="0x20" edc:access="-------n---------------------n--" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x1000004" edc:_addr="0x4000E104">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="ECIA">
            <edc:AdjustPoint edc:offset="0x2"/>
            <edc:SFRFieldDef edc:cname="WDT" edc:nzwidth="0x1" edc:desc="WDT"/>
            <edc:AdjustPoint edc:offset="0x15"/>
            <edc:SFRFieldDef edc:cname="EMC" edc:nzwidth="0x1" edc:desc="EMC"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="ECIA" edc:cname="EN_SET21" edc:nzwidth="0x20" edc:access="-------n---------------------n--" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x1000004" edc:_addr="0x4000E108">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="ECIA">
            <edc:AdjustPoint edc:offset="0x2"/>
            <edc:SFRFieldDef edc:cname="WDT" edc:nzwidth="0x1" edc:desc="WDT"/>
            <edc:AdjustPoint edc:offset="0x15"/>
            <edc:SFRFieldDef edc:cname="EMC" edc:nzwidth="0x1" edc:desc="EMC"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="ECIA" edc:cname="RESULT21" edc:nzwidth="0x20" edc:access="-------r---------------------r--" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x1000004" edc:_addr="0x4000E10C">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="ECIA">
            <edc:AdjustPoint edc:offset="0x2"/>
            <edc:SFRFieldDef edc:cname="WDT" edc:nzwidth="0x1" edc:desc="WDT"/>
            <edc:AdjustPoint edc:offset="0x15"/>
            <edc:SFRFieldDef edc:cname="EMC" edc:nzwidth="0x1" edc:desc="EMC"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="ECIA" edc:cname="EN_CLR21" edc:nzwidth="0x20" edc:access="-------n---------------------n--" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x1000004" edc:_addr="0x4000E110">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="ECIA">
            <edc:AdjustPoint edc:offset="0x2"/>
            <edc:SFRFieldDef edc:cname="WDT" edc:nzwidth="0x1" edc:desc="WDT"/>
            <edc:AdjustPoint edc:offset="0x15"/>
            <edc:SFRFieldDef edc:cname="EMC" edc:nzwidth="0x1" edc:desc="EMC"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:AdjustPoint edc:offset="0x4" edc:_addr="0x4000E114"/>
      <edc:SFRDef ltx:memberofperipheral="ECIA" edc:cname="SRC22" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x4000E118"/>
      <edc:SFRDef ltx:memberofperipheral="ECIA" edc:cname="EN_SET22" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x4000E11C"/>
      <edc:SFRDef ltx:memberofperipheral="ECIA" edc:cname="RESULT22" edc:nzwidth="0x20" edc:access="rrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrr" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x4000E120"/>
      <edc:SFRDef ltx:memberofperipheral="ECIA" edc:cname="EN_CLR22" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x4000E124"/>
      <edc:AdjustPoint edc:offset="0x4" edc:_addr="0x4000E128"/>
      <edc:SFRDef ltx:memberofperipheral="ECIA" edc:cname="SRC23" edc:nzwidth="0x20" edc:access="--------------nn-nnnnn----nn----" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x37C30" edc:_addr="0x4000E12C">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="ECIA">
            <edc:AdjustPoint edc:offset="0x4"/>
            <edc:SFRFieldDef edc:cname="TIMER32_0" edc:nzwidth="0x1" edc:desc="TIMER32_0"/>
            <edc:SFRFieldDef edc:cname="TIMER32_1" edc:nzwidth="0x1" edc:desc="TIMER32_1"/>
            <edc:AdjustPoint edc:offset="0x4"/>
            <edc:SFRFieldDef edc:cname="RTMR" edc:nzwidth="0x1" edc:desc="RTMR"/>
            <edc:SFRFieldDef edc:cname="SWI0" edc:nzwidth="0x1" edc:desc="SWI0"/>
            <edc:SFRFieldDef edc:cname="SWI1" edc:nzwidth="0x1" edc:desc="SWI1"/>
            <edc:SFRFieldDef edc:cname="SWI2" edc:nzwidth="0x1" edc:desc="SWI2"/>
            <edc:SFRFieldDef edc:cname="SWI3" edc:nzwidth="0x1" edc:desc="SWI3"/>
            <edc:AdjustPoint edc:offset="0x1"/>
            <edc:SFRFieldDef edc:cname="HTMR0" edc:nzwidth="0x1" edc:desc="HTMR0"/>
            <edc:SFRFieldDef edc:cname="HTMR1" edc:nzwidth="0x1" edc:desc="HTMR1"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="ECIA" edc:cname="EN_SET23" edc:nzwidth="0x20" edc:access="--------------nn-nnnnn----nn----" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x37C30" edc:_addr="0x4000E130">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="ECIA">
            <edc:AdjustPoint edc:offset="0x4"/>
            <edc:SFRFieldDef edc:cname="TIMER32_0" edc:nzwidth="0x1" edc:desc="TIMER32_0"/>
            <edc:SFRFieldDef edc:cname="TIMER32_1" edc:nzwidth="0x1" edc:desc="TIMER32_1"/>
            <edc:AdjustPoint edc:offset="0x4"/>
            <edc:SFRFieldDef edc:cname="RTMR" edc:nzwidth="0x1" edc:desc="RTMR"/>
            <edc:SFRFieldDef edc:cname="SWI0" edc:nzwidth="0x1" edc:desc="SWI0"/>
            <edc:SFRFieldDef edc:cname="SWI1" edc:nzwidth="0x1" edc:desc="SWI1"/>
            <edc:SFRFieldDef edc:cname="SWI2" edc:nzwidth="0x1" edc:desc="SWI2"/>
            <edc:SFRFieldDef edc:cname="SWI3" edc:nzwidth="0x1" edc:desc="SWI3"/>
            <edc:AdjustPoint edc:offset="0x1"/>
            <edc:SFRFieldDef edc:cname="HTMR0" edc:nzwidth="0x1" edc:desc="HTMR0"/>
            <edc:SFRFieldDef edc:cname="HTMR1" edc:nzwidth="0x1" edc:desc="HTMR1"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="ECIA" edc:cname="RESULT23" edc:nzwidth="0x20" edc:access="--------------rr-rrrrr----rr----" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x37C30" edc:_addr="0x4000E134">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="ECIA">
            <edc:AdjustPoint edc:offset="0x4"/>
            <edc:SFRFieldDef edc:cname="TIMER32_0" edc:nzwidth="0x1" edc:desc="TIMER32_0"/>
            <edc:SFRFieldDef edc:cname="TIMER32_1" edc:nzwidth="0x1" edc:desc="TIMER32_1"/>
            <edc:AdjustPoint edc:offset="0x4"/>
            <edc:SFRFieldDef edc:cname="RTMR" edc:nzwidth="0x1" edc:desc="RTMR"/>
            <edc:SFRFieldDef edc:cname="SWI0" edc:nzwidth="0x1" edc:desc="SWI0"/>
            <edc:SFRFieldDef edc:cname="SWI1" edc:nzwidth="0x1" edc:desc="SWI1"/>
            <edc:SFRFieldDef edc:cname="SWI2" edc:nzwidth="0x1" edc:desc="SWI2"/>
            <edc:SFRFieldDef edc:cname="SWI3" edc:nzwidth="0x1" edc:desc="SWI3"/>
            <edc:AdjustPoint edc:offset="0x1"/>
            <edc:SFRFieldDef edc:cname="HTMR0" edc:nzwidth="0x1" edc:desc="HTMR0"/>
            <edc:SFRFieldDef edc:cname="HTMR1" edc:nzwidth="0x1" edc:desc="HTMR1"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="ECIA" edc:cname="EN_CLR23" edc:nzwidth="0x20" edc:access="--------------nn-nnnnn----nn----" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x37C30" edc:_addr="0x4000E138">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="ECIA">
            <edc:AdjustPoint edc:offset="0x4"/>
            <edc:SFRFieldDef edc:cname="TIMER32_0" edc:nzwidth="0x1" edc:desc="TIMER32_0"/>
            <edc:SFRFieldDef edc:cname="TIMER32_1" edc:nzwidth="0x1" edc:desc="TIMER32_1"/>
            <edc:AdjustPoint edc:offset="0x4"/>
            <edc:SFRFieldDef edc:cname="RTMR" edc:nzwidth="0x1" edc:desc="RTMR"/>
            <edc:SFRFieldDef edc:cname="SWI0" edc:nzwidth="0x1" edc:desc="SWI0"/>
            <edc:SFRFieldDef edc:cname="SWI1" edc:nzwidth="0x1" edc:desc="SWI1"/>
            <edc:SFRFieldDef edc:cname="SWI2" edc:nzwidth="0x1" edc:desc="SWI2"/>
            <edc:SFRFieldDef edc:cname="SWI3" edc:nzwidth="0x1" edc:desc="SWI3"/>
            <edc:AdjustPoint edc:offset="0x1"/>
            <edc:SFRFieldDef edc:cname="HTMR0" edc:nzwidth="0x1" edc:desc="HTMR0"/>
            <edc:SFRFieldDef edc:cname="HTMR1" edc:nzwidth="0x1" edc:desc="HTMR1"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:AdjustPoint edc:offset="0x4" edc:_addr="0x4000E13C"/>
      <edc:SFRDef ltx:memberofperipheral="ECIA" edc:cname="SRC24" edc:nzwidth="0x20" edc:access="-------------------------nnn-nnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x77" edc:_addr="0x4000E140">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="ECIA">
            <edc:SFRFieldDef edc:cname="SPIMON0_VLTN" edc:nzwidth="0x1" edc:desc="SPIMON0_VLTN"/>
            <edc:SFRFieldDef edc:cname="SPIMON0_MTMON" edc:nzwidth="0x1" edc:desc="SPIMON0_MTMON"/>
            <edc:SFRFieldDef edc:cname="SPIMON0_LTMON" edc:nzwidth="0x1" edc:desc="SPIMON0_LTMON"/>
            <edc:AdjustPoint edc:offset="0x1"/>
            <edc:SFRFieldDef edc:cname="SPIMON1_VLTN" edc:nzwidth="0x1" edc:desc="SPIMON1_VLTN"/>
            <edc:SFRFieldDef edc:cname="SPIMON1_MTMON" edc:nzwidth="0x1" edc:desc="SPIMON1_MTMON"/>
            <edc:SFRFieldDef edc:cname="SPIMON1_LTMON" edc:nzwidth="0x1" edc:desc="SPIMON1_LTMON"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="ECIA" edc:cname="EN_SET24" edc:nzwidth="0x20" edc:access="-------------------------nnn-nnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x77" edc:_addr="0x4000E144">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="ECIA">
            <edc:SFRFieldDef edc:cname="SPIMON0_VLTN" edc:nzwidth="0x1" edc:desc="SPIMON0_VLTN"/>
            <edc:SFRFieldDef edc:cname="SPIMON0_MTMON" edc:nzwidth="0x1" edc:desc="SPIMON0_MTMON"/>
            <edc:SFRFieldDef edc:cname="SPIMON0_LTMON" edc:nzwidth="0x1" edc:desc="SPIMON0_LTMON"/>
            <edc:AdjustPoint edc:offset="0x1"/>
            <edc:SFRFieldDef edc:cname="SPIMON1_VLTN" edc:nzwidth="0x1" edc:desc="SPIMON1_VLTN"/>
            <edc:SFRFieldDef edc:cname="SPIMON1_MTMON" edc:nzwidth="0x1" edc:desc="SPIMON1_MTMON"/>
            <edc:SFRFieldDef edc:cname="SPIMON1_LTMON" edc:nzwidth="0x1" edc:desc="SPIMON1_LTMON"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="ECIA" edc:cname="RESULT24" edc:nzwidth="0x20" edc:access="-------------------------rrr-rrr" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x77" edc:_addr="0x4000E148">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="ECIA">
            <edc:SFRFieldDef edc:cname="SPIMON0_VLTN" edc:nzwidth="0x1" edc:desc="SPIMON0_VLTN"/>
            <edc:SFRFieldDef edc:cname="SPIMON0_MTMON" edc:nzwidth="0x1" edc:desc="SPIMON0_MTMON"/>
            <edc:SFRFieldDef edc:cname="SPIMON0_LTMON" edc:nzwidth="0x1" edc:desc="SPIMON0_LTMON"/>
            <edc:AdjustPoint edc:offset="0x1"/>
            <edc:SFRFieldDef edc:cname="SPIMON1_VLTN" edc:nzwidth="0x1" edc:desc="SPIMON1_VLTN"/>
            <edc:SFRFieldDef edc:cname="SPIMON1_MTMON" edc:nzwidth="0x1" edc:desc="SPIMON1_MTMON"/>
            <edc:SFRFieldDef edc:cname="SPIMON1_LTMON" edc:nzwidth="0x1" edc:desc="SPIMON1_LTMON"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="ECIA" edc:cname="EN_CLR24" edc:nzwidth="0x20" edc:access="-------------------------nnn-nnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x77" edc:_addr="0x4000E14C">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="ECIA">
            <edc:SFRFieldDef edc:cname="SPIMON0_VLTN" edc:nzwidth="0x1" edc:desc="SPIMON0_VLTN"/>
            <edc:SFRFieldDef edc:cname="SPIMON0_MTMON" edc:nzwidth="0x1" edc:desc="SPIMON0_MTMON"/>
            <edc:SFRFieldDef edc:cname="SPIMON0_LTMON" edc:nzwidth="0x1" edc:desc="SPIMON0_LTMON"/>
            <edc:AdjustPoint edc:offset="0x1"/>
            <edc:SFRFieldDef edc:cname="SPIMON1_VLTN" edc:nzwidth="0x1" edc:desc="SPIMON1_VLTN"/>
            <edc:SFRFieldDef edc:cname="SPIMON1_MTMON" edc:nzwidth="0x1" edc:desc="SPIMON1_MTMON"/>
            <edc:SFRFieldDef edc:cname="SPIMON1_LTMON" edc:nzwidth="0x1" edc:desc="SPIMON1_LTMON"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:AdjustPoint edc:offset="0x4" edc:_addr="0x4000E150"/>
      <edc:SFRDef ltx:memberofperipheral="ECIA" edc:cname="SRC25" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x4000E154"/>
      <edc:SFRDef ltx:memberofperipheral="ECIA" edc:cname="EN_SET25" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x4000E158"/>
      <edc:SFRDef ltx:memberofperipheral="ECIA" edc:cname="RESULT25" edc:nzwidth="0x20" edc:access="rrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrr" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x4000E15C"/>
      <edc:SFRDef ltx:memberofperipheral="ECIA" edc:cname="EN_CLR25" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x4000E160"/>
      <edc:AdjustPoint edc:offset="0x4" edc:_addr="0x4000E164"/>
      <edc:SFRDef ltx:memberofperipheral="ECIA" edc:cname="SRC26" edc:nzwidth="0x20" edc:access="--------------------n--n--------" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x900" edc:_addr="0x4000E168">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="ECIA">
            <edc:AdjustPoint edc:offset="0x8"/>
            <edc:SFRFieldDef edc:cname="GPIO250" edc:nzwidth="0x1" edc:desc="GPIO250"/>
            <edc:AdjustPoint edc:offset="0x2"/>
            <edc:SFRFieldDef edc:cname="GPIO253" edc:nzwidth="0x1" edc:desc="GPIO253"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="ECIA" edc:cname="EN_SET26" edc:nzwidth="0x20" edc:access="--------------------n--n--------" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x900" edc:_addr="0x4000E16C">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="ECIA">
            <edc:AdjustPoint edc:offset="0x8"/>
            <edc:SFRFieldDef edc:cname="GPIO250" edc:nzwidth="0x1" edc:desc="GPIO250"/>
            <edc:AdjustPoint edc:offset="0x2"/>
            <edc:SFRFieldDef edc:cname="GPIO260" edc:nzwidth="0x1" edc:desc="GPIO260"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="ECIA" edc:cname="RESULT26" edc:nzwidth="0x20" edc:access="--------------------r--r--------" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x900" edc:_addr="0x4000E170">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="ECIA">
            <edc:AdjustPoint edc:offset="0x8"/>
            <edc:SFRFieldDef edc:cname="GPIO250" edc:nzwidth="0x1" edc:desc="GPIO250"/>
            <edc:AdjustPoint edc:offset="0x2"/>
            <edc:SFRFieldDef edc:cname="GPIO260" edc:nzwidth="0x1" edc:desc="GPIO260"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="ECIA" edc:cname="EN_CLR26" edc:nzwidth="0x20" edc:access="--------------------n--n--------" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x900" edc:_addr="0x4000E174">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="ECIA">
            <edc:AdjustPoint edc:offset="0x8"/>
            <edc:SFRFieldDef edc:cname="GPIO250" edc:nzwidth="0x1" edc:desc="GPIO250"/>
            <edc:AdjustPoint edc:offset="0x2"/>
            <edc:SFRFieldDef edc:cname="GPIO260" edc:nzwidth="0x1" edc:desc="GPIO260"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:AdjustPoint edc:offset="0x88" edc:_addr="0x4000E178"/>
      <edc:SFRDef ltx:memberofperipheral="ECIA" edc:cname="BLK_EN_SET" edc:nzwidth="0x20" edc:access="-nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x7FFFFFFF" edc:_addr="0x4000E200">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="ECIA">
            <edc:SFRFieldDef edc:cname="VTOR_EN_SET" edc:nzwidth="0x1F" edc:desc="Each GIRQx bit can be individually enabled to assert an interrupt event.      Reads always return the current value of the internal GIRQX_ENABLE bit. The state of the GIRQX_ENABLE bit is determined by      the corresponding GIRQX_ENABLE_SET bit and the GIRQX_ENABLE_CLEAR bit. (0=disabled, 1=enabled) (R/WS)      1=Interrupts in the GIRQx Source Register may be enabled      0=No effect."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="ECIA" edc:cname="BLK_EN_CLR" edc:nzwidth="0x20" edc:access="-nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x7FFFFFFF" edc:_addr="0x4000E204">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="ECIA">
            <edc:SFRFieldDef edc:cname="VTOR_EN_CLR" edc:nzwidth="0x1F" edc:desc="Each GIRQx bit can be individually disabled to inhibit an interrupt event.      Reads always return the current value of the internal GIRQX_ENABLE bit. The state of the GIRQX_ENABLE bit is determined by      the corresponding GIRQX_ENABLE_SET bit and the GIRQX_ENABLE_CLEAR bit. (0=disabled, 1=enabled) (R/WC)      1=All interrupts in the GIRQx Source Register are disabled      0=No effect."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="ECIA" edc:cname="BLK_IRQ_VTOR" edc:nzwidth="0x20" edc:access="-------rrrrrrrrrrrrrrrrrrrrrrrrr" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x1FFFFFF" edc:_addr="0x4000E208">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="ECIA">
            <edc:SFRFieldDef edc:cname="VTOR" edc:nzwidth="0x19" edc:desc="Each bit in this field reports the status of the group GIRQ interrupt assertion to the NVIC. If the GIRQx interrupt      is disabled as a group, by the Block Enable Clear Register, then the corresponding bit will be '0'b and no interrupt will be asserted."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:AdjustPoint edc:offset="0x19F4" edc:_addr="0x4000E20C"/>
      <edc:SFRDef ltx:memberofperipheral="EC_REG_BANK" edc:cname="SRAM_CNFG" edc:nzwidth="0x8" edc:access="------nn" edc:por="00000000" edc:mclr="00000000" edc:impl="0x3" edc:_addr="0x4000FC00">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="EC_REG_BANK">
            <edc:SFRFieldDef edc:cname="SRAM_SIZE" edc:nzwidth="0x2" edc:desc="SRAM Configuration Register:     0: 384KB         (352k Code, 32k Data)    1: 320kB         (288k Code, 32k Data)    2: 256kB         (224k Code, 32k Data)    3: Illegal 256kB (224k Code, 32k Data)"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:AdjustPoint edc:offset="0x3" edc:_addr="0x4000FC01"/>
      <edc:SFRDef ltx:memberofperipheral="EC_REG_BANK" edc:cname="AHB_ERR_ADDR" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x4000FC04"/>
      <edc:AdjustPoint edc:offset="0xC" edc:_addr="0x4000FC08"/>
      <edc:SFRDef ltx:memberofperipheral="EC_REG_BANK" edc:cname="AHB_ERR_CTRL" edc:nzwidth="0x8" edc:access="nnnnnnnn" edc:por="00000000" edc:mclr="00000000" edc:_addr="0x4000FC14"/>
      <edc:AdjustPoint edc:offset="0x3" edc:_addr="0x4000FC15"/>
      <edc:SFRDef ltx:memberofperipheral="EC_REG_BANK" edc:cname="INTR_CTRL" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000001" edc:mclr="00000000000000000000000000000001" edc:_addr="0x4000FC18"/>
      <edc:SFRDef ltx:memberofperipheral="EC_REG_BANK" edc:cname="ETM_CTRL" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x4000FC1C"/>
      <edc:SFRDef ltx:memberofperipheral="EC_REG_BANK" edc:cname="DEBUG_CTRL" edc:nzwidth="0x20" edc:access="---------------------------nnnnn" edc:por="00000000000000000000000010000000" edc:mclr="00000000000000000000000010000000" edc:impl="0x1F" edc:_addr="0x4000FC20">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="EC_REG_BANK">
            <edc:SFRFieldDef edc:cname="JTAG_EN" edc:nzwidth="0x1" edc:desc="DEBUG_EN (JTAG_EN) This bit enables the JTAG/SWD debug port.               0= JTAG/SWD port disabled. JTAG/SWD cannot be enabled (i.e., the TRST# pin is ignored and the JTAG signals remain in their non-JTAG state)               1= JTAG/SWD port enabled. A high on TRST# enables JTAG or SWD, as determined by SWD_EN."/>
            <edc:SFRFieldDef edc:cname="DBG_PIN_CFG" edc:nzwidth="0x2" edc:desc="This field determines which pins are affected by the TRST# debug enable pin.      3=Reserved      2=The pins associated with the JTAG TCK and TMS switch to the debug interface when TRST# is de-asserted high. The pins      associated with TDI and TDO remain controlled by the associated GPIO. This setting should be used when the ARM Serial      Wire Debug (SWD) is required for debugging and the Serial Wire Viewer is not required      1=The pins associated with the JTAG TCK, TMS and TDO switch to the debug interface when TRST# is de-asserted high. The pin      associated with TDI remains controlled by the associated GPIO. This setting should be used when the ARM Serial Wire Debug      (SWD) and Serial Wire Viewer (SWV) are both required for debugging      0=All four pins associated with JTAG (TCK, TMS, TDI and TDO) switch to the debug interface when TRST# is de-asserted high.      This setting should be used when the JTAG TAP controller is required for debugging.">
              <edc:SFRFieldSemantic edc:cname="JTAG_TCK_TMS" edc:desc="2=The pins associated with the JTAG TCK and TMS switch to the debug interface when TRST# is de-asserted high. The pins           associated with TDI and TDO remain controlled by the associated GPIO. This setting should be used when the ARM Serial          Wire Debug (SWD) is required for debugging and the Serial Wire Viewer is not required " edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="JTAG_TCK_TMS_TDO" edc:desc="1=The pins associated with the JTAG TCK, TMS and TDO switch to the debug interface when TRST# is de-asserted high. The pin           associated with TDI remains controlled by the associated GPIO. This setting should be used when the ARM Serial Wire Debug             (SWD) and Serial Wire Viewer (SWV) are both required for debugging" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="JTAG_TCK_TMS_TDO_TDI" edc:desc="0=All four pins associated with JTAG (TCK, TMS, TDI and TDO) switch to the debug interface when TRST# is de-asserted high.         This setting should be used when the JTAG TAP controller is required for debugging." edc:when="(field &amp; 0x3) == 0x00"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="JTAG_PU_EN" edc:nzwidth="0x1" edc:desc="If this bit is set to '1b' internal pull-up resistors are automatically enabled on the appropriate debugging port      wires whenever the debug port is enabled (the DEBUG_EN bit in this register is '1b' and the JTAG_RST# pin is high). The setting      of DEBUG_PIN_CFG determines which pins have pull-ups enabled when the debug port is enabled."/>
            <edc:SFRFieldDef edc:cname="BS_EN" edc:nzwidth="0x1" edc:desc="This bit sets the boundary scan tap controller accessibility from JTAG port.             1= Boundary scan tap controller accessibile through JTAG Port.             0= Boundary scan tap controller not accessibile through JTAG Port."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="EC_REG_BANK" edc:cname="OTP_LOCK" edc:nzwidth="0x20" edc:access="-----------------------n-----nnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x107" edc:_addr="0x4000FC24">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="EC_REG_BANK">
            <edc:SFRFieldDef edc:cname="TEST" edc:nzwidth="0x1" edc:desc="Test"/>
            <edc:SFRFieldDef edc:cname="VBAT_RAM_LOCK" edc:nzwidth="0x1" edc:desc="VBAT RAM LOCK bit.         0 = Not Locked.         1 = Locked."/>
            <edc:SFRFieldDef edc:cname="VBAT_REG_LOCK" edc:nzwidth="0x1" edc:desc="VBAT REG LOCK.         0 = Not Locked.         1 = Locked."/>
            <edc:AdjustPoint edc:offset="0x5"/>
            <edc:SFRFieldDef edc:cname="SCUR_MBX_LOCK" edc:nzwidth="0x1" edc:desc="Secure Mailbox LOCK.         0 = Not Locked.         1 = Write Locked."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="EC_REG_BANK" edc:cname="WDT_CNT" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x4000FC28"/>
      <edc:SFRDef ltx:memberofperipheral="EC_REG_BANK" edc:cname="AESH_BSWAP_CTRL" edc:nzwidth="0x20" edc:access="------------------------nnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0xFF" edc:_addr="0x4000FC2C">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="EC_REG_BANK">
            <edc:SFRFieldDef edc:cname="IP_BYTE_SWAP_EN" edc:nzwidth="0x1" edc:desc="Used to enable byte swap on a DWORD during AHB read from AES / HASH block: 1=Enable; 0=Disable."/>
            <edc:SFRFieldDef edc:cname="OP_BYTE_SWAP_EN" edc:nzwidth="0x1" edc:desc="Used to enable byte swap on a DWORD during AHB write from AES / HASH block: 1=Enable; 0=Disable."/>
            <edc:SFRFieldDef edc:cname="IP_BLK_SWAP_EN" edc:nzwidth="0x3" edc:desc="Used to enable word swap on a DWORD during AHB read from AES / HASH block 0=Disable.">
              <edc:SFRFieldSemantic edc:cname="SWAP_128_BYTE_BLOCK" edc:desc="4=Swap 32-bit doublewords in 128-byte blocks " edc:when="(field &amp; 0x7) == 0x04"/>
              <edc:SFRFieldSemantic edc:cname="SWAP_64_BYTE_BLOCK" edc:desc="3=Swap doublewords in 64-byte blocks. Useful for SHA-256. Bus references issued in the order 0x3C, 0x38, 0x34, 0x30, 0x2C,          0x28, 0x24, 0x20, 0x1C, 0x18, 0x14, 0x10, 0xC, 0x8, 0x4, 0x0,..." edc:when="(field &amp; 0x7) == 0x03"/>
              <edc:SFRFieldSemantic edc:cname="SWAP_16_BYTE_BLOCK" edc:desc="2=Swap doublewords in 16-byte blocks. Useful for AES. Bus references issued in the order 0xC, 0x8, 0x4, 0x0, 0x1C, 0x18,..." edc:when="(field &amp; 0x7) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="SWAP_8_BYTE_BLOCK" edc:desc="1=Swap doublewords in 8-byte blocks. Useful for SHA-512, which works on 64-bit words. Bus references issued in the order 0x4,       0x0, 0xC, 0x8, ..." edc:when="(field &amp; 0x7) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="DIS" edc:desc="0=Disable." edc:when="(field &amp; 0x7) == 0x00"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="OP_BLK_SWAP_EN" edc:nzwidth="0x3" edc:desc="Used to enable word swap on a DWORD during AHB write from AES / HASH block 0=Disable.">
              <edc:SFRFieldSemantic edc:cname="SWAP_128_BYTE_BLOCK" edc:desc="4=Swap 32-bit doublewords in 128-byte blocks " edc:when="(field &amp; 0x7) == 0x04"/>
              <edc:SFRFieldSemantic edc:cname="SWAP_64_BYTE_BLOCK" edc:desc="3=Swap doublewords in 64-byte blocks. Useful for SHA-256. Bus references issued in the order 0x3C, 0x38, 0x34, 0x30, 0x2C,          0x28, 0x24, 0x20, 0x1C, 0x18, 0x14, 0x10, 0xC, 0x8, 0x4, 0x0,..." edc:when="(field &amp; 0x7) == 0x03"/>
              <edc:SFRFieldSemantic edc:cname="SWAP_16_BYTE_BLOCK" edc:desc="2=Swap doublewords in 16-byte blocks. Useful for AES. Bus references issued in the order 0xC, 0x8, 0x4, 0x0, 0x1C, 0x18,..." edc:when="(field &amp; 0x7) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="SWAP_8_BYTE_BLOCK" edc:desc="1=Swap doublewords in 8-byte blocks. Useful for SHA-512, which works on 64-bit words. Bus references issued in the order 0x4,       0x0, 0xC, 0x8, ..." edc:when="(field &amp; 0x7) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="DIS" edc:desc="0=Disable." edc:when="(field &amp; 0x7) == 0x00"/>
            </edc:SFRFieldDef>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:AdjustPoint edc:offset="0x34" edc:_addr="0x4000FC30"/>
      <edc:SFRDef ltx:memberofperipheral="EC_REG_BANK" edc:cname="GPIO_BANK_PWR" edc:nzwidth="0x20" edc:access="------------------------n-----nn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x83" edc:_addr="0x4000FC64">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="EC_REG_BANK">
            <edc:SFRFieldDef edc:cname="TEST" edc:nzwidth="0x1" edc:desc="This bit must be programmed to 0h for proper operation of the device."/>
            <edc:SFRFieldDef edc:cname="VTR_LVL2" edc:nzwidth="0x1" edc:desc="Voltage value on VTR2. This bit is set by Firmware after a VTR Power On Reset.         It must be set by software if the VTR power rail is not active when RESET_SYS is de-asserted.         Write access is determined by bit 7.      1=VTR2 is powered by 1.8V      0=VTR2 is powered by 3.3V."/>
            <edc:AdjustPoint edc:offset="0x5"/>
            <edc:SFRFieldDef edc:cname="GPIO_BANK_PWR_LOCK" edc:nzwidth="0x1" edc:desc="GPIO Bank Power Lock. 0: VTR_LEVEL bits[2:0] and GPIO Bank Power Lock bit are R/W      1 = VTR_LEVEL bits[2:0] and GPIO Bank Power Lock bit are Read Only."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:AdjustPoint edc:offset="0x8" edc:_addr="0x4000FC68"/>
      <edc:SFRDef ltx:memberofperipheral="EC_REG_BANK" edc:cname="SRAM_BNK_SWP" edc:nzwidth="0x20" edc:access="-------------------------------n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x1" edc:_addr="0x4000FC70">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="EC_REG_BANK">
            <edc:SFRFieldDef edc:cname="BNK_SWP" edc:nzwidth="0x1" edc:desc="SRAM bank Swap Register"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:AdjustPoint edc:offset="0x1C" edc:_addr="0x4000FC74"/>
      <edc:SFRDef ltx:memberofperipheral="EC_REG_BANK" edc:cname="VW_SRC_CNGF" edc:nzwidth="0x20" edc:access="-----------------------------nnn" edc:por="00000000000000000000000000000111" edc:mclr="00000000000000000000000000000111" edc:impl="0x7" edc:_addr="0x4000FC90">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="EC_REG_BANK">
            <edc:SFRFieldDef edc:cname="VW_SRC" edc:nzwidth="0x3" edc:desc="VWIRE_SOURCE [2], VWIRE_SOURCE [1], VWIRE_SOURCE [0]"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:AdjustPoint edc:offset="0x30" edc:_addr="0x4000FC94"/>
      <edc:SFRDef ltx:memberofperipheral="EC_REG_BANK" edc:cname="SPIMON_IB_CNGF" edc:nzwidth="0x20" edc:access="----nnnnnnnn-------n--nn--------" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0xFF01300" edc:_addr="0x4000FCC4">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="EC_REG_BANK">
            <edc:AdjustPoint edc:offset="0x8"/>
            <edc:SFRFieldDef edc:cname="MON0" edc:nzwidth="0x1" edc:desc="QSPI0 Monitor 0. 1 = Route QMSPI0 Traffic to Monitor. 0 = Route Host AP0 Traffic to Monitor"/>
            <edc:SFRFieldDef edc:cname="MON1" edc:nzwidth="0x1" edc:desc="QSPI1 Monitor 1. 1 = Route QMSPI1 Traffic to Monitor. 0 = Route Host AP1 Traffic to Monitor"/>
            <edc:AdjustPoint edc:offset="0x2"/>
            <edc:SFRFieldDef edc:cname="IDL" edc:nzwidth="0x1" edc:desc="Lock bit for IDE"/>
            <edc:AdjustPoint edc:offset="0x7"/>
            <edc:SFRFieldDef edc:cname="IDV" edc:nzwidth="0x5" edc:desc="Delay Value"/>
            <edc:SFRFieldDef edc:cname="IDU" edc:nzwidth="0x2" edc:desc="Delay Units"/>
            <edc:SFRFieldDef edc:cname="IDE" edc:nzwidth="0x1" edc:desc="Inter-Bus Intervention Enable"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:AdjustPoint edc:offset="0x178" edc:_addr="0x4000FCC8"/>
      <edc:SFRDef ltx:memberofperipheral="EC_REG_BANK" edc:cname="PD_MON_CTRL" edc:nzwidth="0x20" edc:access="-----------------nnn--nn-nnn--nn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x7373" edc:_addr="0x4000FE40">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="EC_REG_BANK">
            <edc:SFRFieldDef edc:cname="CTRL_VTR1" edc:nzwidth="0x2" edc:desc="Pad Monitor Control VTR1. 0=OFF, 1=1ms delay, 2=10ms delay, 3=100ms delay">
              <edc:SFRFieldSemantic edc:cname="DISABLED" edc:desc="Disabled" edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="1MS_DEBOUNCE_CNTR" edc:desc="1ms Debounce Counter Enable" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="10MS_DEBOUNCE_CNTR" edc:desc="10ms Debounce Counter Enable" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="100MS_DEBOUNCE_CNTR" edc:desc="100ms Debounce Counter Enable" edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:AdjustPoint edc:offset="0x2"/>
            <edc:SFRFieldDef edc:cname="OVRD_VTR1" edc:nzwidth="0x1" edc:desc="PAD Monitor Override VTR1 0=Normal Operation 1=Override input_disable and pad_protect_n"/>
            <edc:SFRFieldDef edc:cname="VTR1_INPT_DIS" edc:nzwidth="0x1" edc:desc="PAD Monitor Override Input Disable VTR1. 0=Normal Operation 1=input_disable"/>
            <edc:SFRFieldDef edc:cname="VTR1_PROTECN" edc:nzwidth="0x1" edc:desc="PAD Monitor Override Protect N VTR1."/>
            <edc:AdjustPoint edc:offset="0x1"/>
            <edc:SFRFieldDef edc:cname="CTRL_VTR2" edc:nzwidth="0x2" edc:desc="Pad Monitor Control VTR2. 0=OFF, 1=1ms delay, 2=10ms delay, 3=100ms delay">
              <edc:SFRFieldSemantic edc:cname="DISABLED" edc:desc="Disabled" edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="1MS_DEBOUNCE_CNTR" edc:desc="1ms Debounce Counter Enable" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="10MS_DEBOUNCE_CNTR" edc:desc="10ms Debounce Counter Enable" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="100MS_DEBOUNCE_CNTR" edc:desc="100ms Debounce Counter Enable" edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:AdjustPoint edc:offset="0x2"/>
            <edc:SFRFieldDef edc:cname="OVRD_VTR2" edc:nzwidth="0x1" edc:desc="PAD Monitor Override VTR2 0=Normal Operation 1=Override input_disable and pad_protect_n"/>
            <edc:SFRFieldDef edc:cname="VTR2_INPT_DIS" edc:nzwidth="0x1" edc:desc="PAD Monitor Override Input Disable VTR2. 0=Normal Operation 1=input_disable"/>
            <edc:SFRFieldDef edc:cname="VTR2_PROTECN" edc:nzwidth="0x1" edc:desc="PAD Monitor Override Protect N VTR2."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="EC_REG_BANK" edc:cname="PD_MON_INT_EN" edc:nzwidth="0x20" edc:access="----------------------nn------nn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x303" edc:_addr="0x4000FE44">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="EC_REG_BANK">
            <edc:SFRFieldDef edc:cname="VTR1_PD_INTEN" edc:nzwidth="0x1" edc:desc="Pad Monitor VTR1 Power Down Interrupt Enable."/>
            <edc:SFRFieldDef edc:cname="VTR1_PU_INTEN" edc:nzwidth="0x1" edc:desc="Pad Monitor VTR1 Power Up Interrupt Enable"/>
            <edc:AdjustPoint edc:offset="0x6"/>
            <edc:SFRFieldDef edc:cname="VTR2_PD_INTEN" edc:nzwidth="0x1" edc:desc="Pad Monitor VTR2 Power Down Interrupt Enable."/>
            <edc:SFRFieldDef edc:cname="VTR2_PU_INTEN" edc:nzwidth="0x1" edc:desc="Pad Monitor VTR2 Power Up Interrupt Enable"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="EC_REG_BANK" edc:cname="PD_MON_STS" edc:nzwidth="0x20" edc:access="----------------n-----nnn-----nn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x8383" edc:_addr="0x4000FE48">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="EC_REG_BANK">
            <edc:SFRFieldDef edc:cname="VTR1_PD_STS" edc:nzwidth="0x1" edc:desc="Pad Monitor VTR1 Power Down Status"/>
            <edc:SFRFieldDef edc:cname="VTR1_PU_STS" edc:nzwidth="0x1" edc:desc="Pad Monitor VTR1 Power Up Status"/>
            <edc:AdjustPoint edc:offset="0x5"/>
            <edc:SFRFieldDef edc:cname="VTR1_CS_STS" edc:nzwidth="0x1" edc:desc="Pad Monitor Current state VTR1"/>
            <edc:SFRFieldDef edc:cname="VTR2_PD_STS" edc:nzwidth="0x1" edc:desc="Pad Monitor VTR2 Power Down Status"/>
            <edc:SFRFieldDef edc:cname="VTR2_PU_STS" edc:nzwidth="0x1" edc:desc="Pad Monitor VTR2 Power Up Status"/>
            <edc:AdjustPoint edc:offset="0x5"/>
            <edc:SFRFieldDef edc:cname="VTR2_CS_STS" edc:nzwidth="0x1" edc:desc="Pad Monitor Current state VTR2"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:AdjustPoint edc:offset="0x1B4" edc:_addr="0x4000FE4C"/>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON0" edc:cname="MNTR_CTRL" edc:nzwidth="0x20" edc:access="----------nnnnnn-------n------nn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x3F0103" edc:_addr="0x40010000">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON0">
            <edc:SFRFieldDef edc:cname="ACT" edc:nzwidth="0x1" edc:desc="Activate 1= Activate, 0= De-activate"/>
            <edc:SFRFieldDef edc:cname="LCK_ACT" edc:nzwidth="0x1" edc:desc="Lock Activate 1= Activate field Locked, 0= Activate field unlocked"/>
            <edc:AdjustPoint edc:offset="0x6"/>
            <edc:SFRFieldDef edc:cname="SFT_RST" edc:nzwidth="0x1" edc:desc="Soft Reset. This field is auto cleared by hardware. 1= Soft Reset SPI Monitor, 0 = No Effect"/>
            <edc:AdjustPoint edc:offset="0x7"/>
            <edc:SFRFieldDef edc:cname="TAP_SEL" edc:nzwidth="0x5" edc:desc="CPTR_CLK_TAP_SEL selects which 0.5ns delay tap to have the capture clock on.      00h = 0 ns delay (or if TAP_EN = 0).     01h = 0.5ns nom delay; +/- 50%     02h = 1.0ns      03h = 1.5ns     04h = 2.0ns     etc.     1Fh = 15.5ns"/>
            <edc:SFRFieldDef edc:cname="TAP_EN" edc:nzwidth="0x1" edc:desc="CPTR_CLK_TAP_EN enable the delay taps. It is recommended that a customer set the TAP_EN bit to 1, and the TAP_SEL field to 04h."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON0" edc:cname="CFG_STS" edc:nzwidth="0x20" edc:access="n-nnnnnnn-nnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0xBFBFFFFF" edc:_addr="0x40010004">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON0">
            <edc:SFRFieldDef edc:cname="IMD" edc:nzwidth="0x1" edc:desc="Flash Intervention Mode. 0 = Power-Off (POR), 1 = RESET# Pulse "/>
            <edc:SFRFieldDef edc:cname="RST2CSH" edc:nzwidth="0x5" edc:desc="RESET# to CS# High Delay. 2^n x 20us, 00h=20us, 1Fh= 1.3sec. IRQ triggers at this point also."/>
            <edc:SFRFieldDef edc:cname="QBD" edc:nzwidth="0x1" edc:desc="Quad Bus Disable, 1 = Half Bus Mode,  0 = IO[3:0] are all controlled by EQS."/>
            <edc:SFRFieldDef edc:cname="XQS" edc:nzwidth="0x1" edc:desc="Cross-Over Q-Switch status. (BMC-&gt;CPU). RO image of Interbus bit which as 1 overrides EQS bit at both SPI buses without changing their states."/>
            <edc:SFRFieldDef edc:cname="EQS" edc:nzwidth="0x1" edc:desc="Enable Q-Switch (Isolator) to Host. 0 = Disable, 1 = Enable."/>
            <edc:SFRFieldDef edc:cname="CSRT" edc:nzwidth="0x3" edc:desc="Chip Select Routing.      000 = Both CSn#_In pass directly to CSn# Out, both enabled out.     001 = CS1n_In passes to CS1# Output, but CS0# Output is disabled (floats high).     010 = CS0n_In passes to CS0# Output, but CS1# Output is disabled (floats high).     100 = Swap CS1#/CS0#_In to CS0#/CS1# Out respectively, both enabled out.     101 = CS0n_In passes to CS1# Out, and CS0# Output is disabled (floats high).     110 = CS1n_In passes to CS0# Out, and CS1# Output is disabled (floats high).     x11 = CS0n/CS1n Outputs are both disabled (floating high) regardless of inputs."/>
            <edc:SFRFieldDef edc:cname="F0F" edc:nzwidth="0x1" edc:desc="Enable following of Address Mode. (SPI Snooping) for each Flash. 0=Disable, 1=Enable"/>
            <edc:SFRFieldDef edc:cname="F1F" edc:nzwidth="0x1" edc:desc="Enable following of Address Mode. (SPI Snooping) for each Flash. 0=Disable, 1=Enable"/>
            <edc:SFRFieldDef edc:cname="F0A" edc:nzwidth="0x1" edc:desc="Set 3B/4B Address Mode for Flash 0. 0=3B Address Mode, 1=4B Address Mode"/>
            <edc:SFRFieldDef edc:cname="F1A" edc:nzwidth="0x1" edc:desc="Set 3B/4B Address Mode for Flash 1. 0=3B Address Mode, 1=4B Address Mode"/>
            <edc:SFRFieldDef edc:cname="F0SIZE" edc:nzwidth="0x5" edc:desc="Flash 0 Size. Flash sizes are expressed in bytes as a power of 2, matching a Flash Get-ID convention.     For the most common cases:      17h = 23d =&gt; 2^23 = 8MByte     18h = 24d =&gt; 2^24 = 16MByte     19h = 25d =&gt; 2^25 = 32MByte     1Ah = 26d =&gt; 2^26 = 64MByte"/>
            <edc:SFRFieldDef edc:cname="E0W" edc:nzwidth="0x1" edc:desc="Enable Wrap Detection. 0=Disable, 1=Enable."/>
            <edc:AdjustPoint edc:offset="0x1"/>
            <edc:SFRFieldDef edc:cname="F0P" edc:nzwidth="0x1" edc:desc="Flash 0 Present. 0=Not Present, 1=Present"/>
            <edc:SFRFieldDef edc:cname="F1SIZE" edc:nzwidth="0x5" edc:desc="Flash 1 Size. Flash sizes are expressed in bytes as a power of 2, matching a Flash Get-ID convention.     For the most common cases:      17h = 23d =&gt; 2^23 = 8MByte     18h = 24d =&gt; 2^24 = 16MByte     19h = 25d =&gt; 2^25 = 32MByte     1Ah = 26d =&gt; 2^26 = 64MByte"/>
            <edc:SFRFieldDef edc:cname="E1W" edc:nzwidth="0x1" edc:desc="Enable Wrap Detection. 0=Disable, 1=Enable"/>
            <edc:AdjustPoint edc:offset="0x1"/>
            <edc:SFRFieldDef edc:cname="F1P" edc:nzwidth="0x1" edc:desc="Flash 1 Present. 0=Not Present, 1=Present"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON0" edc:cname="SPICFG2" edc:nzwidth="0x20" edc:access="--------------nn--nn--nn------nn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x33303" edc:_addr="0x40010008">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON0">
            <edc:SFRFieldDef edc:cname="HRM" edc:nzwidth="0x1" edc:desc="Host Reset Mode. 0 = APn_RESET#, 1 = Pin."/>
            <edc:SFRFieldDef edc:cname="HRL" edc:nzwidth="0x1" edc:desc="HRM Bit Lock. 0 = Unlocked, 1 = Locked."/>
            <edc:AdjustPoint edc:offset="0x6"/>
            <edc:SFRFieldDef edc:cname="DIV" edc:nzwidth="0x1" edc:desc="Disable Inter Vention. 1 = IRQ-only Mode."/>
            <edc:SFRFieldDef edc:cname="DIL" edc:nzwidth="0x1" edc:desc="DIV Bit Lock. 0 = Unlocked, 1 = Locked."/>
            <edc:AdjustPoint edc:offset="0x2"/>
            <edc:SFRFieldDef edc:cname="RIV" edc:nzwidth="0x1" edc:desc="Special Region InterVention Mode. If DIV=1 then RIV is ignored.     If DIV=0 and RIV=1 then: Reads that are forbidden by the Runtime Region register set     are only cancelled by gating off CSn# for that SPI command, and setting the IRQ.     No system shutdown results, and subsequent legal Reads are allowed."/>
            <edc:SFRFieldDef edc:cname="RIL" edc:nzwidth="0x1" edc:desc="RIV Bit Lock. 0 = Unlocked, 1 = Locked."/>
            <edc:AdjustPoint edc:offset="0x2"/>
            <edc:SFRFieldDef edc:cname="ALG" edc:nzwidth="0x1" edc:desc="Hash Algorithm Mode. 0 = SHA-384, 1 = Reserved "/>
            <edc:SFRFieldDef edc:cname="ALL" edc:nzwidth="0x1" edc:desc="ALG Bit Lock. 0 = Unlocked, 1 = Locked."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON0" edc:cname="VIOCTRLSTS" edc:nzwidth="0x20" edc:access="------------------nnnnnn--nnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x3F3F" edc:_addr="0x4001000C">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON0">
            <edc:SFRFieldDef edc:cname="OP" edc:nzwidth="0x1" edc:desc="Opcode Violation"/>
            <edc:SFRFieldDef edc:cname="MC" edc:nzwidth="0x1" edc:desc="Data Mismatch Violation"/>
            <edc:SFRFieldDef edc:cname="OB" edc:nzwidth="0x1" edc:desc="Out of Bounds. Outside all Runtime Regions"/>
            <edc:SFRFieldDef edc:cname="RG" edc:nzwidth="0x1" edc:desc="Runtime Region R/W Permission Violation"/>
            <edc:SFRFieldDef edc:cname="MT" edc:nzwidth="0x1" edc:desc="Timeout in Match Phase"/>
            <edc:SFRFieldDef edc:cname="AW" edc:nzwidth="0x1" edc:desc="Address Wrap within a Flash device."/>
            <edc:AdjustPoint edc:offset="0x2"/>
            <edc:SFRFieldDef edc:cname="EOP" edc:nzwidth="0x1" edc:desc="Enable Opcode Violation Interrupt. 0 = Disable, 1 = Enable"/>
            <edc:SFRFieldDef edc:cname="EMC" edc:nzwidth="0x1" edc:desc="Enable Data Mismatch Violation Interrupt. 0 = Disable, 1 = Enable"/>
            <edc:SFRFieldDef edc:cname="EOB" edc:nzwidth="0x1" edc:desc="Enable Out of Bounds Interrupt. 0 = Disable, 1 = Enable"/>
            <edc:SFRFieldDef edc:cname="ERG" edc:nzwidth="0x1" edc:desc="Enable Runtime Region R/W Permission Violation Interrupt. 0 = Disable, 1 = Enable"/>
            <edc:SFRFieldDef edc:cname="EMT" edc:nzwidth="0x1" edc:desc="Enable Timeout in Match Phase Interrupt. 0 = Disable, 1 = Enable"/>
            <edc:SFRFieldDef edc:cname="EAW" edc:nzwidth="0x1" edc:desc="Enable Address Wrap within a Flash device Interrupt. 0 = Disable, 1 = Enable"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON0" edc:cname="IVN_STS" edc:nzwidth="0x8" edc:access="----rrrr" edc:por="00000000" edc:mclr="00000000" edc:impl="0xF" edc:_addr="0x40010010">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON0">
            <edc:SFRFieldDef edc:cname="FCS" edc:nzwidth="0x1" edc:desc="Flash Chip Selects forced high and bus forced low."/>
            <edc:SFRFieldDef edc:cname="FPO" edc:nzwidth="0x1" edc:desc="Flash Power or RESET# Activated."/>
            <edc:SFRFieldDef edc:cname="HRS" edc:nzwidth="0x1" edc:desc="Host held in Reset"/>
            <edc:SFRFieldDef edc:cname="HIS" edc:nzwidth="0x1" edc:desc="Host held Isolated"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON0" edc:cname="IVN_REC" edc:nzwidth="0x8" edc:access="----wwww" edc:por="00000000" edc:mclr="00000000" edc:impl="0xF" edc:_addr="0x40010011">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON0">
            <edc:SFRFieldDef edc:cname="FCC" edc:nzwidth="0x1" edc:desc="Write 1 to clear FCS Flash Chip Selects forced high and bus forced low."/>
            <edc:SFRFieldDef edc:cname="FPC" edc:nzwidth="0x1" edc:desc="Write 1 to clear FPO Flash Power or RESET# Activated."/>
            <edc:SFRFieldDef edc:cname="HRC" edc:nzwidth="0x1" edc:desc="Write 1 to clear HRS Host held in Reset"/>
            <edc:SFRFieldDef edc:cname="HIC" edc:nzwidth="0x1" edc:desc="Write 1 to clear HIS Host held Isolated"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:AdjustPoint edc:offset="0x2" edc:_addr="0x40010012"/>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON0" edc:cname="VIO_STS" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnn-nn-n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0xFFFFFFED" edc:_addr="0x40010014">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON0">
            <edc:SFRFieldDef edc:cname="OP" edc:nzwidth="0x1" edc:desc="Opcode Violation"/>
            <edc:AdjustPoint edc:offset="0x1"/>
            <edc:SFRFieldDef edc:cname="ROB" edc:nzwidth="0x1" edc:desc="Region Failure, Out of Bounds"/>
            <edc:SFRFieldDef edc:cname="REG" edc:nzwidth="0x1" edc:desc="Runtime Region Violation"/>
            <edc:AdjustPoint edc:offset="0x1"/>
            <edc:SFRFieldDef edc:cname="AWP" edc:nzwidth="0x1" edc:desc="Address Wrap"/>
            <edc:SFRFieldDef edc:cname="DV" edc:nzwidth="0x1" edc:desc="Device Number"/>
            <edc:SFRFieldDef edc:cname="REGION" edc:nzwidth="0x5" edc:desc="Region Number"/>
            <edc:SFRFieldDef edc:cname="RD" edc:nzwidth="0x1" edc:desc="Killed as a Read"/>
            <edc:SFRFieldDef edc:cname="PE" edc:nzwidth="0x1" edc:desc="Killed as a Program or Erase"/>
            <edc:SFRFieldDef edc:cname="AM" edc:nzwidth="0x1" edc:desc="Flash Address Mode"/>
            <edc:SFRFieldDef edc:cname="CLR" edc:nzwidth="0x1" edc:desc="Clear Register RW1C. This bit is auto clearing"/>
            <edc:SFRFieldDef edc:cname="OPCOD" edc:nzwidth="0x8" edc:desc="Flash Opcode"/>
            <edc:SFRFieldDef edc:cname="DAT" edc:nzwidth="0x8" edc:desc="SPI Data Byte"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON0" edc:cname="ERR_ADDR" edc:nzwidth="0x20" edc:access="rrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrr" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x40010018">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON0">
            <edc:SFRFieldDef edc:cname="ADDR" edc:nzwidth="0x20" edc:desc="Byte address at which the error occurred, within the designated Flash"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:AdjustPoint edc:offset="0x4" edc:_addr="0x4001001C"/>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON0" edc:cname="FLASH_SET0OP_PRMT0" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x40010020">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON0">
            <edc:SFRFieldDef edc:cname="PRMT" edc:nzwidth="0x20" edc:desc="Permit. Each array organized into 8 32-bit registers set per Flash device.    1 = Permit, and if not recognized then ignore.     0 = Kill immediately upon seeing this opcode."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON0" edc:cname="FLASH_SET0OP_PRMT1" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x40010024">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON0">
            <edc:SFRFieldDef edc:cname="PRMT" edc:nzwidth="0x20" edc:desc="Permit. Each array organized into 8 32-bit registers set per Flash device.    1 = Permit, and if not recognized then ignore.     0 = Kill immediately upon seeing this opcode."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON0" edc:cname="FLASH_SET0OP_PRMT2" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x40010028">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON0">
            <edc:SFRFieldDef edc:cname="PRMT" edc:nzwidth="0x20" edc:desc="Permit. Each array organized into 8 32-bit registers set per Flash device.    1 = Permit, and if not recognized then ignore.     0 = Kill immediately upon seeing this opcode."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON0" edc:cname="FLASH_SET0OP_PRMT3" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x4001002C">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON0">
            <edc:SFRFieldDef edc:cname="PRMT" edc:nzwidth="0x20" edc:desc="Permit. Each array organized into 8 32-bit registers set per Flash device.    1 = Permit, and if not recognized then ignore.     0 = Kill immediately upon seeing this opcode."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON0" edc:cname="FLASH_SET0OP_PRMT4" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x40010030">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON0">
            <edc:SFRFieldDef edc:cname="PRMT" edc:nzwidth="0x20" edc:desc="Permit. Each array organized into 8 32-bit registers set per Flash device.    1 = Permit, and if not recognized then ignore.     0 = Kill immediately upon seeing this opcode."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON0" edc:cname="FLASH_SET0OP_PRMT5" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x40010034">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON0">
            <edc:SFRFieldDef edc:cname="PRMT" edc:nzwidth="0x20" edc:desc="Permit. Each array organized into 8 32-bit registers set per Flash device.    1 = Permit, and if not recognized then ignore.     0 = Kill immediately upon seeing this opcode."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON0" edc:cname="FLASH_SET0OP_PRMT6" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x40010038">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON0">
            <edc:SFRFieldDef edc:cname="PRMT" edc:nzwidth="0x20" edc:desc="Permit. Each array organized into 8 32-bit registers set per Flash device.    1 = Permit, and if not recognized then ignore.     0 = Kill immediately upon seeing this opcode."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON0" edc:cname="FLASH_SET0OP_PRMT7" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x4001003C">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON0">
            <edc:SFRFieldDef edc:cname="PRMT" edc:nzwidth="0x20" edc:desc="Permit. Each array organized into 8 32-bit registers set per Flash device.    1 = Permit, and if not recognized then ignore.     0 = Kill immediately upon seeing this opcode."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON0" edc:cname="FLASH_SET0OP_KILLMD0" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x40010040">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON0">
            <edc:SFRFieldDef edc:cname="KILL" edc:nzwidth="0x20" edc:desc="Kill. Each array organized into 8 32-bit registers set per Flash device.    1 = If Killed, then kill as a Write: Holding CS# low.    0 = If Killed, then kill as a Read: Force CS# high first."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON0" edc:cname="FLASH_SET0OP_KILLMD1" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x40010044">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON0">
            <edc:SFRFieldDef edc:cname="KILL" edc:nzwidth="0x20" edc:desc="Kill. Each array organized into 8 32-bit registers set per Flash device.    1 = If Killed, then kill as a Write: Holding CS# low.    0 = If Killed, then kill as a Read: Force CS# high first."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON0" edc:cname="FLASH_SET0OP_KILLMD2" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x40010048">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON0">
            <edc:SFRFieldDef edc:cname="KILL" edc:nzwidth="0x20" edc:desc="Kill. Each array organized into 8 32-bit registers set per Flash device.    1 = If Killed, then kill as a Write: Holding CS# low.    0 = If Killed, then kill as a Read: Force CS# high first."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON0" edc:cname="FLASH_SET0OP_KILLMD3" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x4001004C">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON0">
            <edc:SFRFieldDef edc:cname="KILL" edc:nzwidth="0x20" edc:desc="Kill. Each array organized into 8 32-bit registers set per Flash device.    1 = If Killed, then kill as a Write: Holding CS# low.    0 = If Killed, then kill as a Read: Force CS# high first."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON0" edc:cname="FLASH_SET0OP_KILLMD4" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x40010050">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON0">
            <edc:SFRFieldDef edc:cname="KILL" edc:nzwidth="0x20" edc:desc="Kill. Each array organized into 8 32-bit registers set per Flash device.    1 = If Killed, then kill as a Write: Holding CS# low.    0 = If Killed, then kill as a Read: Force CS# high first."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON0" edc:cname="FLASH_SET0OP_KILLMD5" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x40010054">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON0">
            <edc:SFRFieldDef edc:cname="KILL" edc:nzwidth="0x20" edc:desc="Kill. Each array organized into 8 32-bit registers set per Flash device.    1 = If Killed, then kill as a Write: Holding CS# low.    0 = If Killed, then kill as a Read: Force CS# high first."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON0" edc:cname="FLASH_SET0OP_KILLMD6" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x40010058">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON0">
            <edc:SFRFieldDef edc:cname="KILL" edc:nzwidth="0x20" edc:desc="Kill. Each array organized into 8 32-bit registers set per Flash device.    1 = If Killed, then kill as a Write: Holding CS# low.    0 = If Killed, then kill as a Read: Force CS# high first."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON0" edc:cname="FLASH_SET0OP_KILLMD7" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x4001005C">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON0">
            <edc:SFRFieldDef edc:cname="KILL" edc:nzwidth="0x20" edc:desc="Kill. Each array organized into 8 32-bit registers set per Flash device.    1 = If Killed, then kill as a Write: Holding CS# low.    0 = If Killed, then kill as a Read: Force CS# high first."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON0" edc:cname="FLASH_SET0OP_WPROT0" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x40010060">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON0">
            <edc:SFRFieldDef edc:cname="WPROT" edc:nzwidth="0x20" edc:desc="Write Protect. Each array organized into 8 32-bit registers set per Flash device.    1 = Make the corresponding bits RO in Permit and Killmd regs.    0 = Corresponding bits are R/W."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON0" edc:cname="FLASH_SET0OP_WPROT1" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x40010064">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON0">
            <edc:SFRFieldDef edc:cname="WPROT" edc:nzwidth="0x20" edc:desc="Write Protect. Each array organized into 8 32-bit registers set per Flash device.    1 = Make the corresponding bits RO in Permit and Killmd regs.    0 = Corresponding bits are R/W."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON0" edc:cname="FLASH_SET0OP_WPROT2" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x40010068">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON0">
            <edc:SFRFieldDef edc:cname="WPROT" edc:nzwidth="0x20" edc:desc="Write Protect. Each array organized into 8 32-bit registers set per Flash device.    1 = Make the corresponding bits RO in Permit and Killmd regs.    0 = Corresponding bits are R/W."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON0" edc:cname="FLASH_SET0OP_WPROT3" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x4001006C">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON0">
            <edc:SFRFieldDef edc:cname="WPROT" edc:nzwidth="0x20" edc:desc="Write Protect. Each array organized into 8 32-bit registers set per Flash device.    1 = Make the corresponding bits RO in Permit and Killmd regs.    0 = Corresponding bits are R/W."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON0" edc:cname="FLASH_SET0OP_WPROT4" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x40010070">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON0">
            <edc:SFRFieldDef edc:cname="WPROT" edc:nzwidth="0x20" edc:desc="Write Protect. Each array organized into 8 32-bit registers set per Flash device.    1 = Make the corresponding bits RO in Permit and Killmd regs.    0 = Corresponding bits are R/W."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON0" edc:cname="FLASH_SET0OP_WPROT5" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x40010074">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON0">
            <edc:SFRFieldDef edc:cname="WPROT" edc:nzwidth="0x20" edc:desc="Write Protect. Each array organized into 8 32-bit registers set per Flash device.    1 = Make the corresponding bits RO in Permit and Killmd regs.    0 = Corresponding bits are R/W."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON0" edc:cname="FLASH_SET0OP_WPROT6" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x40010078">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON0">
            <edc:SFRFieldDef edc:cname="WPROT" edc:nzwidth="0x20" edc:desc="Write Protect. Each array organized into 8 32-bit registers set per Flash device.    1 = Make the corresponding bits RO in Permit and Killmd regs.    0 = Corresponding bits are R/W."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON0" edc:cname="FLASH_SET0OP_WPROT7" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x4001007C">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON0">
            <edc:SFRFieldDef edc:cname="WPROT" edc:nzwidth="0x20" edc:desc="Write Protect. Each array organized into 8 32-bit registers set per Flash device.    1 = Make the corresponding bits RO in Permit and Killmd regs.    0 = Corresponding bits are R/W."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON0" edc:cname="FLASH_SET0OP_LOCK0" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x40010080">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON0">
            <edc:SFRFieldDef edc:cname="LOCK" edc:nzwidth="0x20" edc:desc="Lock. Each array organized into 8 32-bit registers set per Flash device.    1 = Make the corresponding bits RO in Permit and Killmd regs, overriding the Wprot register. Any 1 bit in this register is locked.    0 = Corresponding bits are R/W or RO, as determined by the Wprot register."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON0" edc:cname="FLASH_SET0OP_LOCK1" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x40010084">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON0">
            <edc:SFRFieldDef edc:cname="LOCK" edc:nzwidth="0x20" edc:desc="Lock. Each array organized into 8 32-bit registers set per Flash device.    1 = Make the corresponding bits RO in Permit and Killmd regs, overriding the Wprot register. Any 1 bit in this register is locked.    0 = Corresponding bits are R/W or RO, as determined by the Wprot register."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON0" edc:cname="FLASH_SET0OP_LOCK2" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x40010088">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON0">
            <edc:SFRFieldDef edc:cname="LOCK" edc:nzwidth="0x20" edc:desc="Lock. Each array organized into 8 32-bit registers set per Flash device.    1 = Make the corresponding bits RO in Permit and Killmd regs, overriding the Wprot register. Any 1 bit in this register is locked.    0 = Corresponding bits are R/W or RO, as determined by the Wprot register."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON0" edc:cname="FLASH_SET0OP_LOCK3" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x4001008C">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON0">
            <edc:SFRFieldDef edc:cname="LOCK" edc:nzwidth="0x20" edc:desc="Lock. Each array organized into 8 32-bit registers set per Flash device.    1 = Make the corresponding bits RO in Permit and Killmd regs, overriding the Wprot register. Any 1 bit in this register is locked.    0 = Corresponding bits are R/W or RO, as determined by the Wprot register."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON0" edc:cname="FLASH_SET0OP_LOCK4" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x40010090">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON0">
            <edc:SFRFieldDef edc:cname="LOCK" edc:nzwidth="0x20" edc:desc="Lock. Each array organized into 8 32-bit registers set per Flash device.    1 = Make the corresponding bits RO in Permit and Killmd regs, overriding the Wprot register. Any 1 bit in this register is locked.    0 = Corresponding bits are R/W or RO, as determined by the Wprot register."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON0" edc:cname="FLASH_SET0OP_LOCK5" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x40010094">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON0">
            <edc:SFRFieldDef edc:cname="LOCK" edc:nzwidth="0x20" edc:desc="Lock. Each array organized into 8 32-bit registers set per Flash device.    1 = Make the corresponding bits RO in Permit and Killmd regs, overriding the Wprot register. Any 1 bit in this register is locked.    0 = Corresponding bits are R/W or RO, as determined by the Wprot register."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON0" edc:cname="FLASH_SET0OP_LOCK6" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x40010098">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON0">
            <edc:SFRFieldDef edc:cname="LOCK" edc:nzwidth="0x20" edc:desc="Lock. Each array organized into 8 32-bit registers set per Flash device.    1 = Make the corresponding bits RO in Permit and Killmd regs, overriding the Wprot register. Any 1 bit in this register is locked.    0 = Corresponding bits are R/W or RO, as determined by the Wprot register."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON0" edc:cname="FLASH_SET0OP_LOCK7" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x4001009C">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON0">
            <edc:SFRFieldDef edc:cname="LOCK" edc:nzwidth="0x20" edc:desc="Lock. Each array organized into 8 32-bit registers set per Flash device.    1 = Make the corresponding bits RO in Permit and Killmd regs, overriding the Wprot register. Any 1 bit in this register is locked.    0 = Corresponding bits are R/W or RO, as determined by the Wprot register."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON0" edc:cname="FLASH_SET1OP_PRMT0" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x400100A0">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON0">
            <edc:SFRFieldDef edc:cname="PRMT" edc:nzwidth="0x20" edc:desc="Permit. Each array organized into 8 32-bit registers set per Flash device.    1 = Permit, and if not recognized then ignore.     0 = Kill immediately upon seeing this opcode."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON0" edc:cname="FLASH_SET1OP_PRMT1" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x400100A4">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON0">
            <edc:SFRFieldDef edc:cname="PRMT" edc:nzwidth="0x20" edc:desc="Permit. Each array organized into 8 32-bit registers set per Flash device.    1 = Permit, and if not recognized then ignore.     0 = Kill immediately upon seeing this opcode."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON0" edc:cname="FLASH_SET1OP_PRMT2" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x400100A8">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON0">
            <edc:SFRFieldDef edc:cname="PRMT" edc:nzwidth="0x20" edc:desc="Permit. Each array organized into 8 32-bit registers set per Flash device.    1 = Permit, and if not recognized then ignore.     0 = Kill immediately upon seeing this opcode."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON0" edc:cname="FLASH_SET1OP_PRMT3" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x400100AC">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON0">
            <edc:SFRFieldDef edc:cname="PRMT" edc:nzwidth="0x20" edc:desc="Permit. Each array organized into 8 32-bit registers set per Flash device.    1 = Permit, and if not recognized then ignore.     0 = Kill immediately upon seeing this opcode."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON0" edc:cname="FLASH_SET1OP_PRMT4" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x400100B0">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON0">
            <edc:SFRFieldDef edc:cname="PRMT" edc:nzwidth="0x20" edc:desc="Permit. Each array organized into 8 32-bit registers set per Flash device.    1 = Permit, and if not recognized then ignore.     0 = Kill immediately upon seeing this opcode."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON0" edc:cname="FLASH_SET1OP_PRMT5" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x400100B4">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON0">
            <edc:SFRFieldDef edc:cname="PRMT" edc:nzwidth="0x20" edc:desc="Permit. Each array organized into 8 32-bit registers set per Flash device.    1 = Permit, and if not recognized then ignore.     0 = Kill immediately upon seeing this opcode."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON0" edc:cname="FLASH_SET1OP_PRMT6" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x400100B8">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON0">
            <edc:SFRFieldDef edc:cname="PRMT" edc:nzwidth="0x20" edc:desc="Permit. Each array organized into 8 32-bit registers set per Flash device.    1 = Permit, and if not recognized then ignore.     0 = Kill immediately upon seeing this opcode."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON0" edc:cname="FLASH_SET1OP_PRMT7" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x400100BC">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON0">
            <edc:SFRFieldDef edc:cname="PRMT" edc:nzwidth="0x20" edc:desc="Permit. Each array organized into 8 32-bit registers set per Flash device.    1 = Permit, and if not recognized then ignore.     0 = Kill immediately upon seeing this opcode."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON0" edc:cname="FLASH_SET1OP_KILLMD0" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x400100C0">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON0">
            <edc:SFRFieldDef edc:cname="KILL" edc:nzwidth="0x20" edc:desc="Kill. Each array organized into 8 32-bit registers set per Flash device.    1 = If Killed, then kill as a Write: Holding CS# low.    0 = If Killed, then kill as a Read: Force CS# high first."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON0" edc:cname="FLASH_SET1OP_KILLMD1" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x400100C4">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON0">
            <edc:SFRFieldDef edc:cname="KILL" edc:nzwidth="0x20" edc:desc="Kill. Each array organized into 8 32-bit registers set per Flash device.    1 = If Killed, then kill as a Write: Holding CS# low.    0 = If Killed, then kill as a Read: Force CS# high first."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON0" edc:cname="FLASH_SET1OP_KILLMD2" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x400100C8">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON0">
            <edc:SFRFieldDef edc:cname="KILL" edc:nzwidth="0x20" edc:desc="Kill. Each array organized into 8 32-bit registers set per Flash device.    1 = If Killed, then kill as a Write: Holding CS# low.    0 = If Killed, then kill as a Read: Force CS# high first."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON0" edc:cname="FLASH_SET1OP_KILLMD3" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x400100CC">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON0">
            <edc:SFRFieldDef edc:cname="KILL" edc:nzwidth="0x20" edc:desc="Kill. Each array organized into 8 32-bit registers set per Flash device.    1 = If Killed, then kill as a Write: Holding CS# low.    0 = If Killed, then kill as a Read: Force CS# high first."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON0" edc:cname="FLASH_SET1OP_KILLMD4" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x400100D0">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON0">
            <edc:SFRFieldDef edc:cname="KILL" edc:nzwidth="0x20" edc:desc="Kill. Each array organized into 8 32-bit registers set per Flash device.    1 = If Killed, then kill as a Write: Holding CS# low.    0 = If Killed, then kill as a Read: Force CS# high first."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON0" edc:cname="FLASH_SET1OP_KILLMD5" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x400100D4">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON0">
            <edc:SFRFieldDef edc:cname="KILL" edc:nzwidth="0x20" edc:desc="Kill. Each array organized into 8 32-bit registers set per Flash device.    1 = If Killed, then kill as a Write: Holding CS# low.    0 = If Killed, then kill as a Read: Force CS# high first."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON0" edc:cname="FLASH_SET1OP_KILLMD6" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x400100D8">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON0">
            <edc:SFRFieldDef edc:cname="KILL" edc:nzwidth="0x20" edc:desc="Kill. Each array organized into 8 32-bit registers set per Flash device.    1 = If Killed, then kill as a Write: Holding CS# low.    0 = If Killed, then kill as a Read: Force CS# high first."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON0" edc:cname="FLASH_SET1OP_KILLMD7" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x400100DC">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON0">
            <edc:SFRFieldDef edc:cname="KILL" edc:nzwidth="0x20" edc:desc="Kill. Each array organized into 8 32-bit registers set per Flash device.    1 = If Killed, then kill as a Write: Holding CS# low.    0 = If Killed, then kill as a Read: Force CS# high first."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON0" edc:cname="FLASH_SET1OP_WPROT0" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x400100E0">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON0">
            <edc:SFRFieldDef edc:cname="WPROT" edc:nzwidth="0x20" edc:desc="Write Protect. Each array organized into 8 32-bit registers set per Flash device.    1 = Make the corresponding bits RO in Permit and Killmd regs.    0 = Corresponding bits are R/W."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON0" edc:cname="FLASH_SET1OP_WPROT1" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x400100E4">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON0">
            <edc:SFRFieldDef edc:cname="WPROT" edc:nzwidth="0x20" edc:desc="Write Protect. Each array organized into 8 32-bit registers set per Flash device.    1 = Make the corresponding bits RO in Permit and Killmd regs.    0 = Corresponding bits are R/W."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON0" edc:cname="FLASH_SET1OP_WPROT2" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x400100E8">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON0">
            <edc:SFRFieldDef edc:cname="WPROT" edc:nzwidth="0x20" edc:desc="Write Protect. Each array organized into 8 32-bit registers set per Flash device.    1 = Make the corresponding bits RO in Permit and Killmd regs.    0 = Corresponding bits are R/W."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON0" edc:cname="FLASH_SET1OP_WPROT3" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x400100EC">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON0">
            <edc:SFRFieldDef edc:cname="WPROT" edc:nzwidth="0x20" edc:desc="Write Protect. Each array organized into 8 32-bit registers set per Flash device.    1 = Make the corresponding bits RO in Permit and Killmd regs.    0 = Corresponding bits are R/W."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON0" edc:cname="FLASH_SET1OP_WPROT4" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x400100F0">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON0">
            <edc:SFRFieldDef edc:cname="WPROT" edc:nzwidth="0x20" edc:desc="Write Protect. Each array organized into 8 32-bit registers set per Flash device.    1 = Make the corresponding bits RO in Permit and Killmd regs.    0 = Corresponding bits are R/W."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON0" edc:cname="FLASH_SET1OP_WPROT5" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x400100F4">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON0">
            <edc:SFRFieldDef edc:cname="WPROT" edc:nzwidth="0x20" edc:desc="Write Protect. Each array organized into 8 32-bit registers set per Flash device.    1 = Make the corresponding bits RO in Permit and Killmd regs.    0 = Corresponding bits are R/W."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON0" edc:cname="FLASH_SET1OP_WPROT6" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x400100F8">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON0">
            <edc:SFRFieldDef edc:cname="WPROT" edc:nzwidth="0x20" edc:desc="Write Protect. Each array organized into 8 32-bit registers set per Flash device.    1 = Make the corresponding bits RO in Permit and Killmd regs.    0 = Corresponding bits are R/W."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON0" edc:cname="FLASH_SET1OP_WPROT7" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x400100FC">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON0">
            <edc:SFRFieldDef edc:cname="WPROT" edc:nzwidth="0x20" edc:desc="Write Protect. Each array organized into 8 32-bit registers set per Flash device.    1 = Make the corresponding bits RO in Permit and Killmd regs.    0 = Corresponding bits are R/W."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON0" edc:cname="FLASH_SET1OP_LOCK0" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x40010100">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON0">
            <edc:SFRFieldDef edc:cname="LOCK" edc:nzwidth="0x20" edc:desc="Lock. Each array organized into 8 32-bit registers set per Flash device.    1 = Make the corresponding bits RO in Permit and Killmd regs, overriding the Wprot register. Any 1 bit in this register is locked.    0 = Corresponding bits are R/W or RO, as determined by the Wprot register."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON0" edc:cname="FLASH_SET1OP_LOCK1" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x40010104">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON0">
            <edc:SFRFieldDef edc:cname="LOCK" edc:nzwidth="0x20" edc:desc="Lock. Each array organized into 8 32-bit registers set per Flash device.    1 = Make the corresponding bits RO in Permit and Killmd regs, overriding the Wprot register. Any 1 bit in this register is locked.    0 = Corresponding bits are R/W or RO, as determined by the Wprot register."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON0" edc:cname="FLASH_SET1OP_LOCK2" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x40010108">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON0">
            <edc:SFRFieldDef edc:cname="LOCK" edc:nzwidth="0x20" edc:desc="Lock. Each array organized into 8 32-bit registers set per Flash device.    1 = Make the corresponding bits RO in Permit and Killmd regs, overriding the Wprot register. Any 1 bit in this register is locked.    0 = Corresponding bits are R/W or RO, as determined by the Wprot register."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON0" edc:cname="FLASH_SET1OP_LOCK3" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x4001010C">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON0">
            <edc:SFRFieldDef edc:cname="LOCK" edc:nzwidth="0x20" edc:desc="Lock. Each array organized into 8 32-bit registers set per Flash device.    1 = Make the corresponding bits RO in Permit and Killmd regs, overriding the Wprot register. Any 1 bit in this register is locked.    0 = Corresponding bits are R/W or RO, as determined by the Wprot register."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON0" edc:cname="FLASH_SET1OP_LOCK4" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x40010110">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON0">
            <edc:SFRFieldDef edc:cname="LOCK" edc:nzwidth="0x20" edc:desc="Lock. Each array organized into 8 32-bit registers set per Flash device.    1 = Make the corresponding bits RO in Permit and Killmd regs, overriding the Wprot register. Any 1 bit in this register is locked.    0 = Corresponding bits are R/W or RO, as determined by the Wprot register."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON0" edc:cname="FLASH_SET1OP_LOCK5" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x40010114">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON0">
            <edc:SFRFieldDef edc:cname="LOCK" edc:nzwidth="0x20" edc:desc="Lock. Each array organized into 8 32-bit registers set per Flash device.    1 = Make the corresponding bits RO in Permit and Killmd regs, overriding the Wprot register. Any 1 bit in this register is locked.    0 = Corresponding bits are R/W or RO, as determined by the Wprot register."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON0" edc:cname="FLASH_SET1OP_LOCK6" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x40010118">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON0">
            <edc:SFRFieldDef edc:cname="LOCK" edc:nzwidth="0x20" edc:desc="Lock. Each array organized into 8 32-bit registers set per Flash device.    1 = Make the corresponding bits RO in Permit and Killmd regs, overriding the Wprot register. Any 1 bit in this register is locked.    0 = Corresponding bits are R/W or RO, as determined by the Wprot register."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON0" edc:cname="FLASH_SET1OP_LOCK7" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x4001011C">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON0">
            <edc:SFRFieldDef edc:cname="LOCK" edc:nzwidth="0x20" edc:desc="Lock. Each array organized into 8 32-bit registers set per Flash device.    1 = Make the corresponding bits RO in Permit and Killmd regs, overriding the Wprot register. Any 1 bit in this register is locked.    0 = Corresponding bits are R/W or RO, as determined by the Wprot register."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON0" edc:cname="RN_TM0RT_START" edc:nzwidth="0x20" edc:access="n-nnn-nn----nnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0xBB0FFFFF" edc:_addr="0x40010120">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON0">
            <edc:SFRFieldDef edc:cname="STRT" edc:nzwidth="0x14" edc:desc="A Flash address shifted by 12 (4K byte units). Bottom 12 address bits are 000h"/>
            <edc:AdjustPoint edc:offset="0x4"/>
            <edc:SFRFieldDef edc:cname="E32" edc:nzwidth="0x1" edc:desc="Enable 32KByte Erase opcode for this region. 0 = Disable, 1 = Enable"/>
            <edc:SFRFieldDef edc:cname="E64" edc:nzwidth="0x1" edc:desc="Enable 64KByte Erase opcode for this region. 0 = Disable, 1 = Enable"/>
            <edc:AdjustPoint edc:offset="0x1"/>
            <edc:SFRFieldDef edc:cname="DV" edc:nzwidth="0x1" edc:desc="Flash Device 0 = CS0#, 1 = CS1#."/>
            <edc:SFRFieldDef edc:cname="RD" edc:nzwidth="0x1" edc:desc="Read Allowed for Region. 0 = No, 1 = Yes"/>
            <edc:SFRFieldDef edc:cname="WR" edc:nzwidth="0x1" edc:desc="Write Allowed for Region. 0 = No, 1 = Yes"/>
            <edc:AdjustPoint edc:offset="0x1"/>
            <edc:SFRFieldDef edc:cname="EN" edc:nzwidth="0x1" edc:desc="Enable Register Pair for Monitoring. 0 = No, 1 = Yes"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON0" edc:cname="RN_TM0RT_LIMIT" edc:nzwidth="0x20" edc:access="------------nnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0xFFFFF" edc:_addr="0x40010124">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON0">
            <edc:SFRFieldDef edc:cname="LMT" edc:nzwidth="0x14" edc:desc="Limit Register"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON0" edc:cname="RN_TM1RT_START" edc:nzwidth="0x20" edc:access="n-nnn-nn----nnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0xBB0FFFFF" edc:_addr="0x40010128">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON0">
            <edc:SFRFieldDef edc:cname="STRT" edc:nzwidth="0x14" edc:desc="A Flash address shifted by 12 (4K byte units). Bottom 12 address bits are 000h"/>
            <edc:AdjustPoint edc:offset="0x4"/>
            <edc:SFRFieldDef edc:cname="E32" edc:nzwidth="0x1" edc:desc="Enable 32KByte Erase opcode for this region. 0 = Disable, 1 = Enable"/>
            <edc:SFRFieldDef edc:cname="E64" edc:nzwidth="0x1" edc:desc="Enable 64KByte Erase opcode for this region. 0 = Disable, 1 = Enable"/>
            <edc:AdjustPoint edc:offset="0x1"/>
            <edc:SFRFieldDef edc:cname="DV" edc:nzwidth="0x1" edc:desc="Flash Device 0 = CS0#, 1 = CS1#."/>
            <edc:SFRFieldDef edc:cname="RD" edc:nzwidth="0x1" edc:desc="Read Allowed for Region. 0 = No, 1 = Yes"/>
            <edc:SFRFieldDef edc:cname="WR" edc:nzwidth="0x1" edc:desc="Write Allowed for Region. 0 = No, 1 = Yes"/>
            <edc:AdjustPoint edc:offset="0x1"/>
            <edc:SFRFieldDef edc:cname="EN" edc:nzwidth="0x1" edc:desc="Enable Register Pair for Monitoring. 0 = No, 1 = Yes"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON0" edc:cname="RN_TM1RT_LIMIT" edc:nzwidth="0x20" edc:access="------------nnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0xFFFFF" edc:_addr="0x4001012C">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON0">
            <edc:SFRFieldDef edc:cname="LMT" edc:nzwidth="0x14" edc:desc="Limit Register"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON0" edc:cname="RN_TM2RT_START" edc:nzwidth="0x20" edc:access="n-nnn-nn----nnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0xBB0FFFFF" edc:_addr="0x40010130">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON0">
            <edc:SFRFieldDef edc:cname="STRT" edc:nzwidth="0x14" edc:desc="A Flash address shifted by 12 (4K byte units). Bottom 12 address bits are 000h"/>
            <edc:AdjustPoint edc:offset="0x4"/>
            <edc:SFRFieldDef edc:cname="E32" edc:nzwidth="0x1" edc:desc="Enable 32KByte Erase opcode for this region. 0 = Disable, 1 = Enable"/>
            <edc:SFRFieldDef edc:cname="E64" edc:nzwidth="0x1" edc:desc="Enable 64KByte Erase opcode for this region. 0 = Disable, 1 = Enable"/>
            <edc:AdjustPoint edc:offset="0x1"/>
            <edc:SFRFieldDef edc:cname="DV" edc:nzwidth="0x1" edc:desc="Flash Device 0 = CS0#, 1 = CS1#."/>
            <edc:SFRFieldDef edc:cname="RD" edc:nzwidth="0x1" edc:desc="Read Allowed for Region. 0 = No, 1 = Yes"/>
            <edc:SFRFieldDef edc:cname="WR" edc:nzwidth="0x1" edc:desc="Write Allowed for Region. 0 = No, 1 = Yes"/>
            <edc:AdjustPoint edc:offset="0x1"/>
            <edc:SFRFieldDef edc:cname="EN" edc:nzwidth="0x1" edc:desc="Enable Register Pair for Monitoring. 0 = No, 1 = Yes"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON0" edc:cname="RN_TM2RT_LIMIT" edc:nzwidth="0x20" edc:access="------------nnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0xFFFFF" edc:_addr="0x40010134">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON0">
            <edc:SFRFieldDef edc:cname="LMT" edc:nzwidth="0x14" edc:desc="Limit Register"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON0" edc:cname="RN_TM3RT_START" edc:nzwidth="0x20" edc:access="n-nnn-nn----nnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0xBB0FFFFF" edc:_addr="0x40010138">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON0">
            <edc:SFRFieldDef edc:cname="STRT" edc:nzwidth="0x14" edc:desc="A Flash address shifted by 12 (4K byte units). Bottom 12 address bits are 000h"/>
            <edc:AdjustPoint edc:offset="0x4"/>
            <edc:SFRFieldDef edc:cname="E32" edc:nzwidth="0x1" edc:desc="Enable 32KByte Erase opcode for this region. 0 = Disable, 1 = Enable"/>
            <edc:SFRFieldDef edc:cname="E64" edc:nzwidth="0x1" edc:desc="Enable 64KByte Erase opcode for this region. 0 = Disable, 1 = Enable"/>
            <edc:AdjustPoint edc:offset="0x1"/>
            <edc:SFRFieldDef edc:cname="DV" edc:nzwidth="0x1" edc:desc="Flash Device 0 = CS0#, 1 = CS1#."/>
            <edc:SFRFieldDef edc:cname="RD" edc:nzwidth="0x1" edc:desc="Read Allowed for Region. 0 = No, 1 = Yes"/>
            <edc:SFRFieldDef edc:cname="WR" edc:nzwidth="0x1" edc:desc="Write Allowed for Region. 0 = No, 1 = Yes"/>
            <edc:AdjustPoint edc:offset="0x1"/>
            <edc:SFRFieldDef edc:cname="EN" edc:nzwidth="0x1" edc:desc="Enable Register Pair for Monitoring. 0 = No, 1 = Yes"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON0" edc:cname="RN_TM3RT_LIMIT" edc:nzwidth="0x20" edc:access="------------nnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0xFFFFF" edc:_addr="0x4001013C">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON0">
            <edc:SFRFieldDef edc:cname="LMT" edc:nzwidth="0x14" edc:desc="Limit Register"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON0" edc:cname="RN_TM4RT_START" edc:nzwidth="0x20" edc:access="n-nnn-nn----nnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0xBB0FFFFF" edc:_addr="0x40010140">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON0">
            <edc:SFRFieldDef edc:cname="STRT" edc:nzwidth="0x14" edc:desc="A Flash address shifted by 12 (4K byte units). Bottom 12 address bits are 000h"/>
            <edc:AdjustPoint edc:offset="0x4"/>
            <edc:SFRFieldDef edc:cname="E32" edc:nzwidth="0x1" edc:desc="Enable 32KByte Erase opcode for this region. 0 = Disable, 1 = Enable"/>
            <edc:SFRFieldDef edc:cname="E64" edc:nzwidth="0x1" edc:desc="Enable 64KByte Erase opcode for this region. 0 = Disable, 1 = Enable"/>
            <edc:AdjustPoint edc:offset="0x1"/>
            <edc:SFRFieldDef edc:cname="DV" edc:nzwidth="0x1" edc:desc="Flash Device 0 = CS0#, 1 = CS1#."/>
            <edc:SFRFieldDef edc:cname="RD" edc:nzwidth="0x1" edc:desc="Read Allowed for Region. 0 = No, 1 = Yes"/>
            <edc:SFRFieldDef edc:cname="WR" edc:nzwidth="0x1" edc:desc="Write Allowed for Region. 0 = No, 1 = Yes"/>
            <edc:AdjustPoint edc:offset="0x1"/>
            <edc:SFRFieldDef edc:cname="EN" edc:nzwidth="0x1" edc:desc="Enable Register Pair for Monitoring. 0 = No, 1 = Yes"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON0" edc:cname="RN_TM4RT_LIMIT" edc:nzwidth="0x20" edc:access="------------nnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0xFFFFF" edc:_addr="0x40010144">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON0">
            <edc:SFRFieldDef edc:cname="LMT" edc:nzwidth="0x14" edc:desc="Limit Register"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON0" edc:cname="RN_TM5RT_START" edc:nzwidth="0x20" edc:access="n-nnn-nn----nnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0xBB0FFFFF" edc:_addr="0x40010148">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON0">
            <edc:SFRFieldDef edc:cname="STRT" edc:nzwidth="0x14" edc:desc="A Flash address shifted by 12 (4K byte units). Bottom 12 address bits are 000h"/>
            <edc:AdjustPoint edc:offset="0x4"/>
            <edc:SFRFieldDef edc:cname="E32" edc:nzwidth="0x1" edc:desc="Enable 32KByte Erase opcode for this region. 0 = Disable, 1 = Enable"/>
            <edc:SFRFieldDef edc:cname="E64" edc:nzwidth="0x1" edc:desc="Enable 64KByte Erase opcode for this region. 0 = Disable, 1 = Enable"/>
            <edc:AdjustPoint edc:offset="0x1"/>
            <edc:SFRFieldDef edc:cname="DV" edc:nzwidth="0x1" edc:desc="Flash Device 0 = CS0#, 1 = CS1#."/>
            <edc:SFRFieldDef edc:cname="RD" edc:nzwidth="0x1" edc:desc="Read Allowed for Region. 0 = No, 1 = Yes"/>
            <edc:SFRFieldDef edc:cname="WR" edc:nzwidth="0x1" edc:desc="Write Allowed for Region. 0 = No, 1 = Yes"/>
            <edc:AdjustPoint edc:offset="0x1"/>
            <edc:SFRFieldDef edc:cname="EN" edc:nzwidth="0x1" edc:desc="Enable Register Pair for Monitoring. 0 = No, 1 = Yes"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON0" edc:cname="RN_TM5RT_LIMIT" edc:nzwidth="0x20" edc:access="------------nnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0xFFFFF" edc:_addr="0x4001014C">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON0">
            <edc:SFRFieldDef edc:cname="LMT" edc:nzwidth="0x14" edc:desc="Limit Register"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON0" edc:cname="RN_TM6RT_START" edc:nzwidth="0x20" edc:access="n-nnn-nn----nnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0xBB0FFFFF" edc:_addr="0x40010150">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON0">
            <edc:SFRFieldDef edc:cname="STRT" edc:nzwidth="0x14" edc:desc="A Flash address shifted by 12 (4K byte units). Bottom 12 address bits are 000h"/>
            <edc:AdjustPoint edc:offset="0x4"/>
            <edc:SFRFieldDef edc:cname="E32" edc:nzwidth="0x1" edc:desc="Enable 32KByte Erase opcode for this region. 0 = Disable, 1 = Enable"/>
            <edc:SFRFieldDef edc:cname="E64" edc:nzwidth="0x1" edc:desc="Enable 64KByte Erase opcode for this region. 0 = Disable, 1 = Enable"/>
            <edc:AdjustPoint edc:offset="0x1"/>
            <edc:SFRFieldDef edc:cname="DV" edc:nzwidth="0x1" edc:desc="Flash Device 0 = CS0#, 1 = CS1#."/>
            <edc:SFRFieldDef edc:cname="RD" edc:nzwidth="0x1" edc:desc="Read Allowed for Region. 0 = No, 1 = Yes"/>
            <edc:SFRFieldDef edc:cname="WR" edc:nzwidth="0x1" edc:desc="Write Allowed for Region. 0 = No, 1 = Yes"/>
            <edc:AdjustPoint edc:offset="0x1"/>
            <edc:SFRFieldDef edc:cname="EN" edc:nzwidth="0x1" edc:desc="Enable Register Pair for Monitoring. 0 = No, 1 = Yes"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON0" edc:cname="RN_TM6RT_LIMIT" edc:nzwidth="0x20" edc:access="------------nnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0xFFFFF" edc:_addr="0x40010154">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON0">
            <edc:SFRFieldDef edc:cname="LMT" edc:nzwidth="0x14" edc:desc="Limit Register"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON0" edc:cname="RN_TM7RT_START" edc:nzwidth="0x20" edc:access="n-nnn-nn----nnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0xBB0FFFFF" edc:_addr="0x40010158">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON0">
            <edc:SFRFieldDef edc:cname="STRT" edc:nzwidth="0x14" edc:desc="A Flash address shifted by 12 (4K byte units). Bottom 12 address bits are 000h"/>
            <edc:AdjustPoint edc:offset="0x4"/>
            <edc:SFRFieldDef edc:cname="E32" edc:nzwidth="0x1" edc:desc="Enable 32KByte Erase opcode for this region. 0 = Disable, 1 = Enable"/>
            <edc:SFRFieldDef edc:cname="E64" edc:nzwidth="0x1" edc:desc="Enable 64KByte Erase opcode for this region. 0 = Disable, 1 = Enable"/>
            <edc:AdjustPoint edc:offset="0x1"/>
            <edc:SFRFieldDef edc:cname="DV" edc:nzwidth="0x1" edc:desc="Flash Device 0 = CS0#, 1 = CS1#."/>
            <edc:SFRFieldDef edc:cname="RD" edc:nzwidth="0x1" edc:desc="Read Allowed for Region. 0 = No, 1 = Yes"/>
            <edc:SFRFieldDef edc:cname="WR" edc:nzwidth="0x1" edc:desc="Write Allowed for Region. 0 = No, 1 = Yes"/>
            <edc:AdjustPoint edc:offset="0x1"/>
            <edc:SFRFieldDef edc:cname="EN" edc:nzwidth="0x1" edc:desc="Enable Register Pair for Monitoring. 0 = No, 1 = Yes"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON0" edc:cname="RN_TM7RT_LIMIT" edc:nzwidth="0x20" edc:access="------------nnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0xFFFFF" edc:_addr="0x4001015C">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON0">
            <edc:SFRFieldDef edc:cname="LMT" edc:nzwidth="0x14" edc:desc="Limit Register"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON0" edc:cname="RN_TM8RT_START" edc:nzwidth="0x20" edc:access="n-nnn-nn----nnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0xBB0FFFFF" edc:_addr="0x40010160">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON0">
            <edc:SFRFieldDef edc:cname="STRT" edc:nzwidth="0x14" edc:desc="A Flash address shifted by 12 (4K byte units). Bottom 12 address bits are 000h"/>
            <edc:AdjustPoint edc:offset="0x4"/>
            <edc:SFRFieldDef edc:cname="E32" edc:nzwidth="0x1" edc:desc="Enable 32KByte Erase opcode for this region. 0 = Disable, 1 = Enable"/>
            <edc:SFRFieldDef edc:cname="E64" edc:nzwidth="0x1" edc:desc="Enable 64KByte Erase opcode for this region. 0 = Disable, 1 = Enable"/>
            <edc:AdjustPoint edc:offset="0x1"/>
            <edc:SFRFieldDef edc:cname="DV" edc:nzwidth="0x1" edc:desc="Flash Device 0 = CS0#, 1 = CS1#."/>
            <edc:SFRFieldDef edc:cname="RD" edc:nzwidth="0x1" edc:desc="Read Allowed for Region. 0 = No, 1 = Yes"/>
            <edc:SFRFieldDef edc:cname="WR" edc:nzwidth="0x1" edc:desc="Write Allowed for Region. 0 = No, 1 = Yes"/>
            <edc:AdjustPoint edc:offset="0x1"/>
            <edc:SFRFieldDef edc:cname="EN" edc:nzwidth="0x1" edc:desc="Enable Register Pair for Monitoring. 0 = No, 1 = Yes"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON0" edc:cname="RN_TM8RT_LIMIT" edc:nzwidth="0x20" edc:access="------------nnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0xFFFFF" edc:_addr="0x40010164">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON0">
            <edc:SFRFieldDef edc:cname="LMT" edc:nzwidth="0x14" edc:desc="Limit Register"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON0" edc:cname="RN_TM9RT_START" edc:nzwidth="0x20" edc:access="n-nnn-nn----nnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0xBB0FFFFF" edc:_addr="0x40010168">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON0">
            <edc:SFRFieldDef edc:cname="STRT" edc:nzwidth="0x14" edc:desc="A Flash address shifted by 12 (4K byte units). Bottom 12 address bits are 000h"/>
            <edc:AdjustPoint edc:offset="0x4"/>
            <edc:SFRFieldDef edc:cname="E32" edc:nzwidth="0x1" edc:desc="Enable 32KByte Erase opcode for this region. 0 = Disable, 1 = Enable"/>
            <edc:SFRFieldDef edc:cname="E64" edc:nzwidth="0x1" edc:desc="Enable 64KByte Erase opcode for this region. 0 = Disable, 1 = Enable"/>
            <edc:AdjustPoint edc:offset="0x1"/>
            <edc:SFRFieldDef edc:cname="DV" edc:nzwidth="0x1" edc:desc="Flash Device 0 = CS0#, 1 = CS1#."/>
            <edc:SFRFieldDef edc:cname="RD" edc:nzwidth="0x1" edc:desc="Read Allowed for Region. 0 = No, 1 = Yes"/>
            <edc:SFRFieldDef edc:cname="WR" edc:nzwidth="0x1" edc:desc="Write Allowed for Region. 0 = No, 1 = Yes"/>
            <edc:AdjustPoint edc:offset="0x1"/>
            <edc:SFRFieldDef edc:cname="EN" edc:nzwidth="0x1" edc:desc="Enable Register Pair for Monitoring. 0 = No, 1 = Yes"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON0" edc:cname="RN_TM9RT_LIMIT" edc:nzwidth="0x20" edc:access="------------nnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0xFFFFF" edc:_addr="0x4001016C">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON0">
            <edc:SFRFieldDef edc:cname="LMT" edc:nzwidth="0x14" edc:desc="Limit Register"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON0" edc:cname="RN_TM10RT_START" edc:nzwidth="0x20" edc:access="n-nnn-nn----nnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0xBB0FFFFF" edc:_addr="0x40010170">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON0">
            <edc:SFRFieldDef edc:cname="STRT" edc:nzwidth="0x14" edc:desc="A Flash address shifted by 12 (4K byte units). Bottom 12 address bits are 000h"/>
            <edc:AdjustPoint edc:offset="0x4"/>
            <edc:SFRFieldDef edc:cname="E32" edc:nzwidth="0x1" edc:desc="Enable 32KByte Erase opcode for this region. 0 = Disable, 1 = Enable"/>
            <edc:SFRFieldDef edc:cname="E64" edc:nzwidth="0x1" edc:desc="Enable 64KByte Erase opcode for this region. 0 = Disable, 1 = Enable"/>
            <edc:AdjustPoint edc:offset="0x1"/>
            <edc:SFRFieldDef edc:cname="DV" edc:nzwidth="0x1" edc:desc="Flash Device 0 = CS0#, 1 = CS1#."/>
            <edc:SFRFieldDef edc:cname="RD" edc:nzwidth="0x1" edc:desc="Read Allowed for Region. 0 = No, 1 = Yes"/>
            <edc:SFRFieldDef edc:cname="WR" edc:nzwidth="0x1" edc:desc="Write Allowed for Region. 0 = No, 1 = Yes"/>
            <edc:AdjustPoint edc:offset="0x1"/>
            <edc:SFRFieldDef edc:cname="EN" edc:nzwidth="0x1" edc:desc="Enable Register Pair for Monitoring. 0 = No, 1 = Yes"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON0" edc:cname="RN_TM10RT_LIMIT" edc:nzwidth="0x20" edc:access="------------nnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0xFFFFF" edc:_addr="0x40010174">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON0">
            <edc:SFRFieldDef edc:cname="LMT" edc:nzwidth="0x14" edc:desc="Limit Register"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON0" edc:cname="RN_TM11RT_START" edc:nzwidth="0x20" edc:access="n-nnn-nn----nnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0xBB0FFFFF" edc:_addr="0x40010178">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON0">
            <edc:SFRFieldDef edc:cname="STRT" edc:nzwidth="0x14" edc:desc="A Flash address shifted by 12 (4K byte units). Bottom 12 address bits are 000h"/>
            <edc:AdjustPoint edc:offset="0x4"/>
            <edc:SFRFieldDef edc:cname="E32" edc:nzwidth="0x1" edc:desc="Enable 32KByte Erase opcode for this region. 0 = Disable, 1 = Enable"/>
            <edc:SFRFieldDef edc:cname="E64" edc:nzwidth="0x1" edc:desc="Enable 64KByte Erase opcode for this region. 0 = Disable, 1 = Enable"/>
            <edc:AdjustPoint edc:offset="0x1"/>
            <edc:SFRFieldDef edc:cname="DV" edc:nzwidth="0x1" edc:desc="Flash Device 0 = CS0#, 1 = CS1#."/>
            <edc:SFRFieldDef edc:cname="RD" edc:nzwidth="0x1" edc:desc="Read Allowed for Region. 0 = No, 1 = Yes"/>
            <edc:SFRFieldDef edc:cname="WR" edc:nzwidth="0x1" edc:desc="Write Allowed for Region. 0 = No, 1 = Yes"/>
            <edc:AdjustPoint edc:offset="0x1"/>
            <edc:SFRFieldDef edc:cname="EN" edc:nzwidth="0x1" edc:desc="Enable Register Pair for Monitoring. 0 = No, 1 = Yes"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON0" edc:cname="RN_TM11RT_LIMIT" edc:nzwidth="0x20" edc:access="------------nnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0xFFFFF" edc:_addr="0x4001017C">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON0">
            <edc:SFRFieldDef edc:cname="LMT" edc:nzwidth="0x14" edc:desc="Limit Register"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON0" edc:cname="RN_TM12RT_START" edc:nzwidth="0x20" edc:access="n-nnn-nn----nnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0xBB0FFFFF" edc:_addr="0x40010180">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON0">
            <edc:SFRFieldDef edc:cname="STRT" edc:nzwidth="0x14" edc:desc="A Flash address shifted by 12 (4K byte units). Bottom 12 address bits are 000h"/>
            <edc:AdjustPoint edc:offset="0x4"/>
            <edc:SFRFieldDef edc:cname="E32" edc:nzwidth="0x1" edc:desc="Enable 32KByte Erase opcode for this region. 0 = Disable, 1 = Enable"/>
            <edc:SFRFieldDef edc:cname="E64" edc:nzwidth="0x1" edc:desc="Enable 64KByte Erase opcode for this region. 0 = Disable, 1 = Enable"/>
            <edc:AdjustPoint edc:offset="0x1"/>
            <edc:SFRFieldDef edc:cname="DV" edc:nzwidth="0x1" edc:desc="Flash Device 0 = CS0#, 1 = CS1#."/>
            <edc:SFRFieldDef edc:cname="RD" edc:nzwidth="0x1" edc:desc="Read Allowed for Region. 0 = No, 1 = Yes"/>
            <edc:SFRFieldDef edc:cname="WR" edc:nzwidth="0x1" edc:desc="Write Allowed for Region. 0 = No, 1 = Yes"/>
            <edc:AdjustPoint edc:offset="0x1"/>
            <edc:SFRFieldDef edc:cname="EN" edc:nzwidth="0x1" edc:desc="Enable Register Pair for Monitoring. 0 = No, 1 = Yes"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON0" edc:cname="RN_TM12RT_LIMIT" edc:nzwidth="0x20" edc:access="------------nnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0xFFFFF" edc:_addr="0x40010184">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON0">
            <edc:SFRFieldDef edc:cname="LMT" edc:nzwidth="0x14" edc:desc="Limit Register"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON0" edc:cname="RN_TM13RT_START" edc:nzwidth="0x20" edc:access="n-nnn-nn----nnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0xBB0FFFFF" edc:_addr="0x40010188">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON0">
            <edc:SFRFieldDef edc:cname="STRT" edc:nzwidth="0x14" edc:desc="A Flash address shifted by 12 (4K byte units). Bottom 12 address bits are 000h"/>
            <edc:AdjustPoint edc:offset="0x4"/>
            <edc:SFRFieldDef edc:cname="E32" edc:nzwidth="0x1" edc:desc="Enable 32KByte Erase opcode for this region. 0 = Disable, 1 = Enable"/>
            <edc:SFRFieldDef edc:cname="E64" edc:nzwidth="0x1" edc:desc="Enable 64KByte Erase opcode for this region. 0 = Disable, 1 = Enable"/>
            <edc:AdjustPoint edc:offset="0x1"/>
            <edc:SFRFieldDef edc:cname="DV" edc:nzwidth="0x1" edc:desc="Flash Device 0 = CS0#, 1 = CS1#."/>
            <edc:SFRFieldDef edc:cname="RD" edc:nzwidth="0x1" edc:desc="Read Allowed for Region. 0 = No, 1 = Yes"/>
            <edc:SFRFieldDef edc:cname="WR" edc:nzwidth="0x1" edc:desc="Write Allowed for Region. 0 = No, 1 = Yes"/>
            <edc:AdjustPoint edc:offset="0x1"/>
            <edc:SFRFieldDef edc:cname="EN" edc:nzwidth="0x1" edc:desc="Enable Register Pair for Monitoring. 0 = No, 1 = Yes"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON0" edc:cname="RN_TM13RT_LIMIT" edc:nzwidth="0x20" edc:access="------------nnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0xFFFFF" edc:_addr="0x4001018C">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON0">
            <edc:SFRFieldDef edc:cname="LMT" edc:nzwidth="0x14" edc:desc="Limit Register"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON0" edc:cname="RN_TM14RT_START" edc:nzwidth="0x20" edc:access="n-nnn-nn----nnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0xBB0FFFFF" edc:_addr="0x40010190">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON0">
            <edc:SFRFieldDef edc:cname="STRT" edc:nzwidth="0x14" edc:desc="A Flash address shifted by 12 (4K byte units). Bottom 12 address bits are 000h"/>
            <edc:AdjustPoint edc:offset="0x4"/>
            <edc:SFRFieldDef edc:cname="E32" edc:nzwidth="0x1" edc:desc="Enable 32KByte Erase opcode for this region. 0 = Disable, 1 = Enable"/>
            <edc:SFRFieldDef edc:cname="E64" edc:nzwidth="0x1" edc:desc="Enable 64KByte Erase opcode for this region. 0 = Disable, 1 = Enable"/>
            <edc:AdjustPoint edc:offset="0x1"/>
            <edc:SFRFieldDef edc:cname="DV" edc:nzwidth="0x1" edc:desc="Flash Device 0 = CS0#, 1 = CS1#."/>
            <edc:SFRFieldDef edc:cname="RD" edc:nzwidth="0x1" edc:desc="Read Allowed for Region. 0 = No, 1 = Yes"/>
            <edc:SFRFieldDef edc:cname="WR" edc:nzwidth="0x1" edc:desc="Write Allowed for Region. 0 = No, 1 = Yes"/>
            <edc:AdjustPoint edc:offset="0x1"/>
            <edc:SFRFieldDef edc:cname="EN" edc:nzwidth="0x1" edc:desc="Enable Register Pair for Monitoring. 0 = No, 1 = Yes"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON0" edc:cname="RN_TM14RT_LIMIT" edc:nzwidth="0x20" edc:access="------------nnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0xFFFFF" edc:_addr="0x40010194">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON0">
            <edc:SFRFieldDef edc:cname="LMT" edc:nzwidth="0x14" edc:desc="Limit Register"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON0" edc:cname="RN_TM15RT_START" edc:nzwidth="0x20" edc:access="n-nnn-nn----nnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0xBB0FFFFF" edc:_addr="0x40010198">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON0">
            <edc:SFRFieldDef edc:cname="STRT" edc:nzwidth="0x14" edc:desc="A Flash address shifted by 12 (4K byte units). Bottom 12 address bits are 000h"/>
            <edc:AdjustPoint edc:offset="0x4"/>
            <edc:SFRFieldDef edc:cname="E32" edc:nzwidth="0x1" edc:desc="Enable 32KByte Erase opcode for this region. 0 = Disable, 1 = Enable"/>
            <edc:SFRFieldDef edc:cname="E64" edc:nzwidth="0x1" edc:desc="Enable 64KByte Erase opcode for this region. 0 = Disable, 1 = Enable"/>
            <edc:AdjustPoint edc:offset="0x1"/>
            <edc:SFRFieldDef edc:cname="DV" edc:nzwidth="0x1" edc:desc="Flash Device 0 = CS0#, 1 = CS1#."/>
            <edc:SFRFieldDef edc:cname="RD" edc:nzwidth="0x1" edc:desc="Read Allowed for Region. 0 = No, 1 = Yes"/>
            <edc:SFRFieldDef edc:cname="WR" edc:nzwidth="0x1" edc:desc="Write Allowed for Region. 0 = No, 1 = Yes"/>
            <edc:AdjustPoint edc:offset="0x1"/>
            <edc:SFRFieldDef edc:cname="EN" edc:nzwidth="0x1" edc:desc="Enable Register Pair for Monitoring. 0 = No, 1 = Yes"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON0" edc:cname="RN_TM15RT_LIMIT" edc:nzwidth="0x20" edc:access="------------nnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0xFFFFF" edc:_addr="0x4001019C">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON0">
            <edc:SFRFieldDef edc:cname="LMT" edc:nzwidth="0x14" edc:desc="Limit Register"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:AdjustPoint edc:offset="0x30" edc:_addr="0x400101A0"/>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON0" edc:cname="MTMON_CTRLSTS" edc:nzwidth="0x20" edc:access="-------n----nnnn-----nnn-----nnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x10F0707" edc:_addr="0x400101D0">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON0">
            <edc:SFRFieldDef edc:cname="T" edc:nzwidth="0x1" edc:desc="Timeout"/>
            <edc:SFRFieldDef edc:cname="F" edc:nzwidth="0x1" edc:desc="First Fetch in any Match region"/>
            <edc:SFRFieldDef edc:cname="AM" edc:nzwidth="0x1" edc:desc="Set to 1 on a 3B/4B Address Mode switch on either Flash."/>
            <edc:AdjustPoint edc:offset="0x5"/>
            <edc:SFRFieldDef edc:cname="ET_IRQ" edc:nzwidth="0x1" edc:desc="Enable Timeout Interrupt"/>
            <edc:SFRFieldDef edc:cname="EF_IRQ" edc:nzwidth="0x1" edc:desc="Enable First Fetch in any Match region Interrupt"/>
            <edc:SFRFieldDef edc:cname="AM_IRQ" edc:nzwidth="0x1" edc:desc="Enable 3B/4B Address Mode switch on either Flash Interrupt"/>
            <edc:AdjustPoint edc:offset="0x5"/>
            <edc:SFRFieldDef edc:cname="FIFO_MTY" edc:nzwidth="0x1" edc:desc="FIFO Empty"/>
            <edc:SFRFieldDef edc:cname="FIFO_FUL" edc:nzwidth="0x1" edc:desc="FIFO Full"/>
            <edc:SFRFieldDef edc:cname="FIFO_OVRF" edc:nzwidth="0x1" edc:desc="FIFO Overflow"/>
            <edc:SFRFieldDef edc:cname="FIFO_UDRF" edc:nzwidth="0x1" edc:desc="FIFO Underflow"/>
            <edc:AdjustPoint edc:offset="0x4"/>
            <edc:SFRFieldDef edc:cname="CLR_FIFO" edc:nzwidth="0x1" edc:desc="Clear FIFO. This field is autocleared by hardware"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON0" edc:cname="MTMON_ENMD" edc:nzwidth="0x20" edc:access="-----------------------n-------n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x101" edc:_addr="0x400101D4">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON0">
            <edc:SFRFieldDef edc:cname="MON_EN" edc:nzwidth="0x1" edc:desc="Enable Data Matching. 0 = Disabled, 1 = Enabled"/>
            <edc:AdjustPoint edc:offset="0x7"/>
            <edc:SFRFieldDef edc:cname="MON_MS" edc:nzwidth="0x1" edc:desc="Match Pattern Source Mode: 0 = SRAM, 1 = Internal Flash."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON0" edc:cname="MTMON_TCTRL" edc:nzwidth="0x20" edc:access="---------nnnnnnn---------------n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x7F0001" edc:_addr="0x400101D8">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON0">
            <edc:SFRFieldDef edc:cname="ST" edc:nzwidth="0x1" edc:desc="Start Timeout Counter"/>
            <edc:AdjustPoint edc:offset="0xF"/>
            <edc:SFRFieldDef edc:cname="TV" edc:nzwidth="0x5" edc:desc="Timeout Value 0 to 32"/>
            <edc:SFRFieldDef edc:cname="TU" edc:nzwidth="0x2" edc:desc="Timeout Unit 00 = none (off), 01 = 32ms, 10 = 128ms, 11 = 1sec"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:AdjustPoint edc:offset="0x4" edc:_addr="0x400101DC"/>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON0" edc:cname="MT_MON0MTMON_BEGIN" edc:nzwidth="0x20" edc:access="n------------nnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x8007FFFF" edc:_addr="0x400101E0">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON0">
            <edc:SFRFieldDef edc:cname="BGN" edc:nzwidth="0x13" edc:desc="The 19 bits of base address within the designated SPI Flash, specifying the last aligned 8K block."/>
            <edc:AdjustPoint edc:offset="0xC"/>
            <edc:SFRFieldDef edc:cname="DV" edc:nzwidth="0x1" edc:desc="Flash Device number, applying to both Begin and End fields 0 = CS0#, 1 = CS1#"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON0" edc:cname="MT_MON0MTMON_END" edc:nzwidth="0x20" edc:access="-------------nnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x7FFFF" edc:_addr="0x400101E4">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON0">
            <edc:SFRFieldDef edc:cname="END" edc:nzwidth="0x13" edc:desc="The 19 bits of base address within the designated SPI Flash, specifying the last aligned 8K block."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON0" edc:cname="MT_MON0MAP" edc:nzwidth="0x20" edc:access="n------------nnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x8007FFFF" edc:_addr="0x400101E8">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON0">
            <edc:SFRFieldDef edc:cname="MAP" edc:nzwidth="0x13" edc:desc="The 19 bits of base address within the designated SPI Flash, specifying the last aligned 8K block."/>
            <edc:AdjustPoint edc:offset="0xC"/>
            <edc:SFRFieldDef edc:cname="ME" edc:nzwidth="0x1" edc:desc="Match Enable for individual Region R"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON0" edc:cname="MT_MON1MTMON_BEGIN" edc:nzwidth="0x20" edc:access="n------------nnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x8007FFFF" edc:_addr="0x400101EC">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON0">
            <edc:SFRFieldDef edc:cname="BGN" edc:nzwidth="0x13" edc:desc="The 19 bits of base address within the designated SPI Flash, specifying the last aligned 8K block."/>
            <edc:AdjustPoint edc:offset="0xC"/>
            <edc:SFRFieldDef edc:cname="DV" edc:nzwidth="0x1" edc:desc="Flash Device number, applying to both Begin and End fields 0 = CS0#, 1 = CS1#"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON0" edc:cname="MT_MON1MTMON_END" edc:nzwidth="0x20" edc:access="-------------nnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x7FFFF" edc:_addr="0x400101F0">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON0">
            <edc:SFRFieldDef edc:cname="END" edc:nzwidth="0x13" edc:desc="The 19 bits of base address within the designated SPI Flash, specifying the last aligned 8K block."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON0" edc:cname="MT_MON1MAP" edc:nzwidth="0x20" edc:access="n------------nnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x8007FFFF" edc:_addr="0x400101F4">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON0">
            <edc:SFRFieldDef edc:cname="MAP" edc:nzwidth="0x13" edc:desc="The 19 bits of base address within the designated SPI Flash, specifying the last aligned 8K block."/>
            <edc:AdjustPoint edc:offset="0xC"/>
            <edc:SFRFieldDef edc:cname="ME" edc:nzwidth="0x1" edc:desc="Match Enable for individual Region R"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON0" edc:cname="MT_MON2MTMON_BEGIN" edc:nzwidth="0x20" edc:access="n------------nnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x8007FFFF" edc:_addr="0x400101F8">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON0">
            <edc:SFRFieldDef edc:cname="BGN" edc:nzwidth="0x13" edc:desc="The 19 bits of base address within the designated SPI Flash, specifying the last aligned 8K block."/>
            <edc:AdjustPoint edc:offset="0xC"/>
            <edc:SFRFieldDef edc:cname="DV" edc:nzwidth="0x1" edc:desc="Flash Device number, applying to both Begin and End fields 0 = CS0#, 1 = CS1#"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON0" edc:cname="MT_MON2MTMON_END" edc:nzwidth="0x20" edc:access="-------------nnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x7FFFF" edc:_addr="0x400101FC">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON0">
            <edc:SFRFieldDef edc:cname="END" edc:nzwidth="0x13" edc:desc="The 19 bits of base address within the designated SPI Flash, specifying the last aligned 8K block."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON0" edc:cname="MT_MON2MAP" edc:nzwidth="0x20" edc:access="n------------nnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x8007FFFF" edc:_addr="0x40010200">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON0">
            <edc:SFRFieldDef edc:cname="MAP" edc:nzwidth="0x13" edc:desc="The 19 bits of base address within the designated SPI Flash, specifying the last aligned 8K block."/>
            <edc:AdjustPoint edc:offset="0xC"/>
            <edc:SFRFieldDef edc:cname="ME" edc:nzwidth="0x1" edc:desc="Match Enable for individual Region R"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON0" edc:cname="MT_MON3MTMON_BEGIN" edc:nzwidth="0x20" edc:access="n------------nnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x8007FFFF" edc:_addr="0x40010204">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON0">
            <edc:SFRFieldDef edc:cname="BGN" edc:nzwidth="0x13" edc:desc="The 19 bits of base address within the designated SPI Flash, specifying the last aligned 8K block."/>
            <edc:AdjustPoint edc:offset="0xC"/>
            <edc:SFRFieldDef edc:cname="DV" edc:nzwidth="0x1" edc:desc="Flash Device number, applying to both Begin and End fields 0 = CS0#, 1 = CS1#"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON0" edc:cname="MT_MON3MTMON_END" edc:nzwidth="0x20" edc:access="-------------nnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x7FFFF" edc:_addr="0x40010208">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON0">
            <edc:SFRFieldDef edc:cname="END" edc:nzwidth="0x13" edc:desc="The 19 bits of base address within the designated SPI Flash, specifying the last aligned 8K block."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON0" edc:cname="MT_MON3MAP" edc:nzwidth="0x20" edc:access="n------------nnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x8007FFFF" edc:_addr="0x4001020C">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON0">
            <edc:SFRFieldDef edc:cname="MAP" edc:nzwidth="0x13" edc:desc="The 19 bits of base address within the designated SPI Flash, specifying the last aligned 8K block."/>
            <edc:AdjustPoint edc:offset="0xC"/>
            <edc:SFRFieldDef edc:cname="ME" edc:nzwidth="0x1" edc:desc="Match Enable for individual Region R"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON0" edc:cname="MT_MON4MTMON_BEGIN" edc:nzwidth="0x20" edc:access="n------------nnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x8007FFFF" edc:_addr="0x40010210">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON0">
            <edc:SFRFieldDef edc:cname="BGN" edc:nzwidth="0x13" edc:desc="The 19 bits of base address within the designated SPI Flash, specifying the last aligned 8K block."/>
            <edc:AdjustPoint edc:offset="0xC"/>
            <edc:SFRFieldDef edc:cname="DV" edc:nzwidth="0x1" edc:desc="Flash Device number, applying to both Begin and End fields 0 = CS0#, 1 = CS1#"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON0" edc:cname="MT_MON4MTMON_END" edc:nzwidth="0x20" edc:access="-------------nnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x7FFFF" edc:_addr="0x40010214">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON0">
            <edc:SFRFieldDef edc:cname="END" edc:nzwidth="0x13" edc:desc="The 19 bits of base address within the designated SPI Flash, specifying the last aligned 8K block."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON0" edc:cname="MT_MON4MAP" edc:nzwidth="0x20" edc:access="n------------nnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x8007FFFF" edc:_addr="0x40010218">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON0">
            <edc:SFRFieldDef edc:cname="MAP" edc:nzwidth="0x13" edc:desc="The 19 bits of base address within the designated SPI Flash, specifying the last aligned 8K block."/>
            <edc:AdjustPoint edc:offset="0xC"/>
            <edc:SFRFieldDef edc:cname="ME" edc:nzwidth="0x1" edc:desc="Match Enable for individual Region R"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON0" edc:cname="MT_MON5MTMON_BEGIN" edc:nzwidth="0x20" edc:access="n------------nnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x8007FFFF" edc:_addr="0x4001021C">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON0">
            <edc:SFRFieldDef edc:cname="BGN" edc:nzwidth="0x13" edc:desc="The 19 bits of base address within the designated SPI Flash, specifying the last aligned 8K block."/>
            <edc:AdjustPoint edc:offset="0xC"/>
            <edc:SFRFieldDef edc:cname="DV" edc:nzwidth="0x1" edc:desc="Flash Device number, applying to both Begin and End fields 0 = CS0#, 1 = CS1#"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON0" edc:cname="MT_MON5MTMON_END" edc:nzwidth="0x20" edc:access="-------------nnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x7FFFF" edc:_addr="0x40010220">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON0">
            <edc:SFRFieldDef edc:cname="END" edc:nzwidth="0x13" edc:desc="The 19 bits of base address within the designated SPI Flash, specifying the last aligned 8K block."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON0" edc:cname="MT_MON5MAP" edc:nzwidth="0x20" edc:access="n------------nnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x8007FFFF" edc:_addr="0x40010224">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON0">
            <edc:SFRFieldDef edc:cname="MAP" edc:nzwidth="0x13" edc:desc="The 19 bits of base address within the designated SPI Flash, specifying the last aligned 8K block."/>
            <edc:AdjustPoint edc:offset="0xC"/>
            <edc:SFRFieldDef edc:cname="ME" edc:nzwidth="0x1" edc:desc="Match Enable for individual Region R"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON0" edc:cname="MT_MON6MTMON_BEGIN" edc:nzwidth="0x20" edc:access="n------------nnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x8007FFFF" edc:_addr="0x40010228">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON0">
            <edc:SFRFieldDef edc:cname="BGN" edc:nzwidth="0x13" edc:desc="The 19 bits of base address within the designated SPI Flash, specifying the last aligned 8K block."/>
            <edc:AdjustPoint edc:offset="0xC"/>
            <edc:SFRFieldDef edc:cname="DV" edc:nzwidth="0x1" edc:desc="Flash Device number, applying to both Begin and End fields 0 = CS0#, 1 = CS1#"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON0" edc:cname="MT_MON6MTMON_END" edc:nzwidth="0x20" edc:access="-------------nnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x7FFFF" edc:_addr="0x4001022C">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON0">
            <edc:SFRFieldDef edc:cname="END" edc:nzwidth="0x13" edc:desc="The 19 bits of base address within the designated SPI Flash, specifying the last aligned 8K block."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON0" edc:cname="MT_MON6MAP" edc:nzwidth="0x20" edc:access="n------------nnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x8007FFFF" edc:_addr="0x40010230">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON0">
            <edc:SFRFieldDef edc:cname="MAP" edc:nzwidth="0x13" edc:desc="The 19 bits of base address within the designated SPI Flash, specifying the last aligned 8K block."/>
            <edc:AdjustPoint edc:offset="0xC"/>
            <edc:SFRFieldDef edc:cname="ME" edc:nzwidth="0x1" edc:desc="Match Enable for individual Region R"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON0" edc:cname="MT_MON7MTMON_BEGIN" edc:nzwidth="0x20" edc:access="n------------nnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x8007FFFF" edc:_addr="0x40010234">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON0">
            <edc:SFRFieldDef edc:cname="BGN" edc:nzwidth="0x13" edc:desc="The 19 bits of base address within the designated SPI Flash, specifying the last aligned 8K block."/>
            <edc:AdjustPoint edc:offset="0xC"/>
            <edc:SFRFieldDef edc:cname="DV" edc:nzwidth="0x1" edc:desc="Flash Device number, applying to both Begin and End fields 0 = CS0#, 1 = CS1#"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON0" edc:cname="MT_MON7MTMON_END" edc:nzwidth="0x20" edc:access="-------------nnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x7FFFF" edc:_addr="0x40010238">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON0">
            <edc:SFRFieldDef edc:cname="END" edc:nzwidth="0x13" edc:desc="The 19 bits of base address within the designated SPI Flash, specifying the last aligned 8K block."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON0" edc:cname="MT_MON7MAP" edc:nzwidth="0x20" edc:access="n------------nnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x8007FFFF" edc:_addr="0x4001023C">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON0">
            <edc:SFRFieldDef edc:cname="MAP" edc:nzwidth="0x13" edc:desc="The 19 bits of base address within the designated SPI Flash, specifying the last aligned 8K block."/>
            <edc:AdjustPoint edc:offset="0xC"/>
            <edc:SFRFieldDef edc:cname="ME" edc:nzwidth="0x1" edc:desc="Match Enable for individual Region R"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON0" edc:cname="MTMON_VIOSTS" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnn--nnnnnn-n----" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0xFFFFCFD0" edc:_addr="0x40010240">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON0">
            <edc:AdjustPoint edc:offset="0x4"/>
            <edc:SFRFieldDef edc:cname="MTO" edc:nzwidth="0x1" edc:desc="Match Monitor Timeout. This is read-Only bit."/>
            <edc:AdjustPoint edc:offset="0x1"/>
            <edc:SFRFieldDef edc:cname="DV" edc:nzwidth="0x1" edc:desc="Device Number. This is read-Only bit. 0 = CS0, 1 = CS1."/>
            <edc:SFRFieldDef edc:cname="RGN" edc:nzwidth="0x5" edc:desc="Region. This is read-Only bit. Shows which of 8 Match regions [7:0] got the mismatch."/>
            <edc:AdjustPoint edc:offset="0x2"/>
            <edc:SFRFieldDef edc:cname="AM" edc:nzwidth="0x1" edc:desc="Flash Address Mode 0 = 3-byte, 1 = 4-byte"/>
            <edc:SFRFieldDef edc:cname="CLR" edc:nzwidth="0x1" edc:desc="Clear Register RW1C. This bit is auto clearing"/>
            <edc:SFRFieldDef edc:cname="OPCOD" edc:nzwidth="0x8" edc:desc="Flash Opcode"/>
            <edc:SFRFieldDef edc:cname="DATA" edc:nzwidth="0x8" edc:desc="SPI Data Byte"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON0" edc:cname="MTMON_VIOADDR" edc:nzwidth="0x20" edc:access="rrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrr" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x40010244">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON0">
            <edc:SFRFieldDef edc:cname="ADDR" edc:nzwidth="0x20" edc:desc="Byte address at which the error occurred, within the designated Flash"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:AdjustPoint edc:offset="0x8" edc:_addr="0x40010248"/>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON0" edc:cname="LTMON_AGGR" edc:nzwidth="0x20" edc:access="----------------nnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0xFFFF" edc:_addr="0x40010250">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON0">
            <edc:SFRFieldDef edc:cname="IRQ0" edc:nzwidth="0x1" edc:desc="Load 0 Interrupt"/>
            <edc:SFRFieldDef edc:cname="IRQ1" edc:nzwidth="0x1" edc:desc="Load 1 Interrupt"/>
            <edc:SFRFieldDef edc:cname="IRQ2" edc:nzwidth="0x1" edc:desc="Load 2 Interrupt"/>
            <edc:SFRFieldDef edc:cname="IRQ3" edc:nzwidth="0x1" edc:desc="Load 3 Interrupt"/>
            <edc:SFRFieldDef edc:cname="IRQ4" edc:nzwidth="0x1" edc:desc="Load 4 Interrupt"/>
            <edc:SFRFieldDef edc:cname="IRQ5" edc:nzwidth="0x1" edc:desc="Load 5 Interrupt"/>
            <edc:SFRFieldDef edc:cname="IRQ6" edc:nzwidth="0x1" edc:desc="Load 6 Interrupt"/>
            <edc:SFRFieldDef edc:cname="IRQ7" edc:nzwidth="0x1" edc:desc="Load 7 Interrupt"/>
            <edc:SFRFieldDef edc:cname="EN_IRQ0" edc:nzwidth="0x1" edc:desc="Enable Load 0 Interrupt"/>
            <edc:SFRFieldDef edc:cname="EN_IRQ1" edc:nzwidth="0x1" edc:desc="Enable Load 1 Interrupt"/>
            <edc:SFRFieldDef edc:cname="EN_IRQ2" edc:nzwidth="0x1" edc:desc="Enable Load 2 Interrupt"/>
            <edc:SFRFieldDef edc:cname="EN_IRQ3" edc:nzwidth="0x1" edc:desc="Enable Load 3 Interrupt"/>
            <edc:SFRFieldDef edc:cname="EN_IRQ4" edc:nzwidth="0x1" edc:desc="Enable Load 4 Interrupt"/>
            <edc:SFRFieldDef edc:cname="EN_IRQ5" edc:nzwidth="0x1" edc:desc="Enable Load 5 Interrupt"/>
            <edc:SFRFieldDef edc:cname="EN_IRQ6" edc:nzwidth="0x1" edc:desc="Enable Load 6 Interrupt"/>
            <edc:SFRFieldDef edc:cname="EN_IRQ7" edc:nzwidth="0x1" edc:desc="Enable Load 7 Interrupt"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON0" edc:cname="LT_MON0LM_CTRLSTS" edc:nzwidth="0x20" edc:access="--------------------nnnn----nnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0xF0F" edc:_addr="0x40010254">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON0">
            <edc:SFRFieldDef edc:cname="W" edc:nzwidth="0x1" edc:desc="Waiting"/>
            <edc:SFRFieldDef edc:cname="B" edc:nzwidth="0x1" edc:desc="Begin Byte seen"/>
            <edc:SFRFieldDef edc:cname="E" edc:nzwidth="0x1" edc:desc="End Byte seen"/>
            <edc:SFRFieldDef edc:cname="F" edc:nzwidth="0x1" edc:desc="Finalized and result ready"/>
            <edc:AdjustPoint edc:offset="0x4"/>
            <edc:SFRFieldDef edc:cname="W_INTEN" edc:nzwidth="0x1" edc:desc="Enable Waiting Interrupt"/>
            <edc:SFRFieldDef edc:cname="B_INTEN" edc:nzwidth="0x1" edc:desc="Enable Begin Byte seen Interrupt"/>
            <edc:SFRFieldDef edc:cname="E_INTEN" edc:nzwidth="0x1" edc:desc="Enable End Byte seen Interrupt"/>
            <edc:SFRFieldDef edc:cname="F_INTEN" edc:nzwidth="0x1" edc:desc="Enable Finalized and result ready Interrupt"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON0" edc:cname="LT_MON0LM_CHN_CTRL" edc:nzwidth="0x20" edc:access="--------------------nnnn-----nnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0xF07" edc:_addr="0x40010258">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON0">
            <edc:SFRFieldDef edc:cname="GO" edc:nzwidth="0x1" edc:desc="GO: Run the Load Monitor for this channel"/>
            <edc:SFRFieldDef edc:cname="RST" edc:nzwidth="0x1" edc:desc="RST: Stop and Reset calculation for this channel when set to 1"/>
            <edc:SFRFieldDef edc:cname="RSF" edc:nzwidth="0x1" edc:desc="RSF: Reset just Result FIFO pointer when this bit is set to 1"/>
            <edc:AdjustPoint edc:offset="0x5"/>
            <edc:SFRFieldDef edc:cname="FPTR" edc:nzwidth="0x4" edc:desc="FPTR: Result FIFO pointer. In 32Bit. Ranges: 0 to 11 for SHA-384 result 0 to 7 for SHA-256 result"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON0" edc:cname="LT_MON0LM_BEGIN" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x4001025C">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON0">
            <edc:SFRFieldDef edc:cname="BADDR" edc:nzwidth="0x1F" edc:desc="A byte address within the designated Flash, specifying the first byte of the load image."/>
            <edc:SFRFieldDef edc:cname="DV" edc:nzwidth="0x1" edc:desc="Flash Device number, applying to both Begin and End fields. 0 = CS0#, 1 = CS1#"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON0" edc:cname="LT_MON0LM_END" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x40010260">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON0">
            <edc:SFRFieldDef edc:cname="EADDR" edc:nzwidth="0x20" edc:desc="A byte address within the designated Flash, specifying the last byte of the load image."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON0" edc:cname="LT_MON0LM_COUNT" edc:nzwidth="0x20" edc:access="rrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrr" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x40010264">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON0">
            <edc:SFRFieldDef edc:cname="CNT" edc:nzwidth="0x20" edc:desc="A Read-Only count of bytes processed."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON0" edc:cname="LT_MON0LM_DIGEST" edc:nzwidth="0x20" edc:access="rrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrr" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x40010268">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON0">
            <edc:SFRFieldDef edc:cname="DGST" edc:nzwidth="0x20" edc:desc="A Read-Only FIFO Portal to Hash digest result. 12 or 8 Dwords depending on algorithm."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON0" edc:cname="LT_MON1LM_CTRLSTS" edc:nzwidth="0x20" edc:access="--------------------nnnn----nnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0xF0F" edc:_addr="0x4001026C">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON0">
            <edc:SFRFieldDef edc:cname="W" edc:nzwidth="0x1" edc:desc="Waiting"/>
            <edc:SFRFieldDef edc:cname="B" edc:nzwidth="0x1" edc:desc="Begin Byte seen"/>
            <edc:SFRFieldDef edc:cname="E" edc:nzwidth="0x1" edc:desc="End Byte seen"/>
            <edc:SFRFieldDef edc:cname="F" edc:nzwidth="0x1" edc:desc="Finalized and result ready"/>
            <edc:AdjustPoint edc:offset="0x4"/>
            <edc:SFRFieldDef edc:cname="W_INTEN" edc:nzwidth="0x1" edc:desc="Enable Waiting Interrupt"/>
            <edc:SFRFieldDef edc:cname="B_INTEN" edc:nzwidth="0x1" edc:desc="Enable Begin Byte seen Interrupt"/>
            <edc:SFRFieldDef edc:cname="E_INTEN" edc:nzwidth="0x1" edc:desc="Enable End Byte seen Interrupt"/>
            <edc:SFRFieldDef edc:cname="F_INTEN" edc:nzwidth="0x1" edc:desc="Enable Finalized and result ready Interrupt"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON0" edc:cname="LT_MON1LM_CHN_CTRL" edc:nzwidth="0x20" edc:access="--------------------nnnn-----nnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0xF07" edc:_addr="0x40010270">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON0">
            <edc:SFRFieldDef edc:cname="GO" edc:nzwidth="0x1" edc:desc="GO: Run the Load Monitor for this channel"/>
            <edc:SFRFieldDef edc:cname="RST" edc:nzwidth="0x1" edc:desc="RST: Stop and Reset calculation for this channel when set to 1"/>
            <edc:SFRFieldDef edc:cname="RSF" edc:nzwidth="0x1" edc:desc="RSF: Reset just Result FIFO pointer when this bit is set to 1"/>
            <edc:AdjustPoint edc:offset="0x5"/>
            <edc:SFRFieldDef edc:cname="FPTR" edc:nzwidth="0x4" edc:desc="FPTR: Result FIFO pointer. In 32Bit. Ranges: 0 to 11 for SHA-384 result 0 to 7 for SHA-256 result"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON0" edc:cname="LT_MON1LM_BEGIN" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x40010274">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON0">
            <edc:SFRFieldDef edc:cname="BADDR" edc:nzwidth="0x1F" edc:desc="A byte address within the designated Flash, specifying the first byte of the load image."/>
            <edc:SFRFieldDef edc:cname="DV" edc:nzwidth="0x1" edc:desc="Flash Device number, applying to both Begin and End fields. 0 = CS0#, 1 = CS1#"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON0" edc:cname="LT_MON1LM_END" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x40010278">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON0">
            <edc:SFRFieldDef edc:cname="EADDR" edc:nzwidth="0x20" edc:desc="A byte address within the designated Flash, specifying the last byte of the load image."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON0" edc:cname="LT_MON1LM_COUNT" edc:nzwidth="0x20" edc:access="rrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrr" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x4001027C">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON0">
            <edc:SFRFieldDef edc:cname="CNT" edc:nzwidth="0x20" edc:desc="A Read-Only count of bytes processed."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON0" edc:cname="LT_MON1LM_DIGEST" edc:nzwidth="0x20" edc:access="rrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrr" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x40010280">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON0">
            <edc:SFRFieldDef edc:cname="DGST" edc:nzwidth="0x20" edc:desc="A Read-Only FIFO Portal to Hash digest result. 12 or 8 Dwords depending on algorithm."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON0" edc:cname="LT_MON2LM_CTRLSTS" edc:nzwidth="0x20" edc:access="--------------------nnnn----nnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0xF0F" edc:_addr="0x40010284">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON0">
            <edc:SFRFieldDef edc:cname="W" edc:nzwidth="0x1" edc:desc="Waiting"/>
            <edc:SFRFieldDef edc:cname="B" edc:nzwidth="0x1" edc:desc="Begin Byte seen"/>
            <edc:SFRFieldDef edc:cname="E" edc:nzwidth="0x1" edc:desc="End Byte seen"/>
            <edc:SFRFieldDef edc:cname="F" edc:nzwidth="0x1" edc:desc="Finalized and result ready"/>
            <edc:AdjustPoint edc:offset="0x4"/>
            <edc:SFRFieldDef edc:cname="W_INTEN" edc:nzwidth="0x1" edc:desc="Enable Waiting Interrupt"/>
            <edc:SFRFieldDef edc:cname="B_INTEN" edc:nzwidth="0x1" edc:desc="Enable Begin Byte seen Interrupt"/>
            <edc:SFRFieldDef edc:cname="E_INTEN" edc:nzwidth="0x1" edc:desc="Enable End Byte seen Interrupt"/>
            <edc:SFRFieldDef edc:cname="F_INTEN" edc:nzwidth="0x1" edc:desc="Enable Finalized and result ready Interrupt"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON0" edc:cname="LT_MON2LM_CHN_CTRL" edc:nzwidth="0x20" edc:access="--------------------nnnn-----nnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0xF07" edc:_addr="0x40010288">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON0">
            <edc:SFRFieldDef edc:cname="GO" edc:nzwidth="0x1" edc:desc="GO: Run the Load Monitor for this channel"/>
            <edc:SFRFieldDef edc:cname="RST" edc:nzwidth="0x1" edc:desc="RST: Stop and Reset calculation for this channel when set to 1"/>
            <edc:SFRFieldDef edc:cname="RSF" edc:nzwidth="0x1" edc:desc="RSF: Reset just Result FIFO pointer when this bit is set to 1"/>
            <edc:AdjustPoint edc:offset="0x5"/>
            <edc:SFRFieldDef edc:cname="FPTR" edc:nzwidth="0x4" edc:desc="FPTR: Result FIFO pointer. In 32Bit. Ranges: 0 to 11 for SHA-384 result 0 to 7 for SHA-256 result"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON0" edc:cname="LT_MON2LM_BEGIN" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x4001028C">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON0">
            <edc:SFRFieldDef edc:cname="BADDR" edc:nzwidth="0x1F" edc:desc="A byte address within the designated Flash, specifying the first byte of the load image."/>
            <edc:SFRFieldDef edc:cname="DV" edc:nzwidth="0x1" edc:desc="Flash Device number, applying to both Begin and End fields. 0 = CS0#, 1 = CS1#"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON0" edc:cname="LT_MON2LM_END" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x40010290">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON0">
            <edc:SFRFieldDef edc:cname="EADDR" edc:nzwidth="0x20" edc:desc="A byte address within the designated Flash, specifying the last byte of the load image."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON0" edc:cname="LT_MON2LM_COUNT" edc:nzwidth="0x20" edc:access="rrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrr" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x40010294">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON0">
            <edc:SFRFieldDef edc:cname="CNT" edc:nzwidth="0x20" edc:desc="A Read-Only count of bytes processed."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON0" edc:cname="LT_MON2LM_DIGEST" edc:nzwidth="0x20" edc:access="rrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrr" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x40010298">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON0">
            <edc:SFRFieldDef edc:cname="DGST" edc:nzwidth="0x20" edc:desc="A Read-Only FIFO Portal to Hash digest result. 12 or 8 Dwords depending on algorithm."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON0" edc:cname="LT_MON3LM_CTRLSTS" edc:nzwidth="0x20" edc:access="--------------------nnnn----nnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0xF0F" edc:_addr="0x4001029C">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON0">
            <edc:SFRFieldDef edc:cname="W" edc:nzwidth="0x1" edc:desc="Waiting"/>
            <edc:SFRFieldDef edc:cname="B" edc:nzwidth="0x1" edc:desc="Begin Byte seen"/>
            <edc:SFRFieldDef edc:cname="E" edc:nzwidth="0x1" edc:desc="End Byte seen"/>
            <edc:SFRFieldDef edc:cname="F" edc:nzwidth="0x1" edc:desc="Finalized and result ready"/>
            <edc:AdjustPoint edc:offset="0x4"/>
            <edc:SFRFieldDef edc:cname="W_INTEN" edc:nzwidth="0x1" edc:desc="Enable Waiting Interrupt"/>
            <edc:SFRFieldDef edc:cname="B_INTEN" edc:nzwidth="0x1" edc:desc="Enable Begin Byte seen Interrupt"/>
            <edc:SFRFieldDef edc:cname="E_INTEN" edc:nzwidth="0x1" edc:desc="Enable End Byte seen Interrupt"/>
            <edc:SFRFieldDef edc:cname="F_INTEN" edc:nzwidth="0x1" edc:desc="Enable Finalized and result ready Interrupt"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON0" edc:cname="LT_MON3LM_CHN_CTRL" edc:nzwidth="0x20" edc:access="--------------------nnnn-----nnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0xF07" edc:_addr="0x400102A0">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON0">
            <edc:SFRFieldDef edc:cname="GO" edc:nzwidth="0x1" edc:desc="GO: Run the Load Monitor for this channel"/>
            <edc:SFRFieldDef edc:cname="RST" edc:nzwidth="0x1" edc:desc="RST: Stop and Reset calculation for this channel when set to 1"/>
            <edc:SFRFieldDef edc:cname="RSF" edc:nzwidth="0x1" edc:desc="RSF: Reset just Result FIFO pointer when this bit is set to 1"/>
            <edc:AdjustPoint edc:offset="0x5"/>
            <edc:SFRFieldDef edc:cname="FPTR" edc:nzwidth="0x4" edc:desc="FPTR: Result FIFO pointer. In 32Bit. Ranges: 0 to 11 for SHA-384 result 0 to 7 for SHA-256 result"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON0" edc:cname="LT_MON3LM_BEGIN" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x400102A4">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON0">
            <edc:SFRFieldDef edc:cname="BADDR" edc:nzwidth="0x1F" edc:desc="A byte address within the designated Flash, specifying the first byte of the load image."/>
            <edc:SFRFieldDef edc:cname="DV" edc:nzwidth="0x1" edc:desc="Flash Device number, applying to both Begin and End fields. 0 = CS0#, 1 = CS1#"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON0" edc:cname="LT_MON3LM_END" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x400102A8">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON0">
            <edc:SFRFieldDef edc:cname="EADDR" edc:nzwidth="0x20" edc:desc="A byte address within the designated Flash, specifying the last byte of the load image."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON0" edc:cname="LT_MON3LM_COUNT" edc:nzwidth="0x20" edc:access="rrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrr" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x400102AC">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON0">
            <edc:SFRFieldDef edc:cname="CNT" edc:nzwidth="0x20" edc:desc="A Read-Only count of bytes processed."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON0" edc:cname="LT_MON3LM_DIGEST" edc:nzwidth="0x20" edc:access="rrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrr" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x400102B0">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON0">
            <edc:SFRFieldDef edc:cname="DGST" edc:nzwidth="0x20" edc:desc="A Read-Only FIFO Portal to Hash digest result. 12 or 8 Dwords depending on algorithm."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON0" edc:cname="LT_MON4LM_CTRLSTS" edc:nzwidth="0x20" edc:access="--------------------nnnn----nnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0xF0F" edc:_addr="0x400102B4">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON0">
            <edc:SFRFieldDef edc:cname="W" edc:nzwidth="0x1" edc:desc="Waiting"/>
            <edc:SFRFieldDef edc:cname="B" edc:nzwidth="0x1" edc:desc="Begin Byte seen"/>
            <edc:SFRFieldDef edc:cname="E" edc:nzwidth="0x1" edc:desc="End Byte seen"/>
            <edc:SFRFieldDef edc:cname="F" edc:nzwidth="0x1" edc:desc="Finalized and result ready"/>
            <edc:AdjustPoint edc:offset="0x4"/>
            <edc:SFRFieldDef edc:cname="W_INTEN" edc:nzwidth="0x1" edc:desc="Enable Waiting Interrupt"/>
            <edc:SFRFieldDef edc:cname="B_INTEN" edc:nzwidth="0x1" edc:desc="Enable Begin Byte seen Interrupt"/>
            <edc:SFRFieldDef edc:cname="E_INTEN" edc:nzwidth="0x1" edc:desc="Enable End Byte seen Interrupt"/>
            <edc:SFRFieldDef edc:cname="F_INTEN" edc:nzwidth="0x1" edc:desc="Enable Finalized and result ready Interrupt"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON0" edc:cname="LT_MON4LM_CHN_CTRL" edc:nzwidth="0x20" edc:access="--------------------nnnn-----nnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0xF07" edc:_addr="0x400102B8">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON0">
            <edc:SFRFieldDef edc:cname="GO" edc:nzwidth="0x1" edc:desc="GO: Run the Load Monitor for this channel"/>
            <edc:SFRFieldDef edc:cname="RST" edc:nzwidth="0x1" edc:desc="RST: Stop and Reset calculation for this channel when set to 1"/>
            <edc:SFRFieldDef edc:cname="RSF" edc:nzwidth="0x1" edc:desc="RSF: Reset just Result FIFO pointer when this bit is set to 1"/>
            <edc:AdjustPoint edc:offset="0x5"/>
            <edc:SFRFieldDef edc:cname="FPTR" edc:nzwidth="0x4" edc:desc="FPTR: Result FIFO pointer. In 32Bit. Ranges: 0 to 11 for SHA-384 result 0 to 7 for SHA-256 result"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON0" edc:cname="LT_MON4LM_BEGIN" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x400102BC">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON0">
            <edc:SFRFieldDef edc:cname="BADDR" edc:nzwidth="0x1F" edc:desc="A byte address within the designated Flash, specifying the first byte of the load image."/>
            <edc:SFRFieldDef edc:cname="DV" edc:nzwidth="0x1" edc:desc="Flash Device number, applying to both Begin and End fields. 0 = CS0#, 1 = CS1#"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON0" edc:cname="LT_MON4LM_END" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x400102C0">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON0">
            <edc:SFRFieldDef edc:cname="EADDR" edc:nzwidth="0x20" edc:desc="A byte address within the designated Flash, specifying the last byte of the load image."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON0" edc:cname="LT_MON4LM_COUNT" edc:nzwidth="0x20" edc:access="rrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrr" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x400102C4">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON0">
            <edc:SFRFieldDef edc:cname="CNT" edc:nzwidth="0x20" edc:desc="A Read-Only count of bytes processed."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON0" edc:cname="LT_MON4LM_DIGEST" edc:nzwidth="0x20" edc:access="rrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrr" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x400102C8">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON0">
            <edc:SFRFieldDef edc:cname="DGST" edc:nzwidth="0x20" edc:desc="A Read-Only FIFO Portal to Hash digest result. 12 or 8 Dwords depending on algorithm."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON0" edc:cname="LT_MON5LM_CTRLSTS" edc:nzwidth="0x20" edc:access="--------------------nnnn----nnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0xF0F" edc:_addr="0x400102CC">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON0">
            <edc:SFRFieldDef edc:cname="W" edc:nzwidth="0x1" edc:desc="Waiting"/>
            <edc:SFRFieldDef edc:cname="B" edc:nzwidth="0x1" edc:desc="Begin Byte seen"/>
            <edc:SFRFieldDef edc:cname="E" edc:nzwidth="0x1" edc:desc="End Byte seen"/>
            <edc:SFRFieldDef edc:cname="F" edc:nzwidth="0x1" edc:desc="Finalized and result ready"/>
            <edc:AdjustPoint edc:offset="0x4"/>
            <edc:SFRFieldDef edc:cname="W_INTEN" edc:nzwidth="0x1" edc:desc="Enable Waiting Interrupt"/>
            <edc:SFRFieldDef edc:cname="B_INTEN" edc:nzwidth="0x1" edc:desc="Enable Begin Byte seen Interrupt"/>
            <edc:SFRFieldDef edc:cname="E_INTEN" edc:nzwidth="0x1" edc:desc="Enable End Byte seen Interrupt"/>
            <edc:SFRFieldDef edc:cname="F_INTEN" edc:nzwidth="0x1" edc:desc="Enable Finalized and result ready Interrupt"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON0" edc:cname="LT_MON5LM_CHN_CTRL" edc:nzwidth="0x20" edc:access="--------------------nnnn-----nnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0xF07" edc:_addr="0x400102D0">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON0">
            <edc:SFRFieldDef edc:cname="GO" edc:nzwidth="0x1" edc:desc="GO: Run the Load Monitor for this channel"/>
            <edc:SFRFieldDef edc:cname="RST" edc:nzwidth="0x1" edc:desc="RST: Stop and Reset calculation for this channel when set to 1"/>
            <edc:SFRFieldDef edc:cname="RSF" edc:nzwidth="0x1" edc:desc="RSF: Reset just Result FIFO pointer when this bit is set to 1"/>
            <edc:AdjustPoint edc:offset="0x5"/>
            <edc:SFRFieldDef edc:cname="FPTR" edc:nzwidth="0x4" edc:desc="FPTR: Result FIFO pointer. In 32Bit. Ranges: 0 to 11 for SHA-384 result 0 to 7 for SHA-256 result"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON0" edc:cname="LT_MON5LM_BEGIN" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x400102D4">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON0">
            <edc:SFRFieldDef edc:cname="BADDR" edc:nzwidth="0x1F" edc:desc="A byte address within the designated Flash, specifying the first byte of the load image."/>
            <edc:SFRFieldDef edc:cname="DV" edc:nzwidth="0x1" edc:desc="Flash Device number, applying to both Begin and End fields. 0 = CS0#, 1 = CS1#"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON0" edc:cname="LT_MON5LM_END" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x400102D8">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON0">
            <edc:SFRFieldDef edc:cname="EADDR" edc:nzwidth="0x20" edc:desc="A byte address within the designated Flash, specifying the last byte of the load image."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON0" edc:cname="LT_MON5LM_COUNT" edc:nzwidth="0x20" edc:access="rrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrr" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x400102DC">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON0">
            <edc:SFRFieldDef edc:cname="CNT" edc:nzwidth="0x20" edc:desc="A Read-Only count of bytes processed."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON0" edc:cname="LT_MON5LM_DIGEST" edc:nzwidth="0x20" edc:access="rrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrr" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x400102E0">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON0">
            <edc:SFRFieldDef edc:cname="DGST" edc:nzwidth="0x20" edc:desc="A Read-Only FIFO Portal to Hash digest result. 12 or 8 Dwords depending on algorithm."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON0" edc:cname="LT_MON6LM_CTRLSTS" edc:nzwidth="0x20" edc:access="--------------------nnnn----nnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0xF0F" edc:_addr="0x400102E4">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON0">
            <edc:SFRFieldDef edc:cname="W" edc:nzwidth="0x1" edc:desc="Waiting"/>
            <edc:SFRFieldDef edc:cname="B" edc:nzwidth="0x1" edc:desc="Begin Byte seen"/>
            <edc:SFRFieldDef edc:cname="E" edc:nzwidth="0x1" edc:desc="End Byte seen"/>
            <edc:SFRFieldDef edc:cname="F" edc:nzwidth="0x1" edc:desc="Finalized and result ready"/>
            <edc:AdjustPoint edc:offset="0x4"/>
            <edc:SFRFieldDef edc:cname="W_INTEN" edc:nzwidth="0x1" edc:desc="Enable Waiting Interrupt"/>
            <edc:SFRFieldDef edc:cname="B_INTEN" edc:nzwidth="0x1" edc:desc="Enable Begin Byte seen Interrupt"/>
            <edc:SFRFieldDef edc:cname="E_INTEN" edc:nzwidth="0x1" edc:desc="Enable End Byte seen Interrupt"/>
            <edc:SFRFieldDef edc:cname="F_INTEN" edc:nzwidth="0x1" edc:desc="Enable Finalized and result ready Interrupt"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON0" edc:cname="LT_MON6LM_CHN_CTRL" edc:nzwidth="0x20" edc:access="--------------------nnnn-----nnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0xF07" edc:_addr="0x400102E8">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON0">
            <edc:SFRFieldDef edc:cname="GO" edc:nzwidth="0x1" edc:desc="GO: Run the Load Monitor for this channel"/>
            <edc:SFRFieldDef edc:cname="RST" edc:nzwidth="0x1" edc:desc="RST: Stop and Reset calculation for this channel when set to 1"/>
            <edc:SFRFieldDef edc:cname="RSF" edc:nzwidth="0x1" edc:desc="RSF: Reset just Result FIFO pointer when this bit is set to 1"/>
            <edc:AdjustPoint edc:offset="0x5"/>
            <edc:SFRFieldDef edc:cname="FPTR" edc:nzwidth="0x4" edc:desc="FPTR: Result FIFO pointer. In 32Bit. Ranges: 0 to 11 for SHA-384 result 0 to 7 for SHA-256 result"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON0" edc:cname="LT_MON6LM_BEGIN" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x400102EC">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON0">
            <edc:SFRFieldDef edc:cname="BADDR" edc:nzwidth="0x1F" edc:desc="A byte address within the designated Flash, specifying the first byte of the load image."/>
            <edc:SFRFieldDef edc:cname="DV" edc:nzwidth="0x1" edc:desc="Flash Device number, applying to both Begin and End fields. 0 = CS0#, 1 = CS1#"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON0" edc:cname="LT_MON6LM_END" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x400102F0">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON0">
            <edc:SFRFieldDef edc:cname="EADDR" edc:nzwidth="0x20" edc:desc="A byte address within the designated Flash, specifying the last byte of the load image."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON0" edc:cname="LT_MON6LM_COUNT" edc:nzwidth="0x20" edc:access="rrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrr" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x400102F4">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON0">
            <edc:SFRFieldDef edc:cname="CNT" edc:nzwidth="0x20" edc:desc="A Read-Only count of bytes processed."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON0" edc:cname="LT_MON6LM_DIGEST" edc:nzwidth="0x20" edc:access="rrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrr" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x400102F8">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON0">
            <edc:SFRFieldDef edc:cname="DGST" edc:nzwidth="0x20" edc:desc="A Read-Only FIFO Portal to Hash digest result. 12 or 8 Dwords depending on algorithm."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON0" edc:cname="LT_MON7LM_CTRLSTS" edc:nzwidth="0x20" edc:access="--------------------nnnn----nnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0xF0F" edc:_addr="0x400102FC">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON0">
            <edc:SFRFieldDef edc:cname="W" edc:nzwidth="0x1" edc:desc="Waiting"/>
            <edc:SFRFieldDef edc:cname="B" edc:nzwidth="0x1" edc:desc="Begin Byte seen"/>
            <edc:SFRFieldDef edc:cname="E" edc:nzwidth="0x1" edc:desc="End Byte seen"/>
            <edc:SFRFieldDef edc:cname="F" edc:nzwidth="0x1" edc:desc="Finalized and result ready"/>
            <edc:AdjustPoint edc:offset="0x4"/>
            <edc:SFRFieldDef edc:cname="W_INTEN" edc:nzwidth="0x1" edc:desc="Enable Waiting Interrupt"/>
            <edc:SFRFieldDef edc:cname="B_INTEN" edc:nzwidth="0x1" edc:desc="Enable Begin Byte seen Interrupt"/>
            <edc:SFRFieldDef edc:cname="E_INTEN" edc:nzwidth="0x1" edc:desc="Enable End Byte seen Interrupt"/>
            <edc:SFRFieldDef edc:cname="F_INTEN" edc:nzwidth="0x1" edc:desc="Enable Finalized and result ready Interrupt"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON0" edc:cname="LT_MON7LM_CHN_CTRL" edc:nzwidth="0x20" edc:access="--------------------nnnn-----nnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0xF07" edc:_addr="0x40010300">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON0">
            <edc:SFRFieldDef edc:cname="GO" edc:nzwidth="0x1" edc:desc="GO: Run the Load Monitor for this channel"/>
            <edc:SFRFieldDef edc:cname="RST" edc:nzwidth="0x1" edc:desc="RST: Stop and Reset calculation for this channel when set to 1"/>
            <edc:SFRFieldDef edc:cname="RSF" edc:nzwidth="0x1" edc:desc="RSF: Reset just Result FIFO pointer when this bit is set to 1"/>
            <edc:AdjustPoint edc:offset="0x5"/>
            <edc:SFRFieldDef edc:cname="FPTR" edc:nzwidth="0x4" edc:desc="FPTR: Result FIFO pointer. In 32Bit. Ranges: 0 to 11 for SHA-384 result 0 to 7 for SHA-256 result"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON0" edc:cname="LT_MON7LM_BEGIN" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x40010304">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON0">
            <edc:SFRFieldDef edc:cname="BADDR" edc:nzwidth="0x1F" edc:desc="A byte address within the designated Flash, specifying the first byte of the load image."/>
            <edc:SFRFieldDef edc:cname="DV" edc:nzwidth="0x1" edc:desc="Flash Device number, applying to both Begin and End fields. 0 = CS0#, 1 = CS1#"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON0" edc:cname="LT_MON7LM_END" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x40010308">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON0">
            <edc:SFRFieldDef edc:cname="EADDR" edc:nzwidth="0x20" edc:desc="A byte address within the designated Flash, specifying the last byte of the load image."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON0" edc:cname="LT_MON7LM_COUNT" edc:nzwidth="0x20" edc:access="rrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrr" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x4001030C">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON0">
            <edc:SFRFieldDef edc:cname="CNT" edc:nzwidth="0x20" edc:desc="A Read-Only count of bytes processed."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON0" edc:cname="LT_MON7LM_DIGEST" edc:nzwidth="0x20" edc:access="rrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrr" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x40010310">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON0">
            <edc:SFRFieldDef edc:cname="DGST" edc:nzwidth="0x20" edc:desc="A Read-Only FIFO Portal to Hash digest result. 12 or 8 Dwords depending on algorithm."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON0" edc:cname="LTMON_CTRLSTS" edc:nzwidth="0x20" edc:access="-----------------------n----nnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x10F" edc:_addr="0x40010314">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON0">
            <edc:SFRFieldDef edc:cname="FIFO_MTY" edc:nzwidth="0x1" edc:desc="FIFO Empty"/>
            <edc:SFRFieldDef edc:cname="FIFO_FUL" edc:nzwidth="0x1" edc:desc="FIFO Full"/>
            <edc:SFRFieldDef edc:cname="FIFO_OVRF" edc:nzwidth="0x1" edc:desc="FIFO Overflow"/>
            <edc:SFRFieldDef edc:cname="FIFO_UDRF" edc:nzwidth="0x1" edc:desc="FIFO Underflow"/>
            <edc:AdjustPoint edc:offset="0x4"/>
            <edc:SFRFieldDef edc:cname="CLR_FIFO" edc:nzwidth="0x1" edc:desc="Clear FIFO "/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:AdjustPoint edc:offset="0xE8" edc:_addr="0x40010318"/>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON1" edc:cname="MNTR_CTRL" edc:nzwidth="0x20" edc:access="----------nnnnnn-------n------nn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x3F0103" edc:_addr="0x40010400">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON1">
            <edc:SFRFieldDef edc:cname="ACT" edc:nzwidth="0x1" edc:desc="Activate 1= Activate, 0= De-activate"/>
            <edc:SFRFieldDef edc:cname="LCK_ACT" edc:nzwidth="0x1" edc:desc="Lock Activate 1= Activate field Locked, 0= Activate field unlocked"/>
            <edc:AdjustPoint edc:offset="0x6"/>
            <edc:SFRFieldDef edc:cname="SFT_RST" edc:nzwidth="0x1" edc:desc="Soft Reset. This field is auto cleared by hardware. 1= Soft Reset SPI Monitor, 0 = No Effect"/>
            <edc:AdjustPoint edc:offset="0x7"/>
            <edc:SFRFieldDef edc:cname="TAP_SEL" edc:nzwidth="0x5" edc:desc="CPTR_CLK_TAP_SEL selects which 0.5ns delay tap to have the capture clock on.      00h = 0 ns delay (or if TAP_EN = 0).     01h = 0.5ns nom delay; +/- 50%     02h = 1.0ns      03h = 1.5ns     04h = 2.0ns     etc.     1Fh = 15.5ns"/>
            <edc:SFRFieldDef edc:cname="TAP_EN" edc:nzwidth="0x1" edc:desc="CPTR_CLK_TAP_EN enable the delay taps. It is recommended that a customer set the TAP_EN bit to 1, and the TAP_SEL field to 04h."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON1" edc:cname="CFG_STS" edc:nzwidth="0x20" edc:access="n-nnnnnnn-nnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0xBFBFFFFF" edc:_addr="0x40010404">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON1">
            <edc:SFRFieldDef edc:cname="IMD" edc:nzwidth="0x1" edc:desc="Flash Intervention Mode. 0 = Power-Off (POR), 1 = RESET# Pulse "/>
            <edc:SFRFieldDef edc:cname="RST2CSH" edc:nzwidth="0x5" edc:desc="RESET# to CS# High Delay. 2^n x 20us, 00h=20us, 1Fh= 1.3sec. IRQ triggers at this point also."/>
            <edc:SFRFieldDef edc:cname="QBD" edc:nzwidth="0x1" edc:desc="Quad Bus Disable, 1 = Half Bus Mode,  0 = IO[3:0] are all controlled by EQS."/>
            <edc:SFRFieldDef edc:cname="XQS" edc:nzwidth="0x1" edc:desc="Cross-Over Q-Switch status. (BMC-&gt;CPU). RO image of Interbus bit which as 1 overrides EQS bit at both SPI buses without changing their states."/>
            <edc:SFRFieldDef edc:cname="EQS" edc:nzwidth="0x1" edc:desc="Enable Q-Switch (Isolator) to Host. 0 = Disable, 1 = Enable."/>
            <edc:SFRFieldDef edc:cname="CSRT" edc:nzwidth="0x3" edc:desc="Chip Select Routing.      000 = Both CSn#_In pass directly to CSn# Out, both enabled out.     001 = CS1n_In passes to CS1# Output, but CS0# Output is disabled (floats high).     010 = CS0n_In passes to CS0# Output, but CS1# Output is disabled (floats high).     100 = Swap CS1#/CS0#_In to CS0#/CS1# Out respectively, both enabled out.     101 = CS0n_In passes to CS1# Out, and CS0# Output is disabled (floats high).     110 = CS1n_In passes to CS0# Out, and CS1# Output is disabled (floats high).     x11 = CS0n/CS1n Outputs are both disabled (floating high) regardless of inputs."/>
            <edc:SFRFieldDef edc:cname="F0F" edc:nzwidth="0x1" edc:desc="Enable following of Address Mode. (SPI Snooping) for each Flash. 0=Disable, 1=Enable"/>
            <edc:SFRFieldDef edc:cname="F1F" edc:nzwidth="0x1" edc:desc="Enable following of Address Mode. (SPI Snooping) for each Flash. 0=Disable, 1=Enable"/>
            <edc:SFRFieldDef edc:cname="F0A" edc:nzwidth="0x1" edc:desc="Set 3B/4B Address Mode for Flash 0. 0=3B Address Mode, 1=4B Address Mode"/>
            <edc:SFRFieldDef edc:cname="F1A" edc:nzwidth="0x1" edc:desc="Set 3B/4B Address Mode for Flash 1. 0=3B Address Mode, 1=4B Address Mode"/>
            <edc:SFRFieldDef edc:cname="F0SIZE" edc:nzwidth="0x5" edc:desc="Flash 0 Size. Flash sizes are expressed in bytes as a power of 2, matching a Flash Get-ID convention.     For the most common cases:      17h = 23d =&gt; 2^23 = 8MByte     18h = 24d =&gt; 2^24 = 16MByte     19h = 25d =&gt; 2^25 = 32MByte     1Ah = 26d =&gt; 2^26 = 64MByte"/>
            <edc:SFRFieldDef edc:cname="E0W" edc:nzwidth="0x1" edc:desc="Enable Wrap Detection. 0=Disable, 1=Enable."/>
            <edc:AdjustPoint edc:offset="0x1"/>
            <edc:SFRFieldDef edc:cname="F0P" edc:nzwidth="0x1" edc:desc="Flash 0 Present. 0=Not Present, 1=Present"/>
            <edc:SFRFieldDef edc:cname="F1SIZE" edc:nzwidth="0x5" edc:desc="Flash 1 Size. Flash sizes are expressed in bytes as a power of 2, matching a Flash Get-ID convention.     For the most common cases:      17h = 23d =&gt; 2^23 = 8MByte     18h = 24d =&gt; 2^24 = 16MByte     19h = 25d =&gt; 2^25 = 32MByte     1Ah = 26d =&gt; 2^26 = 64MByte"/>
            <edc:SFRFieldDef edc:cname="E1W" edc:nzwidth="0x1" edc:desc="Enable Wrap Detection. 0=Disable, 1=Enable"/>
            <edc:AdjustPoint edc:offset="0x1"/>
            <edc:SFRFieldDef edc:cname="F1P" edc:nzwidth="0x1" edc:desc="Flash 1 Present. 0=Not Present, 1=Present"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON1" edc:cname="SPICFG2" edc:nzwidth="0x20" edc:access="--------------nn--nn--nn------nn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x33303" edc:_addr="0x40010408">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON1">
            <edc:SFRFieldDef edc:cname="HRM" edc:nzwidth="0x1" edc:desc="Host Reset Mode. 0 = APn_RESET#, 1 = Pin."/>
            <edc:SFRFieldDef edc:cname="HRL" edc:nzwidth="0x1" edc:desc="HRM Bit Lock. 0 = Unlocked, 1 = Locked."/>
            <edc:AdjustPoint edc:offset="0x6"/>
            <edc:SFRFieldDef edc:cname="DIV" edc:nzwidth="0x1" edc:desc="Disable Inter Vention. 1 = IRQ-only Mode."/>
            <edc:SFRFieldDef edc:cname="DIL" edc:nzwidth="0x1" edc:desc="DIV Bit Lock. 0 = Unlocked, 1 = Locked."/>
            <edc:AdjustPoint edc:offset="0x2"/>
            <edc:SFRFieldDef edc:cname="RIV" edc:nzwidth="0x1" edc:desc="Special Region InterVention Mode. If DIV=1 then RIV is ignored.     If DIV=0 and RIV=1 then: Reads that are forbidden by the Runtime Region register set     are only cancelled by gating off CSn# for that SPI command, and setting the IRQ.     No system shutdown results, and subsequent legal Reads are allowed."/>
            <edc:SFRFieldDef edc:cname="RIL" edc:nzwidth="0x1" edc:desc="RIV Bit Lock. 0 = Unlocked, 1 = Locked."/>
            <edc:AdjustPoint edc:offset="0x2"/>
            <edc:SFRFieldDef edc:cname="ALG" edc:nzwidth="0x1" edc:desc="Hash Algorithm Mode. 0 = SHA-384, 1 = Reserved "/>
            <edc:SFRFieldDef edc:cname="ALL" edc:nzwidth="0x1" edc:desc="ALG Bit Lock. 0 = Unlocked, 1 = Locked."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON1" edc:cname="VIOCTRLSTS" edc:nzwidth="0x20" edc:access="------------------nnnnnn--nnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x3F3F" edc:_addr="0x4001040C">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON1">
            <edc:SFRFieldDef edc:cname="OP" edc:nzwidth="0x1" edc:desc="Opcode Violation"/>
            <edc:SFRFieldDef edc:cname="MC" edc:nzwidth="0x1" edc:desc="Data Mismatch Violation"/>
            <edc:SFRFieldDef edc:cname="OB" edc:nzwidth="0x1" edc:desc="Out of Bounds. Outside all Runtime Regions"/>
            <edc:SFRFieldDef edc:cname="RG" edc:nzwidth="0x1" edc:desc="Runtime Region R/W Permission Violation"/>
            <edc:SFRFieldDef edc:cname="MT" edc:nzwidth="0x1" edc:desc="Timeout in Match Phase"/>
            <edc:SFRFieldDef edc:cname="AW" edc:nzwidth="0x1" edc:desc="Address Wrap within a Flash device."/>
            <edc:AdjustPoint edc:offset="0x2"/>
            <edc:SFRFieldDef edc:cname="EOP" edc:nzwidth="0x1" edc:desc="Enable Opcode Violation Interrupt. 0 = Disable, 1 = Enable"/>
            <edc:SFRFieldDef edc:cname="EMC" edc:nzwidth="0x1" edc:desc="Enable Data Mismatch Violation Interrupt. 0 = Disable, 1 = Enable"/>
            <edc:SFRFieldDef edc:cname="EOB" edc:nzwidth="0x1" edc:desc="Enable Out of Bounds Interrupt. 0 = Disable, 1 = Enable"/>
            <edc:SFRFieldDef edc:cname="ERG" edc:nzwidth="0x1" edc:desc="Enable Runtime Region R/W Permission Violation Interrupt. 0 = Disable, 1 = Enable"/>
            <edc:SFRFieldDef edc:cname="EMT" edc:nzwidth="0x1" edc:desc="Enable Timeout in Match Phase Interrupt. 0 = Disable, 1 = Enable"/>
            <edc:SFRFieldDef edc:cname="EAW" edc:nzwidth="0x1" edc:desc="Enable Address Wrap within a Flash device Interrupt. 0 = Disable, 1 = Enable"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON1" edc:cname="IVN_STS" edc:nzwidth="0x8" edc:access="----rrrr" edc:por="00000000" edc:mclr="00000000" edc:impl="0xF" edc:_addr="0x40010410">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON1">
            <edc:SFRFieldDef edc:cname="FCS" edc:nzwidth="0x1" edc:desc="Flash Chip Selects forced high and bus forced low."/>
            <edc:SFRFieldDef edc:cname="FPO" edc:nzwidth="0x1" edc:desc="Flash Power or RESET# Activated."/>
            <edc:SFRFieldDef edc:cname="HRS" edc:nzwidth="0x1" edc:desc="Host held in Reset"/>
            <edc:SFRFieldDef edc:cname="HIS" edc:nzwidth="0x1" edc:desc="Host held Isolated"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON1" edc:cname="IVN_REC" edc:nzwidth="0x8" edc:access="----wwww" edc:por="00000000" edc:mclr="00000000" edc:impl="0xF" edc:_addr="0x40010411">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON1">
            <edc:SFRFieldDef edc:cname="FCC" edc:nzwidth="0x1" edc:desc="Write 1 to clear FCS Flash Chip Selects forced high and bus forced low."/>
            <edc:SFRFieldDef edc:cname="FPC" edc:nzwidth="0x1" edc:desc="Write 1 to clear FPO Flash Power or RESET# Activated."/>
            <edc:SFRFieldDef edc:cname="HRC" edc:nzwidth="0x1" edc:desc="Write 1 to clear HRS Host held in Reset"/>
            <edc:SFRFieldDef edc:cname="HIC" edc:nzwidth="0x1" edc:desc="Write 1 to clear HIS Host held Isolated"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:AdjustPoint edc:offset="0x2" edc:_addr="0x40010412"/>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON1" edc:cname="VIO_STS" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnn-nn-n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0xFFFFFFED" edc:_addr="0x40010414">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON1">
            <edc:SFRFieldDef edc:cname="OP" edc:nzwidth="0x1" edc:desc="Opcode Violation"/>
            <edc:AdjustPoint edc:offset="0x1"/>
            <edc:SFRFieldDef edc:cname="ROB" edc:nzwidth="0x1" edc:desc="Region Failure, Out of Bounds"/>
            <edc:SFRFieldDef edc:cname="REG" edc:nzwidth="0x1" edc:desc="Runtime Region Violation"/>
            <edc:AdjustPoint edc:offset="0x1"/>
            <edc:SFRFieldDef edc:cname="AWP" edc:nzwidth="0x1" edc:desc="Address Wrap"/>
            <edc:SFRFieldDef edc:cname="DV" edc:nzwidth="0x1" edc:desc="Device Number"/>
            <edc:SFRFieldDef edc:cname="REGION" edc:nzwidth="0x5" edc:desc="Region Number"/>
            <edc:SFRFieldDef edc:cname="RD" edc:nzwidth="0x1" edc:desc="Killed as a Read"/>
            <edc:SFRFieldDef edc:cname="PE" edc:nzwidth="0x1" edc:desc="Killed as a Program or Erase"/>
            <edc:SFRFieldDef edc:cname="AM" edc:nzwidth="0x1" edc:desc="Flash Address Mode"/>
            <edc:SFRFieldDef edc:cname="CLR" edc:nzwidth="0x1" edc:desc="Clear Register RW1C. This bit is auto clearing"/>
            <edc:SFRFieldDef edc:cname="OPCOD" edc:nzwidth="0x8" edc:desc="Flash Opcode"/>
            <edc:SFRFieldDef edc:cname="DAT" edc:nzwidth="0x8" edc:desc="SPI Data Byte"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON1" edc:cname="ERR_ADDR" edc:nzwidth="0x20" edc:access="rrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrr" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x40010418">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON1">
            <edc:SFRFieldDef edc:cname="ADDR" edc:nzwidth="0x20" edc:desc="Byte address at which the error occurred, within the designated Flash"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:AdjustPoint edc:offset="0x4" edc:_addr="0x4001041C"/>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON1" edc:cname="FLASH_SET0OP_PRMT0" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x40010420">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON1">
            <edc:SFRFieldDef edc:cname="PRMT" edc:nzwidth="0x20" edc:desc="Permit. Each array organized into 8 32-bit registers set per Flash device.    1 = Permit, and if not recognized then ignore.     0 = Kill immediately upon seeing this opcode."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON1" edc:cname="FLASH_SET0OP_PRMT1" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x40010424">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON1">
            <edc:SFRFieldDef edc:cname="PRMT" edc:nzwidth="0x20" edc:desc="Permit. Each array organized into 8 32-bit registers set per Flash device.    1 = Permit, and if not recognized then ignore.     0 = Kill immediately upon seeing this opcode."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON1" edc:cname="FLASH_SET0OP_PRMT2" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x40010428">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON1">
            <edc:SFRFieldDef edc:cname="PRMT" edc:nzwidth="0x20" edc:desc="Permit. Each array organized into 8 32-bit registers set per Flash device.    1 = Permit, and if not recognized then ignore.     0 = Kill immediately upon seeing this opcode."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON1" edc:cname="FLASH_SET0OP_PRMT3" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x4001042C">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON1">
            <edc:SFRFieldDef edc:cname="PRMT" edc:nzwidth="0x20" edc:desc="Permit. Each array organized into 8 32-bit registers set per Flash device.    1 = Permit, and if not recognized then ignore.     0 = Kill immediately upon seeing this opcode."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON1" edc:cname="FLASH_SET0OP_PRMT4" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x40010430">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON1">
            <edc:SFRFieldDef edc:cname="PRMT" edc:nzwidth="0x20" edc:desc="Permit. Each array organized into 8 32-bit registers set per Flash device.    1 = Permit, and if not recognized then ignore.     0 = Kill immediately upon seeing this opcode."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON1" edc:cname="FLASH_SET0OP_PRMT5" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x40010434">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON1">
            <edc:SFRFieldDef edc:cname="PRMT" edc:nzwidth="0x20" edc:desc="Permit. Each array organized into 8 32-bit registers set per Flash device.    1 = Permit, and if not recognized then ignore.     0 = Kill immediately upon seeing this opcode."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON1" edc:cname="FLASH_SET0OP_PRMT6" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x40010438">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON1">
            <edc:SFRFieldDef edc:cname="PRMT" edc:nzwidth="0x20" edc:desc="Permit. Each array organized into 8 32-bit registers set per Flash device.    1 = Permit, and if not recognized then ignore.     0 = Kill immediately upon seeing this opcode."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON1" edc:cname="FLASH_SET0OP_PRMT7" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x4001043C">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON1">
            <edc:SFRFieldDef edc:cname="PRMT" edc:nzwidth="0x20" edc:desc="Permit. Each array organized into 8 32-bit registers set per Flash device.    1 = Permit, and if not recognized then ignore.     0 = Kill immediately upon seeing this opcode."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON1" edc:cname="FLASH_SET0OP_KILLMD0" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x40010440">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON1">
            <edc:SFRFieldDef edc:cname="KILL" edc:nzwidth="0x20" edc:desc="Kill. Each array organized into 8 32-bit registers set per Flash device.    1 = If Killed, then kill as a Write: Holding CS# low.    0 = If Killed, then kill as a Read: Force CS# high first."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON1" edc:cname="FLASH_SET0OP_KILLMD1" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x40010444">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON1">
            <edc:SFRFieldDef edc:cname="KILL" edc:nzwidth="0x20" edc:desc="Kill. Each array organized into 8 32-bit registers set per Flash device.    1 = If Killed, then kill as a Write: Holding CS# low.    0 = If Killed, then kill as a Read: Force CS# high first."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON1" edc:cname="FLASH_SET0OP_KILLMD2" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x40010448">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON1">
            <edc:SFRFieldDef edc:cname="KILL" edc:nzwidth="0x20" edc:desc="Kill. Each array organized into 8 32-bit registers set per Flash device.    1 = If Killed, then kill as a Write: Holding CS# low.    0 = If Killed, then kill as a Read: Force CS# high first."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON1" edc:cname="FLASH_SET0OP_KILLMD3" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x4001044C">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON1">
            <edc:SFRFieldDef edc:cname="KILL" edc:nzwidth="0x20" edc:desc="Kill. Each array organized into 8 32-bit registers set per Flash device.    1 = If Killed, then kill as a Write: Holding CS# low.    0 = If Killed, then kill as a Read: Force CS# high first."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON1" edc:cname="FLASH_SET0OP_KILLMD4" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x40010450">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON1">
            <edc:SFRFieldDef edc:cname="KILL" edc:nzwidth="0x20" edc:desc="Kill. Each array organized into 8 32-bit registers set per Flash device.    1 = If Killed, then kill as a Write: Holding CS# low.    0 = If Killed, then kill as a Read: Force CS# high first."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON1" edc:cname="FLASH_SET0OP_KILLMD5" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x40010454">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON1">
            <edc:SFRFieldDef edc:cname="KILL" edc:nzwidth="0x20" edc:desc="Kill. Each array organized into 8 32-bit registers set per Flash device.    1 = If Killed, then kill as a Write: Holding CS# low.    0 = If Killed, then kill as a Read: Force CS# high first."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON1" edc:cname="FLASH_SET0OP_KILLMD6" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x40010458">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON1">
            <edc:SFRFieldDef edc:cname="KILL" edc:nzwidth="0x20" edc:desc="Kill. Each array organized into 8 32-bit registers set per Flash device.    1 = If Killed, then kill as a Write: Holding CS# low.    0 = If Killed, then kill as a Read: Force CS# high first."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON1" edc:cname="FLASH_SET0OP_KILLMD7" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x4001045C">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON1">
            <edc:SFRFieldDef edc:cname="KILL" edc:nzwidth="0x20" edc:desc="Kill. Each array organized into 8 32-bit registers set per Flash device.    1 = If Killed, then kill as a Write: Holding CS# low.    0 = If Killed, then kill as a Read: Force CS# high first."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON1" edc:cname="FLASH_SET0OP_WPROT0" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x40010460">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON1">
            <edc:SFRFieldDef edc:cname="WPROT" edc:nzwidth="0x20" edc:desc="Write Protect. Each array organized into 8 32-bit registers set per Flash device.    1 = Make the corresponding bits RO in Permit and Killmd regs.    0 = Corresponding bits are R/W."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON1" edc:cname="FLASH_SET0OP_WPROT1" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x40010464">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON1">
            <edc:SFRFieldDef edc:cname="WPROT" edc:nzwidth="0x20" edc:desc="Write Protect. Each array organized into 8 32-bit registers set per Flash device.    1 = Make the corresponding bits RO in Permit and Killmd regs.    0 = Corresponding bits are R/W."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON1" edc:cname="FLASH_SET0OP_WPROT2" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x40010468">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON1">
            <edc:SFRFieldDef edc:cname="WPROT" edc:nzwidth="0x20" edc:desc="Write Protect. Each array organized into 8 32-bit registers set per Flash device.    1 = Make the corresponding bits RO in Permit and Killmd regs.    0 = Corresponding bits are R/W."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON1" edc:cname="FLASH_SET0OP_WPROT3" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x4001046C">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON1">
            <edc:SFRFieldDef edc:cname="WPROT" edc:nzwidth="0x20" edc:desc="Write Protect. Each array organized into 8 32-bit registers set per Flash device.    1 = Make the corresponding bits RO in Permit and Killmd regs.    0 = Corresponding bits are R/W."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON1" edc:cname="FLASH_SET0OP_WPROT4" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x40010470">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON1">
            <edc:SFRFieldDef edc:cname="WPROT" edc:nzwidth="0x20" edc:desc="Write Protect. Each array organized into 8 32-bit registers set per Flash device.    1 = Make the corresponding bits RO in Permit and Killmd regs.    0 = Corresponding bits are R/W."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON1" edc:cname="FLASH_SET0OP_WPROT5" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x40010474">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON1">
            <edc:SFRFieldDef edc:cname="WPROT" edc:nzwidth="0x20" edc:desc="Write Protect. Each array organized into 8 32-bit registers set per Flash device.    1 = Make the corresponding bits RO in Permit and Killmd regs.    0 = Corresponding bits are R/W."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON1" edc:cname="FLASH_SET0OP_WPROT6" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x40010478">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON1">
            <edc:SFRFieldDef edc:cname="WPROT" edc:nzwidth="0x20" edc:desc="Write Protect. Each array organized into 8 32-bit registers set per Flash device.    1 = Make the corresponding bits RO in Permit and Killmd regs.    0 = Corresponding bits are R/W."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON1" edc:cname="FLASH_SET0OP_WPROT7" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x4001047C">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON1">
            <edc:SFRFieldDef edc:cname="WPROT" edc:nzwidth="0x20" edc:desc="Write Protect. Each array organized into 8 32-bit registers set per Flash device.    1 = Make the corresponding bits RO in Permit and Killmd regs.    0 = Corresponding bits are R/W."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON1" edc:cname="FLASH_SET0OP_LOCK0" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x40010480">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON1">
            <edc:SFRFieldDef edc:cname="LOCK" edc:nzwidth="0x20" edc:desc="Lock. Each array organized into 8 32-bit registers set per Flash device.    1 = Make the corresponding bits RO in Permit and Killmd regs, overriding the Wprot register. Any 1 bit in this register is locked.    0 = Corresponding bits are R/W or RO, as determined by the Wprot register."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON1" edc:cname="FLASH_SET0OP_LOCK1" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x40010484">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON1">
            <edc:SFRFieldDef edc:cname="LOCK" edc:nzwidth="0x20" edc:desc="Lock. Each array organized into 8 32-bit registers set per Flash device.    1 = Make the corresponding bits RO in Permit and Killmd regs, overriding the Wprot register. Any 1 bit in this register is locked.    0 = Corresponding bits are R/W or RO, as determined by the Wprot register."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON1" edc:cname="FLASH_SET0OP_LOCK2" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x40010488">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON1">
            <edc:SFRFieldDef edc:cname="LOCK" edc:nzwidth="0x20" edc:desc="Lock. Each array organized into 8 32-bit registers set per Flash device.    1 = Make the corresponding bits RO in Permit and Killmd regs, overriding the Wprot register. Any 1 bit in this register is locked.    0 = Corresponding bits are R/W or RO, as determined by the Wprot register."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON1" edc:cname="FLASH_SET0OP_LOCK3" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x4001048C">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON1">
            <edc:SFRFieldDef edc:cname="LOCK" edc:nzwidth="0x20" edc:desc="Lock. Each array organized into 8 32-bit registers set per Flash device.    1 = Make the corresponding bits RO in Permit and Killmd regs, overriding the Wprot register. Any 1 bit in this register is locked.    0 = Corresponding bits are R/W or RO, as determined by the Wprot register."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON1" edc:cname="FLASH_SET0OP_LOCK4" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x40010490">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON1">
            <edc:SFRFieldDef edc:cname="LOCK" edc:nzwidth="0x20" edc:desc="Lock. Each array organized into 8 32-bit registers set per Flash device.    1 = Make the corresponding bits RO in Permit and Killmd regs, overriding the Wprot register. Any 1 bit in this register is locked.    0 = Corresponding bits are R/W or RO, as determined by the Wprot register."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON1" edc:cname="FLASH_SET0OP_LOCK5" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x40010494">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON1">
            <edc:SFRFieldDef edc:cname="LOCK" edc:nzwidth="0x20" edc:desc="Lock. Each array organized into 8 32-bit registers set per Flash device.    1 = Make the corresponding bits RO in Permit and Killmd regs, overriding the Wprot register. Any 1 bit in this register is locked.    0 = Corresponding bits are R/W or RO, as determined by the Wprot register."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON1" edc:cname="FLASH_SET0OP_LOCK6" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x40010498">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON1">
            <edc:SFRFieldDef edc:cname="LOCK" edc:nzwidth="0x20" edc:desc="Lock. Each array organized into 8 32-bit registers set per Flash device.    1 = Make the corresponding bits RO in Permit and Killmd regs, overriding the Wprot register. Any 1 bit in this register is locked.    0 = Corresponding bits are R/W or RO, as determined by the Wprot register."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON1" edc:cname="FLASH_SET0OP_LOCK7" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x4001049C">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON1">
            <edc:SFRFieldDef edc:cname="LOCK" edc:nzwidth="0x20" edc:desc="Lock. Each array organized into 8 32-bit registers set per Flash device.    1 = Make the corresponding bits RO in Permit and Killmd regs, overriding the Wprot register. Any 1 bit in this register is locked.    0 = Corresponding bits are R/W or RO, as determined by the Wprot register."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON1" edc:cname="FLASH_SET1OP_PRMT0" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x400104A0">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON1">
            <edc:SFRFieldDef edc:cname="PRMT" edc:nzwidth="0x20" edc:desc="Permit. Each array organized into 8 32-bit registers set per Flash device.    1 = Permit, and if not recognized then ignore.     0 = Kill immediately upon seeing this opcode."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON1" edc:cname="FLASH_SET1OP_PRMT1" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x400104A4">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON1">
            <edc:SFRFieldDef edc:cname="PRMT" edc:nzwidth="0x20" edc:desc="Permit. Each array organized into 8 32-bit registers set per Flash device.    1 = Permit, and if not recognized then ignore.     0 = Kill immediately upon seeing this opcode."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON1" edc:cname="FLASH_SET1OP_PRMT2" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x400104A8">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON1">
            <edc:SFRFieldDef edc:cname="PRMT" edc:nzwidth="0x20" edc:desc="Permit. Each array organized into 8 32-bit registers set per Flash device.    1 = Permit, and if not recognized then ignore.     0 = Kill immediately upon seeing this opcode."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON1" edc:cname="FLASH_SET1OP_PRMT3" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x400104AC">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON1">
            <edc:SFRFieldDef edc:cname="PRMT" edc:nzwidth="0x20" edc:desc="Permit. Each array organized into 8 32-bit registers set per Flash device.    1 = Permit, and if not recognized then ignore.     0 = Kill immediately upon seeing this opcode."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON1" edc:cname="FLASH_SET1OP_PRMT4" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x400104B0">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON1">
            <edc:SFRFieldDef edc:cname="PRMT" edc:nzwidth="0x20" edc:desc="Permit. Each array organized into 8 32-bit registers set per Flash device.    1 = Permit, and if not recognized then ignore.     0 = Kill immediately upon seeing this opcode."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON1" edc:cname="FLASH_SET1OP_PRMT5" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x400104B4">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON1">
            <edc:SFRFieldDef edc:cname="PRMT" edc:nzwidth="0x20" edc:desc="Permit. Each array organized into 8 32-bit registers set per Flash device.    1 = Permit, and if not recognized then ignore.     0 = Kill immediately upon seeing this opcode."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON1" edc:cname="FLASH_SET1OP_PRMT6" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x400104B8">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON1">
            <edc:SFRFieldDef edc:cname="PRMT" edc:nzwidth="0x20" edc:desc="Permit. Each array organized into 8 32-bit registers set per Flash device.    1 = Permit, and if not recognized then ignore.     0 = Kill immediately upon seeing this opcode."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON1" edc:cname="FLASH_SET1OP_PRMT7" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x400104BC">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON1">
            <edc:SFRFieldDef edc:cname="PRMT" edc:nzwidth="0x20" edc:desc="Permit. Each array organized into 8 32-bit registers set per Flash device.    1 = Permit, and if not recognized then ignore.     0 = Kill immediately upon seeing this opcode."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON1" edc:cname="FLASH_SET1OP_KILLMD0" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x400104C0">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON1">
            <edc:SFRFieldDef edc:cname="KILL" edc:nzwidth="0x20" edc:desc="Kill. Each array organized into 8 32-bit registers set per Flash device.    1 = If Killed, then kill as a Write: Holding CS# low.    0 = If Killed, then kill as a Read: Force CS# high first."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON1" edc:cname="FLASH_SET1OP_KILLMD1" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x400104C4">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON1">
            <edc:SFRFieldDef edc:cname="KILL" edc:nzwidth="0x20" edc:desc="Kill. Each array organized into 8 32-bit registers set per Flash device.    1 = If Killed, then kill as a Write: Holding CS# low.    0 = If Killed, then kill as a Read: Force CS# high first."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON1" edc:cname="FLASH_SET1OP_KILLMD2" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x400104C8">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON1">
            <edc:SFRFieldDef edc:cname="KILL" edc:nzwidth="0x20" edc:desc="Kill. Each array organized into 8 32-bit registers set per Flash device.    1 = If Killed, then kill as a Write: Holding CS# low.    0 = If Killed, then kill as a Read: Force CS# high first."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON1" edc:cname="FLASH_SET1OP_KILLMD3" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x400104CC">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON1">
            <edc:SFRFieldDef edc:cname="KILL" edc:nzwidth="0x20" edc:desc="Kill. Each array organized into 8 32-bit registers set per Flash device.    1 = If Killed, then kill as a Write: Holding CS# low.    0 = If Killed, then kill as a Read: Force CS# high first."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON1" edc:cname="FLASH_SET1OP_KILLMD4" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x400104D0">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON1">
            <edc:SFRFieldDef edc:cname="KILL" edc:nzwidth="0x20" edc:desc="Kill. Each array organized into 8 32-bit registers set per Flash device.    1 = If Killed, then kill as a Write: Holding CS# low.    0 = If Killed, then kill as a Read: Force CS# high first."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON1" edc:cname="FLASH_SET1OP_KILLMD5" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x400104D4">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON1">
            <edc:SFRFieldDef edc:cname="KILL" edc:nzwidth="0x20" edc:desc="Kill. Each array organized into 8 32-bit registers set per Flash device.    1 = If Killed, then kill as a Write: Holding CS# low.    0 = If Killed, then kill as a Read: Force CS# high first."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON1" edc:cname="FLASH_SET1OP_KILLMD6" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x400104D8">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON1">
            <edc:SFRFieldDef edc:cname="KILL" edc:nzwidth="0x20" edc:desc="Kill. Each array organized into 8 32-bit registers set per Flash device.    1 = If Killed, then kill as a Write: Holding CS# low.    0 = If Killed, then kill as a Read: Force CS# high first."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON1" edc:cname="FLASH_SET1OP_KILLMD7" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x400104DC">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON1">
            <edc:SFRFieldDef edc:cname="KILL" edc:nzwidth="0x20" edc:desc="Kill. Each array organized into 8 32-bit registers set per Flash device.    1 = If Killed, then kill as a Write: Holding CS# low.    0 = If Killed, then kill as a Read: Force CS# high first."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON1" edc:cname="FLASH_SET1OP_WPROT0" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x400104E0">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON1">
            <edc:SFRFieldDef edc:cname="WPROT" edc:nzwidth="0x20" edc:desc="Write Protect. Each array organized into 8 32-bit registers set per Flash device.    1 = Make the corresponding bits RO in Permit and Killmd regs.    0 = Corresponding bits are R/W."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON1" edc:cname="FLASH_SET1OP_WPROT1" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x400104E4">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON1">
            <edc:SFRFieldDef edc:cname="WPROT" edc:nzwidth="0x20" edc:desc="Write Protect. Each array organized into 8 32-bit registers set per Flash device.    1 = Make the corresponding bits RO in Permit and Killmd regs.    0 = Corresponding bits are R/W."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON1" edc:cname="FLASH_SET1OP_WPROT2" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x400104E8">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON1">
            <edc:SFRFieldDef edc:cname="WPROT" edc:nzwidth="0x20" edc:desc="Write Protect. Each array organized into 8 32-bit registers set per Flash device.    1 = Make the corresponding bits RO in Permit and Killmd regs.    0 = Corresponding bits are R/W."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON1" edc:cname="FLASH_SET1OP_WPROT3" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x400104EC">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON1">
            <edc:SFRFieldDef edc:cname="WPROT" edc:nzwidth="0x20" edc:desc="Write Protect. Each array organized into 8 32-bit registers set per Flash device.    1 = Make the corresponding bits RO in Permit and Killmd regs.    0 = Corresponding bits are R/W."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON1" edc:cname="FLASH_SET1OP_WPROT4" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x400104F0">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON1">
            <edc:SFRFieldDef edc:cname="WPROT" edc:nzwidth="0x20" edc:desc="Write Protect. Each array organized into 8 32-bit registers set per Flash device.    1 = Make the corresponding bits RO in Permit and Killmd regs.    0 = Corresponding bits are R/W."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON1" edc:cname="FLASH_SET1OP_WPROT5" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x400104F4">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON1">
            <edc:SFRFieldDef edc:cname="WPROT" edc:nzwidth="0x20" edc:desc="Write Protect. Each array organized into 8 32-bit registers set per Flash device.    1 = Make the corresponding bits RO in Permit and Killmd regs.    0 = Corresponding bits are R/W."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON1" edc:cname="FLASH_SET1OP_WPROT6" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x400104F8">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON1">
            <edc:SFRFieldDef edc:cname="WPROT" edc:nzwidth="0x20" edc:desc="Write Protect. Each array organized into 8 32-bit registers set per Flash device.    1 = Make the corresponding bits RO in Permit and Killmd regs.    0 = Corresponding bits are R/W."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON1" edc:cname="FLASH_SET1OP_WPROT7" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x400104FC">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON1">
            <edc:SFRFieldDef edc:cname="WPROT" edc:nzwidth="0x20" edc:desc="Write Protect. Each array organized into 8 32-bit registers set per Flash device.    1 = Make the corresponding bits RO in Permit and Killmd regs.    0 = Corresponding bits are R/W."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON1" edc:cname="FLASH_SET1OP_LOCK0" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x40010500">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON1">
            <edc:SFRFieldDef edc:cname="LOCK" edc:nzwidth="0x20" edc:desc="Lock. Each array organized into 8 32-bit registers set per Flash device.    1 = Make the corresponding bits RO in Permit and Killmd regs, overriding the Wprot register. Any 1 bit in this register is locked.    0 = Corresponding bits are R/W or RO, as determined by the Wprot register."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON1" edc:cname="FLASH_SET1OP_LOCK1" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x40010504">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON1">
            <edc:SFRFieldDef edc:cname="LOCK" edc:nzwidth="0x20" edc:desc="Lock. Each array organized into 8 32-bit registers set per Flash device.    1 = Make the corresponding bits RO in Permit and Killmd regs, overriding the Wprot register. Any 1 bit in this register is locked.    0 = Corresponding bits are R/W or RO, as determined by the Wprot register."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON1" edc:cname="FLASH_SET1OP_LOCK2" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x40010508">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON1">
            <edc:SFRFieldDef edc:cname="LOCK" edc:nzwidth="0x20" edc:desc="Lock. Each array organized into 8 32-bit registers set per Flash device.    1 = Make the corresponding bits RO in Permit and Killmd regs, overriding the Wprot register. Any 1 bit in this register is locked.    0 = Corresponding bits are R/W or RO, as determined by the Wprot register."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON1" edc:cname="FLASH_SET1OP_LOCK3" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x4001050C">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON1">
            <edc:SFRFieldDef edc:cname="LOCK" edc:nzwidth="0x20" edc:desc="Lock. Each array organized into 8 32-bit registers set per Flash device.    1 = Make the corresponding bits RO in Permit and Killmd regs, overriding the Wprot register. Any 1 bit in this register is locked.    0 = Corresponding bits are R/W or RO, as determined by the Wprot register."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON1" edc:cname="FLASH_SET1OP_LOCK4" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x40010510">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON1">
            <edc:SFRFieldDef edc:cname="LOCK" edc:nzwidth="0x20" edc:desc="Lock. Each array organized into 8 32-bit registers set per Flash device.    1 = Make the corresponding bits RO in Permit and Killmd regs, overriding the Wprot register. Any 1 bit in this register is locked.    0 = Corresponding bits are R/W or RO, as determined by the Wprot register."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON1" edc:cname="FLASH_SET1OP_LOCK5" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x40010514">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON1">
            <edc:SFRFieldDef edc:cname="LOCK" edc:nzwidth="0x20" edc:desc="Lock. Each array organized into 8 32-bit registers set per Flash device.    1 = Make the corresponding bits RO in Permit and Killmd regs, overriding the Wprot register. Any 1 bit in this register is locked.    0 = Corresponding bits are R/W or RO, as determined by the Wprot register."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON1" edc:cname="FLASH_SET1OP_LOCK6" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x40010518">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON1">
            <edc:SFRFieldDef edc:cname="LOCK" edc:nzwidth="0x20" edc:desc="Lock. Each array organized into 8 32-bit registers set per Flash device.    1 = Make the corresponding bits RO in Permit and Killmd regs, overriding the Wprot register. Any 1 bit in this register is locked.    0 = Corresponding bits are R/W or RO, as determined by the Wprot register."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON1" edc:cname="FLASH_SET1OP_LOCK7" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x4001051C">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON1">
            <edc:SFRFieldDef edc:cname="LOCK" edc:nzwidth="0x20" edc:desc="Lock. Each array organized into 8 32-bit registers set per Flash device.    1 = Make the corresponding bits RO in Permit and Killmd regs, overriding the Wprot register. Any 1 bit in this register is locked.    0 = Corresponding bits are R/W or RO, as determined by the Wprot register."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON1" edc:cname="RN_TM0RT_START" edc:nzwidth="0x20" edc:access="n-nnn-nn----nnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0xBB0FFFFF" edc:_addr="0x40010520">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON1">
            <edc:SFRFieldDef edc:cname="STRT" edc:nzwidth="0x14" edc:desc="A Flash address shifted by 12 (4K byte units). Bottom 12 address bits are 000h"/>
            <edc:AdjustPoint edc:offset="0x4"/>
            <edc:SFRFieldDef edc:cname="E32" edc:nzwidth="0x1" edc:desc="Enable 32KByte Erase opcode for this region. 0 = Disable, 1 = Enable"/>
            <edc:SFRFieldDef edc:cname="E64" edc:nzwidth="0x1" edc:desc="Enable 64KByte Erase opcode for this region. 0 = Disable, 1 = Enable"/>
            <edc:AdjustPoint edc:offset="0x1"/>
            <edc:SFRFieldDef edc:cname="DV" edc:nzwidth="0x1" edc:desc="Flash Device 0 = CS0#, 1 = CS1#."/>
            <edc:SFRFieldDef edc:cname="RD" edc:nzwidth="0x1" edc:desc="Read Allowed for Region. 0 = No, 1 = Yes"/>
            <edc:SFRFieldDef edc:cname="WR" edc:nzwidth="0x1" edc:desc="Write Allowed for Region. 0 = No, 1 = Yes"/>
            <edc:AdjustPoint edc:offset="0x1"/>
            <edc:SFRFieldDef edc:cname="EN" edc:nzwidth="0x1" edc:desc="Enable Register Pair for Monitoring. 0 = No, 1 = Yes"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON1" edc:cname="RN_TM0RT_LIMIT" edc:nzwidth="0x20" edc:access="------------nnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0xFFFFF" edc:_addr="0x40010524">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON1">
            <edc:SFRFieldDef edc:cname="LMT" edc:nzwidth="0x14" edc:desc="Limit Register"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON1" edc:cname="RN_TM1RT_START" edc:nzwidth="0x20" edc:access="n-nnn-nn----nnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0xBB0FFFFF" edc:_addr="0x40010528">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON1">
            <edc:SFRFieldDef edc:cname="STRT" edc:nzwidth="0x14" edc:desc="A Flash address shifted by 12 (4K byte units). Bottom 12 address bits are 000h"/>
            <edc:AdjustPoint edc:offset="0x4"/>
            <edc:SFRFieldDef edc:cname="E32" edc:nzwidth="0x1" edc:desc="Enable 32KByte Erase opcode for this region. 0 = Disable, 1 = Enable"/>
            <edc:SFRFieldDef edc:cname="E64" edc:nzwidth="0x1" edc:desc="Enable 64KByte Erase opcode for this region. 0 = Disable, 1 = Enable"/>
            <edc:AdjustPoint edc:offset="0x1"/>
            <edc:SFRFieldDef edc:cname="DV" edc:nzwidth="0x1" edc:desc="Flash Device 0 = CS0#, 1 = CS1#."/>
            <edc:SFRFieldDef edc:cname="RD" edc:nzwidth="0x1" edc:desc="Read Allowed for Region. 0 = No, 1 = Yes"/>
            <edc:SFRFieldDef edc:cname="WR" edc:nzwidth="0x1" edc:desc="Write Allowed for Region. 0 = No, 1 = Yes"/>
            <edc:AdjustPoint edc:offset="0x1"/>
            <edc:SFRFieldDef edc:cname="EN" edc:nzwidth="0x1" edc:desc="Enable Register Pair for Monitoring. 0 = No, 1 = Yes"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON1" edc:cname="RN_TM1RT_LIMIT" edc:nzwidth="0x20" edc:access="------------nnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0xFFFFF" edc:_addr="0x4001052C">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON1">
            <edc:SFRFieldDef edc:cname="LMT" edc:nzwidth="0x14" edc:desc="Limit Register"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON1" edc:cname="RN_TM2RT_START" edc:nzwidth="0x20" edc:access="n-nnn-nn----nnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0xBB0FFFFF" edc:_addr="0x40010530">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON1">
            <edc:SFRFieldDef edc:cname="STRT" edc:nzwidth="0x14" edc:desc="A Flash address shifted by 12 (4K byte units). Bottom 12 address bits are 000h"/>
            <edc:AdjustPoint edc:offset="0x4"/>
            <edc:SFRFieldDef edc:cname="E32" edc:nzwidth="0x1" edc:desc="Enable 32KByte Erase opcode for this region. 0 = Disable, 1 = Enable"/>
            <edc:SFRFieldDef edc:cname="E64" edc:nzwidth="0x1" edc:desc="Enable 64KByte Erase opcode for this region. 0 = Disable, 1 = Enable"/>
            <edc:AdjustPoint edc:offset="0x1"/>
            <edc:SFRFieldDef edc:cname="DV" edc:nzwidth="0x1" edc:desc="Flash Device 0 = CS0#, 1 = CS1#."/>
            <edc:SFRFieldDef edc:cname="RD" edc:nzwidth="0x1" edc:desc="Read Allowed for Region. 0 = No, 1 = Yes"/>
            <edc:SFRFieldDef edc:cname="WR" edc:nzwidth="0x1" edc:desc="Write Allowed for Region. 0 = No, 1 = Yes"/>
            <edc:AdjustPoint edc:offset="0x1"/>
            <edc:SFRFieldDef edc:cname="EN" edc:nzwidth="0x1" edc:desc="Enable Register Pair for Monitoring. 0 = No, 1 = Yes"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON1" edc:cname="RN_TM2RT_LIMIT" edc:nzwidth="0x20" edc:access="------------nnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0xFFFFF" edc:_addr="0x40010534">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON1">
            <edc:SFRFieldDef edc:cname="LMT" edc:nzwidth="0x14" edc:desc="Limit Register"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON1" edc:cname="RN_TM3RT_START" edc:nzwidth="0x20" edc:access="n-nnn-nn----nnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0xBB0FFFFF" edc:_addr="0x40010538">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON1">
            <edc:SFRFieldDef edc:cname="STRT" edc:nzwidth="0x14" edc:desc="A Flash address shifted by 12 (4K byte units). Bottom 12 address bits are 000h"/>
            <edc:AdjustPoint edc:offset="0x4"/>
            <edc:SFRFieldDef edc:cname="E32" edc:nzwidth="0x1" edc:desc="Enable 32KByte Erase opcode for this region. 0 = Disable, 1 = Enable"/>
            <edc:SFRFieldDef edc:cname="E64" edc:nzwidth="0x1" edc:desc="Enable 64KByte Erase opcode for this region. 0 = Disable, 1 = Enable"/>
            <edc:AdjustPoint edc:offset="0x1"/>
            <edc:SFRFieldDef edc:cname="DV" edc:nzwidth="0x1" edc:desc="Flash Device 0 = CS0#, 1 = CS1#."/>
            <edc:SFRFieldDef edc:cname="RD" edc:nzwidth="0x1" edc:desc="Read Allowed for Region. 0 = No, 1 = Yes"/>
            <edc:SFRFieldDef edc:cname="WR" edc:nzwidth="0x1" edc:desc="Write Allowed for Region. 0 = No, 1 = Yes"/>
            <edc:AdjustPoint edc:offset="0x1"/>
            <edc:SFRFieldDef edc:cname="EN" edc:nzwidth="0x1" edc:desc="Enable Register Pair for Monitoring. 0 = No, 1 = Yes"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON1" edc:cname="RN_TM3RT_LIMIT" edc:nzwidth="0x20" edc:access="------------nnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0xFFFFF" edc:_addr="0x4001053C">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON1">
            <edc:SFRFieldDef edc:cname="LMT" edc:nzwidth="0x14" edc:desc="Limit Register"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON1" edc:cname="RN_TM4RT_START" edc:nzwidth="0x20" edc:access="n-nnn-nn----nnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0xBB0FFFFF" edc:_addr="0x40010540">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON1">
            <edc:SFRFieldDef edc:cname="STRT" edc:nzwidth="0x14" edc:desc="A Flash address shifted by 12 (4K byte units). Bottom 12 address bits are 000h"/>
            <edc:AdjustPoint edc:offset="0x4"/>
            <edc:SFRFieldDef edc:cname="E32" edc:nzwidth="0x1" edc:desc="Enable 32KByte Erase opcode for this region. 0 = Disable, 1 = Enable"/>
            <edc:SFRFieldDef edc:cname="E64" edc:nzwidth="0x1" edc:desc="Enable 64KByte Erase opcode for this region. 0 = Disable, 1 = Enable"/>
            <edc:AdjustPoint edc:offset="0x1"/>
            <edc:SFRFieldDef edc:cname="DV" edc:nzwidth="0x1" edc:desc="Flash Device 0 = CS0#, 1 = CS1#."/>
            <edc:SFRFieldDef edc:cname="RD" edc:nzwidth="0x1" edc:desc="Read Allowed for Region. 0 = No, 1 = Yes"/>
            <edc:SFRFieldDef edc:cname="WR" edc:nzwidth="0x1" edc:desc="Write Allowed for Region. 0 = No, 1 = Yes"/>
            <edc:AdjustPoint edc:offset="0x1"/>
            <edc:SFRFieldDef edc:cname="EN" edc:nzwidth="0x1" edc:desc="Enable Register Pair for Monitoring. 0 = No, 1 = Yes"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON1" edc:cname="RN_TM4RT_LIMIT" edc:nzwidth="0x20" edc:access="------------nnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0xFFFFF" edc:_addr="0x40010544">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON1">
            <edc:SFRFieldDef edc:cname="LMT" edc:nzwidth="0x14" edc:desc="Limit Register"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON1" edc:cname="RN_TM5RT_START" edc:nzwidth="0x20" edc:access="n-nnn-nn----nnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0xBB0FFFFF" edc:_addr="0x40010548">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON1">
            <edc:SFRFieldDef edc:cname="STRT" edc:nzwidth="0x14" edc:desc="A Flash address shifted by 12 (4K byte units). Bottom 12 address bits are 000h"/>
            <edc:AdjustPoint edc:offset="0x4"/>
            <edc:SFRFieldDef edc:cname="E32" edc:nzwidth="0x1" edc:desc="Enable 32KByte Erase opcode for this region. 0 = Disable, 1 = Enable"/>
            <edc:SFRFieldDef edc:cname="E64" edc:nzwidth="0x1" edc:desc="Enable 64KByte Erase opcode for this region. 0 = Disable, 1 = Enable"/>
            <edc:AdjustPoint edc:offset="0x1"/>
            <edc:SFRFieldDef edc:cname="DV" edc:nzwidth="0x1" edc:desc="Flash Device 0 = CS0#, 1 = CS1#."/>
            <edc:SFRFieldDef edc:cname="RD" edc:nzwidth="0x1" edc:desc="Read Allowed for Region. 0 = No, 1 = Yes"/>
            <edc:SFRFieldDef edc:cname="WR" edc:nzwidth="0x1" edc:desc="Write Allowed for Region. 0 = No, 1 = Yes"/>
            <edc:AdjustPoint edc:offset="0x1"/>
            <edc:SFRFieldDef edc:cname="EN" edc:nzwidth="0x1" edc:desc="Enable Register Pair for Monitoring. 0 = No, 1 = Yes"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON1" edc:cname="RN_TM5RT_LIMIT" edc:nzwidth="0x20" edc:access="------------nnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0xFFFFF" edc:_addr="0x4001054C">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON1">
            <edc:SFRFieldDef edc:cname="LMT" edc:nzwidth="0x14" edc:desc="Limit Register"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON1" edc:cname="RN_TM6RT_START" edc:nzwidth="0x20" edc:access="n-nnn-nn----nnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0xBB0FFFFF" edc:_addr="0x40010550">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON1">
            <edc:SFRFieldDef edc:cname="STRT" edc:nzwidth="0x14" edc:desc="A Flash address shifted by 12 (4K byte units). Bottom 12 address bits are 000h"/>
            <edc:AdjustPoint edc:offset="0x4"/>
            <edc:SFRFieldDef edc:cname="E32" edc:nzwidth="0x1" edc:desc="Enable 32KByte Erase opcode for this region. 0 = Disable, 1 = Enable"/>
            <edc:SFRFieldDef edc:cname="E64" edc:nzwidth="0x1" edc:desc="Enable 64KByte Erase opcode for this region. 0 = Disable, 1 = Enable"/>
            <edc:AdjustPoint edc:offset="0x1"/>
            <edc:SFRFieldDef edc:cname="DV" edc:nzwidth="0x1" edc:desc="Flash Device 0 = CS0#, 1 = CS1#."/>
            <edc:SFRFieldDef edc:cname="RD" edc:nzwidth="0x1" edc:desc="Read Allowed for Region. 0 = No, 1 = Yes"/>
            <edc:SFRFieldDef edc:cname="WR" edc:nzwidth="0x1" edc:desc="Write Allowed for Region. 0 = No, 1 = Yes"/>
            <edc:AdjustPoint edc:offset="0x1"/>
            <edc:SFRFieldDef edc:cname="EN" edc:nzwidth="0x1" edc:desc="Enable Register Pair for Monitoring. 0 = No, 1 = Yes"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON1" edc:cname="RN_TM6RT_LIMIT" edc:nzwidth="0x20" edc:access="------------nnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0xFFFFF" edc:_addr="0x40010554">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON1">
            <edc:SFRFieldDef edc:cname="LMT" edc:nzwidth="0x14" edc:desc="Limit Register"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON1" edc:cname="RN_TM7RT_START" edc:nzwidth="0x20" edc:access="n-nnn-nn----nnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0xBB0FFFFF" edc:_addr="0x40010558">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON1">
            <edc:SFRFieldDef edc:cname="STRT" edc:nzwidth="0x14" edc:desc="A Flash address shifted by 12 (4K byte units). Bottom 12 address bits are 000h"/>
            <edc:AdjustPoint edc:offset="0x4"/>
            <edc:SFRFieldDef edc:cname="E32" edc:nzwidth="0x1" edc:desc="Enable 32KByte Erase opcode for this region. 0 = Disable, 1 = Enable"/>
            <edc:SFRFieldDef edc:cname="E64" edc:nzwidth="0x1" edc:desc="Enable 64KByte Erase opcode for this region. 0 = Disable, 1 = Enable"/>
            <edc:AdjustPoint edc:offset="0x1"/>
            <edc:SFRFieldDef edc:cname="DV" edc:nzwidth="0x1" edc:desc="Flash Device 0 = CS0#, 1 = CS1#."/>
            <edc:SFRFieldDef edc:cname="RD" edc:nzwidth="0x1" edc:desc="Read Allowed for Region. 0 = No, 1 = Yes"/>
            <edc:SFRFieldDef edc:cname="WR" edc:nzwidth="0x1" edc:desc="Write Allowed for Region. 0 = No, 1 = Yes"/>
            <edc:AdjustPoint edc:offset="0x1"/>
            <edc:SFRFieldDef edc:cname="EN" edc:nzwidth="0x1" edc:desc="Enable Register Pair for Monitoring. 0 = No, 1 = Yes"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON1" edc:cname="RN_TM7RT_LIMIT" edc:nzwidth="0x20" edc:access="------------nnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0xFFFFF" edc:_addr="0x4001055C">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON1">
            <edc:SFRFieldDef edc:cname="LMT" edc:nzwidth="0x14" edc:desc="Limit Register"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON1" edc:cname="RN_TM8RT_START" edc:nzwidth="0x20" edc:access="n-nnn-nn----nnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0xBB0FFFFF" edc:_addr="0x40010560">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON1">
            <edc:SFRFieldDef edc:cname="STRT" edc:nzwidth="0x14" edc:desc="A Flash address shifted by 12 (4K byte units). Bottom 12 address bits are 000h"/>
            <edc:AdjustPoint edc:offset="0x4"/>
            <edc:SFRFieldDef edc:cname="E32" edc:nzwidth="0x1" edc:desc="Enable 32KByte Erase opcode for this region. 0 = Disable, 1 = Enable"/>
            <edc:SFRFieldDef edc:cname="E64" edc:nzwidth="0x1" edc:desc="Enable 64KByte Erase opcode for this region. 0 = Disable, 1 = Enable"/>
            <edc:AdjustPoint edc:offset="0x1"/>
            <edc:SFRFieldDef edc:cname="DV" edc:nzwidth="0x1" edc:desc="Flash Device 0 = CS0#, 1 = CS1#."/>
            <edc:SFRFieldDef edc:cname="RD" edc:nzwidth="0x1" edc:desc="Read Allowed for Region. 0 = No, 1 = Yes"/>
            <edc:SFRFieldDef edc:cname="WR" edc:nzwidth="0x1" edc:desc="Write Allowed for Region. 0 = No, 1 = Yes"/>
            <edc:AdjustPoint edc:offset="0x1"/>
            <edc:SFRFieldDef edc:cname="EN" edc:nzwidth="0x1" edc:desc="Enable Register Pair for Monitoring. 0 = No, 1 = Yes"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON1" edc:cname="RN_TM8RT_LIMIT" edc:nzwidth="0x20" edc:access="------------nnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0xFFFFF" edc:_addr="0x40010564">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON1">
            <edc:SFRFieldDef edc:cname="LMT" edc:nzwidth="0x14" edc:desc="Limit Register"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON1" edc:cname="RN_TM9RT_START" edc:nzwidth="0x20" edc:access="n-nnn-nn----nnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0xBB0FFFFF" edc:_addr="0x40010568">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON1">
            <edc:SFRFieldDef edc:cname="STRT" edc:nzwidth="0x14" edc:desc="A Flash address shifted by 12 (4K byte units). Bottom 12 address bits are 000h"/>
            <edc:AdjustPoint edc:offset="0x4"/>
            <edc:SFRFieldDef edc:cname="E32" edc:nzwidth="0x1" edc:desc="Enable 32KByte Erase opcode for this region. 0 = Disable, 1 = Enable"/>
            <edc:SFRFieldDef edc:cname="E64" edc:nzwidth="0x1" edc:desc="Enable 64KByte Erase opcode for this region. 0 = Disable, 1 = Enable"/>
            <edc:AdjustPoint edc:offset="0x1"/>
            <edc:SFRFieldDef edc:cname="DV" edc:nzwidth="0x1" edc:desc="Flash Device 0 = CS0#, 1 = CS1#."/>
            <edc:SFRFieldDef edc:cname="RD" edc:nzwidth="0x1" edc:desc="Read Allowed for Region. 0 = No, 1 = Yes"/>
            <edc:SFRFieldDef edc:cname="WR" edc:nzwidth="0x1" edc:desc="Write Allowed for Region. 0 = No, 1 = Yes"/>
            <edc:AdjustPoint edc:offset="0x1"/>
            <edc:SFRFieldDef edc:cname="EN" edc:nzwidth="0x1" edc:desc="Enable Register Pair for Monitoring. 0 = No, 1 = Yes"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON1" edc:cname="RN_TM9RT_LIMIT" edc:nzwidth="0x20" edc:access="------------nnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0xFFFFF" edc:_addr="0x4001056C">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON1">
            <edc:SFRFieldDef edc:cname="LMT" edc:nzwidth="0x14" edc:desc="Limit Register"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON1" edc:cname="RN_TM10RT_START" edc:nzwidth="0x20" edc:access="n-nnn-nn----nnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0xBB0FFFFF" edc:_addr="0x40010570">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON1">
            <edc:SFRFieldDef edc:cname="STRT" edc:nzwidth="0x14" edc:desc="A Flash address shifted by 12 (4K byte units). Bottom 12 address bits are 000h"/>
            <edc:AdjustPoint edc:offset="0x4"/>
            <edc:SFRFieldDef edc:cname="E32" edc:nzwidth="0x1" edc:desc="Enable 32KByte Erase opcode for this region. 0 = Disable, 1 = Enable"/>
            <edc:SFRFieldDef edc:cname="E64" edc:nzwidth="0x1" edc:desc="Enable 64KByte Erase opcode for this region. 0 = Disable, 1 = Enable"/>
            <edc:AdjustPoint edc:offset="0x1"/>
            <edc:SFRFieldDef edc:cname="DV" edc:nzwidth="0x1" edc:desc="Flash Device 0 = CS0#, 1 = CS1#."/>
            <edc:SFRFieldDef edc:cname="RD" edc:nzwidth="0x1" edc:desc="Read Allowed for Region. 0 = No, 1 = Yes"/>
            <edc:SFRFieldDef edc:cname="WR" edc:nzwidth="0x1" edc:desc="Write Allowed for Region. 0 = No, 1 = Yes"/>
            <edc:AdjustPoint edc:offset="0x1"/>
            <edc:SFRFieldDef edc:cname="EN" edc:nzwidth="0x1" edc:desc="Enable Register Pair for Monitoring. 0 = No, 1 = Yes"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON1" edc:cname="RN_TM10RT_LIMIT" edc:nzwidth="0x20" edc:access="------------nnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0xFFFFF" edc:_addr="0x40010574">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON1">
            <edc:SFRFieldDef edc:cname="LMT" edc:nzwidth="0x14" edc:desc="Limit Register"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON1" edc:cname="RN_TM11RT_START" edc:nzwidth="0x20" edc:access="n-nnn-nn----nnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0xBB0FFFFF" edc:_addr="0x40010578">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON1">
            <edc:SFRFieldDef edc:cname="STRT" edc:nzwidth="0x14" edc:desc="A Flash address shifted by 12 (4K byte units). Bottom 12 address bits are 000h"/>
            <edc:AdjustPoint edc:offset="0x4"/>
            <edc:SFRFieldDef edc:cname="E32" edc:nzwidth="0x1" edc:desc="Enable 32KByte Erase opcode for this region. 0 = Disable, 1 = Enable"/>
            <edc:SFRFieldDef edc:cname="E64" edc:nzwidth="0x1" edc:desc="Enable 64KByte Erase opcode for this region. 0 = Disable, 1 = Enable"/>
            <edc:AdjustPoint edc:offset="0x1"/>
            <edc:SFRFieldDef edc:cname="DV" edc:nzwidth="0x1" edc:desc="Flash Device 0 = CS0#, 1 = CS1#."/>
            <edc:SFRFieldDef edc:cname="RD" edc:nzwidth="0x1" edc:desc="Read Allowed for Region. 0 = No, 1 = Yes"/>
            <edc:SFRFieldDef edc:cname="WR" edc:nzwidth="0x1" edc:desc="Write Allowed for Region. 0 = No, 1 = Yes"/>
            <edc:AdjustPoint edc:offset="0x1"/>
            <edc:SFRFieldDef edc:cname="EN" edc:nzwidth="0x1" edc:desc="Enable Register Pair for Monitoring. 0 = No, 1 = Yes"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON1" edc:cname="RN_TM11RT_LIMIT" edc:nzwidth="0x20" edc:access="------------nnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0xFFFFF" edc:_addr="0x4001057C">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON1">
            <edc:SFRFieldDef edc:cname="LMT" edc:nzwidth="0x14" edc:desc="Limit Register"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON1" edc:cname="RN_TM12RT_START" edc:nzwidth="0x20" edc:access="n-nnn-nn----nnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0xBB0FFFFF" edc:_addr="0x40010580">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON1">
            <edc:SFRFieldDef edc:cname="STRT" edc:nzwidth="0x14" edc:desc="A Flash address shifted by 12 (4K byte units). Bottom 12 address bits are 000h"/>
            <edc:AdjustPoint edc:offset="0x4"/>
            <edc:SFRFieldDef edc:cname="E32" edc:nzwidth="0x1" edc:desc="Enable 32KByte Erase opcode for this region. 0 = Disable, 1 = Enable"/>
            <edc:SFRFieldDef edc:cname="E64" edc:nzwidth="0x1" edc:desc="Enable 64KByte Erase opcode for this region. 0 = Disable, 1 = Enable"/>
            <edc:AdjustPoint edc:offset="0x1"/>
            <edc:SFRFieldDef edc:cname="DV" edc:nzwidth="0x1" edc:desc="Flash Device 0 = CS0#, 1 = CS1#."/>
            <edc:SFRFieldDef edc:cname="RD" edc:nzwidth="0x1" edc:desc="Read Allowed for Region. 0 = No, 1 = Yes"/>
            <edc:SFRFieldDef edc:cname="WR" edc:nzwidth="0x1" edc:desc="Write Allowed for Region. 0 = No, 1 = Yes"/>
            <edc:AdjustPoint edc:offset="0x1"/>
            <edc:SFRFieldDef edc:cname="EN" edc:nzwidth="0x1" edc:desc="Enable Register Pair for Monitoring. 0 = No, 1 = Yes"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON1" edc:cname="RN_TM12RT_LIMIT" edc:nzwidth="0x20" edc:access="------------nnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0xFFFFF" edc:_addr="0x40010584">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON1">
            <edc:SFRFieldDef edc:cname="LMT" edc:nzwidth="0x14" edc:desc="Limit Register"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON1" edc:cname="RN_TM13RT_START" edc:nzwidth="0x20" edc:access="n-nnn-nn----nnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0xBB0FFFFF" edc:_addr="0x40010588">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON1">
            <edc:SFRFieldDef edc:cname="STRT" edc:nzwidth="0x14" edc:desc="A Flash address shifted by 12 (4K byte units). Bottom 12 address bits are 000h"/>
            <edc:AdjustPoint edc:offset="0x4"/>
            <edc:SFRFieldDef edc:cname="E32" edc:nzwidth="0x1" edc:desc="Enable 32KByte Erase opcode for this region. 0 = Disable, 1 = Enable"/>
            <edc:SFRFieldDef edc:cname="E64" edc:nzwidth="0x1" edc:desc="Enable 64KByte Erase opcode for this region. 0 = Disable, 1 = Enable"/>
            <edc:AdjustPoint edc:offset="0x1"/>
            <edc:SFRFieldDef edc:cname="DV" edc:nzwidth="0x1" edc:desc="Flash Device 0 = CS0#, 1 = CS1#."/>
            <edc:SFRFieldDef edc:cname="RD" edc:nzwidth="0x1" edc:desc="Read Allowed for Region. 0 = No, 1 = Yes"/>
            <edc:SFRFieldDef edc:cname="WR" edc:nzwidth="0x1" edc:desc="Write Allowed for Region. 0 = No, 1 = Yes"/>
            <edc:AdjustPoint edc:offset="0x1"/>
            <edc:SFRFieldDef edc:cname="EN" edc:nzwidth="0x1" edc:desc="Enable Register Pair for Monitoring. 0 = No, 1 = Yes"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON1" edc:cname="RN_TM13RT_LIMIT" edc:nzwidth="0x20" edc:access="------------nnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0xFFFFF" edc:_addr="0x4001058C">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON1">
            <edc:SFRFieldDef edc:cname="LMT" edc:nzwidth="0x14" edc:desc="Limit Register"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON1" edc:cname="RN_TM14RT_START" edc:nzwidth="0x20" edc:access="n-nnn-nn----nnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0xBB0FFFFF" edc:_addr="0x40010590">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON1">
            <edc:SFRFieldDef edc:cname="STRT" edc:nzwidth="0x14" edc:desc="A Flash address shifted by 12 (4K byte units). Bottom 12 address bits are 000h"/>
            <edc:AdjustPoint edc:offset="0x4"/>
            <edc:SFRFieldDef edc:cname="E32" edc:nzwidth="0x1" edc:desc="Enable 32KByte Erase opcode for this region. 0 = Disable, 1 = Enable"/>
            <edc:SFRFieldDef edc:cname="E64" edc:nzwidth="0x1" edc:desc="Enable 64KByte Erase opcode for this region. 0 = Disable, 1 = Enable"/>
            <edc:AdjustPoint edc:offset="0x1"/>
            <edc:SFRFieldDef edc:cname="DV" edc:nzwidth="0x1" edc:desc="Flash Device 0 = CS0#, 1 = CS1#."/>
            <edc:SFRFieldDef edc:cname="RD" edc:nzwidth="0x1" edc:desc="Read Allowed for Region. 0 = No, 1 = Yes"/>
            <edc:SFRFieldDef edc:cname="WR" edc:nzwidth="0x1" edc:desc="Write Allowed for Region. 0 = No, 1 = Yes"/>
            <edc:AdjustPoint edc:offset="0x1"/>
            <edc:SFRFieldDef edc:cname="EN" edc:nzwidth="0x1" edc:desc="Enable Register Pair for Monitoring. 0 = No, 1 = Yes"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON1" edc:cname="RN_TM14RT_LIMIT" edc:nzwidth="0x20" edc:access="------------nnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0xFFFFF" edc:_addr="0x40010594">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON1">
            <edc:SFRFieldDef edc:cname="LMT" edc:nzwidth="0x14" edc:desc="Limit Register"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON1" edc:cname="RN_TM15RT_START" edc:nzwidth="0x20" edc:access="n-nnn-nn----nnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0xBB0FFFFF" edc:_addr="0x40010598">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON1">
            <edc:SFRFieldDef edc:cname="STRT" edc:nzwidth="0x14" edc:desc="A Flash address shifted by 12 (4K byte units). Bottom 12 address bits are 000h"/>
            <edc:AdjustPoint edc:offset="0x4"/>
            <edc:SFRFieldDef edc:cname="E32" edc:nzwidth="0x1" edc:desc="Enable 32KByte Erase opcode for this region. 0 = Disable, 1 = Enable"/>
            <edc:SFRFieldDef edc:cname="E64" edc:nzwidth="0x1" edc:desc="Enable 64KByte Erase opcode for this region. 0 = Disable, 1 = Enable"/>
            <edc:AdjustPoint edc:offset="0x1"/>
            <edc:SFRFieldDef edc:cname="DV" edc:nzwidth="0x1" edc:desc="Flash Device 0 = CS0#, 1 = CS1#."/>
            <edc:SFRFieldDef edc:cname="RD" edc:nzwidth="0x1" edc:desc="Read Allowed for Region. 0 = No, 1 = Yes"/>
            <edc:SFRFieldDef edc:cname="WR" edc:nzwidth="0x1" edc:desc="Write Allowed for Region. 0 = No, 1 = Yes"/>
            <edc:AdjustPoint edc:offset="0x1"/>
            <edc:SFRFieldDef edc:cname="EN" edc:nzwidth="0x1" edc:desc="Enable Register Pair for Monitoring. 0 = No, 1 = Yes"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON1" edc:cname="RN_TM15RT_LIMIT" edc:nzwidth="0x20" edc:access="------------nnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0xFFFFF" edc:_addr="0x4001059C">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON1">
            <edc:SFRFieldDef edc:cname="LMT" edc:nzwidth="0x14" edc:desc="Limit Register"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:AdjustPoint edc:offset="0x30" edc:_addr="0x400105A0"/>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON1" edc:cname="MTMON_CTRLSTS" edc:nzwidth="0x20" edc:access="-------n----nnnn-----nnn-----nnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x10F0707" edc:_addr="0x400105D0">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON1">
            <edc:SFRFieldDef edc:cname="T" edc:nzwidth="0x1" edc:desc="Timeout"/>
            <edc:SFRFieldDef edc:cname="F" edc:nzwidth="0x1" edc:desc="First Fetch in any Match region"/>
            <edc:SFRFieldDef edc:cname="AM" edc:nzwidth="0x1" edc:desc="Set to 1 on a 3B/4B Address Mode switch on either Flash."/>
            <edc:AdjustPoint edc:offset="0x5"/>
            <edc:SFRFieldDef edc:cname="ET_IRQ" edc:nzwidth="0x1" edc:desc="Enable Timeout Interrupt"/>
            <edc:SFRFieldDef edc:cname="EF_IRQ" edc:nzwidth="0x1" edc:desc="Enable First Fetch in any Match region Interrupt"/>
            <edc:SFRFieldDef edc:cname="AM_IRQ" edc:nzwidth="0x1" edc:desc="Enable 3B/4B Address Mode switch on either Flash Interrupt"/>
            <edc:AdjustPoint edc:offset="0x5"/>
            <edc:SFRFieldDef edc:cname="FIFO_MTY" edc:nzwidth="0x1" edc:desc="FIFO Empty"/>
            <edc:SFRFieldDef edc:cname="FIFO_FUL" edc:nzwidth="0x1" edc:desc="FIFO Full"/>
            <edc:SFRFieldDef edc:cname="FIFO_OVRF" edc:nzwidth="0x1" edc:desc="FIFO Overflow"/>
            <edc:SFRFieldDef edc:cname="FIFO_UDRF" edc:nzwidth="0x1" edc:desc="FIFO Underflow"/>
            <edc:AdjustPoint edc:offset="0x4"/>
            <edc:SFRFieldDef edc:cname="CLR_FIFO" edc:nzwidth="0x1" edc:desc="Clear FIFO. This field is autocleared by hardware"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON1" edc:cname="MTMON_ENMD" edc:nzwidth="0x20" edc:access="-----------------------n-------n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x101" edc:_addr="0x400105D4">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON1">
            <edc:SFRFieldDef edc:cname="MON_EN" edc:nzwidth="0x1" edc:desc="Enable Data Matching. 0 = Disabled, 1 = Enabled"/>
            <edc:AdjustPoint edc:offset="0x7"/>
            <edc:SFRFieldDef edc:cname="MON_MS" edc:nzwidth="0x1" edc:desc="Match Pattern Source Mode: 0 = SRAM, 1 = Internal Flash."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON1" edc:cname="MTMON_TCTRL" edc:nzwidth="0x20" edc:access="---------nnnnnnn---------------n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x7F0001" edc:_addr="0x400105D8">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON1">
            <edc:SFRFieldDef edc:cname="ST" edc:nzwidth="0x1" edc:desc="Start Timeout Counter"/>
            <edc:AdjustPoint edc:offset="0xF"/>
            <edc:SFRFieldDef edc:cname="TV" edc:nzwidth="0x5" edc:desc="Timeout Value 0 to 32"/>
            <edc:SFRFieldDef edc:cname="TU" edc:nzwidth="0x2" edc:desc="Timeout Unit 00 = none (off), 01 = 32ms, 10 = 128ms, 11 = 1sec"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:AdjustPoint edc:offset="0x4" edc:_addr="0x400105DC"/>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON1" edc:cname="MT_MON0MTMON_BEGIN" edc:nzwidth="0x20" edc:access="n------------nnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x8007FFFF" edc:_addr="0x400105E0">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON1">
            <edc:SFRFieldDef edc:cname="BGN" edc:nzwidth="0x13" edc:desc="The 19 bits of base address within the designated SPI Flash, specifying the last aligned 8K block."/>
            <edc:AdjustPoint edc:offset="0xC"/>
            <edc:SFRFieldDef edc:cname="DV" edc:nzwidth="0x1" edc:desc="Flash Device number, applying to both Begin and End fields 0 = CS0#, 1 = CS1#"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON1" edc:cname="MT_MON0MTMON_END" edc:nzwidth="0x20" edc:access="-------------nnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x7FFFF" edc:_addr="0x400105E4">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON1">
            <edc:SFRFieldDef edc:cname="END" edc:nzwidth="0x13" edc:desc="The 19 bits of base address within the designated SPI Flash, specifying the last aligned 8K block."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON1" edc:cname="MT_MON0MAP" edc:nzwidth="0x20" edc:access="n------------nnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x8007FFFF" edc:_addr="0x400105E8">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON1">
            <edc:SFRFieldDef edc:cname="MAP" edc:nzwidth="0x13" edc:desc="The 19 bits of base address within the designated SPI Flash, specifying the last aligned 8K block."/>
            <edc:AdjustPoint edc:offset="0xC"/>
            <edc:SFRFieldDef edc:cname="ME" edc:nzwidth="0x1" edc:desc="Match Enable for individual Region R"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON1" edc:cname="MT_MON1MTMON_BEGIN" edc:nzwidth="0x20" edc:access="n------------nnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x8007FFFF" edc:_addr="0x400105EC">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON1">
            <edc:SFRFieldDef edc:cname="BGN" edc:nzwidth="0x13" edc:desc="The 19 bits of base address within the designated SPI Flash, specifying the last aligned 8K block."/>
            <edc:AdjustPoint edc:offset="0xC"/>
            <edc:SFRFieldDef edc:cname="DV" edc:nzwidth="0x1" edc:desc="Flash Device number, applying to both Begin and End fields 0 = CS0#, 1 = CS1#"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON1" edc:cname="MT_MON1MTMON_END" edc:nzwidth="0x20" edc:access="-------------nnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x7FFFF" edc:_addr="0x400105F0">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON1">
            <edc:SFRFieldDef edc:cname="END" edc:nzwidth="0x13" edc:desc="The 19 bits of base address within the designated SPI Flash, specifying the last aligned 8K block."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON1" edc:cname="MT_MON1MAP" edc:nzwidth="0x20" edc:access="n------------nnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x8007FFFF" edc:_addr="0x400105F4">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON1">
            <edc:SFRFieldDef edc:cname="MAP" edc:nzwidth="0x13" edc:desc="The 19 bits of base address within the designated SPI Flash, specifying the last aligned 8K block."/>
            <edc:AdjustPoint edc:offset="0xC"/>
            <edc:SFRFieldDef edc:cname="ME" edc:nzwidth="0x1" edc:desc="Match Enable for individual Region R"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON1" edc:cname="MT_MON2MTMON_BEGIN" edc:nzwidth="0x20" edc:access="n------------nnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x8007FFFF" edc:_addr="0x400105F8">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON1">
            <edc:SFRFieldDef edc:cname="BGN" edc:nzwidth="0x13" edc:desc="The 19 bits of base address within the designated SPI Flash, specifying the last aligned 8K block."/>
            <edc:AdjustPoint edc:offset="0xC"/>
            <edc:SFRFieldDef edc:cname="DV" edc:nzwidth="0x1" edc:desc="Flash Device number, applying to both Begin and End fields 0 = CS0#, 1 = CS1#"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON1" edc:cname="MT_MON2MTMON_END" edc:nzwidth="0x20" edc:access="-------------nnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x7FFFF" edc:_addr="0x400105FC">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON1">
            <edc:SFRFieldDef edc:cname="END" edc:nzwidth="0x13" edc:desc="The 19 bits of base address within the designated SPI Flash, specifying the last aligned 8K block."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON1" edc:cname="MT_MON2MAP" edc:nzwidth="0x20" edc:access="n------------nnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x8007FFFF" edc:_addr="0x40010600">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON1">
            <edc:SFRFieldDef edc:cname="MAP" edc:nzwidth="0x13" edc:desc="The 19 bits of base address within the designated SPI Flash, specifying the last aligned 8K block."/>
            <edc:AdjustPoint edc:offset="0xC"/>
            <edc:SFRFieldDef edc:cname="ME" edc:nzwidth="0x1" edc:desc="Match Enable for individual Region R"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON1" edc:cname="MT_MON3MTMON_BEGIN" edc:nzwidth="0x20" edc:access="n------------nnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x8007FFFF" edc:_addr="0x40010604">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON1">
            <edc:SFRFieldDef edc:cname="BGN" edc:nzwidth="0x13" edc:desc="The 19 bits of base address within the designated SPI Flash, specifying the last aligned 8K block."/>
            <edc:AdjustPoint edc:offset="0xC"/>
            <edc:SFRFieldDef edc:cname="DV" edc:nzwidth="0x1" edc:desc="Flash Device number, applying to both Begin and End fields 0 = CS0#, 1 = CS1#"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON1" edc:cname="MT_MON3MTMON_END" edc:nzwidth="0x20" edc:access="-------------nnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x7FFFF" edc:_addr="0x40010608">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON1">
            <edc:SFRFieldDef edc:cname="END" edc:nzwidth="0x13" edc:desc="The 19 bits of base address within the designated SPI Flash, specifying the last aligned 8K block."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON1" edc:cname="MT_MON3MAP" edc:nzwidth="0x20" edc:access="n------------nnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x8007FFFF" edc:_addr="0x4001060C">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON1">
            <edc:SFRFieldDef edc:cname="MAP" edc:nzwidth="0x13" edc:desc="The 19 bits of base address within the designated SPI Flash, specifying the last aligned 8K block."/>
            <edc:AdjustPoint edc:offset="0xC"/>
            <edc:SFRFieldDef edc:cname="ME" edc:nzwidth="0x1" edc:desc="Match Enable for individual Region R"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON1" edc:cname="MT_MON4MTMON_BEGIN" edc:nzwidth="0x20" edc:access="n------------nnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x8007FFFF" edc:_addr="0x40010610">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON1">
            <edc:SFRFieldDef edc:cname="BGN" edc:nzwidth="0x13" edc:desc="The 19 bits of base address within the designated SPI Flash, specifying the last aligned 8K block."/>
            <edc:AdjustPoint edc:offset="0xC"/>
            <edc:SFRFieldDef edc:cname="DV" edc:nzwidth="0x1" edc:desc="Flash Device number, applying to both Begin and End fields 0 = CS0#, 1 = CS1#"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON1" edc:cname="MT_MON4MTMON_END" edc:nzwidth="0x20" edc:access="-------------nnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x7FFFF" edc:_addr="0x40010614">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON1">
            <edc:SFRFieldDef edc:cname="END" edc:nzwidth="0x13" edc:desc="The 19 bits of base address within the designated SPI Flash, specifying the last aligned 8K block."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON1" edc:cname="MT_MON4MAP" edc:nzwidth="0x20" edc:access="n------------nnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x8007FFFF" edc:_addr="0x40010618">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON1">
            <edc:SFRFieldDef edc:cname="MAP" edc:nzwidth="0x13" edc:desc="The 19 bits of base address within the designated SPI Flash, specifying the last aligned 8K block."/>
            <edc:AdjustPoint edc:offset="0xC"/>
            <edc:SFRFieldDef edc:cname="ME" edc:nzwidth="0x1" edc:desc="Match Enable for individual Region R"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON1" edc:cname="MT_MON5MTMON_BEGIN" edc:nzwidth="0x20" edc:access="n------------nnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x8007FFFF" edc:_addr="0x4001061C">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON1">
            <edc:SFRFieldDef edc:cname="BGN" edc:nzwidth="0x13" edc:desc="The 19 bits of base address within the designated SPI Flash, specifying the last aligned 8K block."/>
            <edc:AdjustPoint edc:offset="0xC"/>
            <edc:SFRFieldDef edc:cname="DV" edc:nzwidth="0x1" edc:desc="Flash Device number, applying to both Begin and End fields 0 = CS0#, 1 = CS1#"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON1" edc:cname="MT_MON5MTMON_END" edc:nzwidth="0x20" edc:access="-------------nnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x7FFFF" edc:_addr="0x40010620">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON1">
            <edc:SFRFieldDef edc:cname="END" edc:nzwidth="0x13" edc:desc="The 19 bits of base address within the designated SPI Flash, specifying the last aligned 8K block."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON1" edc:cname="MT_MON5MAP" edc:nzwidth="0x20" edc:access="n------------nnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x8007FFFF" edc:_addr="0x40010624">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON1">
            <edc:SFRFieldDef edc:cname="MAP" edc:nzwidth="0x13" edc:desc="The 19 bits of base address within the designated SPI Flash, specifying the last aligned 8K block."/>
            <edc:AdjustPoint edc:offset="0xC"/>
            <edc:SFRFieldDef edc:cname="ME" edc:nzwidth="0x1" edc:desc="Match Enable for individual Region R"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON1" edc:cname="MT_MON6MTMON_BEGIN" edc:nzwidth="0x20" edc:access="n------------nnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x8007FFFF" edc:_addr="0x40010628">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON1">
            <edc:SFRFieldDef edc:cname="BGN" edc:nzwidth="0x13" edc:desc="The 19 bits of base address within the designated SPI Flash, specifying the last aligned 8K block."/>
            <edc:AdjustPoint edc:offset="0xC"/>
            <edc:SFRFieldDef edc:cname="DV" edc:nzwidth="0x1" edc:desc="Flash Device number, applying to both Begin and End fields 0 = CS0#, 1 = CS1#"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON1" edc:cname="MT_MON6MTMON_END" edc:nzwidth="0x20" edc:access="-------------nnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x7FFFF" edc:_addr="0x4001062C">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON1">
            <edc:SFRFieldDef edc:cname="END" edc:nzwidth="0x13" edc:desc="The 19 bits of base address within the designated SPI Flash, specifying the last aligned 8K block."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON1" edc:cname="MT_MON6MAP" edc:nzwidth="0x20" edc:access="n------------nnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x8007FFFF" edc:_addr="0x40010630">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON1">
            <edc:SFRFieldDef edc:cname="MAP" edc:nzwidth="0x13" edc:desc="The 19 bits of base address within the designated SPI Flash, specifying the last aligned 8K block."/>
            <edc:AdjustPoint edc:offset="0xC"/>
            <edc:SFRFieldDef edc:cname="ME" edc:nzwidth="0x1" edc:desc="Match Enable for individual Region R"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON1" edc:cname="MT_MON7MTMON_BEGIN" edc:nzwidth="0x20" edc:access="n------------nnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x8007FFFF" edc:_addr="0x40010634">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON1">
            <edc:SFRFieldDef edc:cname="BGN" edc:nzwidth="0x13" edc:desc="The 19 bits of base address within the designated SPI Flash, specifying the last aligned 8K block."/>
            <edc:AdjustPoint edc:offset="0xC"/>
            <edc:SFRFieldDef edc:cname="DV" edc:nzwidth="0x1" edc:desc="Flash Device number, applying to both Begin and End fields 0 = CS0#, 1 = CS1#"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON1" edc:cname="MT_MON7MTMON_END" edc:nzwidth="0x20" edc:access="-------------nnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x7FFFF" edc:_addr="0x40010638">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON1">
            <edc:SFRFieldDef edc:cname="END" edc:nzwidth="0x13" edc:desc="The 19 bits of base address within the designated SPI Flash, specifying the last aligned 8K block."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON1" edc:cname="MT_MON7MAP" edc:nzwidth="0x20" edc:access="n------------nnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x8007FFFF" edc:_addr="0x4001063C">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON1">
            <edc:SFRFieldDef edc:cname="MAP" edc:nzwidth="0x13" edc:desc="The 19 bits of base address within the designated SPI Flash, specifying the last aligned 8K block."/>
            <edc:AdjustPoint edc:offset="0xC"/>
            <edc:SFRFieldDef edc:cname="ME" edc:nzwidth="0x1" edc:desc="Match Enable for individual Region R"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON1" edc:cname="MTMON_VIOSTS" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnn--nnnnnn-n----" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0xFFFFCFD0" edc:_addr="0x40010640">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON1">
            <edc:AdjustPoint edc:offset="0x4"/>
            <edc:SFRFieldDef edc:cname="MTO" edc:nzwidth="0x1" edc:desc="Match Monitor Timeout. This is read-Only bit."/>
            <edc:AdjustPoint edc:offset="0x1"/>
            <edc:SFRFieldDef edc:cname="DV" edc:nzwidth="0x1" edc:desc="Device Number. This is read-Only bit. 0 = CS0, 1 = CS1."/>
            <edc:SFRFieldDef edc:cname="RGN" edc:nzwidth="0x5" edc:desc="Region. This is read-Only bit. Shows which of 8 Match regions [7:0] got the mismatch."/>
            <edc:AdjustPoint edc:offset="0x2"/>
            <edc:SFRFieldDef edc:cname="AM" edc:nzwidth="0x1" edc:desc="Flash Address Mode 0 = 3-byte, 1 = 4-byte"/>
            <edc:SFRFieldDef edc:cname="CLR" edc:nzwidth="0x1" edc:desc="Clear Register RW1C. This bit is auto clearing"/>
            <edc:SFRFieldDef edc:cname="OPCOD" edc:nzwidth="0x8" edc:desc="Flash Opcode"/>
            <edc:SFRFieldDef edc:cname="DATA" edc:nzwidth="0x8" edc:desc="SPI Data Byte"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON1" edc:cname="MTMON_VIOADDR" edc:nzwidth="0x20" edc:access="rrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrr" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x40010644">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON1">
            <edc:SFRFieldDef edc:cname="ADDR" edc:nzwidth="0x20" edc:desc="Byte address at which the error occurred, within the designated Flash"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:AdjustPoint edc:offset="0x8" edc:_addr="0x40010648"/>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON1" edc:cname="LTMON_AGGR" edc:nzwidth="0x20" edc:access="----------------nnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0xFFFF" edc:_addr="0x40010650">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON1">
            <edc:SFRFieldDef edc:cname="IRQ0" edc:nzwidth="0x1" edc:desc="Load 0 Interrupt"/>
            <edc:SFRFieldDef edc:cname="IRQ1" edc:nzwidth="0x1" edc:desc="Load 1 Interrupt"/>
            <edc:SFRFieldDef edc:cname="IRQ2" edc:nzwidth="0x1" edc:desc="Load 2 Interrupt"/>
            <edc:SFRFieldDef edc:cname="IRQ3" edc:nzwidth="0x1" edc:desc="Load 3 Interrupt"/>
            <edc:SFRFieldDef edc:cname="IRQ4" edc:nzwidth="0x1" edc:desc="Load 4 Interrupt"/>
            <edc:SFRFieldDef edc:cname="IRQ5" edc:nzwidth="0x1" edc:desc="Load 5 Interrupt"/>
            <edc:SFRFieldDef edc:cname="IRQ6" edc:nzwidth="0x1" edc:desc="Load 6 Interrupt"/>
            <edc:SFRFieldDef edc:cname="IRQ7" edc:nzwidth="0x1" edc:desc="Load 7 Interrupt"/>
            <edc:SFRFieldDef edc:cname="EN_IRQ0" edc:nzwidth="0x1" edc:desc="Enable Load 0 Interrupt"/>
            <edc:SFRFieldDef edc:cname="EN_IRQ1" edc:nzwidth="0x1" edc:desc="Enable Load 1 Interrupt"/>
            <edc:SFRFieldDef edc:cname="EN_IRQ2" edc:nzwidth="0x1" edc:desc="Enable Load 2 Interrupt"/>
            <edc:SFRFieldDef edc:cname="EN_IRQ3" edc:nzwidth="0x1" edc:desc="Enable Load 3 Interrupt"/>
            <edc:SFRFieldDef edc:cname="EN_IRQ4" edc:nzwidth="0x1" edc:desc="Enable Load 4 Interrupt"/>
            <edc:SFRFieldDef edc:cname="EN_IRQ5" edc:nzwidth="0x1" edc:desc="Enable Load 5 Interrupt"/>
            <edc:SFRFieldDef edc:cname="EN_IRQ6" edc:nzwidth="0x1" edc:desc="Enable Load 6 Interrupt"/>
            <edc:SFRFieldDef edc:cname="EN_IRQ7" edc:nzwidth="0x1" edc:desc="Enable Load 7 Interrupt"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON1" edc:cname="LT_MON0LM_CTRLSTS" edc:nzwidth="0x20" edc:access="--------------------nnnn----nnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0xF0F" edc:_addr="0x40010654">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON1">
            <edc:SFRFieldDef edc:cname="W" edc:nzwidth="0x1" edc:desc="Waiting"/>
            <edc:SFRFieldDef edc:cname="B" edc:nzwidth="0x1" edc:desc="Begin Byte seen"/>
            <edc:SFRFieldDef edc:cname="E" edc:nzwidth="0x1" edc:desc="End Byte seen"/>
            <edc:SFRFieldDef edc:cname="F" edc:nzwidth="0x1" edc:desc="Finalized and result ready"/>
            <edc:AdjustPoint edc:offset="0x4"/>
            <edc:SFRFieldDef edc:cname="W_INTEN" edc:nzwidth="0x1" edc:desc="Enable Waiting Interrupt"/>
            <edc:SFRFieldDef edc:cname="B_INTEN" edc:nzwidth="0x1" edc:desc="Enable Begin Byte seen Interrupt"/>
            <edc:SFRFieldDef edc:cname="E_INTEN" edc:nzwidth="0x1" edc:desc="Enable End Byte seen Interrupt"/>
            <edc:SFRFieldDef edc:cname="F_INTEN" edc:nzwidth="0x1" edc:desc="Enable Finalized and result ready Interrupt"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON1" edc:cname="LT_MON0LM_CHN_CTRL" edc:nzwidth="0x20" edc:access="--------------------nnnn-----nnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0xF07" edc:_addr="0x40010658">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON1">
            <edc:SFRFieldDef edc:cname="GO" edc:nzwidth="0x1" edc:desc="GO: Run the Load Monitor for this channel"/>
            <edc:SFRFieldDef edc:cname="RST" edc:nzwidth="0x1" edc:desc="RST: Stop and Reset calculation for this channel when set to 1"/>
            <edc:SFRFieldDef edc:cname="RSF" edc:nzwidth="0x1" edc:desc="RSF: Reset just Result FIFO pointer when this bit is set to 1"/>
            <edc:AdjustPoint edc:offset="0x5"/>
            <edc:SFRFieldDef edc:cname="FPTR" edc:nzwidth="0x4" edc:desc="FPTR: Result FIFO pointer. In 32Bit. Ranges: 0 to 11 for SHA-384 result 0 to 7 for SHA-256 result"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON1" edc:cname="LT_MON0LM_BEGIN" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x4001065C">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON1">
            <edc:SFRFieldDef edc:cname="BADDR" edc:nzwidth="0x1F" edc:desc="A byte address within the designated Flash, specifying the first byte of the load image."/>
            <edc:SFRFieldDef edc:cname="DV" edc:nzwidth="0x1" edc:desc="Flash Device number, applying to both Begin and End fields. 0 = CS0#, 1 = CS1#"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON1" edc:cname="LT_MON0LM_END" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x40010660">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON1">
            <edc:SFRFieldDef edc:cname="EADDR" edc:nzwidth="0x20" edc:desc="A byte address within the designated Flash, specifying the last byte of the load image."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON1" edc:cname="LT_MON0LM_COUNT" edc:nzwidth="0x20" edc:access="rrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrr" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x40010664">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON1">
            <edc:SFRFieldDef edc:cname="CNT" edc:nzwidth="0x20" edc:desc="A Read-Only count of bytes processed."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON1" edc:cname="LT_MON0LM_DIGEST" edc:nzwidth="0x20" edc:access="rrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrr" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x40010668">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON1">
            <edc:SFRFieldDef edc:cname="DGST" edc:nzwidth="0x20" edc:desc="A Read-Only FIFO Portal to Hash digest result. 12 or 8 Dwords depending on algorithm."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON1" edc:cname="LT_MON1LM_CTRLSTS" edc:nzwidth="0x20" edc:access="--------------------nnnn----nnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0xF0F" edc:_addr="0x4001066C">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON1">
            <edc:SFRFieldDef edc:cname="W" edc:nzwidth="0x1" edc:desc="Waiting"/>
            <edc:SFRFieldDef edc:cname="B" edc:nzwidth="0x1" edc:desc="Begin Byte seen"/>
            <edc:SFRFieldDef edc:cname="E" edc:nzwidth="0x1" edc:desc="End Byte seen"/>
            <edc:SFRFieldDef edc:cname="F" edc:nzwidth="0x1" edc:desc="Finalized and result ready"/>
            <edc:AdjustPoint edc:offset="0x4"/>
            <edc:SFRFieldDef edc:cname="W_INTEN" edc:nzwidth="0x1" edc:desc="Enable Waiting Interrupt"/>
            <edc:SFRFieldDef edc:cname="B_INTEN" edc:nzwidth="0x1" edc:desc="Enable Begin Byte seen Interrupt"/>
            <edc:SFRFieldDef edc:cname="E_INTEN" edc:nzwidth="0x1" edc:desc="Enable End Byte seen Interrupt"/>
            <edc:SFRFieldDef edc:cname="F_INTEN" edc:nzwidth="0x1" edc:desc="Enable Finalized and result ready Interrupt"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON1" edc:cname="LT_MON1LM_CHN_CTRL" edc:nzwidth="0x20" edc:access="--------------------nnnn-----nnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0xF07" edc:_addr="0x40010670">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON1">
            <edc:SFRFieldDef edc:cname="GO" edc:nzwidth="0x1" edc:desc="GO: Run the Load Monitor for this channel"/>
            <edc:SFRFieldDef edc:cname="RST" edc:nzwidth="0x1" edc:desc="RST: Stop and Reset calculation for this channel when set to 1"/>
            <edc:SFRFieldDef edc:cname="RSF" edc:nzwidth="0x1" edc:desc="RSF: Reset just Result FIFO pointer when this bit is set to 1"/>
            <edc:AdjustPoint edc:offset="0x5"/>
            <edc:SFRFieldDef edc:cname="FPTR" edc:nzwidth="0x4" edc:desc="FPTR: Result FIFO pointer. In 32Bit. Ranges: 0 to 11 for SHA-384 result 0 to 7 for SHA-256 result"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON1" edc:cname="LT_MON1LM_BEGIN" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x40010674">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON1">
            <edc:SFRFieldDef edc:cname="BADDR" edc:nzwidth="0x1F" edc:desc="A byte address within the designated Flash, specifying the first byte of the load image."/>
            <edc:SFRFieldDef edc:cname="DV" edc:nzwidth="0x1" edc:desc="Flash Device number, applying to both Begin and End fields. 0 = CS0#, 1 = CS1#"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON1" edc:cname="LT_MON1LM_END" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x40010678">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON1">
            <edc:SFRFieldDef edc:cname="EADDR" edc:nzwidth="0x20" edc:desc="A byte address within the designated Flash, specifying the last byte of the load image."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON1" edc:cname="LT_MON1LM_COUNT" edc:nzwidth="0x20" edc:access="rrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrr" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x4001067C">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON1">
            <edc:SFRFieldDef edc:cname="CNT" edc:nzwidth="0x20" edc:desc="A Read-Only count of bytes processed."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON1" edc:cname="LT_MON1LM_DIGEST" edc:nzwidth="0x20" edc:access="rrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrr" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x40010680">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON1">
            <edc:SFRFieldDef edc:cname="DGST" edc:nzwidth="0x20" edc:desc="A Read-Only FIFO Portal to Hash digest result. 12 or 8 Dwords depending on algorithm."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON1" edc:cname="LT_MON2LM_CTRLSTS" edc:nzwidth="0x20" edc:access="--------------------nnnn----nnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0xF0F" edc:_addr="0x40010684">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON1">
            <edc:SFRFieldDef edc:cname="W" edc:nzwidth="0x1" edc:desc="Waiting"/>
            <edc:SFRFieldDef edc:cname="B" edc:nzwidth="0x1" edc:desc="Begin Byte seen"/>
            <edc:SFRFieldDef edc:cname="E" edc:nzwidth="0x1" edc:desc="End Byte seen"/>
            <edc:SFRFieldDef edc:cname="F" edc:nzwidth="0x1" edc:desc="Finalized and result ready"/>
            <edc:AdjustPoint edc:offset="0x4"/>
            <edc:SFRFieldDef edc:cname="W_INTEN" edc:nzwidth="0x1" edc:desc="Enable Waiting Interrupt"/>
            <edc:SFRFieldDef edc:cname="B_INTEN" edc:nzwidth="0x1" edc:desc="Enable Begin Byte seen Interrupt"/>
            <edc:SFRFieldDef edc:cname="E_INTEN" edc:nzwidth="0x1" edc:desc="Enable End Byte seen Interrupt"/>
            <edc:SFRFieldDef edc:cname="F_INTEN" edc:nzwidth="0x1" edc:desc="Enable Finalized and result ready Interrupt"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON1" edc:cname="LT_MON2LM_CHN_CTRL" edc:nzwidth="0x20" edc:access="--------------------nnnn-----nnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0xF07" edc:_addr="0x40010688">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON1">
            <edc:SFRFieldDef edc:cname="GO" edc:nzwidth="0x1" edc:desc="GO: Run the Load Monitor for this channel"/>
            <edc:SFRFieldDef edc:cname="RST" edc:nzwidth="0x1" edc:desc="RST: Stop and Reset calculation for this channel when set to 1"/>
            <edc:SFRFieldDef edc:cname="RSF" edc:nzwidth="0x1" edc:desc="RSF: Reset just Result FIFO pointer when this bit is set to 1"/>
            <edc:AdjustPoint edc:offset="0x5"/>
            <edc:SFRFieldDef edc:cname="FPTR" edc:nzwidth="0x4" edc:desc="FPTR: Result FIFO pointer. In 32Bit. Ranges: 0 to 11 for SHA-384 result 0 to 7 for SHA-256 result"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON1" edc:cname="LT_MON2LM_BEGIN" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x4001068C">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON1">
            <edc:SFRFieldDef edc:cname="BADDR" edc:nzwidth="0x1F" edc:desc="A byte address within the designated Flash, specifying the first byte of the load image."/>
            <edc:SFRFieldDef edc:cname="DV" edc:nzwidth="0x1" edc:desc="Flash Device number, applying to both Begin and End fields. 0 = CS0#, 1 = CS1#"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON1" edc:cname="LT_MON2LM_END" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x40010690">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON1">
            <edc:SFRFieldDef edc:cname="EADDR" edc:nzwidth="0x20" edc:desc="A byte address within the designated Flash, specifying the last byte of the load image."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON1" edc:cname="LT_MON2LM_COUNT" edc:nzwidth="0x20" edc:access="rrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrr" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x40010694">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON1">
            <edc:SFRFieldDef edc:cname="CNT" edc:nzwidth="0x20" edc:desc="A Read-Only count of bytes processed."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON1" edc:cname="LT_MON2LM_DIGEST" edc:nzwidth="0x20" edc:access="rrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrr" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x40010698">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON1">
            <edc:SFRFieldDef edc:cname="DGST" edc:nzwidth="0x20" edc:desc="A Read-Only FIFO Portal to Hash digest result. 12 or 8 Dwords depending on algorithm."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON1" edc:cname="LT_MON3LM_CTRLSTS" edc:nzwidth="0x20" edc:access="--------------------nnnn----nnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0xF0F" edc:_addr="0x4001069C">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON1">
            <edc:SFRFieldDef edc:cname="W" edc:nzwidth="0x1" edc:desc="Waiting"/>
            <edc:SFRFieldDef edc:cname="B" edc:nzwidth="0x1" edc:desc="Begin Byte seen"/>
            <edc:SFRFieldDef edc:cname="E" edc:nzwidth="0x1" edc:desc="End Byte seen"/>
            <edc:SFRFieldDef edc:cname="F" edc:nzwidth="0x1" edc:desc="Finalized and result ready"/>
            <edc:AdjustPoint edc:offset="0x4"/>
            <edc:SFRFieldDef edc:cname="W_INTEN" edc:nzwidth="0x1" edc:desc="Enable Waiting Interrupt"/>
            <edc:SFRFieldDef edc:cname="B_INTEN" edc:nzwidth="0x1" edc:desc="Enable Begin Byte seen Interrupt"/>
            <edc:SFRFieldDef edc:cname="E_INTEN" edc:nzwidth="0x1" edc:desc="Enable End Byte seen Interrupt"/>
            <edc:SFRFieldDef edc:cname="F_INTEN" edc:nzwidth="0x1" edc:desc="Enable Finalized and result ready Interrupt"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON1" edc:cname="LT_MON3LM_CHN_CTRL" edc:nzwidth="0x20" edc:access="--------------------nnnn-----nnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0xF07" edc:_addr="0x400106A0">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON1">
            <edc:SFRFieldDef edc:cname="GO" edc:nzwidth="0x1" edc:desc="GO: Run the Load Monitor for this channel"/>
            <edc:SFRFieldDef edc:cname="RST" edc:nzwidth="0x1" edc:desc="RST: Stop and Reset calculation for this channel when set to 1"/>
            <edc:SFRFieldDef edc:cname="RSF" edc:nzwidth="0x1" edc:desc="RSF: Reset just Result FIFO pointer when this bit is set to 1"/>
            <edc:AdjustPoint edc:offset="0x5"/>
            <edc:SFRFieldDef edc:cname="FPTR" edc:nzwidth="0x4" edc:desc="FPTR: Result FIFO pointer. In 32Bit. Ranges: 0 to 11 for SHA-384 result 0 to 7 for SHA-256 result"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON1" edc:cname="LT_MON3LM_BEGIN" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x400106A4">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON1">
            <edc:SFRFieldDef edc:cname="BADDR" edc:nzwidth="0x1F" edc:desc="A byte address within the designated Flash, specifying the first byte of the load image."/>
            <edc:SFRFieldDef edc:cname="DV" edc:nzwidth="0x1" edc:desc="Flash Device number, applying to both Begin and End fields. 0 = CS0#, 1 = CS1#"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON1" edc:cname="LT_MON3LM_END" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x400106A8">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON1">
            <edc:SFRFieldDef edc:cname="EADDR" edc:nzwidth="0x20" edc:desc="A byte address within the designated Flash, specifying the last byte of the load image."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON1" edc:cname="LT_MON3LM_COUNT" edc:nzwidth="0x20" edc:access="rrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrr" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x400106AC">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON1">
            <edc:SFRFieldDef edc:cname="CNT" edc:nzwidth="0x20" edc:desc="A Read-Only count of bytes processed."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON1" edc:cname="LT_MON3LM_DIGEST" edc:nzwidth="0x20" edc:access="rrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrr" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x400106B0">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON1">
            <edc:SFRFieldDef edc:cname="DGST" edc:nzwidth="0x20" edc:desc="A Read-Only FIFO Portal to Hash digest result. 12 or 8 Dwords depending on algorithm."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON1" edc:cname="LT_MON4LM_CTRLSTS" edc:nzwidth="0x20" edc:access="--------------------nnnn----nnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0xF0F" edc:_addr="0x400106B4">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON1">
            <edc:SFRFieldDef edc:cname="W" edc:nzwidth="0x1" edc:desc="Waiting"/>
            <edc:SFRFieldDef edc:cname="B" edc:nzwidth="0x1" edc:desc="Begin Byte seen"/>
            <edc:SFRFieldDef edc:cname="E" edc:nzwidth="0x1" edc:desc="End Byte seen"/>
            <edc:SFRFieldDef edc:cname="F" edc:nzwidth="0x1" edc:desc="Finalized and result ready"/>
            <edc:AdjustPoint edc:offset="0x4"/>
            <edc:SFRFieldDef edc:cname="W_INTEN" edc:nzwidth="0x1" edc:desc="Enable Waiting Interrupt"/>
            <edc:SFRFieldDef edc:cname="B_INTEN" edc:nzwidth="0x1" edc:desc="Enable Begin Byte seen Interrupt"/>
            <edc:SFRFieldDef edc:cname="E_INTEN" edc:nzwidth="0x1" edc:desc="Enable End Byte seen Interrupt"/>
            <edc:SFRFieldDef edc:cname="F_INTEN" edc:nzwidth="0x1" edc:desc="Enable Finalized and result ready Interrupt"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON1" edc:cname="LT_MON4LM_CHN_CTRL" edc:nzwidth="0x20" edc:access="--------------------nnnn-----nnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0xF07" edc:_addr="0x400106B8">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON1">
            <edc:SFRFieldDef edc:cname="GO" edc:nzwidth="0x1" edc:desc="GO: Run the Load Monitor for this channel"/>
            <edc:SFRFieldDef edc:cname="RST" edc:nzwidth="0x1" edc:desc="RST: Stop and Reset calculation for this channel when set to 1"/>
            <edc:SFRFieldDef edc:cname="RSF" edc:nzwidth="0x1" edc:desc="RSF: Reset just Result FIFO pointer when this bit is set to 1"/>
            <edc:AdjustPoint edc:offset="0x5"/>
            <edc:SFRFieldDef edc:cname="FPTR" edc:nzwidth="0x4" edc:desc="FPTR: Result FIFO pointer. In 32Bit. Ranges: 0 to 11 for SHA-384 result 0 to 7 for SHA-256 result"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON1" edc:cname="LT_MON4LM_BEGIN" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x400106BC">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON1">
            <edc:SFRFieldDef edc:cname="BADDR" edc:nzwidth="0x1F" edc:desc="A byte address within the designated Flash, specifying the first byte of the load image."/>
            <edc:SFRFieldDef edc:cname="DV" edc:nzwidth="0x1" edc:desc="Flash Device number, applying to both Begin and End fields. 0 = CS0#, 1 = CS1#"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON1" edc:cname="LT_MON4LM_END" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x400106C0">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON1">
            <edc:SFRFieldDef edc:cname="EADDR" edc:nzwidth="0x20" edc:desc="A byte address within the designated Flash, specifying the last byte of the load image."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON1" edc:cname="LT_MON4LM_COUNT" edc:nzwidth="0x20" edc:access="rrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrr" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x400106C4">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON1">
            <edc:SFRFieldDef edc:cname="CNT" edc:nzwidth="0x20" edc:desc="A Read-Only count of bytes processed."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON1" edc:cname="LT_MON4LM_DIGEST" edc:nzwidth="0x20" edc:access="rrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrr" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x400106C8">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON1">
            <edc:SFRFieldDef edc:cname="DGST" edc:nzwidth="0x20" edc:desc="A Read-Only FIFO Portal to Hash digest result. 12 or 8 Dwords depending on algorithm."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON1" edc:cname="LT_MON5LM_CTRLSTS" edc:nzwidth="0x20" edc:access="--------------------nnnn----nnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0xF0F" edc:_addr="0x400106CC">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON1">
            <edc:SFRFieldDef edc:cname="W" edc:nzwidth="0x1" edc:desc="Waiting"/>
            <edc:SFRFieldDef edc:cname="B" edc:nzwidth="0x1" edc:desc="Begin Byte seen"/>
            <edc:SFRFieldDef edc:cname="E" edc:nzwidth="0x1" edc:desc="End Byte seen"/>
            <edc:SFRFieldDef edc:cname="F" edc:nzwidth="0x1" edc:desc="Finalized and result ready"/>
            <edc:AdjustPoint edc:offset="0x4"/>
            <edc:SFRFieldDef edc:cname="W_INTEN" edc:nzwidth="0x1" edc:desc="Enable Waiting Interrupt"/>
            <edc:SFRFieldDef edc:cname="B_INTEN" edc:nzwidth="0x1" edc:desc="Enable Begin Byte seen Interrupt"/>
            <edc:SFRFieldDef edc:cname="E_INTEN" edc:nzwidth="0x1" edc:desc="Enable End Byte seen Interrupt"/>
            <edc:SFRFieldDef edc:cname="F_INTEN" edc:nzwidth="0x1" edc:desc="Enable Finalized and result ready Interrupt"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON1" edc:cname="LT_MON5LM_CHN_CTRL" edc:nzwidth="0x20" edc:access="--------------------nnnn-----nnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0xF07" edc:_addr="0x400106D0">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON1">
            <edc:SFRFieldDef edc:cname="GO" edc:nzwidth="0x1" edc:desc="GO: Run the Load Monitor for this channel"/>
            <edc:SFRFieldDef edc:cname="RST" edc:nzwidth="0x1" edc:desc="RST: Stop and Reset calculation for this channel when set to 1"/>
            <edc:SFRFieldDef edc:cname="RSF" edc:nzwidth="0x1" edc:desc="RSF: Reset just Result FIFO pointer when this bit is set to 1"/>
            <edc:AdjustPoint edc:offset="0x5"/>
            <edc:SFRFieldDef edc:cname="FPTR" edc:nzwidth="0x4" edc:desc="FPTR: Result FIFO pointer. In 32Bit. Ranges: 0 to 11 for SHA-384 result 0 to 7 for SHA-256 result"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON1" edc:cname="LT_MON5LM_BEGIN" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x400106D4">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON1">
            <edc:SFRFieldDef edc:cname="BADDR" edc:nzwidth="0x1F" edc:desc="A byte address within the designated Flash, specifying the first byte of the load image."/>
            <edc:SFRFieldDef edc:cname="DV" edc:nzwidth="0x1" edc:desc="Flash Device number, applying to both Begin and End fields. 0 = CS0#, 1 = CS1#"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON1" edc:cname="LT_MON5LM_END" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x400106D8">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON1">
            <edc:SFRFieldDef edc:cname="EADDR" edc:nzwidth="0x20" edc:desc="A byte address within the designated Flash, specifying the last byte of the load image."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON1" edc:cname="LT_MON5LM_COUNT" edc:nzwidth="0x20" edc:access="rrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrr" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x400106DC">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON1">
            <edc:SFRFieldDef edc:cname="CNT" edc:nzwidth="0x20" edc:desc="A Read-Only count of bytes processed."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON1" edc:cname="LT_MON5LM_DIGEST" edc:nzwidth="0x20" edc:access="rrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrr" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x400106E0">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON1">
            <edc:SFRFieldDef edc:cname="DGST" edc:nzwidth="0x20" edc:desc="A Read-Only FIFO Portal to Hash digest result. 12 or 8 Dwords depending on algorithm."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON1" edc:cname="LT_MON6LM_CTRLSTS" edc:nzwidth="0x20" edc:access="--------------------nnnn----nnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0xF0F" edc:_addr="0x400106E4">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON1">
            <edc:SFRFieldDef edc:cname="W" edc:nzwidth="0x1" edc:desc="Waiting"/>
            <edc:SFRFieldDef edc:cname="B" edc:nzwidth="0x1" edc:desc="Begin Byte seen"/>
            <edc:SFRFieldDef edc:cname="E" edc:nzwidth="0x1" edc:desc="End Byte seen"/>
            <edc:SFRFieldDef edc:cname="F" edc:nzwidth="0x1" edc:desc="Finalized and result ready"/>
            <edc:AdjustPoint edc:offset="0x4"/>
            <edc:SFRFieldDef edc:cname="W_INTEN" edc:nzwidth="0x1" edc:desc="Enable Waiting Interrupt"/>
            <edc:SFRFieldDef edc:cname="B_INTEN" edc:nzwidth="0x1" edc:desc="Enable Begin Byte seen Interrupt"/>
            <edc:SFRFieldDef edc:cname="E_INTEN" edc:nzwidth="0x1" edc:desc="Enable End Byte seen Interrupt"/>
            <edc:SFRFieldDef edc:cname="F_INTEN" edc:nzwidth="0x1" edc:desc="Enable Finalized and result ready Interrupt"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON1" edc:cname="LT_MON6LM_CHN_CTRL" edc:nzwidth="0x20" edc:access="--------------------nnnn-----nnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0xF07" edc:_addr="0x400106E8">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON1">
            <edc:SFRFieldDef edc:cname="GO" edc:nzwidth="0x1" edc:desc="GO: Run the Load Monitor for this channel"/>
            <edc:SFRFieldDef edc:cname="RST" edc:nzwidth="0x1" edc:desc="RST: Stop and Reset calculation for this channel when set to 1"/>
            <edc:SFRFieldDef edc:cname="RSF" edc:nzwidth="0x1" edc:desc="RSF: Reset just Result FIFO pointer when this bit is set to 1"/>
            <edc:AdjustPoint edc:offset="0x5"/>
            <edc:SFRFieldDef edc:cname="FPTR" edc:nzwidth="0x4" edc:desc="FPTR: Result FIFO pointer. In 32Bit. Ranges: 0 to 11 for SHA-384 result 0 to 7 for SHA-256 result"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON1" edc:cname="LT_MON6LM_BEGIN" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x400106EC">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON1">
            <edc:SFRFieldDef edc:cname="BADDR" edc:nzwidth="0x1F" edc:desc="A byte address within the designated Flash, specifying the first byte of the load image."/>
            <edc:SFRFieldDef edc:cname="DV" edc:nzwidth="0x1" edc:desc="Flash Device number, applying to both Begin and End fields. 0 = CS0#, 1 = CS1#"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON1" edc:cname="LT_MON6LM_END" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x400106F0">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON1">
            <edc:SFRFieldDef edc:cname="EADDR" edc:nzwidth="0x20" edc:desc="A byte address within the designated Flash, specifying the last byte of the load image."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON1" edc:cname="LT_MON6LM_COUNT" edc:nzwidth="0x20" edc:access="rrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrr" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x400106F4">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON1">
            <edc:SFRFieldDef edc:cname="CNT" edc:nzwidth="0x20" edc:desc="A Read-Only count of bytes processed."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON1" edc:cname="LT_MON6LM_DIGEST" edc:nzwidth="0x20" edc:access="rrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrr" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x400106F8">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON1">
            <edc:SFRFieldDef edc:cname="DGST" edc:nzwidth="0x20" edc:desc="A Read-Only FIFO Portal to Hash digest result. 12 or 8 Dwords depending on algorithm."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON1" edc:cname="LT_MON7LM_CTRLSTS" edc:nzwidth="0x20" edc:access="--------------------nnnn----nnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0xF0F" edc:_addr="0x400106FC">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON1">
            <edc:SFRFieldDef edc:cname="W" edc:nzwidth="0x1" edc:desc="Waiting"/>
            <edc:SFRFieldDef edc:cname="B" edc:nzwidth="0x1" edc:desc="Begin Byte seen"/>
            <edc:SFRFieldDef edc:cname="E" edc:nzwidth="0x1" edc:desc="End Byte seen"/>
            <edc:SFRFieldDef edc:cname="F" edc:nzwidth="0x1" edc:desc="Finalized and result ready"/>
            <edc:AdjustPoint edc:offset="0x4"/>
            <edc:SFRFieldDef edc:cname="W_INTEN" edc:nzwidth="0x1" edc:desc="Enable Waiting Interrupt"/>
            <edc:SFRFieldDef edc:cname="B_INTEN" edc:nzwidth="0x1" edc:desc="Enable Begin Byte seen Interrupt"/>
            <edc:SFRFieldDef edc:cname="E_INTEN" edc:nzwidth="0x1" edc:desc="Enable End Byte seen Interrupt"/>
            <edc:SFRFieldDef edc:cname="F_INTEN" edc:nzwidth="0x1" edc:desc="Enable Finalized and result ready Interrupt"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON1" edc:cname="LT_MON7LM_CHN_CTRL" edc:nzwidth="0x20" edc:access="--------------------nnnn-----nnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0xF07" edc:_addr="0x40010700">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON1">
            <edc:SFRFieldDef edc:cname="GO" edc:nzwidth="0x1" edc:desc="GO: Run the Load Monitor for this channel"/>
            <edc:SFRFieldDef edc:cname="RST" edc:nzwidth="0x1" edc:desc="RST: Stop and Reset calculation for this channel when set to 1"/>
            <edc:SFRFieldDef edc:cname="RSF" edc:nzwidth="0x1" edc:desc="RSF: Reset just Result FIFO pointer when this bit is set to 1"/>
            <edc:AdjustPoint edc:offset="0x5"/>
            <edc:SFRFieldDef edc:cname="FPTR" edc:nzwidth="0x4" edc:desc="FPTR: Result FIFO pointer. In 32Bit. Ranges: 0 to 11 for SHA-384 result 0 to 7 for SHA-256 result"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON1" edc:cname="LT_MON7LM_BEGIN" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x40010704">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON1">
            <edc:SFRFieldDef edc:cname="BADDR" edc:nzwidth="0x1F" edc:desc="A byte address within the designated Flash, specifying the first byte of the load image."/>
            <edc:SFRFieldDef edc:cname="DV" edc:nzwidth="0x1" edc:desc="Flash Device number, applying to both Begin and End fields. 0 = CS0#, 1 = CS1#"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON1" edc:cname="LT_MON7LM_END" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x40010708">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON1">
            <edc:SFRFieldDef edc:cname="EADDR" edc:nzwidth="0x20" edc:desc="A byte address within the designated Flash, specifying the last byte of the load image."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON1" edc:cname="LT_MON7LM_COUNT" edc:nzwidth="0x20" edc:access="rrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrr" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x4001070C">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON1">
            <edc:SFRFieldDef edc:cname="CNT" edc:nzwidth="0x20" edc:desc="A Read-Only count of bytes processed."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON1" edc:cname="LT_MON7LM_DIGEST" edc:nzwidth="0x20" edc:access="rrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrr" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x40010710">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON1">
            <edc:SFRFieldDef edc:cname="DGST" edc:nzwidth="0x20" edc:desc="A Read-Only FIFO Portal to Hash digest result. 12 or 8 Dwords depending on algorithm."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SPI_MON1" edc:cname="LTMON_CTRLSTS" edc:nzwidth="0x20" edc:access="-----------------------n----nnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x10F" edc:_addr="0x40010714">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SPI_MON1">
            <edc:SFRFieldDef edc:cname="FIFO_MTY" edc:nzwidth="0x1" edc:desc="FIFO Empty"/>
            <edc:SFRFieldDef edc:cname="FIFO_FUL" edc:nzwidth="0x1" edc:desc="FIFO Full"/>
            <edc:SFRFieldDef edc:cname="FIFO_OVRF" edc:nzwidth="0x1" edc:desc="FIFO Overflow"/>
            <edc:SFRFieldDef edc:cname="FIFO_UDRF" edc:nzwidth="0x1" edc:desc="FIFO Underflow"/>
            <edc:AdjustPoint edc:offset="0x4"/>
            <edc:SFRFieldDef edc:cname="CLR_FIFO" edc:nzwidth="0x1" edc:desc="Clear FIFO "/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:AdjustPoint edc:offset="0x5F8E8" edc:_addr="0x40010718"/>
      <edc:SFRDef ltx:memberofperipheral="QMSPI0" edc:cname="MODE" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnn--nn-nnn---nnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0xFFFF371F" edc:_addr="0x40070000">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="QMSPI0">
            <edc:SFRFieldDef edc:cname="ACT" edc:nzwidth="0x1" edc:desc="This bit is used to activate the QMSPI block.     1=Enabled. The block is fully operational                 0=Disabled. Clocks are gated to conserve power and the output signals are set to their inactive state."/>
            <edc:SFRFieldDef edc:cname="SOFT_RESET" edc:nzwidth="0x1" edc:desc="Writing this bit with a 1 will reset the Quad SPI block. It is self-clearing."/>
            <edc:SFRFieldDef edc:cname="DMA_UNLGND_MOD" edc:nzwidth="0x1" edc:desc="When enabled the DMA is allowed to operate w/ unaligned transfer lengths."/>
            <edc:SFRFieldDef edc:cname="LDMA_RXEN" edc:nzwidth="0x1" edc:desc="This enables the Local DMA RX usage (instead of the Central DMA) when the Control register enables the DMA."/>
            <edc:SFRFieldDef edc:cname="LDMA_TXEN" edc:nzwidth="0x1" edc:desc="This enables the Local DMA TX usage (instead of the Central DMA) when the Control register enables the DMA."/>
            <edc:AdjustPoint edc:offset="0x3"/>
            <edc:SFRFieldDef edc:cname="CPOL" edc:nzwidth="0x1" edc:desc="Polarity of the SPI clock line when there are no transactions in process. 1=SPI Clock starts High; 0=SPI Clock starts Low."/>
            <edc:SFRFieldDef edc:cname="CHPA_MOSI" edc:nzwidth="0x1" edc:desc="Clock phase of the Master data out. Common SPI modes require this field to be programmed with the same value as CHPA_MISO in this register.     e.g. Mode 0: CPOL=0; CHPA_MISO=0; CHPA_MOSI=0; Mode 3: CPOL=1; CHPA_MISO=1; CHPA_MOSI=1. See datasheet for alternate mode settings.                 If CPOL=1: 1=Data changes on the falling edge of the SPI clock; 0=Data changes on the rising edge of the SPI clock                 If CPOL=0: 1=Data changes on the rising edge of the SPI clock; 0=Data changes on the falling edge of the SPI clock"/>
            <edc:SFRFieldDef edc:cname="CHPA_MISO" edc:nzwidth="0x1" edc:desc="Clock phase of the Master data in. Common SPI modes require this field to be programmed with the same value as CHPA_MOSI in this register.     e.g. Mode 0: CPOL=0; CHPA_MISO=0; CHPA_MOSI=0; Mode 3: CPOL=1; CHPA_MISO=1; CHPA_MOSI=1. See datasheet for alternate mode settings.                 If CPOL=1: 1=Data are captured on the rising edge of the SPI clock; 0=Data are captured on the falling edge of the SPI clock                 If CPOL=0: 1=Data are captured on the falling edge of the SPI clock; 0=Data are captured on the rising edge of the SPI clock"/>
            <edc:AdjustPoint edc:offset="0x1"/>
            <edc:SFRFieldDef edc:cname="CS" edc:nzwidth="0x2" edc:desc="This defines which Chip Select will be used by the H/W when doing a transfer."/>
            <edc:AdjustPoint edc:offset="0x2"/>
            <edc:SFRFieldDef edc:cname="CLK_DIV" edc:nzwidth="0x10" edc:desc="The SPI clock divide in number of system clocks. A value of 1 divides the master clock by 1, a value of 255 divides the master clock by 255. A value of 0 divides the master clock by 256."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="QMSPI0" edc:cname="CTRL" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x40070004">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="QMSPI0">
            <edc:SFRFieldDef edc:cname="TX_MODE" edc:nzwidth="0x2" edc:desc="This field sets the transmission mode. If this field is set for Dual Mode or Quad Mode then either      TX_TRANSFER_ENABLE or RX_TRANSFER_ENABLE must be 0.                  3=Reserved; 2=Quad Mode; 1=Dual Mode; 0=Single/Duplex Mode."/>
            <edc:SFRFieldDef edc:cname="TX_TRANS_EN" edc:nzwidth="0x2" edc:desc="This field bit selects the transmit function of the SPI interface.                 3=Transmit Enabled in 1 Mode. The MOSI or IO Bus will send out only 1's. The Transmit Buffer will not be used.                 2=Transmit Enabled in 0 Mode. The MOSI or IO Bus will send out only 0's. The Transmit Buffer will not be used.                 1=Transmit Enabled. Data will be fetched from the Transmit Buffer and sent out on the MOSI or IO Bus.                 0=Transmit is Disabled. Not data is sent. This will cause the MOSI be to be undriven, or the IO bus to be undriven if Receive is also disabled."/>
            <edc:SFRFieldDef edc:cname="TX_DMA_EN" edc:nzwidth="0x2" edc:desc="This bit enables DMA support for Transmit Transfer. If enabled, DMA will be requested to fill the FIFO until either     the interface reaches TRANSFER_LENGTH or the DMA sends a termination request. The size defined here must match DMA programmed access size.     1=DMA is enabled.and set to 1 Byte                 2=DMA is enabled and set to 2 Bytes                 3=DMA is enabled and set to 4 Bytes.     0=DMA is disabled. All data in the Transmit Buffer must be emptied by firmware"/>
            <edc:SFRFieldDef edc:cname="RX_TRANS_EN" edc:nzwidth="0x1" edc:desc="This bit enables the receive function of the SPI interface.                 1=Receive is enabled. Data received from the SPI Slave is stored in the Receive Buffer                 0=Receive is disabled"/>
            <edc:SFRFieldDef edc:cname="RX_DMA_EN" edc:nzwidth="0x2" edc:desc="This bit enables DMA support for Receive Transfer. If enabled, DMA will be requested to empty the FIFO until either the interface                 reaches TRANSFER_LENGTH or the DMA sends a termination request. The size defined here must match DMA programmed access size.                 1=DMA is enabled.and set to 1 Byte                 2=DMA is enabled and set to 2 Bytes                 3=DMA is enabled and set to 4 Bytes                 0=DMA is disabled. All data in the Receive Buffer must be emptied by firmware"/>
            <edc:SFRFieldDef edc:cname="CLOSE_TRANS_EN" edc:nzwidth="0x1" edc:desc="This selects what action is taken at the end of a transfer. When the transaction closes, the Chip Select de-asserts, the SPI      interface returns to IDLE and the DMA interface terminates When Description Buffers are in use this bit must be set only on the Last Buffer.     1=The transaction is terminated     0=The transaction is not terminated"/>
            <edc:SFRFieldDef edc:cname="TRANS_UNITS" edc:nzwidth="0x2" edc:desc="3=TRANSFER_LENGTH defined in units of 16-byte segments     2=TRANSFER_LENGTH defined in units of 4-byte segments     1=TRANSFER_LENGTH defined in units of bytes     0=TRANSFER_LENGTH defined in units of bits."/>
            <edc:SFRFieldDef edc:cname="DESCR_BUFF_PTR" edc:nzwidth="0x4" edc:desc="This field selects the first buffer used if Description Buffers are enabled."/>
            <edc:SFRFieldDef edc:cname="DESCR_BUFF_EN" edc:nzwidth="0x1" edc:desc="This enables the Description Buffers to be used.     1=Description Buffers in use. The first buffer is defined in DESCRIPTION_BUFFER_POINTER     0=Description Buffers disabled."/>
            <edc:SFRFieldDef edc:cname="TRANS_LEN" edc:nzwidth="0xF" edc:desc="The length of the SPI transfer. The count is in bytes or bits, depending on the value of TRANSFER_LENGTH_BITS.     A value of 0 means an infinite length transfer."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="QMSPI0" edc:cname="EXE" edc:nzwidth="0x20" edc:access="-----------------------------nnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x7" edc:_addr="0x40070008">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="QMSPI0">
            <edc:SFRFieldDef edc:cname="START" edc:nzwidth="0x1" edc:desc="Writing a 1 to this bit will start the SPI transfer. Writing a 0 to this bit has no effect. This bit is self-clearing.     This bit must not be set to 1 if the field STOP in this register is set to 1."/>
            <edc:SFRFieldDef edc:cname="STOP" edc:nzwidth="0x1" edc:desc="Writing a 1 to this bit will stop any transfer in progress at the next byte boundary. Writing a 0 to this bit has no effect.     This bit is self clearing. This bit must not be set to 1 if the field START in this register is set to 1."/>
            <edc:SFRFieldDef edc:cname="CLR_DAT_BUFF" edc:nzwidth="0x1" edc:desc="Writing a 1 to this bit will clear out the Transmit and Receive FIFOs. Any data stored in the FIFOs is discarded and all count fields are reset.     Writing a 0 to this bit has no effect. This bit is self clearing."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="QMSPI0" edc:cname="IFCTRL" edc:nzwidth="0x20" edc:access="------------------------nnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0xFF" edc:_addr="0x4007000C">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="QMSPI0">
            <edc:SFRFieldDef edc:cname="WR_PRCT_OUT_VAL" edc:nzwidth="0x1" edc:desc="This bit sets the value on the WRITE PROTECT SPI Output Port if it is driven.                 1=WRITE PROTECT is driven to 1; 0=WRITE PROTECT is driven to 0"/>
            <edc:SFRFieldDef edc:cname="WR_PRCT_OUT_EN" edc:nzwidth="0x1" edc:desc="1=WRITE PROTECT SPI Output Port is driven                 0=WRITE PROTECT SPI Output Port is not driven"/>
            <edc:SFRFieldDef edc:cname="HLD_OUT_VAL" edc:nzwidth="0x1" edc:desc="This bit sets the value on the HOLD SPI Output Port if it is driven.                 1=HOLD is driven to 1; 0=HOLD is driven to 0."/>
            <edc:SFRFieldDef edc:cname="HLD_OUT_EN" edc:nzwidth="0x1" edc:desc="1=HOLD SPI Output Port is driven                 0=HOLD SPI Output Port is not driven."/>
            <edc:SFRFieldDef edc:cname="PD_ON_NOT_SEL" edc:nzwidth="0x1" edc:desc="1=Enable pull-down resistors on Receive pins while the SPI Chip Select signal is not asserted     0=No pull-down resistors enabled on Receive pins"/>
            <edc:SFRFieldDef edc:cname="PU_ON_NOTSEL" edc:nzwidth="0x1" edc:desc="1=Enable pull-up resistors on Receive pins while the SPI Chip Select signal is not asserted     0=No pull-up resistors enabled on Receive pins."/>
            <edc:SFRFieldDef edc:cname="PD_ON_NOTDRIVEN" edc:nzwidth="0x1" edc:desc="1=Enable pull-down resistors on Transmit pins while the pins are not driven     0=No pull-down resistors enabled ion Transmit pins."/>
            <edc:SFRFieldDef edc:cname="PU_ON_NOTDRIVEN" edc:nzwidth="0x1" edc:desc="1=Enable pull-up resistors on Transmit pins while the pins are not driven     0=No pull-up resistors enabled ion Transmit pins."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="QMSPI0" edc:cname="STS" edc:nzwidth="0x20" edc:access="----nnnn-------nnnnnnnnn-nnnnnnn" edc:por="00000000000000000010001000000000" edc:mclr="00000000000000000010001000000000" edc:impl="0xF01FF7F" edc:_addr="0x40070010">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="QMSPI0">
            <edc:SFRFieldDef edc:cname="TRANS_COMPL" edc:nzwidth="0x1" edc:desc="In Manual Mode (neither DMA nor Description Buffers are enabled), this bit will be set to 1 when the transfer matches TRANSFER_LENGTH.                 If DMA Mode is enabled, this bit will be set to 1 when DMA_COMPLETE is set to 1. In Description Buffer Mode, this bit will be set to 1 only when the Last Buffer completes its transfer.     In all cases, this bit will be set to 1 if the STOP bit is set to 1 and the controller has completed the current 8 bits being copied.                 1=Transfer completed; 0=Transfer not complete."/>
            <edc:SFRFieldDef edc:cname="DMA_COMPL" edc:nzwidth="0x1" edc:desc="This field has no meaning if DMA is not enabled. This bit will be set to 1 when the DMA controller asserts the DONE signal to the SPI controller.     This occurs either when the SPI controller has closed the DMA transfer, or the DMA channel has completed its count. If both Transmit and Receive DMA transfers are      active, then this bit will only assert after both have completed. If CLOSE_TRANSFER_ENABLE is enabled, DMA_COMPLETE and TRANSFER_COMPLETE will be asserted simultaneously.     This status is not inhibited by the description buffers, so it can fire on all valid description buffers while operating in that mode.                 1=DMA completed; 0=DMA not completed."/>
            <edc:SFRFieldDef edc:cname="TX_BUFF_ERR" edc:nzwidth="0x1" edc:desc="1=Overflow error occurred (attempt to write to a full Transmit Buffer)                 0=No overflow occurred."/>
            <edc:SFRFieldDef edc:cname="RX_BUFF_ERR" edc:nzwidth="0x1" edc:desc="1=Underflow error occurred (attempt to read from an empty Receive Buffer)                 0=No underflow occurred."/>
            <edc:SFRFieldDef edc:cname="PRGM_ERR" edc:nzwidth="0x1" edc:desc="This bit if a programming error is detected.     1=Programming Error detected; 0=No programming error detected."/>
            <edc:SFRFieldDef edc:cname="LDMA_RXERR" edc:nzwidth="0x1" edc:desc="This bit is set if Local DMA Receive error is detected.     1=Local DMA RX Error detected; 0=No Local DMA RX detected."/>
            <edc:SFRFieldDef edc:cname="LDMA_TXERR" edc:nzwidth="0x1" edc:desc="This bit is set if Local DMA Transmit error is detected.     1=Local DMA TX Error detected; 0=No Local DMA TX detected."/>
            <edc:AdjustPoint edc:offset="0x1"/>
            <edc:SFRFieldDef edc:cname="TX_BUFF_FULL" edc:nzwidth="0x1" edc:desc="1=The Transmit Buffer is full     0=The Transmit Buffer is not full."/>
            <edc:SFRFieldDef edc:cname="TX_BUFF_EMP" edc:nzwidth="0x1" edc:desc="1=The Transmit Buffer is empty     0=The Transmit Buffer is not empty."/>
            <edc:SFRFieldDef edc:cname="TX_BUFF_REQ" edc:nzwidth="0x1" edc:desc="This status is asserted if the Transmit Buffer reaches a high water mark established by the TRANSMIT_BUFFER_TRIGGER field.     1=TRANSMIT_BUFFER_COUNT is less than or equal to TRANSMIT_BUFFER_TRIGGER; 0=TRANSMIT_BUFFER_COUNT is greater than TRANSMIT_BUFFER_TRIGGER."/>
            <edc:SFRFieldDef edc:cname="TX_BUFF_STALL" edc:nzwidth="0x1" edc:desc="1=The SPI interface had been stalled due to a flow issue (an attempt by the interface to read from an empty Transmit Buffer)     0=No stalls occurred."/>
            <edc:SFRFieldDef edc:cname="RX_BUFF_FULL" edc:nzwidth="0x1" edc:desc="1=The Receive Buffer is full     0=The Receive Buffer is not full."/>
            <edc:SFRFieldDef edc:cname="RX_BUFF_EMP" edc:nzwidth="0x1" edc:desc="1=The Receive Buffer is empty     0=The Receive Buffer is not empty."/>
            <edc:SFRFieldDef edc:cname="RX_BUFF_REQ" edc:nzwidth="0x1" edc:desc="This status is asserted if the Receive Buffer reaches a high water mark established by the RECEIVE_BUFFER_TRIGGER field.                 1=RECEIVE_BUFFER_COUNT is greater than or equal to RECEIVE_BUFFER_TRIGGER                 0=RECEIVE_BUFFER_COUNT is less than RECEIVE_BUFFER_TRIGGER."/>
            <edc:SFRFieldDef edc:cname="RX_BUFF_STALL" edc:nzwidth="0x1" edc:desc="1=The SPI interface had been stalled due to a flow issue (an attempt by the interface to write to a full Receive Buffer)     0=No stalls occurred."/>
            <edc:SFRFieldDef edc:cname="TRANS_ACTIV" edc:nzwidth="0x1" edc:desc="1=A transfer is currently executing     0=No transfer currently in progress."/>
            <edc:AdjustPoint edc:offset="0x7"/>
            <edc:SFRFieldDef edc:cname="CUR_DESCR_BUF" edc:nzwidth="0x4" edc:desc="This field shows the Description Buffer currently active. This field has no meaning if Description Buffers are not enabled."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="QMSPI0" edc:cname="BUF_CNT_STS" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x40070014">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="QMSPI0">
            <edc:SFRFieldDef edc:cname="TX_BUFF_CNT" edc:nzwidth="0x10" edc:desc="This is a count of the number of bytes currently valid in the Transmit Buffer."/>
            <edc:SFRFieldDef edc:cname="RX_BUFF_CNT" edc:nzwidth="0x10" edc:desc="This is a count of the number of bytes currently valid in the Receive Buffer."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="QMSPI0" edc:cname="IEN" edc:nzwidth="0x20" edc:access="-----------------nnn-nnn-nnnnnnn" edc:por="00000000000000000010000000000000" edc:mclr="00000000000000000010000000000000" edc:impl="0x777F" edc:_addr="0x40070018">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="QMSPI0">
            <edc:SFRFieldDef edc:cname="TRANS_COMPL_EN" edc:nzwidth="0x1" edc:desc="1=Enable an interrupt if TRANSFER_COMPLETE is asserted     0=Disable the interrupt."/>
            <edc:SFRFieldDef edc:cname="DMA_COMPL_EN" edc:nzwidth="0x1" edc:desc="1=Enable an interrupt if DMA_COMPLETE is asserted     0=Disable the interrupt."/>
            <edc:SFRFieldDef edc:cname="TX_BUF_ERR_EN" edc:nzwidth="0x1" edc:desc="1=Enable an interrupt if TRANSMIT_BUFFER_ERROR is asserted     0=Disable the interrupt."/>
            <edc:SFRFieldDef edc:cname="RX_BUF_ERR_EN" edc:nzwidth="0x1" edc:desc="1=Enable an interrupt if RECEIVE_BUFFER_ERROR is asserted     0=Disable the interrupt."/>
            <edc:SFRFieldDef edc:cname="PRGM_ERR_EN" edc:nzwidth="0x1" edc:desc="1=Enable an interrupt if PROGRAMMING_ERROR is asserted     0=Disable the interrupt."/>
            <edc:SFRFieldDef edc:cname="LDMA_RXERRIE" edc:nzwidth="0x1" edc:desc="1=Enable an interrupt if Local DMA RX Error is asserted     0=Disable the interrupt."/>
            <edc:SFRFieldDef edc:cname="LDMA_TXERRIE" edc:nzwidth="0x1" edc:desc="1=Enable an interrupt if Local DMA TX Error is asserted     0=Disable the interrupt."/>
            <edc:AdjustPoint edc:offset="0x1"/>
            <edc:SFRFieldDef edc:cname="TX_BUF_FULL_EN" edc:nzwidth="0x1" edc:desc="1=Enable an interrupt if TRANSMIT_BUFFER_FULL is asserted     0=Disable the interrupt."/>
            <edc:SFRFieldDef edc:cname="TX_BUF_EMPTY_EN" edc:nzwidth="0x1" edc:desc="1=Enable an interrupt if TRANSMIT_BUFFER_EMPTY is asserted     0=Disable the interrupt."/>
            <edc:SFRFieldDef edc:cname="TX_BUF_REQ_EN" edc:nzwidth="0x1" edc:desc="1=Enable an interrupt if TRANSMIT_BUFFER_REQUEST is asserted     0=Disable the interrupt."/>
            <edc:AdjustPoint edc:offset="0x1"/>
            <edc:SFRFieldDef edc:cname="RX_BUF_FUL_EN" edc:nzwidth="0x1" edc:desc="1=Enable an interrupt if RECEIVE_BUFFER_FULL is asserted     0=Disable the interrupt."/>
            <edc:SFRFieldDef edc:cname="RX_BUF_EMPTY_EN" edc:nzwidth="0x1" edc:desc="1=Enable an interrupt if RECEIVE_BUFFER_EMPTY is asserted     0=Disable the interrupt."/>
            <edc:SFRFieldDef edc:cname="RX_BUF_REQ_EN" edc:nzwidth="0x1" edc:desc="1=Enable an interrupt if RECEIVE_BUFFER_REQUEST is asserted     0=Disable the interrupt."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="QMSPI0" edc:cname="BUF_CNT_TRIG" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x4007001C">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="QMSPI0">
            <edc:SFRFieldDef edc:cname="TX_BUF_TRIG" edc:nzwidth="0x10" edc:desc="An interrupt is triggered if the TRANSMIT_BUFFER_COUNT field is less than or equal to this value. A value of 0 disables the interrupt."/>
            <edc:SFRFieldDef edc:cname="RX_BUF_TRIG" edc:nzwidth="0x10" edc:desc="An interrupt is triggered if the RECEIVE_BUFFER_COUNT field is greater than or equal to this value. A value of 0 disables the interrupt."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="QMSPI0" edc:cname="TX_FIFO0" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x40070020">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="QMSPI0">
            <edc:SFRFieldDef edc:cname="TX_BUF" edc:nzwidth="0x20" edc:desc="Writes to this register store data to be transmitted from the SPI Master to the external SPI Slave.     Writes to this block will be written to the Transmit FIFO. A 1 Byte write fills 1 byte of the FIFO. A Word write fills 2 Bytes and a Doubleword write fills 4 bytes.     The data must always be aligned to the bottom most byte (so 1 byte write is on bits [7:0] and Word write is on [15:0]).     An overflow condition, TRANSMIT_BUFFER_ERROR, if a write to a full FIFO occurs. Write accesses to this register increment the TRANSMIT_BUFFER_COUNT field."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="QMSPI0" edc:cname="RX_FIFO0" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x40070024">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="QMSPI0">
            <edc:SFRFieldDef edc:cname="RX_BUF" edc:nzwidth="0x20" edc:desc="Buffer that stores data from the external SPI Slave device to the SPI Master (this block), which is received over MISO or IO.     Reads from this register will empty the Rx FIFO. A 1 Byte read will have valid data on bits [7:0] and a Word read will have data on bits [15:0].     It is possible to request more data than the FIFO has (underflow condition), but this will cause an error (Rx Buffer Error).     Read accesses to this register decrement the RECEIVE_BUFFER_COUNT field."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="QMSPI0" edc:cname="CSTM" edc:nzwidth="0x20" edc:access="nnnnnnnn----nnnn----nnnn----nnnn" edc:por="00000110000001100000010000000110" edc:mclr="00000110000001100000010000000110" edc:impl="0xFF0F0F0F" edc:_addr="0x40070028">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="QMSPI0">
            <edc:SFRFieldDef edc:cname="DLY_CS_ON_TO_CLOCK_START" edc:nzwidth="0x4" edc:desc="This selects the number of system clock cycles between CS assertion to the start of the SPI Clock."/>
            <edc:AdjustPoint edc:offset="0x4"/>
            <edc:SFRFieldDef edc:cname="DLY_CLK_STOP_TO_CS_OFF" edc:nzwidth="0x4" edc:desc="This selects the number of system clock cycles between the last clock edge and the deassertion of CS."/>
            <edc:AdjustPoint edc:offset="0x4"/>
            <edc:SFRFieldDef edc:cname="DLY_LAST_DATA_HOLD" edc:nzwidth="0x4" edc:desc="This selects the number of system clock cycles between CS deassertion to the data ports for WP and HOLD     switching from input to output."/>
            <edc:AdjustPoint edc:offset="0x4"/>
            <edc:SFRFieldDef edc:cname="DLY_CS_OFF_TO_CS_ON" edc:nzwidth="0x8" edc:desc="This selects the number of system clock cycles between CS deassertion to CS assertion. This is the minimum            pulse width of CS deassertion."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:AdjustPoint edc:offset="0x4" edc:_addr="0x4007002C"/>
      <edc:SFRDef ltx:memberofperipheral="QMSPI0" edc:cname="DESCR0" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x40070030">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="QMSPI0">
            <edc:SFRFieldDef edc:cname="INFACE_MOD" edc:nzwidth="0x2" edc:desc="This field sets the transmission mode. If this field is set for Dual Mode or Quad Mode then either TX_TRANSFER_ENABLE or RX_TRANSFER_ENABLE must be 0.     3=Reserved; 2=Quad Mode; 1=Dual Mode; 0=Single/Duplex Mode."/>
            <edc:SFRFieldDef edc:cname="TX_TRANS_EN" edc:nzwidth="0x2" edc:desc="This field bit selects the transmit function of the SPI interface.     3=Transmit Enabled in 1 Mode. The MOSI or IO Bus will send out only 1's. The Transmit Buffer will not be used     2=Transmit Enabled in 0 Mode. The MOSI or IO Bus will send out only 0's. The Transmit Buffer will not be used.     1=Transmit Enabled. Data will be fetched from the Transmit Buffer and sent out on the MOSI or IO Bus.     0=Transmit is Disabled. No data is sent. This will cause the MOSI be to be undriven, or the IO bus to be undriven if Receive is also disabled."/>
            <edc:SFRFieldDef edc:cname="TX_DMA_EN" edc:nzwidth="0x2" edc:desc="This bit enables DMA support for Transmit Transfer. If enabled, DMA will be requested to fill the FIFO until either the interface     reaches TRANSFER_LENGTH or the DMA sends a termination request. The size defined here must match DMA programmed access size.     1=DMA is enabled.and set to 1 Byte      2=DMA is enabled and set to 2 Bytes      3=DMA is enabled and set to 4 Bytes     0=DMA is disabled. All data in the Transmit Buffer must be emptied by firmware."/>
            <edc:SFRFieldDef edc:cname="RX_TRANS_EN" edc:nzwidth="0x1" edc:desc="This bit enables the receive function of the SPI interface.     1=Receive is enabled. Data received from the SPI Slave is stored in the Receive Buffer; 0=Receive is disabled."/>
            <edc:SFRFieldDef edc:cname="RX_DMA_EN" edc:nzwidth="0x2" edc:desc="This bit enables DMA support for Receive Transfer. If enabled, DMA will be requested to empty the FIFO until either the interface reaches TRANSFER_LENGTH or the DMA sends a termination request. The size defined here must match DMA programmed access size.     1=DMA is enabled.and set to 1 Byte     2=DMA is enabled and set to 2 Bytes     3=DMA is enabled and set to 4 Bytes     0=DMA is disabled. All data in the Receive Buffer must be emptied by firmware."/>
            <edc:SFRFieldDef edc:cname="CLOSE_TRANS_EN" edc:nzwidth="0x1" edc:desc="This selects what action is taken at the end of a transfer. This bit must be set only on the Last Buffer.     1=The transfer is terminated. The Chip Select de-asserts, the SPI interface returns to IDLE and the DMA interface completes the transfer.     0=The transfer is not closed. Chip Select remains asserted and the DMA interface and the SPI interface remain active"/>
            <edc:SFRFieldDef edc:cname="TRANS_LEN" edc:nzwidth="0x2" edc:desc="3=TRANSFER_LENGTH defined in units of 16-byte segments,            2=TRANSFER_LENGTH defined in units of 4-byte segments     1=TRANSFER_LENGTH defined in units of bytes,     0=TRANSFER_LENGTH defined in units of bits"/>
            <edc:SFRFieldDef edc:cname="DESCR_BUF_NXT_PTR" edc:nzwidth="0x4" edc:desc="This defines the next buffer to be used if Description Buffers are enabled and this is not the last buffer. This can point to the current buffer, creating an infinite loop."/>
            <edc:SFRFieldDef edc:cname="DESCR_BUF_LAST" edc:nzwidth="0x1" edc:desc="Last Descriptor. 1=Last Description Buffer in the chain. 0=This is not the last buffer."/>
            <edc:SFRFieldDef edc:cname="TX_LEN" edc:nzwidth="0xF" edc:desc="The length of the SPI transfer. The count is in bytes or bits, depending on the value of TRANSFER_LENGTH_BITS. A value of 0 means an infinite length transfer."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="QMSPI0" edc:cname="DESCR1" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x40070034">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="QMSPI0">
            <edc:SFRFieldDef edc:cname="INFACE_MOD" edc:nzwidth="0x2" edc:desc="This field sets the transmission mode. If this field is set for Dual Mode or Quad Mode then either TX_TRANSFER_ENABLE or RX_TRANSFER_ENABLE must be 0.     3=Reserved; 2=Quad Mode; 1=Dual Mode; 0=Single/Duplex Mode."/>
            <edc:SFRFieldDef edc:cname="TX_TRANS_EN" edc:nzwidth="0x2" edc:desc="This field bit selects the transmit function of the SPI interface.     3=Transmit Enabled in 1 Mode. The MOSI or IO Bus will send out only 1's. The Transmit Buffer will not be used     2=Transmit Enabled in 0 Mode. The MOSI or IO Bus will send out only 0's. The Transmit Buffer will not be used.     1=Transmit Enabled. Data will be fetched from the Transmit Buffer and sent out on the MOSI or IO Bus.     0=Transmit is Disabled. No data is sent. This will cause the MOSI be to be undriven, or the IO bus to be undriven if Receive is also disabled."/>
            <edc:SFRFieldDef edc:cname="TX_DMA_EN" edc:nzwidth="0x2" edc:desc="This bit enables DMA support for Transmit Transfer. If enabled, DMA will be requested to fill the FIFO until either the interface     reaches TRANSFER_LENGTH or the DMA sends a termination request. The size defined here must match DMA programmed access size.     1=DMA is enabled.and set to 1 Byte      2=DMA is enabled and set to 2 Bytes      3=DMA is enabled and set to 4 Bytes     0=DMA is disabled. All data in the Transmit Buffer must be emptied by firmware."/>
            <edc:SFRFieldDef edc:cname="RX_TRANS_EN" edc:nzwidth="0x1" edc:desc="This bit enables the receive function of the SPI interface.     1=Receive is enabled. Data received from the SPI Slave is stored in the Receive Buffer; 0=Receive is disabled."/>
            <edc:SFRFieldDef edc:cname="RX_DMA_EN" edc:nzwidth="0x2" edc:desc="This bit enables DMA support for Receive Transfer. If enabled, DMA will be requested to empty the FIFO until either the interface reaches TRANSFER_LENGTH or the DMA sends a termination request. The size defined here must match DMA programmed access size.     1=DMA is enabled.and set to 1 Byte     2=DMA is enabled and set to 2 Bytes     3=DMA is enabled and set to 4 Bytes     0=DMA is disabled. All data in the Receive Buffer must be emptied by firmware."/>
            <edc:SFRFieldDef edc:cname="CLOSE_TRANS_EN" edc:nzwidth="0x1" edc:desc="This selects what action is taken at the end of a transfer. This bit must be set only on the Last Buffer.     1=The transfer is terminated. The Chip Select de-asserts, the SPI interface returns to IDLE and the DMA interface completes the transfer.     0=The transfer is not closed. Chip Select remains asserted and the DMA interface and the SPI interface remain active"/>
            <edc:SFRFieldDef edc:cname="TRANS_LEN" edc:nzwidth="0x2" edc:desc="3=TRANSFER_LENGTH defined in units of 16-byte segments,            2=TRANSFER_LENGTH defined in units of 4-byte segments     1=TRANSFER_LENGTH defined in units of bytes,     0=TRANSFER_LENGTH defined in units of bits"/>
            <edc:SFRFieldDef edc:cname="DESCR_BUF_NXT_PTR" edc:nzwidth="0x4" edc:desc="This defines the next buffer to be used if Description Buffers are enabled and this is not the last buffer. This can point to the current buffer, creating an infinite loop."/>
            <edc:SFRFieldDef edc:cname="DESCR_BUF_LAST" edc:nzwidth="0x1" edc:desc="Last Descriptor. 1=Last Description Buffer in the chain. 0=This is not the last buffer."/>
            <edc:SFRFieldDef edc:cname="TX_LEN" edc:nzwidth="0xF" edc:desc="The length of the SPI transfer. The count is in bytes or bits, depending on the value of TRANSFER_LENGTH_BITS. A value of 0 means an infinite length transfer."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="QMSPI0" edc:cname="DESCR2" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x40070038">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="QMSPI0">
            <edc:SFRFieldDef edc:cname="INFACE_MOD" edc:nzwidth="0x2" edc:desc="This field sets the transmission mode. If this field is set for Dual Mode or Quad Mode then either TX_TRANSFER_ENABLE or RX_TRANSFER_ENABLE must be 0.     3=Reserved; 2=Quad Mode; 1=Dual Mode; 0=Single/Duplex Mode."/>
            <edc:SFRFieldDef edc:cname="TX_TRANS_EN" edc:nzwidth="0x2" edc:desc="This field bit selects the transmit function of the SPI interface.     3=Transmit Enabled in 1 Mode. The MOSI or IO Bus will send out only 1's. The Transmit Buffer will not be used     2=Transmit Enabled in 0 Mode. The MOSI or IO Bus will send out only 0's. The Transmit Buffer will not be used.     1=Transmit Enabled. Data will be fetched from the Transmit Buffer and sent out on the MOSI or IO Bus.     0=Transmit is Disabled. No data is sent. This will cause the MOSI be to be undriven, or the IO bus to be undriven if Receive is also disabled."/>
            <edc:SFRFieldDef edc:cname="TX_DMA_EN" edc:nzwidth="0x2" edc:desc="This bit enables DMA support for Transmit Transfer. If enabled, DMA will be requested to fill the FIFO until either the interface     reaches TRANSFER_LENGTH or the DMA sends a termination request. The size defined here must match DMA programmed access size.     1=DMA is enabled.and set to 1 Byte      2=DMA is enabled and set to 2 Bytes      3=DMA is enabled and set to 4 Bytes     0=DMA is disabled. All data in the Transmit Buffer must be emptied by firmware."/>
            <edc:SFRFieldDef edc:cname="RX_TRANS_EN" edc:nzwidth="0x1" edc:desc="This bit enables the receive function of the SPI interface.     1=Receive is enabled. Data received from the SPI Slave is stored in the Receive Buffer; 0=Receive is disabled."/>
            <edc:SFRFieldDef edc:cname="RX_DMA_EN" edc:nzwidth="0x2" edc:desc="This bit enables DMA support for Receive Transfer. If enabled, DMA will be requested to empty the FIFO until either the interface reaches TRANSFER_LENGTH or the DMA sends a termination request. The size defined here must match DMA programmed access size.     1=DMA is enabled.and set to 1 Byte     2=DMA is enabled and set to 2 Bytes     3=DMA is enabled and set to 4 Bytes     0=DMA is disabled. All data in the Receive Buffer must be emptied by firmware."/>
            <edc:SFRFieldDef edc:cname="CLOSE_TRANS_EN" edc:nzwidth="0x1" edc:desc="This selects what action is taken at the end of a transfer. This bit must be set only on the Last Buffer.     1=The transfer is terminated. The Chip Select de-asserts, the SPI interface returns to IDLE and the DMA interface completes the transfer.     0=The transfer is not closed. Chip Select remains asserted and the DMA interface and the SPI interface remain active"/>
            <edc:SFRFieldDef edc:cname="TRANS_LEN" edc:nzwidth="0x2" edc:desc="3=TRANSFER_LENGTH defined in units of 16-byte segments,            2=TRANSFER_LENGTH defined in units of 4-byte segments     1=TRANSFER_LENGTH defined in units of bytes,     0=TRANSFER_LENGTH defined in units of bits"/>
            <edc:SFRFieldDef edc:cname="DESCR_BUF_NXT_PTR" edc:nzwidth="0x4" edc:desc="This defines the next buffer to be used if Description Buffers are enabled and this is not the last buffer. This can point to the current buffer, creating an infinite loop."/>
            <edc:SFRFieldDef edc:cname="DESCR_BUF_LAST" edc:nzwidth="0x1" edc:desc="Last Descriptor. 1=Last Description Buffer in the chain. 0=This is not the last buffer."/>
            <edc:SFRFieldDef edc:cname="TX_LEN" edc:nzwidth="0xF" edc:desc="The length of the SPI transfer. The count is in bytes or bits, depending on the value of TRANSFER_LENGTH_BITS. A value of 0 means an infinite length transfer."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="QMSPI0" edc:cname="DESCR3" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x4007003C">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="QMSPI0">
            <edc:SFRFieldDef edc:cname="INFACE_MOD" edc:nzwidth="0x2" edc:desc="This field sets the transmission mode. If this field is set for Dual Mode or Quad Mode then either TX_TRANSFER_ENABLE or RX_TRANSFER_ENABLE must be 0.     3=Reserved; 2=Quad Mode; 1=Dual Mode; 0=Single/Duplex Mode."/>
            <edc:SFRFieldDef edc:cname="TX_TRANS_EN" edc:nzwidth="0x2" edc:desc="This field bit selects the transmit function of the SPI interface.     3=Transmit Enabled in 1 Mode. The MOSI or IO Bus will send out only 1's. The Transmit Buffer will not be used     2=Transmit Enabled in 0 Mode. The MOSI or IO Bus will send out only 0's. The Transmit Buffer will not be used.     1=Transmit Enabled. Data will be fetched from the Transmit Buffer and sent out on the MOSI or IO Bus.     0=Transmit is Disabled. No data is sent. This will cause the MOSI be to be undriven, or the IO bus to be undriven if Receive is also disabled."/>
            <edc:SFRFieldDef edc:cname="TX_DMA_EN" edc:nzwidth="0x2" edc:desc="This bit enables DMA support for Transmit Transfer. If enabled, DMA will be requested to fill the FIFO until either the interface     reaches TRANSFER_LENGTH or the DMA sends a termination request. The size defined here must match DMA programmed access size.     1=DMA is enabled.and set to 1 Byte      2=DMA is enabled and set to 2 Bytes      3=DMA is enabled and set to 4 Bytes     0=DMA is disabled. All data in the Transmit Buffer must be emptied by firmware."/>
            <edc:SFRFieldDef edc:cname="RX_TRANS_EN" edc:nzwidth="0x1" edc:desc="This bit enables the receive function of the SPI interface.     1=Receive is enabled. Data received from the SPI Slave is stored in the Receive Buffer; 0=Receive is disabled."/>
            <edc:SFRFieldDef edc:cname="RX_DMA_EN" edc:nzwidth="0x2" edc:desc="This bit enables DMA support for Receive Transfer. If enabled, DMA will be requested to empty the FIFO until either the interface reaches TRANSFER_LENGTH or the DMA sends a termination request. The size defined here must match DMA programmed access size.     1=DMA is enabled.and set to 1 Byte     2=DMA is enabled and set to 2 Bytes     3=DMA is enabled and set to 4 Bytes     0=DMA is disabled. All data in the Receive Buffer must be emptied by firmware."/>
            <edc:SFRFieldDef edc:cname="CLOSE_TRANS_EN" edc:nzwidth="0x1" edc:desc="This selects what action is taken at the end of a transfer. This bit must be set only on the Last Buffer.     1=The transfer is terminated. The Chip Select de-asserts, the SPI interface returns to IDLE and the DMA interface completes the transfer.     0=The transfer is not closed. Chip Select remains asserted and the DMA interface and the SPI interface remain active"/>
            <edc:SFRFieldDef edc:cname="TRANS_LEN" edc:nzwidth="0x2" edc:desc="3=TRANSFER_LENGTH defined in units of 16-byte segments,            2=TRANSFER_LENGTH defined in units of 4-byte segments     1=TRANSFER_LENGTH defined in units of bytes,     0=TRANSFER_LENGTH defined in units of bits"/>
            <edc:SFRFieldDef edc:cname="DESCR_BUF_NXT_PTR" edc:nzwidth="0x4" edc:desc="This defines the next buffer to be used if Description Buffers are enabled and this is not the last buffer. This can point to the current buffer, creating an infinite loop."/>
            <edc:SFRFieldDef edc:cname="DESCR_BUF_LAST" edc:nzwidth="0x1" edc:desc="Last Descriptor. 1=Last Description Buffer in the chain. 0=This is not the last buffer."/>
            <edc:SFRFieldDef edc:cname="TX_LEN" edc:nzwidth="0xF" edc:desc="The length of the SPI transfer. The count is in bytes or bits, depending on the value of TRANSFER_LENGTH_BITS. A value of 0 means an infinite length transfer."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="QMSPI0" edc:cname="DESCR4" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x40070040">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="QMSPI0">
            <edc:SFRFieldDef edc:cname="INFACE_MOD" edc:nzwidth="0x2" edc:desc="This field sets the transmission mode. If this field is set for Dual Mode or Quad Mode then either TX_TRANSFER_ENABLE or RX_TRANSFER_ENABLE must be 0.     3=Reserved; 2=Quad Mode; 1=Dual Mode; 0=Single/Duplex Mode."/>
            <edc:SFRFieldDef edc:cname="TX_TRANS_EN" edc:nzwidth="0x2" edc:desc="This field bit selects the transmit function of the SPI interface.     3=Transmit Enabled in 1 Mode. The MOSI or IO Bus will send out only 1's. The Transmit Buffer will not be used     2=Transmit Enabled in 0 Mode. The MOSI or IO Bus will send out only 0's. The Transmit Buffer will not be used.     1=Transmit Enabled. Data will be fetched from the Transmit Buffer and sent out on the MOSI or IO Bus.     0=Transmit is Disabled. No data is sent. This will cause the MOSI be to be undriven, or the IO bus to be undriven if Receive is also disabled."/>
            <edc:SFRFieldDef edc:cname="TX_DMA_EN" edc:nzwidth="0x2" edc:desc="This bit enables DMA support for Transmit Transfer. If enabled, DMA will be requested to fill the FIFO until either the interface     reaches TRANSFER_LENGTH or the DMA sends a termination request. The size defined here must match DMA programmed access size.     1=DMA is enabled.and set to 1 Byte      2=DMA is enabled and set to 2 Bytes      3=DMA is enabled and set to 4 Bytes     0=DMA is disabled. All data in the Transmit Buffer must be emptied by firmware."/>
            <edc:SFRFieldDef edc:cname="RX_TRANS_EN" edc:nzwidth="0x1" edc:desc="This bit enables the receive function of the SPI interface.     1=Receive is enabled. Data received from the SPI Slave is stored in the Receive Buffer; 0=Receive is disabled."/>
            <edc:SFRFieldDef edc:cname="RX_DMA_EN" edc:nzwidth="0x2" edc:desc="This bit enables DMA support for Receive Transfer. If enabled, DMA will be requested to empty the FIFO until either the interface reaches TRANSFER_LENGTH or the DMA sends a termination request. The size defined here must match DMA programmed access size.     1=DMA is enabled.and set to 1 Byte     2=DMA is enabled and set to 2 Bytes     3=DMA is enabled and set to 4 Bytes     0=DMA is disabled. All data in the Receive Buffer must be emptied by firmware."/>
            <edc:SFRFieldDef edc:cname="CLOSE_TRANS_EN" edc:nzwidth="0x1" edc:desc="This selects what action is taken at the end of a transfer. This bit must be set only on the Last Buffer.     1=The transfer is terminated. The Chip Select de-asserts, the SPI interface returns to IDLE and the DMA interface completes the transfer.     0=The transfer is not closed. Chip Select remains asserted and the DMA interface and the SPI interface remain active"/>
            <edc:SFRFieldDef edc:cname="TRANS_LEN" edc:nzwidth="0x2" edc:desc="3=TRANSFER_LENGTH defined in units of 16-byte segments,            2=TRANSFER_LENGTH defined in units of 4-byte segments     1=TRANSFER_LENGTH defined in units of bytes,     0=TRANSFER_LENGTH defined in units of bits"/>
            <edc:SFRFieldDef edc:cname="DESCR_BUF_NXT_PTR" edc:nzwidth="0x4" edc:desc="This defines the next buffer to be used if Description Buffers are enabled and this is not the last buffer. This can point to the current buffer, creating an infinite loop."/>
            <edc:SFRFieldDef edc:cname="DESCR_BUF_LAST" edc:nzwidth="0x1" edc:desc="Last Descriptor. 1=Last Description Buffer in the chain. 0=This is not the last buffer."/>
            <edc:SFRFieldDef edc:cname="TX_LEN" edc:nzwidth="0xF" edc:desc="The length of the SPI transfer. The count is in bytes or bits, depending on the value of TRANSFER_LENGTH_BITS. A value of 0 means an infinite length transfer."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="QMSPI0" edc:cname="DESCR5" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x40070044">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="QMSPI0">
            <edc:SFRFieldDef edc:cname="INFACE_MOD" edc:nzwidth="0x2" edc:desc="This field sets the transmission mode. If this field is set for Dual Mode or Quad Mode then either TX_TRANSFER_ENABLE or RX_TRANSFER_ENABLE must be 0.     3=Reserved; 2=Quad Mode; 1=Dual Mode; 0=Single/Duplex Mode."/>
            <edc:SFRFieldDef edc:cname="TX_TRANS_EN" edc:nzwidth="0x2" edc:desc="This field bit selects the transmit function of the SPI interface.     3=Transmit Enabled in 1 Mode. The MOSI or IO Bus will send out only 1's. The Transmit Buffer will not be used     2=Transmit Enabled in 0 Mode. The MOSI or IO Bus will send out only 0's. The Transmit Buffer will not be used.     1=Transmit Enabled. Data will be fetched from the Transmit Buffer and sent out on the MOSI or IO Bus.     0=Transmit is Disabled. No data is sent. This will cause the MOSI be to be undriven, or the IO bus to be undriven if Receive is also disabled."/>
            <edc:SFRFieldDef edc:cname="TX_DMA_EN" edc:nzwidth="0x2" edc:desc="This bit enables DMA support for Transmit Transfer. If enabled, DMA will be requested to fill the FIFO until either the interface     reaches TRANSFER_LENGTH or the DMA sends a termination request. The size defined here must match DMA programmed access size.     1=DMA is enabled.and set to 1 Byte      2=DMA is enabled and set to 2 Bytes      3=DMA is enabled and set to 4 Bytes     0=DMA is disabled. All data in the Transmit Buffer must be emptied by firmware."/>
            <edc:SFRFieldDef edc:cname="RX_TRANS_EN" edc:nzwidth="0x1" edc:desc="This bit enables the receive function of the SPI interface.     1=Receive is enabled. Data received from the SPI Slave is stored in the Receive Buffer; 0=Receive is disabled."/>
            <edc:SFRFieldDef edc:cname="RX_DMA_EN" edc:nzwidth="0x2" edc:desc="This bit enables DMA support for Receive Transfer. If enabled, DMA will be requested to empty the FIFO until either the interface reaches TRANSFER_LENGTH or the DMA sends a termination request. The size defined here must match DMA programmed access size.     1=DMA is enabled.and set to 1 Byte     2=DMA is enabled and set to 2 Bytes     3=DMA is enabled and set to 4 Bytes     0=DMA is disabled. All data in the Receive Buffer must be emptied by firmware."/>
            <edc:SFRFieldDef edc:cname="CLOSE_TRANS_EN" edc:nzwidth="0x1" edc:desc="This selects what action is taken at the end of a transfer. This bit must be set only on the Last Buffer.     1=The transfer is terminated. The Chip Select de-asserts, the SPI interface returns to IDLE and the DMA interface completes the transfer.     0=The transfer is not closed. Chip Select remains asserted and the DMA interface and the SPI interface remain active"/>
            <edc:SFRFieldDef edc:cname="TRANS_LEN" edc:nzwidth="0x2" edc:desc="3=TRANSFER_LENGTH defined in units of 16-byte segments,            2=TRANSFER_LENGTH defined in units of 4-byte segments     1=TRANSFER_LENGTH defined in units of bytes,     0=TRANSFER_LENGTH defined in units of bits"/>
            <edc:SFRFieldDef edc:cname="DESCR_BUF_NXT_PTR" edc:nzwidth="0x4" edc:desc="This defines the next buffer to be used if Description Buffers are enabled and this is not the last buffer. This can point to the current buffer, creating an infinite loop."/>
            <edc:SFRFieldDef edc:cname="DESCR_BUF_LAST" edc:nzwidth="0x1" edc:desc="Last Descriptor. 1=Last Description Buffer in the chain. 0=This is not the last buffer."/>
            <edc:SFRFieldDef edc:cname="TX_LEN" edc:nzwidth="0xF" edc:desc="The length of the SPI transfer. The count is in bytes or bits, depending on the value of TRANSFER_LENGTH_BITS. A value of 0 means an infinite length transfer."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="QMSPI0" edc:cname="DESCR6" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x40070048">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="QMSPI0">
            <edc:SFRFieldDef edc:cname="INFACE_MOD" edc:nzwidth="0x2" edc:desc="This field sets the transmission mode. If this field is set for Dual Mode or Quad Mode then either TX_TRANSFER_ENABLE or RX_TRANSFER_ENABLE must be 0.     3=Reserved; 2=Quad Mode; 1=Dual Mode; 0=Single/Duplex Mode."/>
            <edc:SFRFieldDef edc:cname="TX_TRANS_EN" edc:nzwidth="0x2" edc:desc="This field bit selects the transmit function of the SPI interface.     3=Transmit Enabled in 1 Mode. The MOSI or IO Bus will send out only 1's. The Transmit Buffer will not be used     2=Transmit Enabled in 0 Mode. The MOSI or IO Bus will send out only 0's. The Transmit Buffer will not be used.     1=Transmit Enabled. Data will be fetched from the Transmit Buffer and sent out on the MOSI or IO Bus.     0=Transmit is Disabled. No data is sent. This will cause the MOSI be to be undriven, or the IO bus to be undriven if Receive is also disabled."/>
            <edc:SFRFieldDef edc:cname="TX_DMA_EN" edc:nzwidth="0x2" edc:desc="This bit enables DMA support for Transmit Transfer. If enabled, DMA will be requested to fill the FIFO until either the interface     reaches TRANSFER_LENGTH or the DMA sends a termination request. The size defined here must match DMA programmed access size.     1=DMA is enabled.and set to 1 Byte      2=DMA is enabled and set to 2 Bytes      3=DMA is enabled and set to 4 Bytes     0=DMA is disabled. All data in the Transmit Buffer must be emptied by firmware."/>
            <edc:SFRFieldDef edc:cname="RX_TRANS_EN" edc:nzwidth="0x1" edc:desc="This bit enables the receive function of the SPI interface.     1=Receive is enabled. Data received from the SPI Slave is stored in the Receive Buffer; 0=Receive is disabled."/>
            <edc:SFRFieldDef edc:cname="RX_DMA_EN" edc:nzwidth="0x2" edc:desc="This bit enables DMA support for Receive Transfer. If enabled, DMA will be requested to empty the FIFO until either the interface reaches TRANSFER_LENGTH or the DMA sends a termination request. The size defined here must match DMA programmed access size.     1=DMA is enabled.and set to 1 Byte     2=DMA is enabled and set to 2 Bytes     3=DMA is enabled and set to 4 Bytes     0=DMA is disabled. All data in the Receive Buffer must be emptied by firmware."/>
            <edc:SFRFieldDef edc:cname="CLOSE_TRANS_EN" edc:nzwidth="0x1" edc:desc="This selects what action is taken at the end of a transfer. This bit must be set only on the Last Buffer.     1=The transfer is terminated. The Chip Select de-asserts, the SPI interface returns to IDLE and the DMA interface completes the transfer.     0=The transfer is not closed. Chip Select remains asserted and the DMA interface and the SPI interface remain active"/>
            <edc:SFRFieldDef edc:cname="TRANS_LEN" edc:nzwidth="0x2" edc:desc="3=TRANSFER_LENGTH defined in units of 16-byte segments,            2=TRANSFER_LENGTH defined in units of 4-byte segments     1=TRANSFER_LENGTH defined in units of bytes,     0=TRANSFER_LENGTH defined in units of bits"/>
            <edc:SFRFieldDef edc:cname="DESCR_BUF_NXT_PTR" edc:nzwidth="0x4" edc:desc="This defines the next buffer to be used if Description Buffers are enabled and this is not the last buffer. This can point to the current buffer, creating an infinite loop."/>
            <edc:SFRFieldDef edc:cname="DESCR_BUF_LAST" edc:nzwidth="0x1" edc:desc="Last Descriptor. 1=Last Description Buffer in the chain. 0=This is not the last buffer."/>
            <edc:SFRFieldDef edc:cname="TX_LEN" edc:nzwidth="0xF" edc:desc="The length of the SPI transfer. The count is in bytes or bits, depending on the value of TRANSFER_LENGTH_BITS. A value of 0 means an infinite length transfer."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="QMSPI0" edc:cname="DESCR7" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x4007004C">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="QMSPI0">
            <edc:SFRFieldDef edc:cname="INFACE_MOD" edc:nzwidth="0x2" edc:desc="This field sets the transmission mode. If this field is set for Dual Mode or Quad Mode then either TX_TRANSFER_ENABLE or RX_TRANSFER_ENABLE must be 0.     3=Reserved; 2=Quad Mode; 1=Dual Mode; 0=Single/Duplex Mode."/>
            <edc:SFRFieldDef edc:cname="TX_TRANS_EN" edc:nzwidth="0x2" edc:desc="This field bit selects the transmit function of the SPI interface.     3=Transmit Enabled in 1 Mode. The MOSI or IO Bus will send out only 1's. The Transmit Buffer will not be used     2=Transmit Enabled in 0 Mode. The MOSI or IO Bus will send out only 0's. The Transmit Buffer will not be used.     1=Transmit Enabled. Data will be fetched from the Transmit Buffer and sent out on the MOSI or IO Bus.     0=Transmit is Disabled. No data is sent. This will cause the MOSI be to be undriven, or the IO bus to be undriven if Receive is also disabled."/>
            <edc:SFRFieldDef edc:cname="TX_DMA_EN" edc:nzwidth="0x2" edc:desc="This bit enables DMA support for Transmit Transfer. If enabled, DMA will be requested to fill the FIFO until either the interface     reaches TRANSFER_LENGTH or the DMA sends a termination request. The size defined here must match DMA programmed access size.     1=DMA is enabled.and set to 1 Byte      2=DMA is enabled and set to 2 Bytes      3=DMA is enabled and set to 4 Bytes     0=DMA is disabled. All data in the Transmit Buffer must be emptied by firmware."/>
            <edc:SFRFieldDef edc:cname="RX_TRANS_EN" edc:nzwidth="0x1" edc:desc="This bit enables the receive function of the SPI interface.     1=Receive is enabled. Data received from the SPI Slave is stored in the Receive Buffer; 0=Receive is disabled."/>
            <edc:SFRFieldDef edc:cname="RX_DMA_EN" edc:nzwidth="0x2" edc:desc="This bit enables DMA support for Receive Transfer. If enabled, DMA will be requested to empty the FIFO until either the interface reaches TRANSFER_LENGTH or the DMA sends a termination request. The size defined here must match DMA programmed access size.     1=DMA is enabled.and set to 1 Byte     2=DMA is enabled and set to 2 Bytes     3=DMA is enabled and set to 4 Bytes     0=DMA is disabled. All data in the Receive Buffer must be emptied by firmware."/>
            <edc:SFRFieldDef edc:cname="CLOSE_TRANS_EN" edc:nzwidth="0x1" edc:desc="This selects what action is taken at the end of a transfer. This bit must be set only on the Last Buffer.     1=The transfer is terminated. The Chip Select de-asserts, the SPI interface returns to IDLE and the DMA interface completes the transfer.     0=The transfer is not closed. Chip Select remains asserted and the DMA interface and the SPI interface remain active"/>
            <edc:SFRFieldDef edc:cname="TRANS_LEN" edc:nzwidth="0x2" edc:desc="3=TRANSFER_LENGTH defined in units of 16-byte segments,            2=TRANSFER_LENGTH defined in units of 4-byte segments     1=TRANSFER_LENGTH defined in units of bytes,     0=TRANSFER_LENGTH defined in units of bits"/>
            <edc:SFRFieldDef edc:cname="DESCR_BUF_NXT_PTR" edc:nzwidth="0x4" edc:desc="This defines the next buffer to be used if Description Buffers are enabled and this is not the last buffer. This can point to the current buffer, creating an infinite loop."/>
            <edc:SFRFieldDef edc:cname="DESCR_BUF_LAST" edc:nzwidth="0x1" edc:desc="Last Descriptor. 1=Last Description Buffer in the chain. 0=This is not the last buffer."/>
            <edc:SFRFieldDef edc:cname="TX_LEN" edc:nzwidth="0xF" edc:desc="The length of the SPI transfer. The count is in bytes or bits, depending on the value of TRANSFER_LENGTH_BITS. A value of 0 means an infinite length transfer."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="QMSPI0" edc:cname="DESCR8" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x40070050">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="QMSPI0">
            <edc:SFRFieldDef edc:cname="INFACE_MOD" edc:nzwidth="0x2" edc:desc="This field sets the transmission mode. If this field is set for Dual Mode or Quad Mode then either TX_TRANSFER_ENABLE or RX_TRANSFER_ENABLE must be 0.     3=Reserved; 2=Quad Mode; 1=Dual Mode; 0=Single/Duplex Mode."/>
            <edc:SFRFieldDef edc:cname="TX_TRANS_EN" edc:nzwidth="0x2" edc:desc="This field bit selects the transmit function of the SPI interface.     3=Transmit Enabled in 1 Mode. The MOSI or IO Bus will send out only 1's. The Transmit Buffer will not be used     2=Transmit Enabled in 0 Mode. The MOSI or IO Bus will send out only 0's. The Transmit Buffer will not be used.     1=Transmit Enabled. Data will be fetched from the Transmit Buffer and sent out on the MOSI or IO Bus.     0=Transmit is Disabled. No data is sent. This will cause the MOSI be to be undriven, or the IO bus to be undriven if Receive is also disabled."/>
            <edc:SFRFieldDef edc:cname="TX_DMA_EN" edc:nzwidth="0x2" edc:desc="This bit enables DMA support for Transmit Transfer. If enabled, DMA will be requested to fill the FIFO until either the interface     reaches TRANSFER_LENGTH or the DMA sends a termination request. The size defined here must match DMA programmed access size.     1=DMA is enabled.and set to 1 Byte      2=DMA is enabled and set to 2 Bytes      3=DMA is enabled and set to 4 Bytes     0=DMA is disabled. All data in the Transmit Buffer must be emptied by firmware."/>
            <edc:SFRFieldDef edc:cname="RX_TRANS_EN" edc:nzwidth="0x1" edc:desc="This bit enables the receive function of the SPI interface.     1=Receive is enabled. Data received from the SPI Slave is stored in the Receive Buffer; 0=Receive is disabled."/>
            <edc:SFRFieldDef edc:cname="RX_DMA_EN" edc:nzwidth="0x2" edc:desc="This bit enables DMA support for Receive Transfer. If enabled, DMA will be requested to empty the FIFO until either the interface reaches TRANSFER_LENGTH or the DMA sends a termination request. The size defined here must match DMA programmed access size.     1=DMA is enabled.and set to 1 Byte     2=DMA is enabled and set to 2 Bytes     3=DMA is enabled and set to 4 Bytes     0=DMA is disabled. All data in the Receive Buffer must be emptied by firmware."/>
            <edc:SFRFieldDef edc:cname="CLOSE_TRANS_EN" edc:nzwidth="0x1" edc:desc="This selects what action is taken at the end of a transfer. This bit must be set only on the Last Buffer.     1=The transfer is terminated. The Chip Select de-asserts, the SPI interface returns to IDLE and the DMA interface completes the transfer.     0=The transfer is not closed. Chip Select remains asserted and the DMA interface and the SPI interface remain active"/>
            <edc:SFRFieldDef edc:cname="TRANS_LEN" edc:nzwidth="0x2" edc:desc="3=TRANSFER_LENGTH defined in units of 16-byte segments,            2=TRANSFER_LENGTH defined in units of 4-byte segments     1=TRANSFER_LENGTH defined in units of bytes,     0=TRANSFER_LENGTH defined in units of bits"/>
            <edc:SFRFieldDef edc:cname="DESCR_BUF_NXT_PTR" edc:nzwidth="0x4" edc:desc="This defines the next buffer to be used if Description Buffers are enabled and this is not the last buffer. This can point to the current buffer, creating an infinite loop."/>
            <edc:SFRFieldDef edc:cname="DESCR_BUF_LAST" edc:nzwidth="0x1" edc:desc="Last Descriptor. 1=Last Description Buffer in the chain. 0=This is not the last buffer."/>
            <edc:SFRFieldDef edc:cname="TX_LEN" edc:nzwidth="0xF" edc:desc="The length of the SPI transfer. The count is in bytes or bits, depending on the value of TRANSFER_LENGTH_BITS. A value of 0 means an infinite length transfer."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="QMSPI0" edc:cname="DESCR9" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x40070054">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="QMSPI0">
            <edc:SFRFieldDef edc:cname="INFACE_MOD" edc:nzwidth="0x2" edc:desc="This field sets the transmission mode. If this field is set for Dual Mode or Quad Mode then either TX_TRANSFER_ENABLE or RX_TRANSFER_ENABLE must be 0.     3=Reserved; 2=Quad Mode; 1=Dual Mode; 0=Single/Duplex Mode."/>
            <edc:SFRFieldDef edc:cname="TX_TRANS_EN" edc:nzwidth="0x2" edc:desc="This field bit selects the transmit function of the SPI interface.     3=Transmit Enabled in 1 Mode. The MOSI or IO Bus will send out only 1's. The Transmit Buffer will not be used     2=Transmit Enabled in 0 Mode. The MOSI or IO Bus will send out only 0's. The Transmit Buffer will not be used.     1=Transmit Enabled. Data will be fetched from the Transmit Buffer and sent out on the MOSI or IO Bus.     0=Transmit is Disabled. No data is sent. This will cause the MOSI be to be undriven, or the IO bus to be undriven if Receive is also disabled."/>
            <edc:SFRFieldDef edc:cname="TX_DMA_EN" edc:nzwidth="0x2" edc:desc="This bit enables DMA support for Transmit Transfer. If enabled, DMA will be requested to fill the FIFO until either the interface     reaches TRANSFER_LENGTH or the DMA sends a termination request. The size defined here must match DMA programmed access size.     1=DMA is enabled.and set to 1 Byte      2=DMA is enabled and set to 2 Bytes      3=DMA is enabled and set to 4 Bytes     0=DMA is disabled. All data in the Transmit Buffer must be emptied by firmware."/>
            <edc:SFRFieldDef edc:cname="RX_TRANS_EN" edc:nzwidth="0x1" edc:desc="This bit enables the receive function of the SPI interface.     1=Receive is enabled. Data received from the SPI Slave is stored in the Receive Buffer; 0=Receive is disabled."/>
            <edc:SFRFieldDef edc:cname="RX_DMA_EN" edc:nzwidth="0x2" edc:desc="This bit enables DMA support for Receive Transfer. If enabled, DMA will be requested to empty the FIFO until either the interface reaches TRANSFER_LENGTH or the DMA sends a termination request. The size defined here must match DMA programmed access size.     1=DMA is enabled.and set to 1 Byte     2=DMA is enabled and set to 2 Bytes     3=DMA is enabled and set to 4 Bytes     0=DMA is disabled. All data in the Receive Buffer must be emptied by firmware."/>
            <edc:SFRFieldDef edc:cname="CLOSE_TRANS_EN" edc:nzwidth="0x1" edc:desc="This selects what action is taken at the end of a transfer. This bit must be set only on the Last Buffer.     1=The transfer is terminated. The Chip Select de-asserts, the SPI interface returns to IDLE and the DMA interface completes the transfer.     0=The transfer is not closed. Chip Select remains asserted and the DMA interface and the SPI interface remain active"/>
            <edc:SFRFieldDef edc:cname="TRANS_LEN" edc:nzwidth="0x2" edc:desc="3=TRANSFER_LENGTH defined in units of 16-byte segments,            2=TRANSFER_LENGTH defined in units of 4-byte segments     1=TRANSFER_LENGTH defined in units of bytes,     0=TRANSFER_LENGTH defined in units of bits"/>
            <edc:SFRFieldDef edc:cname="DESCR_BUF_NXT_PTR" edc:nzwidth="0x4" edc:desc="This defines the next buffer to be used if Description Buffers are enabled and this is not the last buffer. This can point to the current buffer, creating an infinite loop."/>
            <edc:SFRFieldDef edc:cname="DESCR_BUF_LAST" edc:nzwidth="0x1" edc:desc="Last Descriptor. 1=Last Description Buffer in the chain. 0=This is not the last buffer."/>
            <edc:SFRFieldDef edc:cname="TX_LEN" edc:nzwidth="0xF" edc:desc="The length of the SPI transfer. The count is in bytes or bits, depending on the value of TRANSFER_LENGTH_BITS. A value of 0 means an infinite length transfer."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="QMSPI0" edc:cname="DESCR10" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x40070058">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="QMSPI0">
            <edc:SFRFieldDef edc:cname="INFACE_MOD" edc:nzwidth="0x2" edc:desc="This field sets the transmission mode. If this field is set for Dual Mode or Quad Mode then either TX_TRANSFER_ENABLE or RX_TRANSFER_ENABLE must be 0.     3=Reserved; 2=Quad Mode; 1=Dual Mode; 0=Single/Duplex Mode."/>
            <edc:SFRFieldDef edc:cname="TX_TRANS_EN" edc:nzwidth="0x2" edc:desc="This field bit selects the transmit function of the SPI interface.     3=Transmit Enabled in 1 Mode. The MOSI or IO Bus will send out only 1's. The Transmit Buffer will not be used     2=Transmit Enabled in 0 Mode. The MOSI or IO Bus will send out only 0's. The Transmit Buffer will not be used.     1=Transmit Enabled. Data will be fetched from the Transmit Buffer and sent out on the MOSI or IO Bus.     0=Transmit is Disabled. No data is sent. This will cause the MOSI be to be undriven, or the IO bus to be undriven if Receive is also disabled."/>
            <edc:SFRFieldDef edc:cname="TX_DMA_EN" edc:nzwidth="0x2" edc:desc="This bit enables DMA support for Transmit Transfer. If enabled, DMA will be requested to fill the FIFO until either the interface     reaches TRANSFER_LENGTH or the DMA sends a termination request. The size defined here must match DMA programmed access size.     1=DMA is enabled.and set to 1 Byte      2=DMA is enabled and set to 2 Bytes      3=DMA is enabled and set to 4 Bytes     0=DMA is disabled. All data in the Transmit Buffer must be emptied by firmware."/>
            <edc:SFRFieldDef edc:cname="RX_TRANS_EN" edc:nzwidth="0x1" edc:desc="This bit enables the receive function of the SPI interface.     1=Receive is enabled. Data received from the SPI Slave is stored in the Receive Buffer; 0=Receive is disabled."/>
            <edc:SFRFieldDef edc:cname="RX_DMA_EN" edc:nzwidth="0x2" edc:desc="This bit enables DMA support for Receive Transfer. If enabled, DMA will be requested to empty the FIFO until either the interface reaches TRANSFER_LENGTH or the DMA sends a termination request. The size defined here must match DMA programmed access size.     1=DMA is enabled.and set to 1 Byte     2=DMA is enabled and set to 2 Bytes     3=DMA is enabled and set to 4 Bytes     0=DMA is disabled. All data in the Receive Buffer must be emptied by firmware."/>
            <edc:SFRFieldDef edc:cname="CLOSE_TRANS_EN" edc:nzwidth="0x1" edc:desc="This selects what action is taken at the end of a transfer. This bit must be set only on the Last Buffer.     1=The transfer is terminated. The Chip Select de-asserts, the SPI interface returns to IDLE and the DMA interface completes the transfer.     0=The transfer is not closed. Chip Select remains asserted and the DMA interface and the SPI interface remain active"/>
            <edc:SFRFieldDef edc:cname="TRANS_LEN" edc:nzwidth="0x2" edc:desc="3=TRANSFER_LENGTH defined in units of 16-byte segments,            2=TRANSFER_LENGTH defined in units of 4-byte segments     1=TRANSFER_LENGTH defined in units of bytes,     0=TRANSFER_LENGTH defined in units of bits"/>
            <edc:SFRFieldDef edc:cname="DESCR_BUF_NXT_PTR" edc:nzwidth="0x4" edc:desc="This defines the next buffer to be used if Description Buffers are enabled and this is not the last buffer. This can point to the current buffer, creating an infinite loop."/>
            <edc:SFRFieldDef edc:cname="DESCR_BUF_LAST" edc:nzwidth="0x1" edc:desc="Last Descriptor. 1=Last Description Buffer in the chain. 0=This is not the last buffer."/>
            <edc:SFRFieldDef edc:cname="TX_LEN" edc:nzwidth="0xF" edc:desc="The length of the SPI transfer. The count is in bytes or bits, depending on the value of TRANSFER_LENGTH_BITS. A value of 0 means an infinite length transfer."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="QMSPI0" edc:cname="DESCR11" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x4007005C">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="QMSPI0">
            <edc:SFRFieldDef edc:cname="INFACE_MOD" edc:nzwidth="0x2" edc:desc="This field sets the transmission mode. If this field is set for Dual Mode or Quad Mode then either TX_TRANSFER_ENABLE or RX_TRANSFER_ENABLE must be 0.     3=Reserved; 2=Quad Mode; 1=Dual Mode; 0=Single/Duplex Mode."/>
            <edc:SFRFieldDef edc:cname="TX_TRANS_EN" edc:nzwidth="0x2" edc:desc="This field bit selects the transmit function of the SPI interface.     3=Transmit Enabled in 1 Mode. The MOSI or IO Bus will send out only 1's. The Transmit Buffer will not be used     2=Transmit Enabled in 0 Mode. The MOSI or IO Bus will send out only 0's. The Transmit Buffer will not be used.     1=Transmit Enabled. Data will be fetched from the Transmit Buffer and sent out on the MOSI or IO Bus.     0=Transmit is Disabled. No data is sent. This will cause the MOSI be to be undriven, or the IO bus to be undriven if Receive is also disabled."/>
            <edc:SFRFieldDef edc:cname="TX_DMA_EN" edc:nzwidth="0x2" edc:desc="This bit enables DMA support for Transmit Transfer. If enabled, DMA will be requested to fill the FIFO until either the interface     reaches TRANSFER_LENGTH or the DMA sends a termination request. The size defined here must match DMA programmed access size.     1=DMA is enabled.and set to 1 Byte      2=DMA is enabled and set to 2 Bytes      3=DMA is enabled and set to 4 Bytes     0=DMA is disabled. All data in the Transmit Buffer must be emptied by firmware."/>
            <edc:SFRFieldDef edc:cname="RX_TRANS_EN" edc:nzwidth="0x1" edc:desc="This bit enables the receive function of the SPI interface.     1=Receive is enabled. Data received from the SPI Slave is stored in the Receive Buffer; 0=Receive is disabled."/>
            <edc:SFRFieldDef edc:cname="RX_DMA_EN" edc:nzwidth="0x2" edc:desc="This bit enables DMA support for Receive Transfer. If enabled, DMA will be requested to empty the FIFO until either the interface reaches TRANSFER_LENGTH or the DMA sends a termination request. The size defined here must match DMA programmed access size.     1=DMA is enabled.and set to 1 Byte     2=DMA is enabled and set to 2 Bytes     3=DMA is enabled and set to 4 Bytes     0=DMA is disabled. All data in the Receive Buffer must be emptied by firmware."/>
            <edc:SFRFieldDef edc:cname="CLOSE_TRANS_EN" edc:nzwidth="0x1" edc:desc="This selects what action is taken at the end of a transfer. This bit must be set only on the Last Buffer.     1=The transfer is terminated. The Chip Select de-asserts, the SPI interface returns to IDLE and the DMA interface completes the transfer.     0=The transfer is not closed. Chip Select remains asserted and the DMA interface and the SPI interface remain active"/>
            <edc:SFRFieldDef edc:cname="TRANS_LEN" edc:nzwidth="0x2" edc:desc="3=TRANSFER_LENGTH defined in units of 16-byte segments,            2=TRANSFER_LENGTH defined in units of 4-byte segments     1=TRANSFER_LENGTH defined in units of bytes,     0=TRANSFER_LENGTH defined in units of bits"/>
            <edc:SFRFieldDef edc:cname="DESCR_BUF_NXT_PTR" edc:nzwidth="0x4" edc:desc="This defines the next buffer to be used if Description Buffers are enabled and this is not the last buffer. This can point to the current buffer, creating an infinite loop."/>
            <edc:SFRFieldDef edc:cname="DESCR_BUF_LAST" edc:nzwidth="0x1" edc:desc="Last Descriptor. 1=Last Description Buffer in the chain. 0=This is not the last buffer."/>
            <edc:SFRFieldDef edc:cname="TX_LEN" edc:nzwidth="0xF" edc:desc="The length of the SPI transfer. The count is in bytes or bits, depending on the value of TRANSFER_LENGTH_BITS. A value of 0 means an infinite length transfer."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="QMSPI0" edc:cname="DESCR12" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x40070060">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="QMSPI0">
            <edc:SFRFieldDef edc:cname="INFACE_MOD" edc:nzwidth="0x2" edc:desc="This field sets the transmission mode. If this field is set for Dual Mode or Quad Mode then either TX_TRANSFER_ENABLE or RX_TRANSFER_ENABLE must be 0.     3=Reserved; 2=Quad Mode; 1=Dual Mode; 0=Single/Duplex Mode."/>
            <edc:SFRFieldDef edc:cname="TX_TRANS_EN" edc:nzwidth="0x2" edc:desc="This field bit selects the transmit function of the SPI interface.     3=Transmit Enabled in 1 Mode. The MOSI or IO Bus will send out only 1's. The Transmit Buffer will not be used     2=Transmit Enabled in 0 Mode. The MOSI or IO Bus will send out only 0's. The Transmit Buffer will not be used.     1=Transmit Enabled. Data will be fetched from the Transmit Buffer and sent out on the MOSI or IO Bus.     0=Transmit is Disabled. No data is sent. This will cause the MOSI be to be undriven, or the IO bus to be undriven if Receive is also disabled."/>
            <edc:SFRFieldDef edc:cname="TX_DMA_EN" edc:nzwidth="0x2" edc:desc="This bit enables DMA support for Transmit Transfer. If enabled, DMA will be requested to fill the FIFO until either the interface     reaches TRANSFER_LENGTH or the DMA sends a termination request. The size defined here must match DMA programmed access size.     1=DMA is enabled.and set to 1 Byte      2=DMA is enabled and set to 2 Bytes      3=DMA is enabled and set to 4 Bytes     0=DMA is disabled. All data in the Transmit Buffer must be emptied by firmware."/>
            <edc:SFRFieldDef edc:cname="RX_TRANS_EN" edc:nzwidth="0x1" edc:desc="This bit enables the receive function of the SPI interface.     1=Receive is enabled. Data received from the SPI Slave is stored in the Receive Buffer; 0=Receive is disabled."/>
            <edc:SFRFieldDef edc:cname="RX_DMA_EN" edc:nzwidth="0x2" edc:desc="This bit enables DMA support for Receive Transfer. If enabled, DMA will be requested to empty the FIFO until either the interface reaches TRANSFER_LENGTH or the DMA sends a termination request. The size defined here must match DMA programmed access size.     1=DMA is enabled.and set to 1 Byte     2=DMA is enabled and set to 2 Bytes     3=DMA is enabled and set to 4 Bytes     0=DMA is disabled. All data in the Receive Buffer must be emptied by firmware."/>
            <edc:SFRFieldDef edc:cname="CLOSE_TRANS_EN" edc:nzwidth="0x1" edc:desc="This selects what action is taken at the end of a transfer. This bit must be set only on the Last Buffer.     1=The transfer is terminated. The Chip Select de-asserts, the SPI interface returns to IDLE and the DMA interface completes the transfer.     0=The transfer is not closed. Chip Select remains asserted and the DMA interface and the SPI interface remain active"/>
            <edc:SFRFieldDef edc:cname="TRANS_LEN" edc:nzwidth="0x2" edc:desc="3=TRANSFER_LENGTH defined in units of 16-byte segments,            2=TRANSFER_LENGTH defined in units of 4-byte segments     1=TRANSFER_LENGTH defined in units of bytes,     0=TRANSFER_LENGTH defined in units of bits"/>
            <edc:SFRFieldDef edc:cname="DESCR_BUF_NXT_PTR" edc:nzwidth="0x4" edc:desc="This defines the next buffer to be used if Description Buffers are enabled and this is not the last buffer. This can point to the current buffer, creating an infinite loop."/>
            <edc:SFRFieldDef edc:cname="DESCR_BUF_LAST" edc:nzwidth="0x1" edc:desc="Last Descriptor. 1=Last Description Buffer in the chain. 0=This is not the last buffer."/>
            <edc:SFRFieldDef edc:cname="TX_LEN" edc:nzwidth="0xF" edc:desc="The length of the SPI transfer. The count is in bytes or bits, depending on the value of TRANSFER_LENGTH_BITS. A value of 0 means an infinite length transfer."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="QMSPI0" edc:cname="DESCR13" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x40070064">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="QMSPI0">
            <edc:SFRFieldDef edc:cname="INFACE_MOD" edc:nzwidth="0x2" edc:desc="This field sets the transmission mode. If this field is set for Dual Mode or Quad Mode then either TX_TRANSFER_ENABLE or RX_TRANSFER_ENABLE must be 0.     3=Reserved; 2=Quad Mode; 1=Dual Mode; 0=Single/Duplex Mode."/>
            <edc:SFRFieldDef edc:cname="TX_TRANS_EN" edc:nzwidth="0x2" edc:desc="This field bit selects the transmit function of the SPI interface.     3=Transmit Enabled in 1 Mode. The MOSI or IO Bus will send out only 1's. The Transmit Buffer will not be used     2=Transmit Enabled in 0 Mode. The MOSI or IO Bus will send out only 0's. The Transmit Buffer will not be used.     1=Transmit Enabled. Data will be fetched from the Transmit Buffer and sent out on the MOSI or IO Bus.     0=Transmit is Disabled. No data is sent. This will cause the MOSI be to be undriven, or the IO bus to be undriven if Receive is also disabled."/>
            <edc:SFRFieldDef edc:cname="TX_DMA_EN" edc:nzwidth="0x2" edc:desc="This bit enables DMA support for Transmit Transfer. If enabled, DMA will be requested to fill the FIFO until either the interface     reaches TRANSFER_LENGTH or the DMA sends a termination request. The size defined here must match DMA programmed access size.     1=DMA is enabled.and set to 1 Byte      2=DMA is enabled and set to 2 Bytes      3=DMA is enabled and set to 4 Bytes     0=DMA is disabled. All data in the Transmit Buffer must be emptied by firmware."/>
            <edc:SFRFieldDef edc:cname="RX_TRANS_EN" edc:nzwidth="0x1" edc:desc="This bit enables the receive function of the SPI interface.     1=Receive is enabled. Data received from the SPI Slave is stored in the Receive Buffer; 0=Receive is disabled."/>
            <edc:SFRFieldDef edc:cname="RX_DMA_EN" edc:nzwidth="0x2" edc:desc="This bit enables DMA support for Receive Transfer. If enabled, DMA will be requested to empty the FIFO until either the interface reaches TRANSFER_LENGTH or the DMA sends a termination request. The size defined here must match DMA programmed access size.     1=DMA is enabled.and set to 1 Byte     2=DMA is enabled and set to 2 Bytes     3=DMA is enabled and set to 4 Bytes     0=DMA is disabled. All data in the Receive Buffer must be emptied by firmware."/>
            <edc:SFRFieldDef edc:cname="CLOSE_TRANS_EN" edc:nzwidth="0x1" edc:desc="This selects what action is taken at the end of a transfer. This bit must be set only on the Last Buffer.     1=The transfer is terminated. The Chip Select de-asserts, the SPI interface returns to IDLE and the DMA interface completes the transfer.     0=The transfer is not closed. Chip Select remains asserted and the DMA interface and the SPI interface remain active"/>
            <edc:SFRFieldDef edc:cname="TRANS_LEN" edc:nzwidth="0x2" edc:desc="3=TRANSFER_LENGTH defined in units of 16-byte segments,            2=TRANSFER_LENGTH defined in units of 4-byte segments     1=TRANSFER_LENGTH defined in units of bytes,     0=TRANSFER_LENGTH defined in units of bits"/>
            <edc:SFRFieldDef edc:cname="DESCR_BUF_NXT_PTR" edc:nzwidth="0x4" edc:desc="This defines the next buffer to be used if Description Buffers are enabled and this is not the last buffer. This can point to the current buffer, creating an infinite loop."/>
            <edc:SFRFieldDef edc:cname="DESCR_BUF_LAST" edc:nzwidth="0x1" edc:desc="Last Descriptor. 1=Last Description Buffer in the chain. 0=This is not the last buffer."/>
            <edc:SFRFieldDef edc:cname="TX_LEN" edc:nzwidth="0xF" edc:desc="The length of the SPI transfer. The count is in bytes or bits, depending on the value of TRANSFER_LENGTH_BITS. A value of 0 means an infinite length transfer."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="QMSPI0" edc:cname="DESCR14" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x40070068">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="QMSPI0">
            <edc:SFRFieldDef edc:cname="INFACE_MOD" edc:nzwidth="0x2" edc:desc="This field sets the transmission mode. If this field is set for Dual Mode or Quad Mode then either TX_TRANSFER_ENABLE or RX_TRANSFER_ENABLE must be 0.     3=Reserved; 2=Quad Mode; 1=Dual Mode; 0=Single/Duplex Mode."/>
            <edc:SFRFieldDef edc:cname="TX_TRANS_EN" edc:nzwidth="0x2" edc:desc="This field bit selects the transmit function of the SPI interface.     3=Transmit Enabled in 1 Mode. The MOSI or IO Bus will send out only 1's. The Transmit Buffer will not be used     2=Transmit Enabled in 0 Mode. The MOSI or IO Bus will send out only 0's. The Transmit Buffer will not be used.     1=Transmit Enabled. Data will be fetched from the Transmit Buffer and sent out on the MOSI or IO Bus.     0=Transmit is Disabled. No data is sent. This will cause the MOSI be to be undriven, or the IO bus to be undriven if Receive is also disabled."/>
            <edc:SFRFieldDef edc:cname="TX_DMA_EN" edc:nzwidth="0x2" edc:desc="This bit enables DMA support for Transmit Transfer. If enabled, DMA will be requested to fill the FIFO until either the interface     reaches TRANSFER_LENGTH or the DMA sends a termination request. The size defined here must match DMA programmed access size.     1=DMA is enabled.and set to 1 Byte      2=DMA is enabled and set to 2 Bytes      3=DMA is enabled and set to 4 Bytes     0=DMA is disabled. All data in the Transmit Buffer must be emptied by firmware."/>
            <edc:SFRFieldDef edc:cname="RX_TRANS_EN" edc:nzwidth="0x1" edc:desc="This bit enables the receive function of the SPI interface.     1=Receive is enabled. Data received from the SPI Slave is stored in the Receive Buffer; 0=Receive is disabled."/>
            <edc:SFRFieldDef edc:cname="RX_DMA_EN" edc:nzwidth="0x2" edc:desc="This bit enables DMA support for Receive Transfer. If enabled, DMA will be requested to empty the FIFO until either the interface reaches TRANSFER_LENGTH or the DMA sends a termination request. The size defined here must match DMA programmed access size.     1=DMA is enabled.and set to 1 Byte     2=DMA is enabled and set to 2 Bytes     3=DMA is enabled and set to 4 Bytes     0=DMA is disabled. All data in the Receive Buffer must be emptied by firmware."/>
            <edc:SFRFieldDef edc:cname="CLOSE_TRANS_EN" edc:nzwidth="0x1" edc:desc="This selects what action is taken at the end of a transfer. This bit must be set only on the Last Buffer.     1=The transfer is terminated. The Chip Select de-asserts, the SPI interface returns to IDLE and the DMA interface completes the transfer.     0=The transfer is not closed. Chip Select remains asserted and the DMA interface and the SPI interface remain active"/>
            <edc:SFRFieldDef edc:cname="TRANS_LEN" edc:nzwidth="0x2" edc:desc="3=TRANSFER_LENGTH defined in units of 16-byte segments,            2=TRANSFER_LENGTH defined in units of 4-byte segments     1=TRANSFER_LENGTH defined in units of bytes,     0=TRANSFER_LENGTH defined in units of bits"/>
            <edc:SFRFieldDef edc:cname="DESCR_BUF_NXT_PTR" edc:nzwidth="0x4" edc:desc="This defines the next buffer to be used if Description Buffers are enabled and this is not the last buffer. This can point to the current buffer, creating an infinite loop."/>
            <edc:SFRFieldDef edc:cname="DESCR_BUF_LAST" edc:nzwidth="0x1" edc:desc="Last Descriptor. 1=Last Description Buffer in the chain. 0=This is not the last buffer."/>
            <edc:SFRFieldDef edc:cname="TX_LEN" edc:nzwidth="0xF" edc:desc="The length of the SPI transfer. The count is in bytes or bits, depending on the value of TRANSFER_LENGTH_BITS. A value of 0 means an infinite length transfer."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="QMSPI0" edc:cname="DESCR15" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x4007006C">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="QMSPI0">
            <edc:SFRFieldDef edc:cname="INFACE_MOD" edc:nzwidth="0x2" edc:desc="This field sets the transmission mode. If this field is set for Dual Mode or Quad Mode then either TX_TRANSFER_ENABLE or RX_TRANSFER_ENABLE must be 0.     3=Reserved; 2=Quad Mode; 1=Dual Mode; 0=Single/Duplex Mode."/>
            <edc:SFRFieldDef edc:cname="TX_TRANS_EN" edc:nzwidth="0x2" edc:desc="This field bit selects the transmit function of the SPI interface.     3=Transmit Enabled in 1 Mode. The MOSI or IO Bus will send out only 1's. The Transmit Buffer will not be used     2=Transmit Enabled in 0 Mode. The MOSI or IO Bus will send out only 0's. The Transmit Buffer will not be used.     1=Transmit Enabled. Data will be fetched from the Transmit Buffer and sent out on the MOSI or IO Bus.     0=Transmit is Disabled. No data is sent. This will cause the MOSI be to be undriven, or the IO bus to be undriven if Receive is also disabled."/>
            <edc:SFRFieldDef edc:cname="TX_DMA_EN" edc:nzwidth="0x2" edc:desc="This bit enables DMA support for Transmit Transfer. If enabled, DMA will be requested to fill the FIFO until either the interface     reaches TRANSFER_LENGTH or the DMA sends a termination request. The size defined here must match DMA programmed access size.     1=DMA is enabled.and set to 1 Byte      2=DMA is enabled and set to 2 Bytes      3=DMA is enabled and set to 4 Bytes     0=DMA is disabled. All data in the Transmit Buffer must be emptied by firmware."/>
            <edc:SFRFieldDef edc:cname="RX_TRANS_EN" edc:nzwidth="0x1" edc:desc="This bit enables the receive function of the SPI interface.     1=Receive is enabled. Data received from the SPI Slave is stored in the Receive Buffer; 0=Receive is disabled."/>
            <edc:SFRFieldDef edc:cname="RX_DMA_EN" edc:nzwidth="0x2" edc:desc="This bit enables DMA support for Receive Transfer. If enabled, DMA will be requested to empty the FIFO until either the interface reaches TRANSFER_LENGTH or the DMA sends a termination request. The size defined here must match DMA programmed access size.     1=DMA is enabled.and set to 1 Byte     2=DMA is enabled and set to 2 Bytes     3=DMA is enabled and set to 4 Bytes     0=DMA is disabled. All data in the Receive Buffer must be emptied by firmware."/>
            <edc:SFRFieldDef edc:cname="CLOSE_TRANS_EN" edc:nzwidth="0x1" edc:desc="This selects what action is taken at the end of a transfer. This bit must be set only on the Last Buffer.     1=The transfer is terminated. The Chip Select de-asserts, the SPI interface returns to IDLE and the DMA interface completes the transfer.     0=The transfer is not closed. Chip Select remains asserted and the DMA interface and the SPI interface remain active"/>
            <edc:SFRFieldDef edc:cname="TRANS_LEN" edc:nzwidth="0x2" edc:desc="3=TRANSFER_LENGTH defined in units of 16-byte segments,            2=TRANSFER_LENGTH defined in units of 4-byte segments     1=TRANSFER_LENGTH defined in units of bytes,     0=TRANSFER_LENGTH defined in units of bits"/>
            <edc:SFRFieldDef edc:cname="DESCR_BUF_NXT_PTR" edc:nzwidth="0x4" edc:desc="This defines the next buffer to be used if Description Buffers are enabled and this is not the last buffer. This can point to the current buffer, creating an infinite loop."/>
            <edc:SFRFieldDef edc:cname="DESCR_BUF_LAST" edc:nzwidth="0x1" edc:desc="Last Descriptor. 1=Last Description Buffer in the chain. 0=This is not the last buffer."/>
            <edc:SFRFieldDef edc:cname="TX_LEN" edc:nzwidth="0xF" edc:desc="The length of the SPI transfer. The count is in bytes or bits, depending on the value of TRANSFER_LENGTH_BITS. A value of 0 means an infinite length transfer."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:AdjustPoint edc:offset="0x40" edc:_addr="0x40070070"/>
      <edc:SFRDef ltx:memberofperipheral="QMSPI0" edc:cname="ALIAS_CTRL" edc:nzwidth="0x20" edc:access="wwwwwwwwwwwwwwwwwwwwwwww-wwwwwww" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0xFFFFFF7F" edc:_addr="0x400700B0">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="QMSPI0">
            <edc:SFRFieldDef edc:cname="ALS_EXEC_STRT" edc:nzwidth="0x1" edc:desc="Alias for the QMSPI Execution:Start field."/>
            <edc:SFRFieldDef edc:cname="CLS_ALTMODE_EN" edc:nzwidth="0x1" edc:desc="Enable the CS1 Clock Divide to be active if CS1 is the interface in use."/>
            <edc:SFRFieldDef edc:cname="ALS_WR_TXBUF" edc:nzwidth="0x1" edc:desc="Alias that triggers a write to the Tx Buffer of 1 Byte using data from Alias Tx Buffer Data in this register."/>
            <edc:SFRFieldDef edc:cname="ALS_WRDBUF_XFRLEN" edc:nzwidth="0x1" edc:desc="Alias that triggers a write to the Description Buffer pointed to by Alias Description Buffer Select in this register to modify the Transfer Length field with the value of Alias Description Buffer Transfer Length in this register."/>
            <edc:SFRFieldDef edc:cname="ALS_MOD_CS" edc:nzwidth="0x2" edc:desc="Alias for the QMSPI Mode:Chip Select field."/>
            <edc:SFRFieldDef edc:cname="ALS_LDMA_INCR_ADD" edc:nzwidth="0x1" edc:desc="Alias that overrides the value in all QMSPI Local DMA * [Tx/Rx] Control:Increment Address Enable fields w/ this value."/>
            <edc:AdjustPoint edc:offset="0x1"/>
            <edc:SFRFieldDef edc:cname="ALS_CTRL_DBUF_PTR" edc:nzwidth="0x4" edc:desc="Alias for the QMSPI Control:Description Buffer Pointer field."/>
            <edc:SFRFieldDef edc:cname="ALS_DBUF_SEL" edc:nzwidth="0x4" edc:desc="Which Description Buffer will be modified by a write if Alias Write Description Buffer Transfer Length is set."/>
            <edc:SFRFieldDef edc:cname="ALS_DBUF_XFR_LEN" edc:nzwidth="0x8" edc:desc="The value of the data written to the Description Buffers Transfer Length field, if the write is enabled."/>
            <edc:SFRFieldDef edc:cname="ALS_TXDBUF_DATA" edc:nzwidth="0x8" edc:desc="The Byte of data written into the Tx Buffer if the write is enabled."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:AdjustPoint edc:offset="0xC" edc:_addr="0x400700B4"/>
      <edc:SFRDef ltx:memberofperipheral="QMSPI0" edc:cname="MODE_ALT1" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnn---------------n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0xFFFF0001" edc:_addr="0x400700C0">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="QMSPI0">
            <edc:SFRFieldDef edc:cname="CS1_ALTMOD_EN" edc:nzwidth="0x1" edc:desc="Enable the CS1 Clock Divide to be active if CS1 is the interface in use."/>
            <edc:AdjustPoint edc:offset="0xF"/>
            <edc:SFRFieldDef edc:cname="CS1_ALTCLK_DIV" edc:nzwidth="0x10" edc:desc="The SPI clock divide in number of system clocks when CS1 is in use and CS1 Alt Mode Enable is set."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:AdjustPoint edc:offset="0xC" edc:_addr="0x400700C4"/>
      <edc:SFRDef ltx:memberofperipheral="QMSPI0" edc:cname="TAPS" edc:nzwidth="0x20" edc:access="----------------nnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0xFFFF" edc:_addr="0x400700D0">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="QMSPI0">
            <edc:SFRFieldDef edc:cname="SCK_TAP" edc:nzwidth="0x8" edc:desc="This will select the tap point for the feed-back SCK."/>
            <edc:SFRFieldDef edc:cname="CTRL_TAP" edc:nzwidth="0x8" edc:desc="This will select the tap point for signals that go from the System Domain."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="QMSPI0" edc:cname="TAP_ADJ" edc:nzwidth="0x20" edc:access="----------------nnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0xFFFF" edc:_addr="0x400700D4">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="QMSPI0">
            <edc:SFRFieldDef edc:cname="SCK_ADJ" edc:nzwidth="0x8" edc:desc="This is a signed value that will be added to the Select SCK Tap to come up with the final value for the delay."/>
            <edc:SFRFieldDef edc:cname="CTRL_ADJ" edc:nzwidth="0x8" edc:desc="This is a signed value that will be added to the Select Control Tap to come up with the final value for the delay."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="QMSPI0" edc:cname="TAP_CTRL" edc:nzwidth="0x20" edc:access="-------------nnn-------n-----nnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x70107" edc:_addr="0x400700D8">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="QMSPI0">
            <edc:SFRFieldDef edc:cname="AUTO_MOD" edc:nzwidth="0x2" edc:desc="This enables the automatic H/W trim of the Tap."/>
            <edc:SFRFieldDef edc:cname="CTRL" edc:nzwidth="0x1" edc:desc="This is a signed value that will be added to the Select Control Tap to come up with the final value for the delay."/>
            <edc:AdjustPoint edc:offset="0x5"/>
            <edc:SFRFieldDef edc:cname="FW_GO" edc:nzwidth="0x1" edc:desc="This will force the auto-trim H/W to run and find a new trim value."/>
            <edc:AdjustPoint edc:offset="0x7"/>
            <edc:SFRFieldDef edc:cname="AUTO_MULT" edc:nzwidth="0x3" edc:desc="This will multiply the target delay value the Auto-trim H/W will search for."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:AdjustPoint edc:offset="0x24" edc:_addr="0x400700DC"/>
      <edc:SFRDef ltx:memberofperipheral="QMSPI0" edc:cname="DESC_LDMA_RXEN" edc:nzwidth="0x20" edc:access="----------------nnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0xFFFF" edc:_addr="0x40070100">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="QMSPI0">
            <edc:SFRFieldDef edc:cname="DESC_LDMA_RXEN" edc:nzwidth="0x10" edc:desc="This enables the Local RX DMA usage (instead of the Central DMA) when the Descriptor Buffer register enables the DMA."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="QMSPI0" edc:cname="DESC_LDMA_TXEN" edc:nzwidth="0x20" edc:access="----------------nnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0xFFFF" edc:_addr="0x40070104">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="QMSPI0">
            <edc:SFRFieldDef edc:cname="DESC_LDMA_TXEN" edc:nzwidth="0x10" edc:desc="This enables the Local TX DMA usage (instead of the Central DMA) when the Descriptor Buffer register enables the DMA."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:AdjustPoint edc:offset="0x8" edc:_addr="0x40070108"/>
      <edc:SFRDef ltx:memberofperipheral="QMSPI0" edc:cname="LDMA_RX0LDMA_RXCTRL" edc:nzwidth="0x20" edc:access="-------------------------nnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x7F" edc:_addr="0x40070110">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="QMSPI0">
            <edc:SFRFieldDef edc:cname="CH_EN" edc:nzwidth="0x1" edc:desc="This enables the Local RX DMA Channel."/>
            <edc:SFRFieldDef edc:cname="RSTRT_EN" edc:nzwidth="0x1" edc:desc="This bit automatically re-enables the Local DMA Channel after completion of previous transfer."/>
            <edc:SFRFieldDef edc:cname="BUF_ADDR_EN" edc:nzwidth="0x1" edc:desc="Address re-enable will automatically re-enables the same address upon completion previous transfer."/>
            <edc:SFRFieldDef edc:cname="OVRD_LEN" edc:nzwidth="0x1" edc:desc="Override Lenght will override the length field to the QMSPI protocol FSM with the length programmed into the Local DMA."/>
            <edc:SFRFieldDef edc:cname="ACS_SZ" edc:nzwidth="0x2" edc:desc="Access Size selects the AHB Access Size."/>
            <edc:SFRFieldDef edc:cname="INC_ADDR_EN" edc:nzwidth="0x1" edc:desc="When set, the DMA Channels Start Address will increment on every access. If not set the address will not increment."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="QMSPI0" edc:cname="LDMA_RX0LDMA_RXSTRT_ADDR" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x40070114">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="QMSPI0">
            <edc:SFRFieldDef edc:cname="STRT_ADDR" edc:nzwidth="0x20" edc:desc="This is the Starting Address for the DMA access into the memory space (write to this address on Rx). This address is updated by the transfer size based on the Local DMA Access Size after every access."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="QMSPI0" edc:cname="LDMA_RX0LDMA_RX_LEN" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x40070118">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="QMSPI0">
            <edc:SFRFieldDef edc:cname="RX_LEN" edc:nzwidth="0x20" edc:desc="This is the maximum Length of the transfer in Bytes that the DMA Channel will allow access to."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="QMSPI0" edc:cname="LDMA_RX0RSVD" edc:nzwidth="0x20" edc:access="rrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrr" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x4007011C"/>
      <edc:SFRDef ltx:memberofperipheral="QMSPI0" edc:cname="LDMA_RX1LDMA_RXCTRL" edc:nzwidth="0x20" edc:access="-------------------------nnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x7F" edc:_addr="0x40070120">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="QMSPI0">
            <edc:SFRFieldDef edc:cname="CH_EN" edc:nzwidth="0x1" edc:desc="This enables the Local RX DMA Channel."/>
            <edc:SFRFieldDef edc:cname="RSTRT_EN" edc:nzwidth="0x1" edc:desc="This bit automatically re-enables the Local DMA Channel after completion of previous transfer."/>
            <edc:SFRFieldDef edc:cname="BUF_ADDR_EN" edc:nzwidth="0x1" edc:desc="Address re-enable will automatically re-enables the same address upon completion previous transfer."/>
            <edc:SFRFieldDef edc:cname="OVRD_LEN" edc:nzwidth="0x1" edc:desc="Override Lenght will override the length field to the QMSPI protocol FSM with the length programmed into the Local DMA."/>
            <edc:SFRFieldDef edc:cname="ACS_SZ" edc:nzwidth="0x2" edc:desc="Access Size selects the AHB Access Size."/>
            <edc:SFRFieldDef edc:cname="INC_ADDR_EN" edc:nzwidth="0x1" edc:desc="When set, the DMA Channels Start Address will increment on every access. If not set the address will not increment."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="QMSPI0" edc:cname="LDMA_RX1LDMA_RXSTRT_ADDR" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x40070124">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="QMSPI0">
            <edc:SFRFieldDef edc:cname="STRT_ADDR" edc:nzwidth="0x20" edc:desc="This is the Starting Address for the DMA access into the memory space (write to this address on Rx). This address is updated by the transfer size based on the Local DMA Access Size after every access."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="QMSPI0" edc:cname="LDMA_RX1LDMA_RX_LEN" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x40070128">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="QMSPI0">
            <edc:SFRFieldDef edc:cname="RX_LEN" edc:nzwidth="0x20" edc:desc="This is the maximum Length of the transfer in Bytes that the DMA Channel will allow access to."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="QMSPI0" edc:cname="LDMA_RX1RSVD" edc:nzwidth="0x20" edc:access="rrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrr" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x4007012C"/>
      <edc:SFRDef ltx:memberofperipheral="QMSPI0" edc:cname="LDMA_RX2LDMA_RXCTRL" edc:nzwidth="0x20" edc:access="-------------------------nnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x7F" edc:_addr="0x40070130">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="QMSPI0">
            <edc:SFRFieldDef edc:cname="CH_EN" edc:nzwidth="0x1" edc:desc="This enables the Local RX DMA Channel."/>
            <edc:SFRFieldDef edc:cname="RSTRT_EN" edc:nzwidth="0x1" edc:desc="This bit automatically re-enables the Local DMA Channel after completion of previous transfer."/>
            <edc:SFRFieldDef edc:cname="BUF_ADDR_EN" edc:nzwidth="0x1" edc:desc="Address re-enable will automatically re-enables the same address upon completion previous transfer."/>
            <edc:SFRFieldDef edc:cname="OVRD_LEN" edc:nzwidth="0x1" edc:desc="Override Lenght will override the length field to the QMSPI protocol FSM with the length programmed into the Local DMA."/>
            <edc:SFRFieldDef edc:cname="ACS_SZ" edc:nzwidth="0x2" edc:desc="Access Size selects the AHB Access Size."/>
            <edc:SFRFieldDef edc:cname="INC_ADDR_EN" edc:nzwidth="0x1" edc:desc="When set, the DMA Channels Start Address will increment on every access. If not set the address will not increment."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="QMSPI0" edc:cname="LDMA_RX2LDMA_RXSTRT_ADDR" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x40070134">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="QMSPI0">
            <edc:SFRFieldDef edc:cname="STRT_ADDR" edc:nzwidth="0x20" edc:desc="This is the Starting Address for the DMA access into the memory space (write to this address on Rx). This address is updated by the transfer size based on the Local DMA Access Size after every access."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="QMSPI0" edc:cname="LDMA_RX2LDMA_RX_LEN" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x40070138">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="QMSPI0">
            <edc:SFRFieldDef edc:cname="RX_LEN" edc:nzwidth="0x20" edc:desc="This is the maximum Length of the transfer in Bytes that the DMA Channel will allow access to."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="QMSPI0" edc:cname="LDMA_RX2RSVD" edc:nzwidth="0x20" edc:access="rrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrr" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x4007013C"/>
      <edc:SFRDef ltx:memberofperipheral="QMSPI0" edc:cname="LDMA_TX0LDMA_TXCTRL" edc:nzwidth="0x20" edc:access="-------------------------nnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x7F" edc:_addr="0x40070140">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="QMSPI0">
            <edc:SFRFieldDef edc:cname="CH_EN" edc:nzwidth="0x1" edc:desc="This enables the Local TX DMA Channel."/>
            <edc:SFRFieldDef edc:cname="RSTRT_EN" edc:nzwidth="0x1" edc:desc="This bit automatically re-enables the Local DMA Channel after completion of previous transfer."/>
            <edc:SFRFieldDef edc:cname="BUF_ADDR_EN" edc:nzwidth="0x1" edc:desc="Address re-enable will automatically re-enables the same address upon completion previous transfer."/>
            <edc:SFRFieldDef edc:cname="OVRD_LEN" edc:nzwidth="0x1" edc:desc="Override Lenght will override the length field to the QMSPI protocol FSM with the length programmed into the Local DMA."/>
            <edc:SFRFieldDef edc:cname="ACS_SZ" edc:nzwidth="0x2" edc:desc="Access Size selects the AHB Access Size."/>
            <edc:SFRFieldDef edc:cname="INC_ADDR_EN" edc:nzwidth="0x1" edc:desc="When set, the DMA Channels Start Address will increment on every access. If not set the address will not increment."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="QMSPI0" edc:cname="LDMA_TX0LDMA_TXSTRT_ADDR" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x40070144">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="QMSPI0">
            <edc:SFRFieldDef edc:cname="STRT_ADDR" edc:nzwidth="0x20" edc:desc="This is the Starting Address for the DMA access into the memory space (Read from this address on Tx). This address is updated by the transfer size based on the Local DMA Access Size after every access."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="QMSPI0" edc:cname="LDMA_TX0LDMA_TX_LEN" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x40070148">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="QMSPI0">
            <edc:SFRFieldDef edc:cname="TX_LEN" edc:nzwidth="0x20" edc:desc="This is the maximum Length of the transfer in Bytes that the DMA Channel will allow access to."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="QMSPI0" edc:cname="LDMA_TX0RSVD" edc:nzwidth="0x20" edc:access="rrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrr" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x4007014C"/>
      <edc:SFRDef ltx:memberofperipheral="QMSPI0" edc:cname="LDMA_TX1LDMA_TXCTRL" edc:nzwidth="0x20" edc:access="-------------------------nnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x7F" edc:_addr="0x40070150">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="QMSPI0">
            <edc:SFRFieldDef edc:cname="CH_EN" edc:nzwidth="0x1" edc:desc="This enables the Local TX DMA Channel."/>
            <edc:SFRFieldDef edc:cname="RSTRT_EN" edc:nzwidth="0x1" edc:desc="This bit automatically re-enables the Local DMA Channel after completion of previous transfer."/>
            <edc:SFRFieldDef edc:cname="BUF_ADDR_EN" edc:nzwidth="0x1" edc:desc="Address re-enable will automatically re-enables the same address upon completion previous transfer."/>
            <edc:SFRFieldDef edc:cname="OVRD_LEN" edc:nzwidth="0x1" edc:desc="Override Lenght will override the length field to the QMSPI protocol FSM with the length programmed into the Local DMA."/>
            <edc:SFRFieldDef edc:cname="ACS_SZ" edc:nzwidth="0x2" edc:desc="Access Size selects the AHB Access Size."/>
            <edc:SFRFieldDef edc:cname="INC_ADDR_EN" edc:nzwidth="0x1" edc:desc="When set, the DMA Channels Start Address will increment on every access. If not set the address will not increment."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="QMSPI0" edc:cname="LDMA_TX1LDMA_TXSTRT_ADDR" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x40070154">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="QMSPI0">
            <edc:SFRFieldDef edc:cname="STRT_ADDR" edc:nzwidth="0x20" edc:desc="This is the Starting Address for the DMA access into the memory space (Read from this address on Tx). This address is updated by the transfer size based on the Local DMA Access Size after every access."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="QMSPI0" edc:cname="LDMA_TX1LDMA_TX_LEN" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x40070158">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="QMSPI0">
            <edc:SFRFieldDef edc:cname="TX_LEN" edc:nzwidth="0x20" edc:desc="This is the maximum Length of the transfer in Bytes that the DMA Channel will allow access to."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="QMSPI0" edc:cname="LDMA_TX1RSVD" edc:nzwidth="0x20" edc:access="rrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrr" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x4007015C"/>
      <edc:SFRDef ltx:memberofperipheral="QMSPI0" edc:cname="LDMA_TX2LDMA_TXCTRL" edc:nzwidth="0x20" edc:access="-------------------------nnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x7F" edc:_addr="0x40070160">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="QMSPI0">
            <edc:SFRFieldDef edc:cname="CH_EN" edc:nzwidth="0x1" edc:desc="This enables the Local TX DMA Channel."/>
            <edc:SFRFieldDef edc:cname="RSTRT_EN" edc:nzwidth="0x1" edc:desc="This bit automatically re-enables the Local DMA Channel after completion of previous transfer."/>
            <edc:SFRFieldDef edc:cname="BUF_ADDR_EN" edc:nzwidth="0x1" edc:desc="Address re-enable will automatically re-enables the same address upon completion previous transfer."/>
            <edc:SFRFieldDef edc:cname="OVRD_LEN" edc:nzwidth="0x1" edc:desc="Override Lenght will override the length field to the QMSPI protocol FSM with the length programmed into the Local DMA."/>
            <edc:SFRFieldDef edc:cname="ACS_SZ" edc:nzwidth="0x2" edc:desc="Access Size selects the AHB Access Size."/>
            <edc:SFRFieldDef edc:cname="INC_ADDR_EN" edc:nzwidth="0x1" edc:desc="When set, the DMA Channels Start Address will increment on every access. If not set the address will not increment."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="QMSPI0" edc:cname="LDMA_TX2LDMA_TXSTRT_ADDR" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x40070164">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="QMSPI0">
            <edc:SFRFieldDef edc:cname="STRT_ADDR" edc:nzwidth="0x20" edc:desc="This is the Starting Address for the DMA access into the memory space (Read from this address on Tx). This address is updated by the transfer size based on the Local DMA Access Size after every access."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="QMSPI0" edc:cname="LDMA_TX2LDMA_TX_LEN" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x40070168">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="QMSPI0">
            <edc:SFRFieldDef edc:cname="TX_LEN" edc:nzwidth="0x20" edc:desc="This is the maximum Length of the transfer in Bytes that the DMA Channel will allow access to."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="QMSPI0" edc:cname="LDMA_TX2RSVD" edc:nzwidth="0x20" edc:access="rrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrr" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x4007016C"/>
      <edc:AdjustPoint edc:offset="0x90" edc:_addr="0x40070170"/>
      <edc:SFRDef ltx:memberofperipheral="QMSPI1" edc:cname="MODE" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnn--nn-nnn---nnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0xFFFF371F" edc:_addr="0x40070200">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="QMSPI1">
            <edc:SFRFieldDef edc:cname="ACT" edc:nzwidth="0x1" edc:desc="This bit is used to activate the QMSPI block.     1=Enabled. The block is fully operational                 0=Disabled. Clocks are gated to conserve power and the output signals are set to their inactive state."/>
            <edc:SFRFieldDef edc:cname="SOFT_RESET" edc:nzwidth="0x1" edc:desc="Writing this bit with a 1 will reset the Quad SPI block. It is self-clearing."/>
            <edc:SFRFieldDef edc:cname="DMA_UNLGND_MOD" edc:nzwidth="0x1" edc:desc="When enabled the DMA is allowed to operate w/ unaligned transfer lengths."/>
            <edc:SFRFieldDef edc:cname="LDMA_RXEN" edc:nzwidth="0x1" edc:desc="This enables the Local DMA RX usage (instead of the Central DMA) when the Control register enables the DMA."/>
            <edc:SFRFieldDef edc:cname="LDMA_TXEN" edc:nzwidth="0x1" edc:desc="This enables the Local DMA TX usage (instead of the Central DMA) when the Control register enables the DMA."/>
            <edc:AdjustPoint edc:offset="0x3"/>
            <edc:SFRFieldDef edc:cname="CPOL" edc:nzwidth="0x1" edc:desc="Polarity of the SPI clock line when there are no transactions in process. 1=SPI Clock starts High; 0=SPI Clock starts Low."/>
            <edc:SFRFieldDef edc:cname="CHPA_MOSI" edc:nzwidth="0x1" edc:desc="Clock phase of the Master data out. Common SPI modes require this field to be programmed with the same value as CHPA_MISO in this register.     e.g. Mode 0: CPOL=0; CHPA_MISO=0; CHPA_MOSI=0; Mode 3: CPOL=1; CHPA_MISO=1; CHPA_MOSI=1. See datasheet for alternate mode settings.                 If CPOL=1: 1=Data changes on the falling edge of the SPI clock; 0=Data changes on the rising edge of the SPI clock                 If CPOL=0: 1=Data changes on the rising edge of the SPI clock; 0=Data changes on the falling edge of the SPI clock"/>
            <edc:SFRFieldDef edc:cname="CHPA_MISO" edc:nzwidth="0x1" edc:desc="Clock phase of the Master data in. Common SPI modes require this field to be programmed with the same value as CHPA_MOSI in this register.     e.g. Mode 0: CPOL=0; CHPA_MISO=0; CHPA_MOSI=0; Mode 3: CPOL=1; CHPA_MISO=1; CHPA_MOSI=1. See datasheet for alternate mode settings.                 If CPOL=1: 1=Data are captured on the rising edge of the SPI clock; 0=Data are captured on the falling edge of the SPI clock                 If CPOL=0: 1=Data are captured on the falling edge of the SPI clock; 0=Data are captured on the rising edge of the SPI clock"/>
            <edc:AdjustPoint edc:offset="0x1"/>
            <edc:SFRFieldDef edc:cname="CS" edc:nzwidth="0x2" edc:desc="This defines which Chip Select will be used by the H/W when doing a transfer."/>
            <edc:AdjustPoint edc:offset="0x2"/>
            <edc:SFRFieldDef edc:cname="CLK_DIV" edc:nzwidth="0x10" edc:desc="The SPI clock divide in number of system clocks. A value of 1 divides the master clock by 1, a value of 255 divides the master clock by 255. A value of 0 divides the master clock by 256."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="QMSPI1" edc:cname="CTRL" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x40070204">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="QMSPI1">
            <edc:SFRFieldDef edc:cname="TX_MODE" edc:nzwidth="0x2" edc:desc="This field sets the transmission mode. If this field is set for Dual Mode or Quad Mode then either      TX_TRANSFER_ENABLE or RX_TRANSFER_ENABLE must be 0.                  3=Reserved; 2=Quad Mode; 1=Dual Mode; 0=Single/Duplex Mode."/>
            <edc:SFRFieldDef edc:cname="TX_TRANS_EN" edc:nzwidth="0x2" edc:desc="This field bit selects the transmit function of the SPI interface.                 3=Transmit Enabled in 1 Mode. The MOSI or IO Bus will send out only 1's. The Transmit Buffer will not be used.                 2=Transmit Enabled in 0 Mode. The MOSI or IO Bus will send out only 0's. The Transmit Buffer will not be used.                 1=Transmit Enabled. Data will be fetched from the Transmit Buffer and sent out on the MOSI or IO Bus.                 0=Transmit is Disabled. Not data is sent. This will cause the MOSI be to be undriven, or the IO bus to be undriven if Receive is also disabled."/>
            <edc:SFRFieldDef edc:cname="TX_DMA_EN" edc:nzwidth="0x2" edc:desc="This bit enables DMA support for Transmit Transfer. If enabled, DMA will be requested to fill the FIFO until either     the interface reaches TRANSFER_LENGTH or the DMA sends a termination request. The size defined here must match DMA programmed access size.     1=DMA is enabled.and set to 1 Byte                 2=DMA is enabled and set to 2 Bytes                 3=DMA is enabled and set to 4 Bytes.     0=DMA is disabled. All data in the Transmit Buffer must be emptied by firmware"/>
            <edc:SFRFieldDef edc:cname="RX_TRANS_EN" edc:nzwidth="0x1" edc:desc="This bit enables the receive function of the SPI interface.                 1=Receive is enabled. Data received from the SPI Slave is stored in the Receive Buffer                 0=Receive is disabled"/>
            <edc:SFRFieldDef edc:cname="RX_DMA_EN" edc:nzwidth="0x2" edc:desc="This bit enables DMA support for Receive Transfer. If enabled, DMA will be requested to empty the FIFO until either the interface                 reaches TRANSFER_LENGTH or the DMA sends a termination request. The size defined here must match DMA programmed access size.                 1=DMA is enabled.and set to 1 Byte                 2=DMA is enabled and set to 2 Bytes                 3=DMA is enabled and set to 4 Bytes                 0=DMA is disabled. All data in the Receive Buffer must be emptied by firmware"/>
            <edc:SFRFieldDef edc:cname="CLOSE_TRANS_EN" edc:nzwidth="0x1" edc:desc="This selects what action is taken at the end of a transfer. When the transaction closes, the Chip Select de-asserts, the SPI      interface returns to IDLE and the DMA interface terminates When Description Buffers are in use this bit must be set only on the Last Buffer.     1=The transaction is terminated     0=The transaction is not terminated"/>
            <edc:SFRFieldDef edc:cname="TRANS_UNITS" edc:nzwidth="0x2" edc:desc="3=TRANSFER_LENGTH defined in units of 16-byte segments     2=TRANSFER_LENGTH defined in units of 4-byte segments     1=TRANSFER_LENGTH defined in units of bytes     0=TRANSFER_LENGTH defined in units of bits."/>
            <edc:SFRFieldDef edc:cname="DESCR_BUFF_PTR" edc:nzwidth="0x4" edc:desc="This field selects the first buffer used if Description Buffers are enabled."/>
            <edc:SFRFieldDef edc:cname="DESCR_BUFF_EN" edc:nzwidth="0x1" edc:desc="This enables the Description Buffers to be used.     1=Description Buffers in use. The first buffer is defined in DESCRIPTION_BUFFER_POINTER     0=Description Buffers disabled."/>
            <edc:SFRFieldDef edc:cname="TRANS_LEN" edc:nzwidth="0xF" edc:desc="The length of the SPI transfer. The count is in bytes or bits, depending on the value of TRANSFER_LENGTH_BITS.     A value of 0 means an infinite length transfer."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="QMSPI1" edc:cname="EXE" edc:nzwidth="0x20" edc:access="-----------------------------nnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x7" edc:_addr="0x40070208">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="QMSPI1">
            <edc:SFRFieldDef edc:cname="START" edc:nzwidth="0x1" edc:desc="Writing a 1 to this bit will start the SPI transfer. Writing a 0 to this bit has no effect. This bit is self-clearing.     This bit must not be set to 1 if the field STOP in this register is set to 1."/>
            <edc:SFRFieldDef edc:cname="STOP" edc:nzwidth="0x1" edc:desc="Writing a 1 to this bit will stop any transfer in progress at the next byte boundary. Writing a 0 to this bit has no effect.     This bit is self clearing. This bit must not be set to 1 if the field START in this register is set to 1."/>
            <edc:SFRFieldDef edc:cname="CLR_DAT_BUFF" edc:nzwidth="0x1" edc:desc="Writing a 1 to this bit will clear out the Transmit and Receive FIFOs. Any data stored in the FIFOs is discarded and all count fields are reset.     Writing a 0 to this bit has no effect. This bit is self clearing."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="QMSPI1" edc:cname="IFCTRL" edc:nzwidth="0x20" edc:access="------------------------nnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0xFF" edc:_addr="0x4007020C">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="QMSPI1">
            <edc:SFRFieldDef edc:cname="WR_PRCT_OUT_VAL" edc:nzwidth="0x1" edc:desc="This bit sets the value on the WRITE PROTECT SPI Output Port if it is driven.                 1=WRITE PROTECT is driven to 1; 0=WRITE PROTECT is driven to 0"/>
            <edc:SFRFieldDef edc:cname="WR_PRCT_OUT_EN" edc:nzwidth="0x1" edc:desc="1=WRITE PROTECT SPI Output Port is driven                 0=WRITE PROTECT SPI Output Port is not driven"/>
            <edc:SFRFieldDef edc:cname="HLD_OUT_VAL" edc:nzwidth="0x1" edc:desc="This bit sets the value on the HOLD SPI Output Port if it is driven.                 1=HOLD is driven to 1; 0=HOLD is driven to 0."/>
            <edc:SFRFieldDef edc:cname="HLD_OUT_EN" edc:nzwidth="0x1" edc:desc="1=HOLD SPI Output Port is driven                 0=HOLD SPI Output Port is not driven."/>
            <edc:SFRFieldDef edc:cname="PD_ON_NOT_SEL" edc:nzwidth="0x1" edc:desc="1=Enable pull-down resistors on Receive pins while the SPI Chip Select signal is not asserted     0=No pull-down resistors enabled on Receive pins"/>
            <edc:SFRFieldDef edc:cname="PU_ON_NOTSEL" edc:nzwidth="0x1" edc:desc="1=Enable pull-up resistors on Receive pins while the SPI Chip Select signal is not asserted     0=No pull-up resistors enabled on Receive pins."/>
            <edc:SFRFieldDef edc:cname="PD_ON_NOTDRIVEN" edc:nzwidth="0x1" edc:desc="1=Enable pull-down resistors on Transmit pins while the pins are not driven     0=No pull-down resistors enabled ion Transmit pins."/>
            <edc:SFRFieldDef edc:cname="PU_ON_NOTDRIVEN" edc:nzwidth="0x1" edc:desc="1=Enable pull-up resistors on Transmit pins while the pins are not driven     0=No pull-up resistors enabled ion Transmit pins."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="QMSPI1" edc:cname="STS" edc:nzwidth="0x20" edc:access="----nnnn-------nnnnnnnnn-nnnnnnn" edc:por="00000000000000000010001000000000" edc:mclr="00000000000000000010001000000000" edc:impl="0xF01FF7F" edc:_addr="0x40070210">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="QMSPI1">
            <edc:SFRFieldDef edc:cname="TRANS_COMPL" edc:nzwidth="0x1" edc:desc="In Manual Mode (neither DMA nor Description Buffers are enabled), this bit will be set to 1 when the transfer matches TRANSFER_LENGTH.                 If DMA Mode is enabled, this bit will be set to 1 when DMA_COMPLETE is set to 1. In Description Buffer Mode, this bit will be set to 1 only when the Last Buffer completes its transfer.     In all cases, this bit will be set to 1 if the STOP bit is set to 1 and the controller has completed the current 8 bits being copied.                 1=Transfer completed; 0=Transfer not complete."/>
            <edc:SFRFieldDef edc:cname="DMA_COMPL" edc:nzwidth="0x1" edc:desc="This field has no meaning if DMA is not enabled. This bit will be set to 1 when the DMA controller asserts the DONE signal to the SPI controller.     This occurs either when the SPI controller has closed the DMA transfer, or the DMA channel has completed its count. If both Transmit and Receive DMA transfers are      active, then this bit will only assert after both have completed. If CLOSE_TRANSFER_ENABLE is enabled, DMA_COMPLETE and TRANSFER_COMPLETE will be asserted simultaneously.     This status is not inhibited by the description buffers, so it can fire on all valid description buffers while operating in that mode.                 1=DMA completed; 0=DMA not completed."/>
            <edc:SFRFieldDef edc:cname="TX_BUFF_ERR" edc:nzwidth="0x1" edc:desc="1=Overflow error occurred (attempt to write to a full Transmit Buffer)                 0=No overflow occurred."/>
            <edc:SFRFieldDef edc:cname="RX_BUFF_ERR" edc:nzwidth="0x1" edc:desc="1=Underflow error occurred (attempt to read from an empty Receive Buffer)                 0=No underflow occurred."/>
            <edc:SFRFieldDef edc:cname="PRGM_ERR" edc:nzwidth="0x1" edc:desc="This bit if a programming error is detected.     1=Programming Error detected; 0=No programming error detected."/>
            <edc:SFRFieldDef edc:cname="LDMA_RXERR" edc:nzwidth="0x1" edc:desc="This bit is set if Local DMA Receive error is detected.     1=Local DMA RX Error detected; 0=No Local DMA RX detected."/>
            <edc:SFRFieldDef edc:cname="LDMA_TXERR" edc:nzwidth="0x1" edc:desc="This bit is set if Local DMA Transmit error is detected.     1=Local DMA TX Error detected; 0=No Local DMA TX detected."/>
            <edc:AdjustPoint edc:offset="0x1"/>
            <edc:SFRFieldDef edc:cname="TX_BUFF_FULL" edc:nzwidth="0x1" edc:desc="1=The Transmit Buffer is full     0=The Transmit Buffer is not full."/>
            <edc:SFRFieldDef edc:cname="TX_BUFF_EMP" edc:nzwidth="0x1" edc:desc="1=The Transmit Buffer is empty     0=The Transmit Buffer is not empty."/>
            <edc:SFRFieldDef edc:cname="TX_BUFF_REQ" edc:nzwidth="0x1" edc:desc="This status is asserted if the Transmit Buffer reaches a high water mark established by the TRANSMIT_BUFFER_TRIGGER field.     1=TRANSMIT_BUFFER_COUNT is less than or equal to TRANSMIT_BUFFER_TRIGGER; 0=TRANSMIT_BUFFER_COUNT is greater than TRANSMIT_BUFFER_TRIGGER."/>
            <edc:SFRFieldDef edc:cname="TX_BUFF_STALL" edc:nzwidth="0x1" edc:desc="1=The SPI interface had been stalled due to a flow issue (an attempt by the interface to read from an empty Transmit Buffer)     0=No stalls occurred."/>
            <edc:SFRFieldDef edc:cname="RX_BUFF_FULL" edc:nzwidth="0x1" edc:desc="1=The Receive Buffer is full     0=The Receive Buffer is not full."/>
            <edc:SFRFieldDef edc:cname="RX_BUFF_EMP" edc:nzwidth="0x1" edc:desc="1=The Receive Buffer is empty     0=The Receive Buffer is not empty."/>
            <edc:SFRFieldDef edc:cname="RX_BUFF_REQ" edc:nzwidth="0x1" edc:desc="This status is asserted if the Receive Buffer reaches a high water mark established by the RECEIVE_BUFFER_TRIGGER field.                 1=RECEIVE_BUFFER_COUNT is greater than or equal to RECEIVE_BUFFER_TRIGGER                 0=RECEIVE_BUFFER_COUNT is less than RECEIVE_BUFFER_TRIGGER."/>
            <edc:SFRFieldDef edc:cname="RX_BUFF_STALL" edc:nzwidth="0x1" edc:desc="1=The SPI interface had been stalled due to a flow issue (an attempt by the interface to write to a full Receive Buffer)     0=No stalls occurred."/>
            <edc:SFRFieldDef edc:cname="TRANS_ACTIV" edc:nzwidth="0x1" edc:desc="1=A transfer is currently executing     0=No transfer currently in progress."/>
            <edc:AdjustPoint edc:offset="0x7"/>
            <edc:SFRFieldDef edc:cname="CUR_DESCR_BUF" edc:nzwidth="0x4" edc:desc="This field shows the Description Buffer currently active. This field has no meaning if Description Buffers are not enabled."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="QMSPI1" edc:cname="BUF_CNT_STS" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x40070214">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="QMSPI1">
            <edc:SFRFieldDef edc:cname="TX_BUFF_CNT" edc:nzwidth="0x10" edc:desc="This is a count of the number of bytes currently valid in the Transmit Buffer."/>
            <edc:SFRFieldDef edc:cname="RX_BUFF_CNT" edc:nzwidth="0x10" edc:desc="This is a count of the number of bytes currently valid in the Receive Buffer."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="QMSPI1" edc:cname="IEN" edc:nzwidth="0x20" edc:access="-----------------nnn-nnn-nnnnnnn" edc:por="00000000000000000010000000000000" edc:mclr="00000000000000000010000000000000" edc:impl="0x777F" edc:_addr="0x40070218">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="QMSPI1">
            <edc:SFRFieldDef edc:cname="TRANS_COMPL_EN" edc:nzwidth="0x1" edc:desc="1=Enable an interrupt if TRANSFER_COMPLETE is asserted     0=Disable the interrupt."/>
            <edc:SFRFieldDef edc:cname="DMA_COMPL_EN" edc:nzwidth="0x1" edc:desc="1=Enable an interrupt if DMA_COMPLETE is asserted     0=Disable the interrupt."/>
            <edc:SFRFieldDef edc:cname="TX_BUF_ERR_EN" edc:nzwidth="0x1" edc:desc="1=Enable an interrupt if TRANSMIT_BUFFER_ERROR is asserted     0=Disable the interrupt."/>
            <edc:SFRFieldDef edc:cname="RX_BUF_ERR_EN" edc:nzwidth="0x1" edc:desc="1=Enable an interrupt if RECEIVE_BUFFER_ERROR is asserted     0=Disable the interrupt."/>
            <edc:SFRFieldDef edc:cname="PRGM_ERR_EN" edc:nzwidth="0x1" edc:desc="1=Enable an interrupt if PROGRAMMING_ERROR is asserted     0=Disable the interrupt."/>
            <edc:SFRFieldDef edc:cname="LDMA_RXERRIE" edc:nzwidth="0x1" edc:desc="1=Enable an interrupt if Local DMA RX Error is asserted     0=Disable the interrupt."/>
            <edc:SFRFieldDef edc:cname="LDMA_TXERRIE" edc:nzwidth="0x1" edc:desc="1=Enable an interrupt if Local DMA TX Error is asserted     0=Disable the interrupt."/>
            <edc:AdjustPoint edc:offset="0x1"/>
            <edc:SFRFieldDef edc:cname="TX_BUF_FULL_EN" edc:nzwidth="0x1" edc:desc="1=Enable an interrupt if TRANSMIT_BUFFER_FULL is asserted     0=Disable the interrupt."/>
            <edc:SFRFieldDef edc:cname="TX_BUF_EMPTY_EN" edc:nzwidth="0x1" edc:desc="1=Enable an interrupt if TRANSMIT_BUFFER_EMPTY is asserted     0=Disable the interrupt."/>
            <edc:SFRFieldDef edc:cname="TX_BUF_REQ_EN" edc:nzwidth="0x1" edc:desc="1=Enable an interrupt if TRANSMIT_BUFFER_REQUEST is asserted     0=Disable the interrupt."/>
            <edc:AdjustPoint edc:offset="0x1"/>
            <edc:SFRFieldDef edc:cname="RX_BUF_FUL_EN" edc:nzwidth="0x1" edc:desc="1=Enable an interrupt if RECEIVE_BUFFER_FULL is asserted     0=Disable the interrupt."/>
            <edc:SFRFieldDef edc:cname="RX_BUF_EMPTY_EN" edc:nzwidth="0x1" edc:desc="1=Enable an interrupt if RECEIVE_BUFFER_EMPTY is asserted     0=Disable the interrupt."/>
            <edc:SFRFieldDef edc:cname="RX_BUF_REQ_EN" edc:nzwidth="0x1" edc:desc="1=Enable an interrupt if RECEIVE_BUFFER_REQUEST is asserted     0=Disable the interrupt."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="QMSPI1" edc:cname="BUF_CNT_TRIG" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x4007021C">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="QMSPI1">
            <edc:SFRFieldDef edc:cname="TX_BUF_TRIG" edc:nzwidth="0x10" edc:desc="An interrupt is triggered if the TRANSMIT_BUFFER_COUNT field is less than or equal to this value. A value of 0 disables the interrupt."/>
            <edc:SFRFieldDef edc:cname="RX_BUF_TRIG" edc:nzwidth="0x10" edc:desc="An interrupt is triggered if the RECEIVE_BUFFER_COUNT field is greater than or equal to this value. A value of 0 disables the interrupt."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="QMSPI1" edc:cname="TX_FIFO0" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x40070220">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="QMSPI1">
            <edc:SFRFieldDef edc:cname="TX_BUF" edc:nzwidth="0x20" edc:desc="Writes to this register store data to be transmitted from the SPI Master to the external SPI Slave.     Writes to this block will be written to the Transmit FIFO. A 1 Byte write fills 1 byte of the FIFO. A Word write fills 2 Bytes and a Doubleword write fills 4 bytes.     The data must always be aligned to the bottom most byte (so 1 byte write is on bits [7:0] and Word write is on [15:0]).     An overflow condition, TRANSMIT_BUFFER_ERROR, if a write to a full FIFO occurs. Write accesses to this register increment the TRANSMIT_BUFFER_COUNT field."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="QMSPI1" edc:cname="RX_FIFO0" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x40070224">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="QMSPI1">
            <edc:SFRFieldDef edc:cname="RX_BUF" edc:nzwidth="0x20" edc:desc="Buffer that stores data from the external SPI Slave device to the SPI Master (this block), which is received over MISO or IO.     Reads from this register will empty the Rx FIFO. A 1 Byte read will have valid data on bits [7:0] and a Word read will have data on bits [15:0].     It is possible to request more data than the FIFO has (underflow condition), but this will cause an error (Rx Buffer Error).     Read accesses to this register decrement the RECEIVE_BUFFER_COUNT field."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="QMSPI1" edc:cname="CSTM" edc:nzwidth="0x20" edc:access="nnnnnnnn----nnnn----nnnn----nnnn" edc:por="00000110000001100000010000000110" edc:mclr="00000110000001100000010000000110" edc:impl="0xFF0F0F0F" edc:_addr="0x40070228">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="QMSPI1">
            <edc:SFRFieldDef edc:cname="DLY_CS_ON_TO_CLOCK_START" edc:nzwidth="0x4" edc:desc="This selects the number of system clock cycles between CS assertion to the start of the SPI Clock."/>
            <edc:AdjustPoint edc:offset="0x4"/>
            <edc:SFRFieldDef edc:cname="DLY_CLK_STOP_TO_CS_OFF" edc:nzwidth="0x4" edc:desc="This selects the number of system clock cycles between the last clock edge and the deassertion of CS."/>
            <edc:AdjustPoint edc:offset="0x4"/>
            <edc:SFRFieldDef edc:cname="DLY_LAST_DATA_HOLD" edc:nzwidth="0x4" edc:desc="This selects the number of system clock cycles between CS deassertion to the data ports for WP and HOLD     switching from input to output."/>
            <edc:AdjustPoint edc:offset="0x4"/>
            <edc:SFRFieldDef edc:cname="DLY_CS_OFF_TO_CS_ON" edc:nzwidth="0x8" edc:desc="This selects the number of system clock cycles between CS deassertion to CS assertion. This is the minimum            pulse width of CS deassertion."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:AdjustPoint edc:offset="0x4" edc:_addr="0x4007022C"/>
      <edc:SFRDef ltx:memberofperipheral="QMSPI1" edc:cname="DESCR0" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x40070230">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="QMSPI1">
            <edc:SFRFieldDef edc:cname="INFACE_MOD" edc:nzwidth="0x2" edc:desc="This field sets the transmission mode. If this field is set for Dual Mode or Quad Mode then either TX_TRANSFER_ENABLE or RX_TRANSFER_ENABLE must be 0.     3=Reserved; 2=Quad Mode; 1=Dual Mode; 0=Single/Duplex Mode."/>
            <edc:SFRFieldDef edc:cname="TX_TRANS_EN" edc:nzwidth="0x2" edc:desc="This field bit selects the transmit function of the SPI interface.     3=Transmit Enabled in 1 Mode. The MOSI or IO Bus will send out only 1's. The Transmit Buffer will not be used     2=Transmit Enabled in 0 Mode. The MOSI or IO Bus will send out only 0's. The Transmit Buffer will not be used.     1=Transmit Enabled. Data will be fetched from the Transmit Buffer and sent out on the MOSI or IO Bus.     0=Transmit is Disabled. No data is sent. This will cause the MOSI be to be undriven, or the IO bus to be undriven if Receive is also disabled."/>
            <edc:SFRFieldDef edc:cname="TX_DMA_EN" edc:nzwidth="0x2" edc:desc="This bit enables DMA support for Transmit Transfer. If enabled, DMA will be requested to fill the FIFO until either the interface     reaches TRANSFER_LENGTH or the DMA sends a termination request. The size defined here must match DMA programmed access size.     1=DMA is enabled.and set to 1 Byte      2=DMA is enabled and set to 2 Bytes      3=DMA is enabled and set to 4 Bytes     0=DMA is disabled. All data in the Transmit Buffer must be emptied by firmware."/>
            <edc:SFRFieldDef edc:cname="RX_TRANS_EN" edc:nzwidth="0x1" edc:desc="This bit enables the receive function of the SPI interface.     1=Receive is enabled. Data received from the SPI Slave is stored in the Receive Buffer; 0=Receive is disabled."/>
            <edc:SFRFieldDef edc:cname="RX_DMA_EN" edc:nzwidth="0x2" edc:desc="This bit enables DMA support for Receive Transfer. If enabled, DMA will be requested to empty the FIFO until either the interface reaches TRANSFER_LENGTH or the DMA sends a termination request. The size defined here must match DMA programmed access size.     1=DMA is enabled.and set to 1 Byte     2=DMA is enabled and set to 2 Bytes     3=DMA is enabled and set to 4 Bytes     0=DMA is disabled. All data in the Receive Buffer must be emptied by firmware."/>
            <edc:SFRFieldDef edc:cname="CLOSE_TRANS_EN" edc:nzwidth="0x1" edc:desc="This selects what action is taken at the end of a transfer. This bit must be set only on the Last Buffer.     1=The transfer is terminated. The Chip Select de-asserts, the SPI interface returns to IDLE and the DMA interface completes the transfer.     0=The transfer is not closed. Chip Select remains asserted and the DMA interface and the SPI interface remain active"/>
            <edc:SFRFieldDef edc:cname="TRANS_LEN" edc:nzwidth="0x2" edc:desc="3=TRANSFER_LENGTH defined in units of 16-byte segments,            2=TRANSFER_LENGTH defined in units of 4-byte segments     1=TRANSFER_LENGTH defined in units of bytes,     0=TRANSFER_LENGTH defined in units of bits"/>
            <edc:SFRFieldDef edc:cname="DESCR_BUF_NXT_PTR" edc:nzwidth="0x4" edc:desc="This defines the next buffer to be used if Description Buffers are enabled and this is not the last buffer. This can point to the current buffer, creating an infinite loop."/>
            <edc:SFRFieldDef edc:cname="DESCR_BUF_LAST" edc:nzwidth="0x1" edc:desc="Last Descriptor. 1=Last Description Buffer in the chain. 0=This is not the last buffer."/>
            <edc:SFRFieldDef edc:cname="TX_LEN" edc:nzwidth="0xF" edc:desc="The length of the SPI transfer. The count is in bytes or bits, depending on the value of TRANSFER_LENGTH_BITS. A value of 0 means an infinite length transfer."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="QMSPI1" edc:cname="DESCR1" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x40070234">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="QMSPI1">
            <edc:SFRFieldDef edc:cname="INFACE_MOD" edc:nzwidth="0x2" edc:desc="This field sets the transmission mode. If this field is set for Dual Mode or Quad Mode then either TX_TRANSFER_ENABLE or RX_TRANSFER_ENABLE must be 0.     3=Reserved; 2=Quad Mode; 1=Dual Mode; 0=Single/Duplex Mode."/>
            <edc:SFRFieldDef edc:cname="TX_TRANS_EN" edc:nzwidth="0x2" edc:desc="This field bit selects the transmit function of the SPI interface.     3=Transmit Enabled in 1 Mode. The MOSI or IO Bus will send out only 1's. The Transmit Buffer will not be used     2=Transmit Enabled in 0 Mode. The MOSI or IO Bus will send out only 0's. The Transmit Buffer will not be used.     1=Transmit Enabled. Data will be fetched from the Transmit Buffer and sent out on the MOSI or IO Bus.     0=Transmit is Disabled. No data is sent. This will cause the MOSI be to be undriven, or the IO bus to be undriven if Receive is also disabled."/>
            <edc:SFRFieldDef edc:cname="TX_DMA_EN" edc:nzwidth="0x2" edc:desc="This bit enables DMA support for Transmit Transfer. If enabled, DMA will be requested to fill the FIFO until either the interface     reaches TRANSFER_LENGTH or the DMA sends a termination request. The size defined here must match DMA programmed access size.     1=DMA is enabled.and set to 1 Byte      2=DMA is enabled and set to 2 Bytes      3=DMA is enabled and set to 4 Bytes     0=DMA is disabled. All data in the Transmit Buffer must be emptied by firmware."/>
            <edc:SFRFieldDef edc:cname="RX_TRANS_EN" edc:nzwidth="0x1" edc:desc="This bit enables the receive function of the SPI interface.     1=Receive is enabled. Data received from the SPI Slave is stored in the Receive Buffer; 0=Receive is disabled."/>
            <edc:SFRFieldDef edc:cname="RX_DMA_EN" edc:nzwidth="0x2" edc:desc="This bit enables DMA support for Receive Transfer. If enabled, DMA will be requested to empty the FIFO until either the interface reaches TRANSFER_LENGTH or the DMA sends a termination request. The size defined here must match DMA programmed access size.     1=DMA is enabled.and set to 1 Byte     2=DMA is enabled and set to 2 Bytes     3=DMA is enabled and set to 4 Bytes     0=DMA is disabled. All data in the Receive Buffer must be emptied by firmware."/>
            <edc:SFRFieldDef edc:cname="CLOSE_TRANS_EN" edc:nzwidth="0x1" edc:desc="This selects what action is taken at the end of a transfer. This bit must be set only on the Last Buffer.     1=The transfer is terminated. The Chip Select de-asserts, the SPI interface returns to IDLE and the DMA interface completes the transfer.     0=The transfer is not closed. Chip Select remains asserted and the DMA interface and the SPI interface remain active"/>
            <edc:SFRFieldDef edc:cname="TRANS_LEN" edc:nzwidth="0x2" edc:desc="3=TRANSFER_LENGTH defined in units of 16-byte segments,            2=TRANSFER_LENGTH defined in units of 4-byte segments     1=TRANSFER_LENGTH defined in units of bytes,     0=TRANSFER_LENGTH defined in units of bits"/>
            <edc:SFRFieldDef edc:cname="DESCR_BUF_NXT_PTR" edc:nzwidth="0x4" edc:desc="This defines the next buffer to be used if Description Buffers are enabled and this is not the last buffer. This can point to the current buffer, creating an infinite loop."/>
            <edc:SFRFieldDef edc:cname="DESCR_BUF_LAST" edc:nzwidth="0x1" edc:desc="Last Descriptor. 1=Last Description Buffer in the chain. 0=This is not the last buffer."/>
            <edc:SFRFieldDef edc:cname="TX_LEN" edc:nzwidth="0xF" edc:desc="The length of the SPI transfer. The count is in bytes or bits, depending on the value of TRANSFER_LENGTH_BITS. A value of 0 means an infinite length transfer."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="QMSPI1" edc:cname="DESCR2" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x40070238">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="QMSPI1">
            <edc:SFRFieldDef edc:cname="INFACE_MOD" edc:nzwidth="0x2" edc:desc="This field sets the transmission mode. If this field is set for Dual Mode or Quad Mode then either TX_TRANSFER_ENABLE or RX_TRANSFER_ENABLE must be 0.     3=Reserved; 2=Quad Mode; 1=Dual Mode; 0=Single/Duplex Mode."/>
            <edc:SFRFieldDef edc:cname="TX_TRANS_EN" edc:nzwidth="0x2" edc:desc="This field bit selects the transmit function of the SPI interface.     3=Transmit Enabled in 1 Mode. The MOSI or IO Bus will send out only 1's. The Transmit Buffer will not be used     2=Transmit Enabled in 0 Mode. The MOSI or IO Bus will send out only 0's. The Transmit Buffer will not be used.     1=Transmit Enabled. Data will be fetched from the Transmit Buffer and sent out on the MOSI or IO Bus.     0=Transmit is Disabled. No data is sent. This will cause the MOSI be to be undriven, or the IO bus to be undriven if Receive is also disabled."/>
            <edc:SFRFieldDef edc:cname="TX_DMA_EN" edc:nzwidth="0x2" edc:desc="This bit enables DMA support for Transmit Transfer. If enabled, DMA will be requested to fill the FIFO until either the interface     reaches TRANSFER_LENGTH or the DMA sends a termination request. The size defined here must match DMA programmed access size.     1=DMA is enabled.and set to 1 Byte      2=DMA is enabled and set to 2 Bytes      3=DMA is enabled and set to 4 Bytes     0=DMA is disabled. All data in the Transmit Buffer must be emptied by firmware."/>
            <edc:SFRFieldDef edc:cname="RX_TRANS_EN" edc:nzwidth="0x1" edc:desc="This bit enables the receive function of the SPI interface.     1=Receive is enabled. Data received from the SPI Slave is stored in the Receive Buffer; 0=Receive is disabled."/>
            <edc:SFRFieldDef edc:cname="RX_DMA_EN" edc:nzwidth="0x2" edc:desc="This bit enables DMA support for Receive Transfer. If enabled, DMA will be requested to empty the FIFO until either the interface reaches TRANSFER_LENGTH or the DMA sends a termination request. The size defined here must match DMA programmed access size.     1=DMA is enabled.and set to 1 Byte     2=DMA is enabled and set to 2 Bytes     3=DMA is enabled and set to 4 Bytes     0=DMA is disabled. All data in the Receive Buffer must be emptied by firmware."/>
            <edc:SFRFieldDef edc:cname="CLOSE_TRANS_EN" edc:nzwidth="0x1" edc:desc="This selects what action is taken at the end of a transfer. This bit must be set only on the Last Buffer.     1=The transfer is terminated. The Chip Select de-asserts, the SPI interface returns to IDLE and the DMA interface completes the transfer.     0=The transfer is not closed. Chip Select remains asserted and the DMA interface and the SPI interface remain active"/>
            <edc:SFRFieldDef edc:cname="TRANS_LEN" edc:nzwidth="0x2" edc:desc="3=TRANSFER_LENGTH defined in units of 16-byte segments,            2=TRANSFER_LENGTH defined in units of 4-byte segments     1=TRANSFER_LENGTH defined in units of bytes,     0=TRANSFER_LENGTH defined in units of bits"/>
            <edc:SFRFieldDef edc:cname="DESCR_BUF_NXT_PTR" edc:nzwidth="0x4" edc:desc="This defines the next buffer to be used if Description Buffers are enabled and this is not the last buffer. This can point to the current buffer, creating an infinite loop."/>
            <edc:SFRFieldDef edc:cname="DESCR_BUF_LAST" edc:nzwidth="0x1" edc:desc="Last Descriptor. 1=Last Description Buffer in the chain. 0=This is not the last buffer."/>
            <edc:SFRFieldDef edc:cname="TX_LEN" edc:nzwidth="0xF" edc:desc="The length of the SPI transfer. The count is in bytes or bits, depending on the value of TRANSFER_LENGTH_BITS. A value of 0 means an infinite length transfer."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="QMSPI1" edc:cname="DESCR3" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x4007023C">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="QMSPI1">
            <edc:SFRFieldDef edc:cname="INFACE_MOD" edc:nzwidth="0x2" edc:desc="This field sets the transmission mode. If this field is set for Dual Mode or Quad Mode then either TX_TRANSFER_ENABLE or RX_TRANSFER_ENABLE must be 0.     3=Reserved; 2=Quad Mode; 1=Dual Mode; 0=Single/Duplex Mode."/>
            <edc:SFRFieldDef edc:cname="TX_TRANS_EN" edc:nzwidth="0x2" edc:desc="This field bit selects the transmit function of the SPI interface.     3=Transmit Enabled in 1 Mode. The MOSI or IO Bus will send out only 1's. The Transmit Buffer will not be used     2=Transmit Enabled in 0 Mode. The MOSI or IO Bus will send out only 0's. The Transmit Buffer will not be used.     1=Transmit Enabled. Data will be fetched from the Transmit Buffer and sent out on the MOSI or IO Bus.     0=Transmit is Disabled. No data is sent. This will cause the MOSI be to be undriven, or the IO bus to be undriven if Receive is also disabled."/>
            <edc:SFRFieldDef edc:cname="TX_DMA_EN" edc:nzwidth="0x2" edc:desc="This bit enables DMA support for Transmit Transfer. If enabled, DMA will be requested to fill the FIFO until either the interface     reaches TRANSFER_LENGTH or the DMA sends a termination request. The size defined here must match DMA programmed access size.     1=DMA is enabled.and set to 1 Byte      2=DMA is enabled and set to 2 Bytes      3=DMA is enabled and set to 4 Bytes     0=DMA is disabled. All data in the Transmit Buffer must be emptied by firmware."/>
            <edc:SFRFieldDef edc:cname="RX_TRANS_EN" edc:nzwidth="0x1" edc:desc="This bit enables the receive function of the SPI interface.     1=Receive is enabled. Data received from the SPI Slave is stored in the Receive Buffer; 0=Receive is disabled."/>
            <edc:SFRFieldDef edc:cname="RX_DMA_EN" edc:nzwidth="0x2" edc:desc="This bit enables DMA support for Receive Transfer. If enabled, DMA will be requested to empty the FIFO until either the interface reaches TRANSFER_LENGTH or the DMA sends a termination request. The size defined here must match DMA programmed access size.     1=DMA is enabled.and set to 1 Byte     2=DMA is enabled and set to 2 Bytes     3=DMA is enabled and set to 4 Bytes     0=DMA is disabled. All data in the Receive Buffer must be emptied by firmware."/>
            <edc:SFRFieldDef edc:cname="CLOSE_TRANS_EN" edc:nzwidth="0x1" edc:desc="This selects what action is taken at the end of a transfer. This bit must be set only on the Last Buffer.     1=The transfer is terminated. The Chip Select de-asserts, the SPI interface returns to IDLE and the DMA interface completes the transfer.     0=The transfer is not closed. Chip Select remains asserted and the DMA interface and the SPI interface remain active"/>
            <edc:SFRFieldDef edc:cname="TRANS_LEN" edc:nzwidth="0x2" edc:desc="3=TRANSFER_LENGTH defined in units of 16-byte segments,            2=TRANSFER_LENGTH defined in units of 4-byte segments     1=TRANSFER_LENGTH defined in units of bytes,     0=TRANSFER_LENGTH defined in units of bits"/>
            <edc:SFRFieldDef edc:cname="DESCR_BUF_NXT_PTR" edc:nzwidth="0x4" edc:desc="This defines the next buffer to be used if Description Buffers are enabled and this is not the last buffer. This can point to the current buffer, creating an infinite loop."/>
            <edc:SFRFieldDef edc:cname="DESCR_BUF_LAST" edc:nzwidth="0x1" edc:desc="Last Descriptor. 1=Last Description Buffer in the chain. 0=This is not the last buffer."/>
            <edc:SFRFieldDef edc:cname="TX_LEN" edc:nzwidth="0xF" edc:desc="The length of the SPI transfer. The count is in bytes or bits, depending on the value of TRANSFER_LENGTH_BITS. A value of 0 means an infinite length transfer."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="QMSPI1" edc:cname="DESCR4" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x40070240">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="QMSPI1">
            <edc:SFRFieldDef edc:cname="INFACE_MOD" edc:nzwidth="0x2" edc:desc="This field sets the transmission mode. If this field is set for Dual Mode or Quad Mode then either TX_TRANSFER_ENABLE or RX_TRANSFER_ENABLE must be 0.     3=Reserved; 2=Quad Mode; 1=Dual Mode; 0=Single/Duplex Mode."/>
            <edc:SFRFieldDef edc:cname="TX_TRANS_EN" edc:nzwidth="0x2" edc:desc="This field bit selects the transmit function of the SPI interface.     3=Transmit Enabled in 1 Mode. The MOSI or IO Bus will send out only 1's. The Transmit Buffer will not be used     2=Transmit Enabled in 0 Mode. The MOSI or IO Bus will send out only 0's. The Transmit Buffer will not be used.     1=Transmit Enabled. Data will be fetched from the Transmit Buffer and sent out on the MOSI or IO Bus.     0=Transmit is Disabled. No data is sent. This will cause the MOSI be to be undriven, or the IO bus to be undriven if Receive is also disabled."/>
            <edc:SFRFieldDef edc:cname="TX_DMA_EN" edc:nzwidth="0x2" edc:desc="This bit enables DMA support for Transmit Transfer. If enabled, DMA will be requested to fill the FIFO until either the interface     reaches TRANSFER_LENGTH or the DMA sends a termination request. The size defined here must match DMA programmed access size.     1=DMA is enabled.and set to 1 Byte      2=DMA is enabled and set to 2 Bytes      3=DMA is enabled and set to 4 Bytes     0=DMA is disabled. All data in the Transmit Buffer must be emptied by firmware."/>
            <edc:SFRFieldDef edc:cname="RX_TRANS_EN" edc:nzwidth="0x1" edc:desc="This bit enables the receive function of the SPI interface.     1=Receive is enabled. Data received from the SPI Slave is stored in the Receive Buffer; 0=Receive is disabled."/>
            <edc:SFRFieldDef edc:cname="RX_DMA_EN" edc:nzwidth="0x2" edc:desc="This bit enables DMA support for Receive Transfer. If enabled, DMA will be requested to empty the FIFO until either the interface reaches TRANSFER_LENGTH or the DMA sends a termination request. The size defined here must match DMA programmed access size.     1=DMA is enabled.and set to 1 Byte     2=DMA is enabled and set to 2 Bytes     3=DMA is enabled and set to 4 Bytes     0=DMA is disabled. All data in the Receive Buffer must be emptied by firmware."/>
            <edc:SFRFieldDef edc:cname="CLOSE_TRANS_EN" edc:nzwidth="0x1" edc:desc="This selects what action is taken at the end of a transfer. This bit must be set only on the Last Buffer.     1=The transfer is terminated. The Chip Select de-asserts, the SPI interface returns to IDLE and the DMA interface completes the transfer.     0=The transfer is not closed. Chip Select remains asserted and the DMA interface and the SPI interface remain active"/>
            <edc:SFRFieldDef edc:cname="TRANS_LEN" edc:nzwidth="0x2" edc:desc="3=TRANSFER_LENGTH defined in units of 16-byte segments,            2=TRANSFER_LENGTH defined in units of 4-byte segments     1=TRANSFER_LENGTH defined in units of bytes,     0=TRANSFER_LENGTH defined in units of bits"/>
            <edc:SFRFieldDef edc:cname="DESCR_BUF_NXT_PTR" edc:nzwidth="0x4" edc:desc="This defines the next buffer to be used if Description Buffers are enabled and this is not the last buffer. This can point to the current buffer, creating an infinite loop."/>
            <edc:SFRFieldDef edc:cname="DESCR_BUF_LAST" edc:nzwidth="0x1" edc:desc="Last Descriptor. 1=Last Description Buffer in the chain. 0=This is not the last buffer."/>
            <edc:SFRFieldDef edc:cname="TX_LEN" edc:nzwidth="0xF" edc:desc="The length of the SPI transfer. The count is in bytes or bits, depending on the value of TRANSFER_LENGTH_BITS. A value of 0 means an infinite length transfer."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="QMSPI1" edc:cname="DESCR5" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x40070244">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="QMSPI1">
            <edc:SFRFieldDef edc:cname="INFACE_MOD" edc:nzwidth="0x2" edc:desc="This field sets the transmission mode. If this field is set for Dual Mode or Quad Mode then either TX_TRANSFER_ENABLE or RX_TRANSFER_ENABLE must be 0.     3=Reserved; 2=Quad Mode; 1=Dual Mode; 0=Single/Duplex Mode."/>
            <edc:SFRFieldDef edc:cname="TX_TRANS_EN" edc:nzwidth="0x2" edc:desc="This field bit selects the transmit function of the SPI interface.     3=Transmit Enabled in 1 Mode. The MOSI or IO Bus will send out only 1's. The Transmit Buffer will not be used     2=Transmit Enabled in 0 Mode. The MOSI or IO Bus will send out only 0's. The Transmit Buffer will not be used.     1=Transmit Enabled. Data will be fetched from the Transmit Buffer and sent out on the MOSI or IO Bus.     0=Transmit is Disabled. No data is sent. This will cause the MOSI be to be undriven, or the IO bus to be undriven if Receive is also disabled."/>
            <edc:SFRFieldDef edc:cname="TX_DMA_EN" edc:nzwidth="0x2" edc:desc="This bit enables DMA support for Transmit Transfer. If enabled, DMA will be requested to fill the FIFO until either the interface     reaches TRANSFER_LENGTH or the DMA sends a termination request. The size defined here must match DMA programmed access size.     1=DMA is enabled.and set to 1 Byte      2=DMA is enabled and set to 2 Bytes      3=DMA is enabled and set to 4 Bytes     0=DMA is disabled. All data in the Transmit Buffer must be emptied by firmware."/>
            <edc:SFRFieldDef edc:cname="RX_TRANS_EN" edc:nzwidth="0x1" edc:desc="This bit enables the receive function of the SPI interface.     1=Receive is enabled. Data received from the SPI Slave is stored in the Receive Buffer; 0=Receive is disabled."/>
            <edc:SFRFieldDef edc:cname="RX_DMA_EN" edc:nzwidth="0x2" edc:desc="This bit enables DMA support for Receive Transfer. If enabled, DMA will be requested to empty the FIFO until either the interface reaches TRANSFER_LENGTH or the DMA sends a termination request. The size defined here must match DMA programmed access size.     1=DMA is enabled.and set to 1 Byte     2=DMA is enabled and set to 2 Bytes     3=DMA is enabled and set to 4 Bytes     0=DMA is disabled. All data in the Receive Buffer must be emptied by firmware."/>
            <edc:SFRFieldDef edc:cname="CLOSE_TRANS_EN" edc:nzwidth="0x1" edc:desc="This selects what action is taken at the end of a transfer. This bit must be set only on the Last Buffer.     1=The transfer is terminated. The Chip Select de-asserts, the SPI interface returns to IDLE and the DMA interface completes the transfer.     0=The transfer is not closed. Chip Select remains asserted and the DMA interface and the SPI interface remain active"/>
            <edc:SFRFieldDef edc:cname="TRANS_LEN" edc:nzwidth="0x2" edc:desc="3=TRANSFER_LENGTH defined in units of 16-byte segments,            2=TRANSFER_LENGTH defined in units of 4-byte segments     1=TRANSFER_LENGTH defined in units of bytes,     0=TRANSFER_LENGTH defined in units of bits"/>
            <edc:SFRFieldDef edc:cname="DESCR_BUF_NXT_PTR" edc:nzwidth="0x4" edc:desc="This defines the next buffer to be used if Description Buffers are enabled and this is not the last buffer. This can point to the current buffer, creating an infinite loop."/>
            <edc:SFRFieldDef edc:cname="DESCR_BUF_LAST" edc:nzwidth="0x1" edc:desc="Last Descriptor. 1=Last Description Buffer in the chain. 0=This is not the last buffer."/>
            <edc:SFRFieldDef edc:cname="TX_LEN" edc:nzwidth="0xF" edc:desc="The length of the SPI transfer. The count is in bytes or bits, depending on the value of TRANSFER_LENGTH_BITS. A value of 0 means an infinite length transfer."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="QMSPI1" edc:cname="DESCR6" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x40070248">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="QMSPI1">
            <edc:SFRFieldDef edc:cname="INFACE_MOD" edc:nzwidth="0x2" edc:desc="This field sets the transmission mode. If this field is set for Dual Mode or Quad Mode then either TX_TRANSFER_ENABLE or RX_TRANSFER_ENABLE must be 0.     3=Reserved; 2=Quad Mode; 1=Dual Mode; 0=Single/Duplex Mode."/>
            <edc:SFRFieldDef edc:cname="TX_TRANS_EN" edc:nzwidth="0x2" edc:desc="This field bit selects the transmit function of the SPI interface.     3=Transmit Enabled in 1 Mode. The MOSI or IO Bus will send out only 1's. The Transmit Buffer will not be used     2=Transmit Enabled in 0 Mode. The MOSI or IO Bus will send out only 0's. The Transmit Buffer will not be used.     1=Transmit Enabled. Data will be fetched from the Transmit Buffer and sent out on the MOSI or IO Bus.     0=Transmit is Disabled. No data is sent. This will cause the MOSI be to be undriven, or the IO bus to be undriven if Receive is also disabled."/>
            <edc:SFRFieldDef edc:cname="TX_DMA_EN" edc:nzwidth="0x2" edc:desc="This bit enables DMA support for Transmit Transfer. If enabled, DMA will be requested to fill the FIFO until either the interface     reaches TRANSFER_LENGTH or the DMA sends a termination request. The size defined here must match DMA programmed access size.     1=DMA is enabled.and set to 1 Byte      2=DMA is enabled and set to 2 Bytes      3=DMA is enabled and set to 4 Bytes     0=DMA is disabled. All data in the Transmit Buffer must be emptied by firmware."/>
            <edc:SFRFieldDef edc:cname="RX_TRANS_EN" edc:nzwidth="0x1" edc:desc="This bit enables the receive function of the SPI interface.     1=Receive is enabled. Data received from the SPI Slave is stored in the Receive Buffer; 0=Receive is disabled."/>
            <edc:SFRFieldDef edc:cname="RX_DMA_EN" edc:nzwidth="0x2" edc:desc="This bit enables DMA support for Receive Transfer. If enabled, DMA will be requested to empty the FIFO until either the interface reaches TRANSFER_LENGTH or the DMA sends a termination request. The size defined here must match DMA programmed access size.     1=DMA is enabled.and set to 1 Byte     2=DMA is enabled and set to 2 Bytes     3=DMA is enabled and set to 4 Bytes     0=DMA is disabled. All data in the Receive Buffer must be emptied by firmware."/>
            <edc:SFRFieldDef edc:cname="CLOSE_TRANS_EN" edc:nzwidth="0x1" edc:desc="This selects what action is taken at the end of a transfer. This bit must be set only on the Last Buffer.     1=The transfer is terminated. The Chip Select de-asserts, the SPI interface returns to IDLE and the DMA interface completes the transfer.     0=The transfer is not closed. Chip Select remains asserted and the DMA interface and the SPI interface remain active"/>
            <edc:SFRFieldDef edc:cname="TRANS_LEN" edc:nzwidth="0x2" edc:desc="3=TRANSFER_LENGTH defined in units of 16-byte segments,            2=TRANSFER_LENGTH defined in units of 4-byte segments     1=TRANSFER_LENGTH defined in units of bytes,     0=TRANSFER_LENGTH defined in units of bits"/>
            <edc:SFRFieldDef edc:cname="DESCR_BUF_NXT_PTR" edc:nzwidth="0x4" edc:desc="This defines the next buffer to be used if Description Buffers are enabled and this is not the last buffer. This can point to the current buffer, creating an infinite loop."/>
            <edc:SFRFieldDef edc:cname="DESCR_BUF_LAST" edc:nzwidth="0x1" edc:desc="Last Descriptor. 1=Last Description Buffer in the chain. 0=This is not the last buffer."/>
            <edc:SFRFieldDef edc:cname="TX_LEN" edc:nzwidth="0xF" edc:desc="The length of the SPI transfer. The count is in bytes or bits, depending on the value of TRANSFER_LENGTH_BITS. A value of 0 means an infinite length transfer."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="QMSPI1" edc:cname="DESCR7" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x4007024C">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="QMSPI1">
            <edc:SFRFieldDef edc:cname="INFACE_MOD" edc:nzwidth="0x2" edc:desc="This field sets the transmission mode. If this field is set for Dual Mode or Quad Mode then either TX_TRANSFER_ENABLE or RX_TRANSFER_ENABLE must be 0.     3=Reserved; 2=Quad Mode; 1=Dual Mode; 0=Single/Duplex Mode."/>
            <edc:SFRFieldDef edc:cname="TX_TRANS_EN" edc:nzwidth="0x2" edc:desc="This field bit selects the transmit function of the SPI interface.     3=Transmit Enabled in 1 Mode. The MOSI or IO Bus will send out only 1's. The Transmit Buffer will not be used     2=Transmit Enabled in 0 Mode. The MOSI or IO Bus will send out only 0's. The Transmit Buffer will not be used.     1=Transmit Enabled. Data will be fetched from the Transmit Buffer and sent out on the MOSI or IO Bus.     0=Transmit is Disabled. No data is sent. This will cause the MOSI be to be undriven, or the IO bus to be undriven if Receive is also disabled."/>
            <edc:SFRFieldDef edc:cname="TX_DMA_EN" edc:nzwidth="0x2" edc:desc="This bit enables DMA support for Transmit Transfer. If enabled, DMA will be requested to fill the FIFO until either the interface     reaches TRANSFER_LENGTH or the DMA sends a termination request. The size defined here must match DMA programmed access size.     1=DMA is enabled.and set to 1 Byte      2=DMA is enabled and set to 2 Bytes      3=DMA is enabled and set to 4 Bytes     0=DMA is disabled. All data in the Transmit Buffer must be emptied by firmware."/>
            <edc:SFRFieldDef edc:cname="RX_TRANS_EN" edc:nzwidth="0x1" edc:desc="This bit enables the receive function of the SPI interface.     1=Receive is enabled. Data received from the SPI Slave is stored in the Receive Buffer; 0=Receive is disabled."/>
            <edc:SFRFieldDef edc:cname="RX_DMA_EN" edc:nzwidth="0x2" edc:desc="This bit enables DMA support for Receive Transfer. If enabled, DMA will be requested to empty the FIFO until either the interface reaches TRANSFER_LENGTH or the DMA sends a termination request. The size defined here must match DMA programmed access size.     1=DMA is enabled.and set to 1 Byte     2=DMA is enabled and set to 2 Bytes     3=DMA is enabled and set to 4 Bytes     0=DMA is disabled. All data in the Receive Buffer must be emptied by firmware."/>
            <edc:SFRFieldDef edc:cname="CLOSE_TRANS_EN" edc:nzwidth="0x1" edc:desc="This selects what action is taken at the end of a transfer. This bit must be set only on the Last Buffer.     1=The transfer is terminated. The Chip Select de-asserts, the SPI interface returns to IDLE and the DMA interface completes the transfer.     0=The transfer is not closed. Chip Select remains asserted and the DMA interface and the SPI interface remain active"/>
            <edc:SFRFieldDef edc:cname="TRANS_LEN" edc:nzwidth="0x2" edc:desc="3=TRANSFER_LENGTH defined in units of 16-byte segments,            2=TRANSFER_LENGTH defined in units of 4-byte segments     1=TRANSFER_LENGTH defined in units of bytes,     0=TRANSFER_LENGTH defined in units of bits"/>
            <edc:SFRFieldDef edc:cname="DESCR_BUF_NXT_PTR" edc:nzwidth="0x4" edc:desc="This defines the next buffer to be used if Description Buffers are enabled and this is not the last buffer. This can point to the current buffer, creating an infinite loop."/>
            <edc:SFRFieldDef edc:cname="DESCR_BUF_LAST" edc:nzwidth="0x1" edc:desc="Last Descriptor. 1=Last Description Buffer in the chain. 0=This is not the last buffer."/>
            <edc:SFRFieldDef edc:cname="TX_LEN" edc:nzwidth="0xF" edc:desc="The length of the SPI transfer. The count is in bytes or bits, depending on the value of TRANSFER_LENGTH_BITS. A value of 0 means an infinite length transfer."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="QMSPI1" edc:cname="DESCR8" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x40070250">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="QMSPI1">
            <edc:SFRFieldDef edc:cname="INFACE_MOD" edc:nzwidth="0x2" edc:desc="This field sets the transmission mode. If this field is set for Dual Mode or Quad Mode then either TX_TRANSFER_ENABLE or RX_TRANSFER_ENABLE must be 0.     3=Reserved; 2=Quad Mode; 1=Dual Mode; 0=Single/Duplex Mode."/>
            <edc:SFRFieldDef edc:cname="TX_TRANS_EN" edc:nzwidth="0x2" edc:desc="This field bit selects the transmit function of the SPI interface.     3=Transmit Enabled in 1 Mode. The MOSI or IO Bus will send out only 1's. The Transmit Buffer will not be used     2=Transmit Enabled in 0 Mode. The MOSI or IO Bus will send out only 0's. The Transmit Buffer will not be used.     1=Transmit Enabled. Data will be fetched from the Transmit Buffer and sent out on the MOSI or IO Bus.     0=Transmit is Disabled. No data is sent. This will cause the MOSI be to be undriven, or the IO bus to be undriven if Receive is also disabled."/>
            <edc:SFRFieldDef edc:cname="TX_DMA_EN" edc:nzwidth="0x2" edc:desc="This bit enables DMA support for Transmit Transfer. If enabled, DMA will be requested to fill the FIFO until either the interface     reaches TRANSFER_LENGTH or the DMA sends a termination request. The size defined here must match DMA programmed access size.     1=DMA is enabled.and set to 1 Byte      2=DMA is enabled and set to 2 Bytes      3=DMA is enabled and set to 4 Bytes     0=DMA is disabled. All data in the Transmit Buffer must be emptied by firmware."/>
            <edc:SFRFieldDef edc:cname="RX_TRANS_EN" edc:nzwidth="0x1" edc:desc="This bit enables the receive function of the SPI interface.     1=Receive is enabled. Data received from the SPI Slave is stored in the Receive Buffer; 0=Receive is disabled."/>
            <edc:SFRFieldDef edc:cname="RX_DMA_EN" edc:nzwidth="0x2" edc:desc="This bit enables DMA support for Receive Transfer. If enabled, DMA will be requested to empty the FIFO until either the interface reaches TRANSFER_LENGTH or the DMA sends a termination request. The size defined here must match DMA programmed access size.     1=DMA is enabled.and set to 1 Byte     2=DMA is enabled and set to 2 Bytes     3=DMA is enabled and set to 4 Bytes     0=DMA is disabled. All data in the Receive Buffer must be emptied by firmware."/>
            <edc:SFRFieldDef edc:cname="CLOSE_TRANS_EN" edc:nzwidth="0x1" edc:desc="This selects what action is taken at the end of a transfer. This bit must be set only on the Last Buffer.     1=The transfer is terminated. The Chip Select de-asserts, the SPI interface returns to IDLE and the DMA interface completes the transfer.     0=The transfer is not closed. Chip Select remains asserted and the DMA interface and the SPI interface remain active"/>
            <edc:SFRFieldDef edc:cname="TRANS_LEN" edc:nzwidth="0x2" edc:desc="3=TRANSFER_LENGTH defined in units of 16-byte segments,            2=TRANSFER_LENGTH defined in units of 4-byte segments     1=TRANSFER_LENGTH defined in units of bytes,     0=TRANSFER_LENGTH defined in units of bits"/>
            <edc:SFRFieldDef edc:cname="DESCR_BUF_NXT_PTR" edc:nzwidth="0x4" edc:desc="This defines the next buffer to be used if Description Buffers are enabled and this is not the last buffer. This can point to the current buffer, creating an infinite loop."/>
            <edc:SFRFieldDef edc:cname="DESCR_BUF_LAST" edc:nzwidth="0x1" edc:desc="Last Descriptor. 1=Last Description Buffer in the chain. 0=This is not the last buffer."/>
            <edc:SFRFieldDef edc:cname="TX_LEN" edc:nzwidth="0xF" edc:desc="The length of the SPI transfer. The count is in bytes or bits, depending on the value of TRANSFER_LENGTH_BITS. A value of 0 means an infinite length transfer."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="QMSPI1" edc:cname="DESCR9" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x40070254">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="QMSPI1">
            <edc:SFRFieldDef edc:cname="INFACE_MOD" edc:nzwidth="0x2" edc:desc="This field sets the transmission mode. If this field is set for Dual Mode or Quad Mode then either TX_TRANSFER_ENABLE or RX_TRANSFER_ENABLE must be 0.     3=Reserved; 2=Quad Mode; 1=Dual Mode; 0=Single/Duplex Mode."/>
            <edc:SFRFieldDef edc:cname="TX_TRANS_EN" edc:nzwidth="0x2" edc:desc="This field bit selects the transmit function of the SPI interface.     3=Transmit Enabled in 1 Mode. The MOSI or IO Bus will send out only 1's. The Transmit Buffer will not be used     2=Transmit Enabled in 0 Mode. The MOSI or IO Bus will send out only 0's. The Transmit Buffer will not be used.     1=Transmit Enabled. Data will be fetched from the Transmit Buffer and sent out on the MOSI or IO Bus.     0=Transmit is Disabled. No data is sent. This will cause the MOSI be to be undriven, or the IO bus to be undriven if Receive is also disabled."/>
            <edc:SFRFieldDef edc:cname="TX_DMA_EN" edc:nzwidth="0x2" edc:desc="This bit enables DMA support for Transmit Transfer. If enabled, DMA will be requested to fill the FIFO until either the interface     reaches TRANSFER_LENGTH or the DMA sends a termination request. The size defined here must match DMA programmed access size.     1=DMA is enabled.and set to 1 Byte      2=DMA is enabled and set to 2 Bytes      3=DMA is enabled and set to 4 Bytes     0=DMA is disabled. All data in the Transmit Buffer must be emptied by firmware."/>
            <edc:SFRFieldDef edc:cname="RX_TRANS_EN" edc:nzwidth="0x1" edc:desc="This bit enables the receive function of the SPI interface.     1=Receive is enabled. Data received from the SPI Slave is stored in the Receive Buffer; 0=Receive is disabled."/>
            <edc:SFRFieldDef edc:cname="RX_DMA_EN" edc:nzwidth="0x2" edc:desc="This bit enables DMA support for Receive Transfer. If enabled, DMA will be requested to empty the FIFO until either the interface reaches TRANSFER_LENGTH or the DMA sends a termination request. The size defined here must match DMA programmed access size.     1=DMA is enabled.and set to 1 Byte     2=DMA is enabled and set to 2 Bytes     3=DMA is enabled and set to 4 Bytes     0=DMA is disabled. All data in the Receive Buffer must be emptied by firmware."/>
            <edc:SFRFieldDef edc:cname="CLOSE_TRANS_EN" edc:nzwidth="0x1" edc:desc="This selects what action is taken at the end of a transfer. This bit must be set only on the Last Buffer.     1=The transfer is terminated. The Chip Select de-asserts, the SPI interface returns to IDLE and the DMA interface completes the transfer.     0=The transfer is not closed. Chip Select remains asserted and the DMA interface and the SPI interface remain active"/>
            <edc:SFRFieldDef edc:cname="TRANS_LEN" edc:nzwidth="0x2" edc:desc="3=TRANSFER_LENGTH defined in units of 16-byte segments,            2=TRANSFER_LENGTH defined in units of 4-byte segments     1=TRANSFER_LENGTH defined in units of bytes,     0=TRANSFER_LENGTH defined in units of bits"/>
            <edc:SFRFieldDef edc:cname="DESCR_BUF_NXT_PTR" edc:nzwidth="0x4" edc:desc="This defines the next buffer to be used if Description Buffers are enabled and this is not the last buffer. This can point to the current buffer, creating an infinite loop."/>
            <edc:SFRFieldDef edc:cname="DESCR_BUF_LAST" edc:nzwidth="0x1" edc:desc="Last Descriptor. 1=Last Description Buffer in the chain. 0=This is not the last buffer."/>
            <edc:SFRFieldDef edc:cname="TX_LEN" edc:nzwidth="0xF" edc:desc="The length of the SPI transfer. The count is in bytes or bits, depending on the value of TRANSFER_LENGTH_BITS. A value of 0 means an infinite length transfer."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="QMSPI1" edc:cname="DESCR10" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x40070258">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="QMSPI1">
            <edc:SFRFieldDef edc:cname="INFACE_MOD" edc:nzwidth="0x2" edc:desc="This field sets the transmission mode. If this field is set for Dual Mode or Quad Mode then either TX_TRANSFER_ENABLE or RX_TRANSFER_ENABLE must be 0.     3=Reserved; 2=Quad Mode; 1=Dual Mode; 0=Single/Duplex Mode."/>
            <edc:SFRFieldDef edc:cname="TX_TRANS_EN" edc:nzwidth="0x2" edc:desc="This field bit selects the transmit function of the SPI interface.     3=Transmit Enabled in 1 Mode. The MOSI or IO Bus will send out only 1's. The Transmit Buffer will not be used     2=Transmit Enabled in 0 Mode. The MOSI or IO Bus will send out only 0's. The Transmit Buffer will not be used.     1=Transmit Enabled. Data will be fetched from the Transmit Buffer and sent out on the MOSI or IO Bus.     0=Transmit is Disabled. No data is sent. This will cause the MOSI be to be undriven, or the IO bus to be undriven if Receive is also disabled."/>
            <edc:SFRFieldDef edc:cname="TX_DMA_EN" edc:nzwidth="0x2" edc:desc="This bit enables DMA support for Transmit Transfer. If enabled, DMA will be requested to fill the FIFO until either the interface     reaches TRANSFER_LENGTH or the DMA sends a termination request. The size defined here must match DMA programmed access size.     1=DMA is enabled.and set to 1 Byte      2=DMA is enabled and set to 2 Bytes      3=DMA is enabled and set to 4 Bytes     0=DMA is disabled. All data in the Transmit Buffer must be emptied by firmware."/>
            <edc:SFRFieldDef edc:cname="RX_TRANS_EN" edc:nzwidth="0x1" edc:desc="This bit enables the receive function of the SPI interface.     1=Receive is enabled. Data received from the SPI Slave is stored in the Receive Buffer; 0=Receive is disabled."/>
            <edc:SFRFieldDef edc:cname="RX_DMA_EN" edc:nzwidth="0x2" edc:desc="This bit enables DMA support for Receive Transfer. If enabled, DMA will be requested to empty the FIFO until either the interface reaches TRANSFER_LENGTH or the DMA sends a termination request. The size defined here must match DMA programmed access size.     1=DMA is enabled.and set to 1 Byte     2=DMA is enabled and set to 2 Bytes     3=DMA is enabled and set to 4 Bytes     0=DMA is disabled. All data in the Receive Buffer must be emptied by firmware."/>
            <edc:SFRFieldDef edc:cname="CLOSE_TRANS_EN" edc:nzwidth="0x1" edc:desc="This selects what action is taken at the end of a transfer. This bit must be set only on the Last Buffer.     1=The transfer is terminated. The Chip Select de-asserts, the SPI interface returns to IDLE and the DMA interface completes the transfer.     0=The transfer is not closed. Chip Select remains asserted and the DMA interface and the SPI interface remain active"/>
            <edc:SFRFieldDef edc:cname="TRANS_LEN" edc:nzwidth="0x2" edc:desc="3=TRANSFER_LENGTH defined in units of 16-byte segments,            2=TRANSFER_LENGTH defined in units of 4-byte segments     1=TRANSFER_LENGTH defined in units of bytes,     0=TRANSFER_LENGTH defined in units of bits"/>
            <edc:SFRFieldDef edc:cname="DESCR_BUF_NXT_PTR" edc:nzwidth="0x4" edc:desc="This defines the next buffer to be used if Description Buffers are enabled and this is not the last buffer. This can point to the current buffer, creating an infinite loop."/>
            <edc:SFRFieldDef edc:cname="DESCR_BUF_LAST" edc:nzwidth="0x1" edc:desc="Last Descriptor. 1=Last Description Buffer in the chain. 0=This is not the last buffer."/>
            <edc:SFRFieldDef edc:cname="TX_LEN" edc:nzwidth="0xF" edc:desc="The length of the SPI transfer. The count is in bytes or bits, depending on the value of TRANSFER_LENGTH_BITS. A value of 0 means an infinite length transfer."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="QMSPI1" edc:cname="DESCR11" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x4007025C">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="QMSPI1">
            <edc:SFRFieldDef edc:cname="INFACE_MOD" edc:nzwidth="0x2" edc:desc="This field sets the transmission mode. If this field is set for Dual Mode or Quad Mode then either TX_TRANSFER_ENABLE or RX_TRANSFER_ENABLE must be 0.     3=Reserved; 2=Quad Mode; 1=Dual Mode; 0=Single/Duplex Mode."/>
            <edc:SFRFieldDef edc:cname="TX_TRANS_EN" edc:nzwidth="0x2" edc:desc="This field bit selects the transmit function of the SPI interface.     3=Transmit Enabled in 1 Mode. The MOSI or IO Bus will send out only 1's. The Transmit Buffer will not be used     2=Transmit Enabled in 0 Mode. The MOSI or IO Bus will send out only 0's. The Transmit Buffer will not be used.     1=Transmit Enabled. Data will be fetched from the Transmit Buffer and sent out on the MOSI or IO Bus.     0=Transmit is Disabled. No data is sent. This will cause the MOSI be to be undriven, or the IO bus to be undriven if Receive is also disabled."/>
            <edc:SFRFieldDef edc:cname="TX_DMA_EN" edc:nzwidth="0x2" edc:desc="This bit enables DMA support for Transmit Transfer. If enabled, DMA will be requested to fill the FIFO until either the interface     reaches TRANSFER_LENGTH or the DMA sends a termination request. The size defined here must match DMA programmed access size.     1=DMA is enabled.and set to 1 Byte      2=DMA is enabled and set to 2 Bytes      3=DMA is enabled and set to 4 Bytes     0=DMA is disabled. All data in the Transmit Buffer must be emptied by firmware."/>
            <edc:SFRFieldDef edc:cname="RX_TRANS_EN" edc:nzwidth="0x1" edc:desc="This bit enables the receive function of the SPI interface.     1=Receive is enabled. Data received from the SPI Slave is stored in the Receive Buffer; 0=Receive is disabled."/>
            <edc:SFRFieldDef edc:cname="RX_DMA_EN" edc:nzwidth="0x2" edc:desc="This bit enables DMA support for Receive Transfer. If enabled, DMA will be requested to empty the FIFO until either the interface reaches TRANSFER_LENGTH or the DMA sends a termination request. The size defined here must match DMA programmed access size.     1=DMA is enabled.and set to 1 Byte     2=DMA is enabled and set to 2 Bytes     3=DMA is enabled and set to 4 Bytes     0=DMA is disabled. All data in the Receive Buffer must be emptied by firmware."/>
            <edc:SFRFieldDef edc:cname="CLOSE_TRANS_EN" edc:nzwidth="0x1" edc:desc="This selects what action is taken at the end of a transfer. This bit must be set only on the Last Buffer.     1=The transfer is terminated. The Chip Select de-asserts, the SPI interface returns to IDLE and the DMA interface completes the transfer.     0=The transfer is not closed. Chip Select remains asserted and the DMA interface and the SPI interface remain active"/>
            <edc:SFRFieldDef edc:cname="TRANS_LEN" edc:nzwidth="0x2" edc:desc="3=TRANSFER_LENGTH defined in units of 16-byte segments,            2=TRANSFER_LENGTH defined in units of 4-byte segments     1=TRANSFER_LENGTH defined in units of bytes,     0=TRANSFER_LENGTH defined in units of bits"/>
            <edc:SFRFieldDef edc:cname="DESCR_BUF_NXT_PTR" edc:nzwidth="0x4" edc:desc="This defines the next buffer to be used if Description Buffers are enabled and this is not the last buffer. This can point to the current buffer, creating an infinite loop."/>
            <edc:SFRFieldDef edc:cname="DESCR_BUF_LAST" edc:nzwidth="0x1" edc:desc="Last Descriptor. 1=Last Description Buffer in the chain. 0=This is not the last buffer."/>
            <edc:SFRFieldDef edc:cname="TX_LEN" edc:nzwidth="0xF" edc:desc="The length of the SPI transfer. The count is in bytes or bits, depending on the value of TRANSFER_LENGTH_BITS. A value of 0 means an infinite length transfer."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="QMSPI1" edc:cname="DESCR12" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x40070260">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="QMSPI1">
            <edc:SFRFieldDef edc:cname="INFACE_MOD" edc:nzwidth="0x2" edc:desc="This field sets the transmission mode. If this field is set for Dual Mode or Quad Mode then either TX_TRANSFER_ENABLE or RX_TRANSFER_ENABLE must be 0.     3=Reserved; 2=Quad Mode; 1=Dual Mode; 0=Single/Duplex Mode."/>
            <edc:SFRFieldDef edc:cname="TX_TRANS_EN" edc:nzwidth="0x2" edc:desc="This field bit selects the transmit function of the SPI interface.     3=Transmit Enabled in 1 Mode. The MOSI or IO Bus will send out only 1's. The Transmit Buffer will not be used     2=Transmit Enabled in 0 Mode. The MOSI or IO Bus will send out only 0's. The Transmit Buffer will not be used.     1=Transmit Enabled. Data will be fetched from the Transmit Buffer and sent out on the MOSI or IO Bus.     0=Transmit is Disabled. No data is sent. This will cause the MOSI be to be undriven, or the IO bus to be undriven if Receive is also disabled."/>
            <edc:SFRFieldDef edc:cname="TX_DMA_EN" edc:nzwidth="0x2" edc:desc="This bit enables DMA support for Transmit Transfer. If enabled, DMA will be requested to fill the FIFO until either the interface     reaches TRANSFER_LENGTH or the DMA sends a termination request. The size defined here must match DMA programmed access size.     1=DMA is enabled.and set to 1 Byte      2=DMA is enabled and set to 2 Bytes      3=DMA is enabled and set to 4 Bytes     0=DMA is disabled. All data in the Transmit Buffer must be emptied by firmware."/>
            <edc:SFRFieldDef edc:cname="RX_TRANS_EN" edc:nzwidth="0x1" edc:desc="This bit enables the receive function of the SPI interface.     1=Receive is enabled. Data received from the SPI Slave is stored in the Receive Buffer; 0=Receive is disabled."/>
            <edc:SFRFieldDef edc:cname="RX_DMA_EN" edc:nzwidth="0x2" edc:desc="This bit enables DMA support for Receive Transfer. If enabled, DMA will be requested to empty the FIFO until either the interface reaches TRANSFER_LENGTH or the DMA sends a termination request. The size defined here must match DMA programmed access size.     1=DMA is enabled.and set to 1 Byte     2=DMA is enabled and set to 2 Bytes     3=DMA is enabled and set to 4 Bytes     0=DMA is disabled. All data in the Receive Buffer must be emptied by firmware."/>
            <edc:SFRFieldDef edc:cname="CLOSE_TRANS_EN" edc:nzwidth="0x1" edc:desc="This selects what action is taken at the end of a transfer. This bit must be set only on the Last Buffer.     1=The transfer is terminated. The Chip Select de-asserts, the SPI interface returns to IDLE and the DMA interface completes the transfer.     0=The transfer is not closed. Chip Select remains asserted and the DMA interface and the SPI interface remain active"/>
            <edc:SFRFieldDef edc:cname="TRANS_LEN" edc:nzwidth="0x2" edc:desc="3=TRANSFER_LENGTH defined in units of 16-byte segments,            2=TRANSFER_LENGTH defined in units of 4-byte segments     1=TRANSFER_LENGTH defined in units of bytes,     0=TRANSFER_LENGTH defined in units of bits"/>
            <edc:SFRFieldDef edc:cname="DESCR_BUF_NXT_PTR" edc:nzwidth="0x4" edc:desc="This defines the next buffer to be used if Description Buffers are enabled and this is not the last buffer. This can point to the current buffer, creating an infinite loop."/>
            <edc:SFRFieldDef edc:cname="DESCR_BUF_LAST" edc:nzwidth="0x1" edc:desc="Last Descriptor. 1=Last Description Buffer in the chain. 0=This is not the last buffer."/>
            <edc:SFRFieldDef edc:cname="TX_LEN" edc:nzwidth="0xF" edc:desc="The length of the SPI transfer. The count is in bytes or bits, depending on the value of TRANSFER_LENGTH_BITS. A value of 0 means an infinite length transfer."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="QMSPI1" edc:cname="DESCR13" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x40070264">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="QMSPI1">
            <edc:SFRFieldDef edc:cname="INFACE_MOD" edc:nzwidth="0x2" edc:desc="This field sets the transmission mode. If this field is set for Dual Mode or Quad Mode then either TX_TRANSFER_ENABLE or RX_TRANSFER_ENABLE must be 0.     3=Reserved; 2=Quad Mode; 1=Dual Mode; 0=Single/Duplex Mode."/>
            <edc:SFRFieldDef edc:cname="TX_TRANS_EN" edc:nzwidth="0x2" edc:desc="This field bit selects the transmit function of the SPI interface.     3=Transmit Enabled in 1 Mode. The MOSI or IO Bus will send out only 1's. The Transmit Buffer will not be used     2=Transmit Enabled in 0 Mode. The MOSI or IO Bus will send out only 0's. The Transmit Buffer will not be used.     1=Transmit Enabled. Data will be fetched from the Transmit Buffer and sent out on the MOSI or IO Bus.     0=Transmit is Disabled. No data is sent. This will cause the MOSI be to be undriven, or the IO bus to be undriven if Receive is also disabled."/>
            <edc:SFRFieldDef edc:cname="TX_DMA_EN" edc:nzwidth="0x2" edc:desc="This bit enables DMA support for Transmit Transfer. If enabled, DMA will be requested to fill the FIFO until either the interface     reaches TRANSFER_LENGTH or the DMA sends a termination request. The size defined here must match DMA programmed access size.     1=DMA is enabled.and set to 1 Byte      2=DMA is enabled and set to 2 Bytes      3=DMA is enabled and set to 4 Bytes     0=DMA is disabled. All data in the Transmit Buffer must be emptied by firmware."/>
            <edc:SFRFieldDef edc:cname="RX_TRANS_EN" edc:nzwidth="0x1" edc:desc="This bit enables the receive function of the SPI interface.     1=Receive is enabled. Data received from the SPI Slave is stored in the Receive Buffer; 0=Receive is disabled."/>
            <edc:SFRFieldDef edc:cname="RX_DMA_EN" edc:nzwidth="0x2" edc:desc="This bit enables DMA support for Receive Transfer. If enabled, DMA will be requested to empty the FIFO until either the interface reaches TRANSFER_LENGTH or the DMA sends a termination request. The size defined here must match DMA programmed access size.     1=DMA is enabled.and set to 1 Byte     2=DMA is enabled and set to 2 Bytes     3=DMA is enabled and set to 4 Bytes     0=DMA is disabled. All data in the Receive Buffer must be emptied by firmware."/>
            <edc:SFRFieldDef edc:cname="CLOSE_TRANS_EN" edc:nzwidth="0x1" edc:desc="This selects what action is taken at the end of a transfer. This bit must be set only on the Last Buffer.     1=The transfer is terminated. The Chip Select de-asserts, the SPI interface returns to IDLE and the DMA interface completes the transfer.     0=The transfer is not closed. Chip Select remains asserted and the DMA interface and the SPI interface remain active"/>
            <edc:SFRFieldDef edc:cname="TRANS_LEN" edc:nzwidth="0x2" edc:desc="3=TRANSFER_LENGTH defined in units of 16-byte segments,            2=TRANSFER_LENGTH defined in units of 4-byte segments     1=TRANSFER_LENGTH defined in units of bytes,     0=TRANSFER_LENGTH defined in units of bits"/>
            <edc:SFRFieldDef edc:cname="DESCR_BUF_NXT_PTR" edc:nzwidth="0x4" edc:desc="This defines the next buffer to be used if Description Buffers are enabled and this is not the last buffer. This can point to the current buffer, creating an infinite loop."/>
            <edc:SFRFieldDef edc:cname="DESCR_BUF_LAST" edc:nzwidth="0x1" edc:desc="Last Descriptor. 1=Last Description Buffer in the chain. 0=This is not the last buffer."/>
            <edc:SFRFieldDef edc:cname="TX_LEN" edc:nzwidth="0xF" edc:desc="The length of the SPI transfer. The count is in bytes or bits, depending on the value of TRANSFER_LENGTH_BITS. A value of 0 means an infinite length transfer."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="QMSPI1" edc:cname="DESCR14" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x40070268">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="QMSPI1">
            <edc:SFRFieldDef edc:cname="INFACE_MOD" edc:nzwidth="0x2" edc:desc="This field sets the transmission mode. If this field is set for Dual Mode or Quad Mode then either TX_TRANSFER_ENABLE or RX_TRANSFER_ENABLE must be 0.     3=Reserved; 2=Quad Mode; 1=Dual Mode; 0=Single/Duplex Mode."/>
            <edc:SFRFieldDef edc:cname="TX_TRANS_EN" edc:nzwidth="0x2" edc:desc="This field bit selects the transmit function of the SPI interface.     3=Transmit Enabled in 1 Mode. The MOSI or IO Bus will send out only 1's. The Transmit Buffer will not be used     2=Transmit Enabled in 0 Mode. The MOSI or IO Bus will send out only 0's. The Transmit Buffer will not be used.     1=Transmit Enabled. Data will be fetched from the Transmit Buffer and sent out on the MOSI or IO Bus.     0=Transmit is Disabled. No data is sent. This will cause the MOSI be to be undriven, or the IO bus to be undriven if Receive is also disabled."/>
            <edc:SFRFieldDef edc:cname="TX_DMA_EN" edc:nzwidth="0x2" edc:desc="This bit enables DMA support for Transmit Transfer. If enabled, DMA will be requested to fill the FIFO until either the interface     reaches TRANSFER_LENGTH or the DMA sends a termination request. The size defined here must match DMA programmed access size.     1=DMA is enabled.and set to 1 Byte      2=DMA is enabled and set to 2 Bytes      3=DMA is enabled and set to 4 Bytes     0=DMA is disabled. All data in the Transmit Buffer must be emptied by firmware."/>
            <edc:SFRFieldDef edc:cname="RX_TRANS_EN" edc:nzwidth="0x1" edc:desc="This bit enables the receive function of the SPI interface.     1=Receive is enabled. Data received from the SPI Slave is stored in the Receive Buffer; 0=Receive is disabled."/>
            <edc:SFRFieldDef edc:cname="RX_DMA_EN" edc:nzwidth="0x2" edc:desc="This bit enables DMA support for Receive Transfer. If enabled, DMA will be requested to empty the FIFO until either the interface reaches TRANSFER_LENGTH or the DMA sends a termination request. The size defined here must match DMA programmed access size.     1=DMA is enabled.and set to 1 Byte     2=DMA is enabled and set to 2 Bytes     3=DMA is enabled and set to 4 Bytes     0=DMA is disabled. All data in the Receive Buffer must be emptied by firmware."/>
            <edc:SFRFieldDef edc:cname="CLOSE_TRANS_EN" edc:nzwidth="0x1" edc:desc="This selects what action is taken at the end of a transfer. This bit must be set only on the Last Buffer.     1=The transfer is terminated. The Chip Select de-asserts, the SPI interface returns to IDLE and the DMA interface completes the transfer.     0=The transfer is not closed. Chip Select remains asserted and the DMA interface and the SPI interface remain active"/>
            <edc:SFRFieldDef edc:cname="TRANS_LEN" edc:nzwidth="0x2" edc:desc="3=TRANSFER_LENGTH defined in units of 16-byte segments,            2=TRANSFER_LENGTH defined in units of 4-byte segments     1=TRANSFER_LENGTH defined in units of bytes,     0=TRANSFER_LENGTH defined in units of bits"/>
            <edc:SFRFieldDef edc:cname="DESCR_BUF_NXT_PTR" edc:nzwidth="0x4" edc:desc="This defines the next buffer to be used if Description Buffers are enabled and this is not the last buffer. This can point to the current buffer, creating an infinite loop."/>
            <edc:SFRFieldDef edc:cname="DESCR_BUF_LAST" edc:nzwidth="0x1" edc:desc="Last Descriptor. 1=Last Description Buffer in the chain. 0=This is not the last buffer."/>
            <edc:SFRFieldDef edc:cname="TX_LEN" edc:nzwidth="0xF" edc:desc="The length of the SPI transfer. The count is in bytes or bits, depending on the value of TRANSFER_LENGTH_BITS. A value of 0 means an infinite length transfer."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="QMSPI1" edc:cname="DESCR15" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x4007026C">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="QMSPI1">
            <edc:SFRFieldDef edc:cname="INFACE_MOD" edc:nzwidth="0x2" edc:desc="This field sets the transmission mode. If this field is set for Dual Mode or Quad Mode then either TX_TRANSFER_ENABLE or RX_TRANSFER_ENABLE must be 0.     3=Reserved; 2=Quad Mode; 1=Dual Mode; 0=Single/Duplex Mode."/>
            <edc:SFRFieldDef edc:cname="TX_TRANS_EN" edc:nzwidth="0x2" edc:desc="This field bit selects the transmit function of the SPI interface.     3=Transmit Enabled in 1 Mode. The MOSI or IO Bus will send out only 1's. The Transmit Buffer will not be used     2=Transmit Enabled in 0 Mode. The MOSI or IO Bus will send out only 0's. The Transmit Buffer will not be used.     1=Transmit Enabled. Data will be fetched from the Transmit Buffer and sent out on the MOSI or IO Bus.     0=Transmit is Disabled. No data is sent. This will cause the MOSI be to be undriven, or the IO bus to be undriven if Receive is also disabled."/>
            <edc:SFRFieldDef edc:cname="TX_DMA_EN" edc:nzwidth="0x2" edc:desc="This bit enables DMA support for Transmit Transfer. If enabled, DMA will be requested to fill the FIFO until either the interface     reaches TRANSFER_LENGTH or the DMA sends a termination request. The size defined here must match DMA programmed access size.     1=DMA is enabled.and set to 1 Byte      2=DMA is enabled and set to 2 Bytes      3=DMA is enabled and set to 4 Bytes     0=DMA is disabled. All data in the Transmit Buffer must be emptied by firmware."/>
            <edc:SFRFieldDef edc:cname="RX_TRANS_EN" edc:nzwidth="0x1" edc:desc="This bit enables the receive function of the SPI interface.     1=Receive is enabled. Data received from the SPI Slave is stored in the Receive Buffer; 0=Receive is disabled."/>
            <edc:SFRFieldDef edc:cname="RX_DMA_EN" edc:nzwidth="0x2" edc:desc="This bit enables DMA support for Receive Transfer. If enabled, DMA will be requested to empty the FIFO until either the interface reaches TRANSFER_LENGTH or the DMA sends a termination request. The size defined here must match DMA programmed access size.     1=DMA is enabled.and set to 1 Byte     2=DMA is enabled and set to 2 Bytes     3=DMA is enabled and set to 4 Bytes     0=DMA is disabled. All data in the Receive Buffer must be emptied by firmware."/>
            <edc:SFRFieldDef edc:cname="CLOSE_TRANS_EN" edc:nzwidth="0x1" edc:desc="This selects what action is taken at the end of a transfer. This bit must be set only on the Last Buffer.     1=The transfer is terminated. The Chip Select de-asserts, the SPI interface returns to IDLE and the DMA interface completes the transfer.     0=The transfer is not closed. Chip Select remains asserted and the DMA interface and the SPI interface remain active"/>
            <edc:SFRFieldDef edc:cname="TRANS_LEN" edc:nzwidth="0x2" edc:desc="3=TRANSFER_LENGTH defined in units of 16-byte segments,            2=TRANSFER_LENGTH defined in units of 4-byte segments     1=TRANSFER_LENGTH defined in units of bytes,     0=TRANSFER_LENGTH defined in units of bits"/>
            <edc:SFRFieldDef edc:cname="DESCR_BUF_NXT_PTR" edc:nzwidth="0x4" edc:desc="This defines the next buffer to be used if Description Buffers are enabled and this is not the last buffer. This can point to the current buffer, creating an infinite loop."/>
            <edc:SFRFieldDef edc:cname="DESCR_BUF_LAST" edc:nzwidth="0x1" edc:desc="Last Descriptor. 1=Last Description Buffer in the chain. 0=This is not the last buffer."/>
            <edc:SFRFieldDef edc:cname="TX_LEN" edc:nzwidth="0xF" edc:desc="The length of the SPI transfer. The count is in bytes or bits, depending on the value of TRANSFER_LENGTH_BITS. A value of 0 means an infinite length transfer."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:AdjustPoint edc:offset="0x40" edc:_addr="0x40070270"/>
      <edc:SFRDef ltx:memberofperipheral="QMSPI1" edc:cname="ALIAS_CTRL" edc:nzwidth="0x20" edc:access="wwwwwwwwwwwwwwwwwwwwwwww-wwwwwww" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0xFFFFFF7F" edc:_addr="0x400702B0">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="QMSPI1">
            <edc:SFRFieldDef edc:cname="ALS_EXEC_STRT" edc:nzwidth="0x1" edc:desc="Alias for the QMSPI Execution:Start field."/>
            <edc:SFRFieldDef edc:cname="CLS_ALTMODE_EN" edc:nzwidth="0x1" edc:desc="Enable the CS1 Clock Divide to be active if CS1 is the interface in use."/>
            <edc:SFRFieldDef edc:cname="ALS_WR_TXBUF" edc:nzwidth="0x1" edc:desc="Alias that triggers a write to the Tx Buffer of 1 Byte using data from Alias Tx Buffer Data in this register."/>
            <edc:SFRFieldDef edc:cname="ALS_WRDBUF_XFRLEN" edc:nzwidth="0x1" edc:desc="Alias that triggers a write to the Description Buffer pointed to by Alias Description Buffer Select in this register to modify the Transfer Length field with the value of Alias Description Buffer Transfer Length in this register."/>
            <edc:SFRFieldDef edc:cname="ALS_MOD_CS" edc:nzwidth="0x2" edc:desc="Alias for the QMSPI Mode:Chip Select field."/>
            <edc:SFRFieldDef edc:cname="ALS_LDMA_INCR_ADD" edc:nzwidth="0x1" edc:desc="Alias that overrides the value in all QMSPI Local DMA * [Tx/Rx] Control:Increment Address Enable fields w/ this value."/>
            <edc:AdjustPoint edc:offset="0x1"/>
            <edc:SFRFieldDef edc:cname="ALS_CTRL_DBUF_PTR" edc:nzwidth="0x4" edc:desc="Alias for the QMSPI Control:Description Buffer Pointer field."/>
            <edc:SFRFieldDef edc:cname="ALS_DBUF_SEL" edc:nzwidth="0x4" edc:desc="Which Description Buffer will be modified by a write if Alias Write Description Buffer Transfer Length is set."/>
            <edc:SFRFieldDef edc:cname="ALS_DBUF_XFR_LEN" edc:nzwidth="0x8" edc:desc="The value of the data written to the Description Buffers Transfer Length field, if the write is enabled."/>
            <edc:SFRFieldDef edc:cname="ALS_TXDBUF_DATA" edc:nzwidth="0x8" edc:desc="The Byte of data written into the Tx Buffer if the write is enabled."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:AdjustPoint edc:offset="0xC" edc:_addr="0x400702B4"/>
      <edc:SFRDef ltx:memberofperipheral="QMSPI1" edc:cname="MODE_ALT1" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnn---------------n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0xFFFF0001" edc:_addr="0x400702C0">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="QMSPI1">
            <edc:SFRFieldDef edc:cname="CS1_ALTMOD_EN" edc:nzwidth="0x1" edc:desc="Enable the CS1 Clock Divide to be active if CS1 is the interface in use."/>
            <edc:AdjustPoint edc:offset="0xF"/>
            <edc:SFRFieldDef edc:cname="CS1_ALTCLK_DIV" edc:nzwidth="0x10" edc:desc="The SPI clock divide in number of system clocks when CS1 is in use and CS1 Alt Mode Enable is set."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:AdjustPoint edc:offset="0xC" edc:_addr="0x400702C4"/>
      <edc:SFRDef ltx:memberofperipheral="QMSPI1" edc:cname="TAPS" edc:nzwidth="0x20" edc:access="----------------nnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0xFFFF" edc:_addr="0x400702D0">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="QMSPI1">
            <edc:SFRFieldDef edc:cname="SCK_TAP" edc:nzwidth="0x8" edc:desc="This will select the tap point for the feed-back SCK."/>
            <edc:SFRFieldDef edc:cname="CTRL_TAP" edc:nzwidth="0x8" edc:desc="This will select the tap point for signals that go from the System Domain."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="QMSPI1" edc:cname="TAP_ADJ" edc:nzwidth="0x20" edc:access="----------------nnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0xFFFF" edc:_addr="0x400702D4">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="QMSPI1">
            <edc:SFRFieldDef edc:cname="SCK_ADJ" edc:nzwidth="0x8" edc:desc="This is a signed value that will be added to the Select SCK Tap to come up with the final value for the delay."/>
            <edc:SFRFieldDef edc:cname="CTRL_ADJ" edc:nzwidth="0x8" edc:desc="This is a signed value that will be added to the Select Control Tap to come up with the final value for the delay."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="QMSPI1" edc:cname="TAP_CTRL" edc:nzwidth="0x20" edc:access="-------------nnn-------n-----nnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x70107" edc:_addr="0x400702D8">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="QMSPI1">
            <edc:SFRFieldDef edc:cname="AUTO_MOD" edc:nzwidth="0x2" edc:desc="This enables the automatic H/W trim of the Tap."/>
            <edc:SFRFieldDef edc:cname="CTRL" edc:nzwidth="0x1" edc:desc="This is a signed value that will be added to the Select Control Tap to come up with the final value for the delay."/>
            <edc:AdjustPoint edc:offset="0x5"/>
            <edc:SFRFieldDef edc:cname="FW_GO" edc:nzwidth="0x1" edc:desc="This will force the auto-trim H/W to run and find a new trim value."/>
            <edc:AdjustPoint edc:offset="0x7"/>
            <edc:SFRFieldDef edc:cname="AUTO_MULT" edc:nzwidth="0x3" edc:desc="This will multiply the target delay value the Auto-trim H/W will search for."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:AdjustPoint edc:offset="0x24" edc:_addr="0x400702DC"/>
      <edc:SFRDef ltx:memberofperipheral="QMSPI1" edc:cname="DESC_LDMA_RXEN" edc:nzwidth="0x20" edc:access="----------------nnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0xFFFF" edc:_addr="0x40070300">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="QMSPI1">
            <edc:SFRFieldDef edc:cname="DESC_LDMA_RXEN" edc:nzwidth="0x10" edc:desc="This enables the Local RX DMA usage (instead of the Central DMA) when the Descriptor Buffer register enables the DMA."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="QMSPI1" edc:cname="DESC_LDMA_TXEN" edc:nzwidth="0x20" edc:access="----------------nnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0xFFFF" edc:_addr="0x40070304">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="QMSPI1">
            <edc:SFRFieldDef edc:cname="DESC_LDMA_TXEN" edc:nzwidth="0x10" edc:desc="This enables the Local TX DMA usage (instead of the Central DMA) when the Descriptor Buffer register enables the DMA."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:AdjustPoint edc:offset="0x8" edc:_addr="0x40070308"/>
      <edc:SFRDef ltx:memberofperipheral="QMSPI1" edc:cname="LDMA_RX0LDMA_RXCTRL" edc:nzwidth="0x20" edc:access="-------------------------nnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x7F" edc:_addr="0x40070310">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="QMSPI1">
            <edc:SFRFieldDef edc:cname="CH_EN" edc:nzwidth="0x1" edc:desc="This enables the Local RX DMA Channel."/>
            <edc:SFRFieldDef edc:cname="RSTRT_EN" edc:nzwidth="0x1" edc:desc="This bit automatically re-enables the Local DMA Channel after completion of previous transfer."/>
            <edc:SFRFieldDef edc:cname="BUF_ADDR_EN" edc:nzwidth="0x1" edc:desc="Address re-enable will automatically re-enables the same address upon completion previous transfer."/>
            <edc:SFRFieldDef edc:cname="OVRD_LEN" edc:nzwidth="0x1" edc:desc="Override Lenght will override the length field to the QMSPI protocol FSM with the length programmed into the Local DMA."/>
            <edc:SFRFieldDef edc:cname="ACS_SZ" edc:nzwidth="0x2" edc:desc="Access Size selects the AHB Access Size."/>
            <edc:SFRFieldDef edc:cname="INC_ADDR_EN" edc:nzwidth="0x1" edc:desc="When set, the DMA Channels Start Address will increment on every access. If not set the address will not increment."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="QMSPI1" edc:cname="LDMA_RX0LDMA_RXSTRT_ADDR" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x40070314">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="QMSPI1">
            <edc:SFRFieldDef edc:cname="STRT_ADDR" edc:nzwidth="0x20" edc:desc="This is the Starting Address for the DMA access into the memory space (write to this address on Rx). This address is updated by the transfer size based on the Local DMA Access Size after every access."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="QMSPI1" edc:cname="LDMA_RX0LDMA_RX_LEN" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x40070318">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="QMSPI1">
            <edc:SFRFieldDef edc:cname="RX_LEN" edc:nzwidth="0x20" edc:desc="This is the maximum Length of the transfer in Bytes that the DMA Channel will allow access to."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="QMSPI1" edc:cname="LDMA_RX0RSVD" edc:nzwidth="0x20" edc:access="rrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrr" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x4007031C"/>
      <edc:SFRDef ltx:memberofperipheral="QMSPI1" edc:cname="LDMA_RX1LDMA_RXCTRL" edc:nzwidth="0x20" edc:access="-------------------------nnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x7F" edc:_addr="0x40070320">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="QMSPI1">
            <edc:SFRFieldDef edc:cname="CH_EN" edc:nzwidth="0x1" edc:desc="This enables the Local RX DMA Channel."/>
            <edc:SFRFieldDef edc:cname="RSTRT_EN" edc:nzwidth="0x1" edc:desc="This bit automatically re-enables the Local DMA Channel after completion of previous transfer."/>
            <edc:SFRFieldDef edc:cname="BUF_ADDR_EN" edc:nzwidth="0x1" edc:desc="Address re-enable will automatically re-enables the same address upon completion previous transfer."/>
            <edc:SFRFieldDef edc:cname="OVRD_LEN" edc:nzwidth="0x1" edc:desc="Override Lenght will override the length field to the QMSPI protocol FSM with the length programmed into the Local DMA."/>
            <edc:SFRFieldDef edc:cname="ACS_SZ" edc:nzwidth="0x2" edc:desc="Access Size selects the AHB Access Size."/>
            <edc:SFRFieldDef edc:cname="INC_ADDR_EN" edc:nzwidth="0x1" edc:desc="When set, the DMA Channels Start Address will increment on every access. If not set the address will not increment."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="QMSPI1" edc:cname="LDMA_RX1LDMA_RXSTRT_ADDR" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x40070324">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="QMSPI1">
            <edc:SFRFieldDef edc:cname="STRT_ADDR" edc:nzwidth="0x20" edc:desc="This is the Starting Address for the DMA access into the memory space (write to this address on Rx). This address is updated by the transfer size based on the Local DMA Access Size after every access."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="QMSPI1" edc:cname="LDMA_RX1LDMA_RX_LEN" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x40070328">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="QMSPI1">
            <edc:SFRFieldDef edc:cname="RX_LEN" edc:nzwidth="0x20" edc:desc="This is the maximum Length of the transfer in Bytes that the DMA Channel will allow access to."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="QMSPI1" edc:cname="LDMA_RX1RSVD" edc:nzwidth="0x20" edc:access="rrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrr" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x4007032C"/>
      <edc:SFRDef ltx:memberofperipheral="QMSPI1" edc:cname="LDMA_RX2LDMA_RXCTRL" edc:nzwidth="0x20" edc:access="-------------------------nnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x7F" edc:_addr="0x40070330">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="QMSPI1">
            <edc:SFRFieldDef edc:cname="CH_EN" edc:nzwidth="0x1" edc:desc="This enables the Local RX DMA Channel."/>
            <edc:SFRFieldDef edc:cname="RSTRT_EN" edc:nzwidth="0x1" edc:desc="This bit automatically re-enables the Local DMA Channel after completion of previous transfer."/>
            <edc:SFRFieldDef edc:cname="BUF_ADDR_EN" edc:nzwidth="0x1" edc:desc="Address re-enable will automatically re-enables the same address upon completion previous transfer."/>
            <edc:SFRFieldDef edc:cname="OVRD_LEN" edc:nzwidth="0x1" edc:desc="Override Lenght will override the length field to the QMSPI protocol FSM with the length programmed into the Local DMA."/>
            <edc:SFRFieldDef edc:cname="ACS_SZ" edc:nzwidth="0x2" edc:desc="Access Size selects the AHB Access Size."/>
            <edc:SFRFieldDef edc:cname="INC_ADDR_EN" edc:nzwidth="0x1" edc:desc="When set, the DMA Channels Start Address will increment on every access. If not set the address will not increment."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="QMSPI1" edc:cname="LDMA_RX2LDMA_RXSTRT_ADDR" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x40070334">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="QMSPI1">
            <edc:SFRFieldDef edc:cname="STRT_ADDR" edc:nzwidth="0x20" edc:desc="This is the Starting Address for the DMA access into the memory space (write to this address on Rx). This address is updated by the transfer size based on the Local DMA Access Size after every access."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="QMSPI1" edc:cname="LDMA_RX2LDMA_RX_LEN" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x40070338">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="QMSPI1">
            <edc:SFRFieldDef edc:cname="RX_LEN" edc:nzwidth="0x20" edc:desc="This is the maximum Length of the transfer in Bytes that the DMA Channel will allow access to."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="QMSPI1" edc:cname="LDMA_RX2RSVD" edc:nzwidth="0x20" edc:access="rrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrr" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x4007033C"/>
      <edc:SFRDef ltx:memberofperipheral="QMSPI1" edc:cname="LDMA_TX0LDMA_TXCTRL" edc:nzwidth="0x20" edc:access="-------------------------nnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x7F" edc:_addr="0x40070340">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="QMSPI1">
            <edc:SFRFieldDef edc:cname="CH_EN" edc:nzwidth="0x1" edc:desc="This enables the Local TX DMA Channel."/>
            <edc:SFRFieldDef edc:cname="RSTRT_EN" edc:nzwidth="0x1" edc:desc="This bit automatically re-enables the Local DMA Channel after completion of previous transfer."/>
            <edc:SFRFieldDef edc:cname="BUF_ADDR_EN" edc:nzwidth="0x1" edc:desc="Address re-enable will automatically re-enables the same address upon completion previous transfer."/>
            <edc:SFRFieldDef edc:cname="OVRD_LEN" edc:nzwidth="0x1" edc:desc="Override Lenght will override the length field to the QMSPI protocol FSM with the length programmed into the Local DMA."/>
            <edc:SFRFieldDef edc:cname="ACS_SZ" edc:nzwidth="0x2" edc:desc="Access Size selects the AHB Access Size."/>
            <edc:SFRFieldDef edc:cname="INC_ADDR_EN" edc:nzwidth="0x1" edc:desc="When set, the DMA Channels Start Address will increment on every access. If not set the address will not increment."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="QMSPI1" edc:cname="LDMA_TX0LDMA_TXSTRT_ADDR" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x40070344">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="QMSPI1">
            <edc:SFRFieldDef edc:cname="STRT_ADDR" edc:nzwidth="0x20" edc:desc="This is the Starting Address for the DMA access into the memory space (Read from this address on Tx). This address is updated by the transfer size based on the Local DMA Access Size after every access."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="QMSPI1" edc:cname="LDMA_TX0LDMA_TX_LEN" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x40070348">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="QMSPI1">
            <edc:SFRFieldDef edc:cname="TX_LEN" edc:nzwidth="0x20" edc:desc="This is the maximum Length of the transfer in Bytes that the DMA Channel will allow access to."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="QMSPI1" edc:cname="LDMA_TX0RSVD" edc:nzwidth="0x20" edc:access="rrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrr" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x4007034C"/>
      <edc:SFRDef ltx:memberofperipheral="QMSPI1" edc:cname="LDMA_TX1LDMA_TXCTRL" edc:nzwidth="0x20" edc:access="-------------------------nnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x7F" edc:_addr="0x40070350">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="QMSPI1">
            <edc:SFRFieldDef edc:cname="CH_EN" edc:nzwidth="0x1" edc:desc="This enables the Local TX DMA Channel."/>
            <edc:SFRFieldDef edc:cname="RSTRT_EN" edc:nzwidth="0x1" edc:desc="This bit automatically re-enables the Local DMA Channel after completion of previous transfer."/>
            <edc:SFRFieldDef edc:cname="BUF_ADDR_EN" edc:nzwidth="0x1" edc:desc="Address re-enable will automatically re-enables the same address upon completion previous transfer."/>
            <edc:SFRFieldDef edc:cname="OVRD_LEN" edc:nzwidth="0x1" edc:desc="Override Lenght will override the length field to the QMSPI protocol FSM with the length programmed into the Local DMA."/>
            <edc:SFRFieldDef edc:cname="ACS_SZ" edc:nzwidth="0x2" edc:desc="Access Size selects the AHB Access Size."/>
            <edc:SFRFieldDef edc:cname="INC_ADDR_EN" edc:nzwidth="0x1" edc:desc="When set, the DMA Channels Start Address will increment on every access. If not set the address will not increment."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="QMSPI1" edc:cname="LDMA_TX1LDMA_TXSTRT_ADDR" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x40070354">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="QMSPI1">
            <edc:SFRFieldDef edc:cname="STRT_ADDR" edc:nzwidth="0x20" edc:desc="This is the Starting Address for the DMA access into the memory space (Read from this address on Tx). This address is updated by the transfer size based on the Local DMA Access Size after every access."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="QMSPI1" edc:cname="LDMA_TX1LDMA_TX_LEN" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x40070358">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="QMSPI1">
            <edc:SFRFieldDef edc:cname="TX_LEN" edc:nzwidth="0x20" edc:desc="This is the maximum Length of the transfer in Bytes that the DMA Channel will allow access to."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="QMSPI1" edc:cname="LDMA_TX1RSVD" edc:nzwidth="0x20" edc:access="rrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrr" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x4007035C"/>
      <edc:SFRDef ltx:memberofperipheral="QMSPI1" edc:cname="LDMA_TX2LDMA_TXCTRL" edc:nzwidth="0x20" edc:access="-------------------------nnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x7F" edc:_addr="0x40070360">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="QMSPI1">
            <edc:SFRFieldDef edc:cname="CH_EN" edc:nzwidth="0x1" edc:desc="This enables the Local TX DMA Channel."/>
            <edc:SFRFieldDef edc:cname="RSTRT_EN" edc:nzwidth="0x1" edc:desc="This bit automatically re-enables the Local DMA Channel after completion of previous transfer."/>
            <edc:SFRFieldDef edc:cname="BUF_ADDR_EN" edc:nzwidth="0x1" edc:desc="Address re-enable will automatically re-enables the same address upon completion previous transfer."/>
            <edc:SFRFieldDef edc:cname="OVRD_LEN" edc:nzwidth="0x1" edc:desc="Override Lenght will override the length field to the QMSPI protocol FSM with the length programmed into the Local DMA."/>
            <edc:SFRFieldDef edc:cname="ACS_SZ" edc:nzwidth="0x2" edc:desc="Access Size selects the AHB Access Size."/>
            <edc:SFRFieldDef edc:cname="INC_ADDR_EN" edc:nzwidth="0x1" edc:desc="When set, the DMA Channels Start Address will increment on every access. If not set the address will not increment."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="QMSPI1" edc:cname="LDMA_TX2LDMA_TXSTRT_ADDR" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x40070364">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="QMSPI1">
            <edc:SFRFieldDef edc:cname="STRT_ADDR" edc:nzwidth="0x20" edc:desc="This is the Starting Address for the DMA access into the memory space (Read from this address on Tx). This address is updated by the transfer size based on the Local DMA Access Size after every access."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="QMSPI1" edc:cname="LDMA_TX2LDMA_TX_LEN" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x40070368">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="QMSPI1">
            <edc:SFRFieldDef edc:cname="TX_LEN" edc:nzwidth="0x20" edc:desc="This is the maximum Length of the transfer in Bytes that the DMA Channel will allow access to."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="QMSPI1" edc:cname="LDMA_TX2RSVD" edc:nzwidth="0x20" edc:access="rrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrr" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x4007036C"/>
    </edc:SFRDataSector>
    <edc:SFRDataSector edc:regionid="GPIO_REGISTERS" edc:beginaddr="0x40080000" edc:endaddr="0x40082054" edc:rw="rw">
      <edc:AdjustPoint edc:offset="0x104" edc:_addr="0x40080000"/>
      <edc:SFRDef ltx:memberofperipheral="PCR" edc:cname="PROC_CLK_CTRL" edc:nzwidth="0x20" edc:access="------------------------nnnnnnnn" edc:por="00000000000000000000000000000100" edc:mclr="00000000000000000000000000000100" edc:impl="0xFF" edc:_addr="0x40080104">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="PCR">
            <edc:SFRFieldDef edc:cname="DIV" edc:nzwidth="0x8" edc:desc="Selects the EC clock rate">
              <edc:SFRFieldSemantic edc:cname="DIVIDE_BY_1" edc:desc="Divide 96 MHz clock by 1 (96 MHz Processor Clock)" edc:when="(field &amp; 0xFF) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="DIVIDE_BY_2" edc:desc="Divide 96 MHz clock by 2 (48 MHz Processor Clock)" edc:when="(field &amp; 0xFF) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="DIVIDE_BY_4" edc:desc="Divide 96 MHz clock by 4 (24 MHz Processor Clock)" edc:when="(field &amp; 0xFF) == 0x04"/>
              <edc:SFRFieldSemantic edc:cname="DIVIDE_BY_16" edc:desc="Divide 96 MHz clock by 16 (6 MHz Processor Clock)" edc:when="(field &amp; 0xFF) == 0x10"/>
              <edc:SFRFieldSemantic edc:cname="DIVIDE_BY_48" edc:desc="Divide 96 MHz clock by 48 (2 MHz Processor Clock)" edc:when="(field &amp; 0xFF) == 0x30"/>
            </edc:SFRFieldDef>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="PCR" edc:cname="SLOW_CLK_CTRL" edc:nzwidth="0x20" edc:access="----------------------nnnnnnnnnn" edc:por="00000000000000000000000111100000" edc:mclr="00000000000000000000000111100000" edc:impl="0x3FF" edc:_addr="0x40080108">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="PCR">
            <edc:SFRFieldDef edc:cname="DIV" edc:nzwidth="0xA" edc:desc="SLOW_CLOCK_DIVIDE. n=Divide by n; 0=Clock off"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="PCR" edc:cname="OSC_ID" edc:nzwidth="0x20" edc:access="-----------------------nnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x1FF" edc:_addr="0x4008010C">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="PCR">
            <edc:SFRFieldDef edc:cname="TEST" edc:nzwidth="0x8" edc:desc="Test bits"/>
            <edc:SFRFieldDef edc:cname="PLL_LOCK" edc:nzwidth="0x1" edc:desc="PLL Lock Status"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="PCR" edc:cname="PWR_RST_STS" edc:nzwidth="0x20" edc:access="--------------------nn-nnnnnnn--" edc:por="00000000000000000000000001010000" edc:mclr="00000000000000000000000001010000" edc:impl="0xDFC" edc:_addr="0x40080110">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="PCR">
            <edc:AdjustPoint edc:offset="0x2"/>
            <edc:SFRFieldDef edc:cname="VCC_PWRGD_STS" edc:nzwidth="0x1" edc:desc="Indicates the status of VCC_PWRGD. 0 = PWRGD not asserted. 1 = PWRGD asserte."/>
            <edc:SFRFieldDef edc:cname="RST_H_STS" edc:nzwidth="0x1" edc:desc="Indicates the status of RESET_VCC. 0 = reset active. 1 = reset not active."/>
            <edc:SFRFieldDef edc:cname="RST_VTR_STS" edc:nzwidth="0x1" edc:desc="Indicates the status of RESET_VTR. 0 = reset active. 1 = reset not active.(R/W1C)"/>
            <edc:SFRFieldDef edc:cname="VBAT_RST_STS" edc:nzwidth="0x1" edc:desc="VBAT reset status 0 = No reset occurred while VTR was off or since the last time this bit was cleared. 1 = A reset occurred.(R/WC)"/>
            <edc:SFRFieldDef edc:cname="RST_SYS_STS" edc:nzwidth="0x1" edc:desc="Indicates the status of RESET_SYS.(R/W1C)                0 = No reset occurred since the last time this bit was cleared.                1 = A reset occurred."/>
            <edc:SFRFieldDef edc:cname="JTAG_RST_STS" edc:nzwidth="0x1" edc:desc="Indicates status of JTAG_TRST# pin.                0 = No JTAG reset occurred since the last time this bit was cleared.                1 = A reset occurred because of a JTAG command."/>
            <edc:SFRFieldDef edc:cname="WDT_EVENT" edc:nzwidth="0x1" edc:desc="Indicates that a WDT_EVENT happened. (R/W1C)                0 = Not active.                1 = A WDT_EVENT occured."/>
            <edc:AdjustPoint edc:offset="0x1"/>
            <edc:SFRFieldDef edc:cname="ACTIVE_32K" edc:nzwidth="0x1" edc:desc="32K ACTIVE (ACTIVE_32K)"/>
            <edc:SFRFieldDef edc:cname="PCICLK_ACTIVE" edc:nzwidth="0x1" edc:desc="PCICLK_ACTIVE (PCICLK_ACTIVE)"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:AdjustPoint edc:offset="0x4" edc:_addr="0x40080114"/>
      <edc:SFRDef ltx:memberofperipheral="PCR" edc:cname="SYS_RST" edc:nzwidth="0x20" edc:access="-----------------------n--------" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x100" edc:_addr="0x40080118">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="PCR">
            <edc:AdjustPoint edc:offset="0x8"/>
            <edc:SFRFieldDef edc:cname="SOFT_SYS_RST" edc:nzwidth="0x1" edc:desc="A write of a 1 forces an assertion of the RESET_SYS reset signal, resetting the device. A write of 0 has no effect."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:AdjustPoint edc:offset="0x8" edc:_addr="0x4008011C"/>
      <edc:SFRDef ltx:memberofperipheral="PCR" edc:cname="PRIV_EN_LOCK" edc:nzwidth="0x20" edc:access="-------------------------------n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x1" edc:_addr="0x40080124">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="PCR">
            <edc:SFRFieldDef edc:cname="LOCK_EN" edc:nzwidth="0x1" edc:desc="Peripheral Privilege Lock Register. 1=Locked, 0=Unlocked. Locks Itself and CHIP_PRIV_EN, EC_PRIV_EN,           EC_PRIV_EN2, EC_PRIV_EN3, HOST_PRIV_EN registers"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:AdjustPoint edc:offset="0x8" edc:_addr="0x40080128"/>
      <edc:SFRDef ltx:memberofperipheral="PCR" edc:cname="SLP_EN_0" edc:nzwidth="0x20" edc:access="------------------------nnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0xFF" edc:_addr="0x40080130">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="PCR">
            <edc:SFRFieldDef edc:cname="STAP_SLP_EN" edc:nzwidth="0x1" edc:desc="STAP Sleep Enable"/>
            <edc:SFRFieldDef edc:cname="OTP_SLP_EN" edc:nzwidth="0x1" edc:desc="OTP Sleep Enable"/>
            <edc:SFRFieldDef edc:cname="IMSPI_SLP_EN" edc:nzwidth="0x1" edc:desc="IMSPI Sleep Enable"/>
            <edc:SFRFieldDef edc:cname="CHPTST_SLP_EN" edc:nzwidth="0x1" edc:desc="Chip Test Sleep Enable"/>
            <edc:SFRFieldDef edc:cname="HRBNK_SLP_EN" edc:nzwidth="0x1" edc:desc="Host Register Bank Sleep Enable"/>
            <edc:SFRFieldDef edc:cname="TSTSPI_SLP_EN" edc:nzwidth="0x1" edc:desc="Test SPI Sleep Enable"/>
            <edc:SFRFieldDef edc:cname="GPIO_SLP_EN" edc:nzwidth="0x1" edc:desc="GPIO Sleep Enable"/>
            <edc:SFRFieldDef edc:cname="PCR_SLP_EN" edc:nzwidth="0x1" edc:desc="PCR Sleep Enable"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="PCR" edc:cname="SLP_EN_1" edc:nzwidth="0x20" edc:access="nnn------------------nnnnnnn---n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0xE00007F1" edc:_addr="0x40080134">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="PCR">
            <edc:SFRFieldDef edc:cname="INT_SLP_EN" edc:nzwidth="0x1" edc:desc="Interrupt Sleep Enable"/>
            <edc:AdjustPoint edc:offset="0x3"/>
            <edc:SFRFieldDef edc:cname="PWM0_SLP_EN" edc:nzwidth="0x1" edc:desc="PWM0 Sleep Enable (PWM0_SLP_EN)"/>
            <edc:SFRFieldDef edc:cname="PMC_SLP_EN" edc:nzwidth="0x1" edc:desc="PMC Sleep Enable (PMC_SLP_EN)"/>
            <edc:SFRFieldDef edc:cname="DMA_SLP_EN" edc:nzwidth="0x1" edc:desc="DMA Sleep Enable (DMA_SLP_EN)"/>
            <edc:SFRFieldDef edc:cname="TFDP_SLP_EN" edc:nzwidth="0x1" edc:desc="TFDP Sleep Enable (TFDP_SLP_EN)"/>
            <edc:SFRFieldDef edc:cname="PROC_SLP_EN" edc:nzwidth="0x1" edc:desc="PROCESSOR Sleep Enable (PROCESSOR_SLP_EN)"/>
            <edc:SFRFieldDef edc:cname="WDT_SLP_EN" edc:nzwidth="0x1" edc:desc="Watch Dog Sleep Enable (WDT_SLP_EN)"/>
            <edc:SFRFieldDef edc:cname="SMB0_SLP_EN" edc:nzwidth="0x1" edc:desc="SMB0 Sleep Enable (SMB0_SLP_EN)"/>
            <edc:AdjustPoint edc:offset="0x12"/>
            <edc:SFRFieldDef edc:cname="EC_REG_BANK_SLP_EN" edc:nzwidth="0x1" edc:desc="EC Register Bank Sleep Enable (EC_REG_BANK_SLP_EN)"/>
            <edc:SFRFieldDef edc:cname="TMR32_0_SLP_EN" edc:nzwidth="0x1" edc:desc="TIMER32_0 Sleep Enable (TIMER32_0_SLP_EN)"/>
            <edc:SFRFieldDef edc:cname="TMR32_1_SLP_EN" edc:nzwidth="0x1" edc:desc="TIMER32_1 Sleep Enable (TIMER32_1_SLP_EN)"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:AdjustPoint edc:offset="0x4" edc:_addr="0x40080138"/>
      <edc:SFRDef ltx:memberofperipheral="PCR" edc:cname="SLP_EN_3" edc:nzwidth="0x20" edc:access="-nn--n-----n--nnnnn--n----------" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x6413E400" edc:_addr="0x4008013C">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="PCR">
            <edc:AdjustPoint edc:offset="0xA"/>
            <edc:SFRFieldDef edc:cname="HTM_0_SLP_EN" edc:nzwidth="0x1" edc:desc="Hibernation Timer 0 Sleep Enable (HTM_0_SLP_EN)"/>
            <edc:AdjustPoint edc:offset="0x2"/>
            <edc:SFRFieldDef edc:cname="SMB1_SLP_EN" edc:nzwidth="0x1" edc:desc="SMB1 Sleep Enable (SMB1_SLP_EN)"/>
            <edc:SFRFieldDef edc:cname="SMB2_SLP_EN" edc:nzwidth="0x1" edc:desc="SMB2 Sleep Enable (SMB2_SLP_EN)"/>
            <edc:SFRFieldDef edc:cname="SMB3_SLP_EN" edc:nzwidth="0x1" edc:desc="SMB3 Sleep Enable (SMB3_SLP_EN)"/>
            <edc:SFRFieldDef edc:cname="LED0_SLP_EN" edc:nzwidth="0x1" edc:desc="LED0 Sleep Enable (LED0_SLP_EN)"/>
            <edc:SFRFieldDef edc:cname="LED1_SLP_EN" edc:nzwidth="0x1" edc:desc="LED1 Sleep Enable (LED1_SLP_EN)"/>
            <edc:AdjustPoint edc:offset="0x2"/>
            <edc:SFRFieldDef edc:cname="SMB4_SLP_EN" edc:nzwidth="0x1" edc:desc="SMB4 Sleep Enable (SMB4_SLP_EN)"/>
            <edc:AdjustPoint edc:offset="0x5"/>
            <edc:SFRFieldDef edc:cname="CRYPTO_SLP_EN" edc:nzwidth="0x1" edc:desc="CRYPTO Sleep Enable"/>
            <edc:AdjustPoint edc:offset="0x2"/>
            <edc:SFRFieldDef edc:cname="HTM_1_SLP_EN" edc:nzwidth="0x1" edc:desc="Hibernation TIMER 1 Sleep Enable (HTM_1_SLP_EN)"/>
            <edc:SFRFieldDef edc:cname="CCT_SLP_EN" edc:nzwidth="0x1" edc:desc="Capture Compare Timer Sleep Enable (CCTIMER_SLP_EN)"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="PCR" edc:cname="SLP_EN_4" edc:nzwidth="0x20" edc:access="--------nnn----n------nn-n----nn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0xE10343" edc:_addr="0x40080140">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="PCR">
            <edc:SFRFieldDef edc:cname="SECMON0_SLP_EN" edc:nzwidth="0x1" edc:desc="SPI Monitor 0 Sleep Enable (SECMON0_SLP_EN)"/>
            <edc:SFRFieldDef edc:cname="SECMON1_SLP_EN" edc:nzwidth="0x1" edc:desc="SPI Monitor 1 Sleep Enable (SECMON1_SLP_EN)"/>
            <edc:AdjustPoint edc:offset="0x4"/>
            <edc:SFRFieldDef edc:cname="RTOS_SLP_EN" edc:nzwidth="0x1" edc:desc="RTOS Sleep Enable (RTOS_SLP_EN)"/>
            <edc:AdjustPoint edc:offset="0x1"/>
            <edc:SFRFieldDef edc:cname="QMSPI0_SLP_EN" edc:nzwidth="0x1" edc:desc="Quad Master SPI 0 Sleep Enable (QMSPI_1_SLP_EN)"/>
            <edc:SFRFieldDef edc:cname="UART0_SLP_EN" edc:nzwidth="0x1" edc:desc="UART0 Sleep Enable (UART_1_SLP_EN)"/>
            <edc:AdjustPoint edc:offset="0x6"/>
            <edc:SFRFieldDef edc:cname="SPIPER0_SLP_EN" edc:nzwidth="0x1" edc:desc="SPI Peropheral 0 Sleep Enable (SPIPER0_SLP_EN)"/>
            <edc:AdjustPoint edc:offset="0x4"/>
            <edc:SFRFieldDef edc:cname="SPIPER1_SLP_EN" edc:nzwidth="0x1" edc:desc="SPI Peropheral 1 Sleep Enable (SPIPER1_SLP_EN)"/>
            <edc:SFRFieldDef edc:cname="QMSPI_1_SLP_EN" edc:nzwidth="0x1" edc:desc="QMSPI 1 Sleep Enable (QMSPI_1_SLP_EN)"/>
            <edc:SFRFieldDef edc:cname="VBAT_REG_SLP_EN" edc:nzwidth="0x1" edc:desc="VBAT REG Sleep Enable (VBAT_REG_SLP_EN)"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:AdjustPoint edc:offset="0x2C" edc:_addr="0x40080144"/>
      <edc:SFRDef ltx:memberofperipheral="PCR" edc:cname="RST_EN_0" edc:nzwidth="0x20" edc:access="------------------------nnn-n-nn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0xEB" edc:_addr="0x40080170">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="PCR">
            <edc:SFRFieldDef edc:cname="JTAG_STAP_CLK_REQ" edc:nzwidth="0x1" edc:desc="JTAG STAP Enable"/>
            <edc:SFRFieldDef edc:cname="OTP_RST_EN" edc:nzwidth="0x1" edc:desc="OTP Reset Enable"/>
            <edc:AdjustPoint edc:offset="0x1"/>
            <edc:SFRFieldDef edc:cname="CHPTST_RST_EN" edc:nzwidth="0x1" edc:desc="Chip Test Reset Enable"/>
            <edc:AdjustPoint edc:offset="0x1"/>
            <edc:SFRFieldDef edc:cname="TSTSPI_RST_EN" edc:nzwidth="0x1" edc:desc="Test SPI Reset Enable"/>
            <edc:SFRFieldDef edc:cname="GPIO_RST_EN" edc:nzwidth="0x1" edc:desc="GPIO Reset Enable"/>
            <edc:SFRFieldDef edc:cname="PCR_RST_EN" edc:nzwidth="0x1" edc:desc="PCR Reset Enable"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="PCR" edc:cname="RST_EN_1" edc:nzwidth="0x20" edc:access="nn-------------------nn-nn-n---n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0xC00006D1" edc:_addr="0x40080174">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="PCR">
            <edc:SFRFieldDef edc:cname="INT_RST_EN" edc:nzwidth="0x1" edc:desc="Interrupt Reset Enable"/>
            <edc:AdjustPoint edc:offset="0x3"/>
            <edc:SFRFieldDef edc:cname="PWM0_RST_EN" edc:nzwidth="0x1" edc:desc="PWM0 Reset Enable (PWM0_RST_EN)"/>
            <edc:AdjustPoint edc:offset="0x1"/>
            <edc:SFRFieldDef edc:cname="DMA_RST_EN" edc:nzwidth="0x1" edc:desc="DMA Reset Enable (DMA_RST_EN)"/>
            <edc:SFRFieldDef edc:cname="TFDP_RST_EN" edc:nzwidth="0x1" edc:desc="TFDP Reset Enable (TFDP_RST_EN)"/>
            <edc:AdjustPoint edc:offset="0x1"/>
            <edc:SFRFieldDef edc:cname="WDT_RST_EN" edc:nzwidth="0x1" edc:desc="WDT Reset Enable (WDT_RST_EN)"/>
            <edc:SFRFieldDef edc:cname="SMB0_RST_EN" edc:nzwidth="0x1" edc:desc="SMB0 Reset Enable (SMB0_RST_EN)"/>
            <edc:AdjustPoint edc:offset="0x13"/>
            <edc:SFRFieldDef edc:cname="TMR32_0_RST_EN" edc:nzwidth="0x1" edc:desc="TIMER32_0 Reset Enable (TIMER32_0_RST_EN)"/>
            <edc:SFRFieldDef edc:cname="TMR32_1_RST_EN" edc:nzwidth="0x1" edc:desc="TIMER32_1 Reset Enable (TIMER32_1_RST_EN)"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:AdjustPoint edc:offset="0x4" edc:_addr="0x40080178"/>
      <edc:SFRDef ltx:memberofperipheral="PCR" edc:cname="RST_EN_3" edc:nzwidth="0x20" edc:access="-nn--n-----n--nnnnn--n----------" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x6413E400" edc:_addr="0x4008017C">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="PCR">
            <edc:AdjustPoint edc:offset="0xA"/>
            <edc:SFRFieldDef edc:cname="HTM_0_RST_EN" edc:nzwidth="0x1" edc:desc="Hibernation TIMER 0 Reset Enable (HTM_0_RST_EN)"/>
            <edc:AdjustPoint edc:offset="0x2"/>
            <edc:SFRFieldDef edc:cname="SMB1_RST_EN" edc:nzwidth="0x1" edc:desc="SMB1 Reset Enable (SMB1_RST_EN)"/>
            <edc:SFRFieldDef edc:cname="SMB2_RST_EN" edc:nzwidth="0x1" edc:desc="SMB2 Reset Enable (SMB2_RST_EN)"/>
            <edc:SFRFieldDef edc:cname="SMB3_RST_EN" edc:nzwidth="0x1" edc:desc="SMB3 Reset Enable (SMB3_RST_EN)"/>
            <edc:SFRFieldDef edc:cname="LED0_RST_EN" edc:nzwidth="0x1" edc:desc="LED0 Reset Enable (LED0_RST_EN)"/>
            <edc:SFRFieldDef edc:cname="LED1_RST_EN" edc:nzwidth="0x1" edc:desc="LED1 Reset Enable (LED1_RST_EN)"/>
            <edc:AdjustPoint edc:offset="0x2"/>
            <edc:SFRFieldDef edc:cname="SMB_4_RST_EN" edc:nzwidth="0x1" edc:desc="SMB 4 Reset Enable (SMB_4_RST_EN)"/>
            <edc:AdjustPoint edc:offset="0x5"/>
            <edc:SFRFieldDef edc:cname="CRYPTO_RST_EN" edc:nzwidth="0x1" edc:desc="CRYPTO Reset Enable"/>
            <edc:AdjustPoint edc:offset="0x2"/>
            <edc:SFRFieldDef edc:cname="HTM_1_RST_EN" edc:nzwidth="0x1" edc:desc="Hibernation TIMER 1 Reset Enable (HTM_1_RST_EN)"/>
            <edc:SFRFieldDef edc:cname="CCTIMER_RST_EN" edc:nzwidth="0x1" edc:desc="Capture Compare Timer Reset Enable (CCTIMER_RST_EN)"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="PCR" edc:cname="RST_EN_4" edc:nzwidth="0x20" edc:access="--------nnn----n------nn-n----nn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0xE10343" edc:_addr="0x40080180">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="PCR">
            <edc:SFRFieldDef edc:cname="SECMON0_RST_EN" edc:nzwidth="0x1" edc:desc="SPI Monitor 0 Reset Enable (SECMON0_RST_EN)"/>
            <edc:SFRFieldDef edc:cname="SECMON1_RST_EN" edc:nzwidth="0x1" edc:desc="SPI Monitor 1 Reset Enable (SECMON1_RST_EN)"/>
            <edc:AdjustPoint edc:offset="0x4"/>
            <edc:SFRFieldDef edc:cname="RTOS_RST_EN" edc:nzwidth="0x1" edc:desc="RTOS Reset Enable (RTOS_RST_EN)"/>
            <edc:AdjustPoint edc:offset="0x1"/>
            <edc:SFRFieldDef edc:cname="QMSPI0_RST_EN" edc:nzwidth="0x1" edc:desc="Quad Master SPI 0 Reset Enable (QMSPI_1_RST_EN)"/>
            <edc:SFRFieldDef edc:cname="UART0_RST_EN" edc:nzwidth="0x1" edc:desc="UART0 Reset Enable (UART_0_RST_EN)"/>
            <edc:AdjustPoint edc:offset="0x6"/>
            <edc:SFRFieldDef edc:cname="SPIPER0_RST_EN" edc:nzwidth="0x1" edc:desc="SPI Peropheral 0 Reset Enable (SPIPER0_RST_EN)"/>
            <edc:AdjustPoint edc:offset="0x4"/>
            <edc:SFRFieldDef edc:cname="SPIPER1_RST_EN" edc:nzwidth="0x1" edc:desc="SPI Peropheral 1 Reset Enable (SPIPER1_RST_EN)"/>
            <edc:SFRFieldDef edc:cname="QMSPI_1_RST_EN" edc:nzwidth="0x1" edc:desc="QMSPI 1 Reset Enable (QMSPI_1_RST_EN)"/>
            <edc:SFRFieldDef edc:cname="VBAT_REG_RST_EN" edc:nzwidth="0x1" edc:desc="VBAT REG Reset Enable (VBAT_REG_RST_EN)"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="PCR" edc:cname="PERIPH_RST_EN_LOCK" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="10100110001110000010110101001101" edc:mclr="10100110001110000010110101001101" edc:_addr="0x40080184">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="PCR">
            <edc:SFRFieldDef edc:cname="EN" edc:nzwidth="0x20" edc:desc="PCR Reset Enable Lock Register."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:AdjustPoint edc:offset="0x68" edc:_addr="0x40080188"/>
      <edc:SFRDef ltx:memberofperipheral="PCR" edc:cname="EC_PRIV_EN0" edc:nzwidth="0x20" edc:access="------------------------nnnn--n-" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0xF2" edc:_addr="0x400801F0">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="PCR">
            <edc:AdjustPoint edc:offset="0x1"/>
            <edc:SFRFieldDef edc:cname="OTP" edc:nzwidth="0x1" edc:desc="OTP Privilege Enable."/>
            <edc:AdjustPoint edc:offset="0x2"/>
            <edc:SFRFieldDef edc:cname="HOST_REG" edc:nzwidth="0x1" edc:desc="Host Register Bank Privilege Enable."/>
            <edc:SFRFieldDef edc:cname="TST_SPI" edc:nzwidth="0x1" edc:desc="Test SPI Privilege Enable."/>
            <edc:SFRFieldDef edc:cname="GPIO" edc:nzwidth="0x1" edc:desc="GPIO Privilege Enable."/>
            <edc:SFRFieldDef edc:cname="PCR" edc:nzwidth="0x1" edc:desc="PCR Privilege Enable."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="PCR" edc:cname="EC_PRIV_EN1" edc:nzwidth="0x20" edc:access="nnn------------------nn-nnnn---n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0xE00006F1" edc:_addr="0x400801F4">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="PCR">
            <edc:SFRFieldDef edc:cname="INTR" edc:nzwidth="0x1" edc:desc="Interrupt Privilege Enable."/>
            <edc:AdjustPoint edc:offset="0x3"/>
            <edc:SFRFieldDef edc:cname="PWM0" edc:nzwidth="0x1" edc:desc="PWM 0 Privilege Enable."/>
            <edc:SFRFieldDef edc:cname="PMC" edc:nzwidth="0x1" edc:desc="PMC Privilege Enable."/>
            <edc:SFRFieldDef edc:cname="DMA" edc:nzwidth="0x1" edc:desc="DMA Privilege Enable."/>
            <edc:SFRFieldDef edc:cname="TFDP" edc:nzwidth="0x1" edc:desc="TFDP Privilege Enable."/>
            <edc:AdjustPoint edc:offset="0x1"/>
            <edc:SFRFieldDef edc:cname="WDT" edc:nzwidth="0x1" edc:desc="WDT Privilege Enable."/>
            <edc:SFRFieldDef edc:cname="SMB_I2C0" edc:nzwidth="0x1" edc:desc="SMB I2C 0 Privilege Enable."/>
            <edc:AdjustPoint edc:offset="0x12"/>
            <edc:SFRFieldDef edc:cname="EC_REGS" edc:nzwidth="0x1" edc:desc="EC Registers Privilege Enable."/>
            <edc:SFRFieldDef edc:cname="BASIC_TMR0" edc:nzwidth="0x1" edc:desc="Basic Timer 0 Privilege Enable."/>
            <edc:SFRFieldDef edc:cname="BASIC_TMR1" edc:nzwidth="0x1" edc:desc="Basic Timer 1 Privilege Enable."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="PCR" edc:cname="EC_PRIV_EN3" edc:nzwidth="0x20" edc:access="-nn--n-----n--nnnnn--n----------" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x6413E400" edc:_addr="0x400801F8">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="PCR">
            <edc:AdjustPoint edc:offset="0xA"/>
            <edc:SFRFieldDef edc:cname="HIB_TIM0" edc:nzwidth="0x1" edc:desc="Hibernation TIMER 0 Privilege Enable."/>
            <edc:AdjustPoint edc:offset="0x2"/>
            <edc:SFRFieldDef edc:cname="SMB_I2C1" edc:nzwidth="0x1" edc:desc="SMB I2C 1 Privilege Enable."/>
            <edc:SFRFieldDef edc:cname="SMB_I2C2" edc:nzwidth="0x1" edc:desc="SMB I2C 2 Privilege Enable."/>
            <edc:SFRFieldDef edc:cname="SMB_I2C3" edc:nzwidth="0x1" edc:desc="SMB I2C 3 Privilege Enable."/>
            <edc:SFRFieldDef edc:cname="LED0" edc:nzwidth="0x1" edc:desc="LED 0 Privilege Enable."/>
            <edc:SFRFieldDef edc:cname="LED1" edc:nzwidth="0x1" edc:desc="LED 1 Privilege Enable."/>
            <edc:AdjustPoint edc:offset="0x2"/>
            <edc:SFRFieldDef edc:cname="SMB_I2C4" edc:nzwidth="0x1" edc:desc="SMB I2C 4 Privilege Enable."/>
            <edc:AdjustPoint edc:offset="0x5"/>
            <edc:SFRFieldDef edc:cname="CRYPTO" edc:nzwidth="0x1" edc:desc="Crypto Privilege Enable."/>
            <edc:AdjustPoint edc:offset="0x2"/>
            <edc:SFRFieldDef edc:cname="HIB_TIM1" edc:nzwidth="0x1" edc:desc="Hibernation Timer 1 Privilege Enable."/>
            <edc:SFRFieldDef edc:cname="CCT0" edc:nzwidth="0x1" edc:desc="Capture Compare Timer Privilege Enable."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="PCR" edc:cname="EC_PRIV_EN4" edc:nzwidth="0x20" edc:access="--------nnn----n------nn-n----nn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0xE10343" edc:_addr="0x400801FC">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="PCR">
            <edc:SFRFieldDef edc:cname="SPIMON0" edc:nzwidth="0x1" edc:desc="SPI Monitor 0 Privilege Enable."/>
            <edc:SFRFieldDef edc:cname="SPIMON1" edc:nzwidth="0x1" edc:desc="SPI Monitor 1 Privilege Enable."/>
            <edc:AdjustPoint edc:offset="0x4"/>
            <edc:SFRFieldDef edc:cname="RTOS_TIM" edc:nzwidth="0x1" edc:desc="RTOS Timer Privilege Enable."/>
            <edc:AdjustPoint edc:offset="0x1"/>
            <edc:SFRFieldDef edc:cname="QMSPI0" edc:nzwidth="0x1" edc:desc="QMSPI 0 Privilege Enable."/>
            <edc:SFRFieldDef edc:cname="UART0" edc:nzwidth="0x1" edc:desc="UART 0 Privilege Enable."/>
            <edc:AdjustPoint edc:offset="0x6"/>
            <edc:SFRFieldDef edc:cname="SPISLV0" edc:nzwidth="0x1" edc:desc="SPISLV 0 Privilege Enable."/>
            <edc:AdjustPoint edc:offset="0x4"/>
            <edc:SFRFieldDef edc:cname="SPISLV1" edc:nzwidth="0x1" edc:desc="SPISLV 1 Privilege Enable."/>
            <edc:SFRFieldDef edc:cname="QMSPI1" edc:nzwidth="0x1" edc:desc="QMSPI 1 Privilege Enable."/>
            <edc:SFRFieldDef edc:cname="VBAT_REG" edc:nzwidth="0x1" edc:desc="VBAT Register Privilege Enable."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:AdjustPoint edc:offset="0xE00" edc:_addr="0x40080200"/>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL00" edc:nzwidth="0x20" edc:access="-------n-------nnnnnnnnnnnnnnnnn" edc:por="00000000000000001000000001000000" edc:mclr="00000000000000001000000001000000" edc:impl="0x101FFFF" edc:_addr="0x40081000">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="PU_PD" edc:nzwidth="0x2" edc:desc="These bits are used to enable an internal pull-up or pull-down resistor.">
              <edc:SFRFieldSemantic edc:cname="NONE" edc:desc="None. Pin tristates when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="UP" edc:desc="Pull Up Enabled" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="DOWN" edc:desc="Pull Down Enabled" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="REPEATER" edc:desc="Repeater mode. Pin is kept at previous voltage level when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="PWR_GATING" edc:nzwidth="0x2" edc:desc="The GPIO pin will be tristated when the selected power well is off."/>
            <edc:SFRFieldDef edc:cname="INTR_DET" edc:nzwidth="0x3" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="EDGE_EN" edc:nzwidth="0x1" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="OUT_BUFF_TYPE" edc:nzwidth="0x1" edc:desc="0 = Push-Pull, 1 = Open Drain"/>
            <edc:SFRFieldDef edc:cname="GPIO_DIR" edc:nzwidth="0x1" edc:desc="Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output"/>
            <edc:SFRFieldDef edc:cname="GPIO_OUT_SEL" edc:nzwidth="0x1" edc:desc="GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register."/>
            <edc:SFRFieldDef edc:cname="POL" edc:nzwidth="0x1" edc:desc="1=Inverted; 0=Non-inverted"/>
            <edc:SFRFieldDef edc:cname="MUX_CTRL" edc:nzwidth="0x3" edc:desc="00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3.">
              <edc:SFRFieldSemantic edc:cname="GPIO" edc:desc="GPIO function selected" edc:when="(field &amp; 0x7) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="FUNC1" edc:desc="Signal function 1 selected" edc:when="(field &amp; 0x7) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="FUNC2" edc:desc="Signal function 2 selected" edc:when="(field &amp; 0x7) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="FUNC3" edc:desc="Signal function 3 selected" edc:when="(field &amp; 0x7) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="INP_DIS" edc:nzwidth="0x1" edc:desc="GPIO input disable"/>
            <edc:SFRFieldDef edc:cname="ALT_GPIO_DATA" edc:nzwidth="0x1" edc:desc="GPIO Alternate Data Register."/>
            <edc:AdjustPoint edc:offset="0x7"/>
            <edc:SFRFieldDef edc:cname="GPIO_INP" edc:nzwidth="0x1" edc:desc="GPIO input from pin, independent of the Mux selection for the pin or the Direction."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL01" edc:nzwidth="0x20" edc:access="-------n-------nnnnnnnnnnnnnnnnn" edc:por="00000000000000001000000001000000" edc:mclr="00000000000000001000000001000000" edc:impl="0x101FFFF" edc:_addr="0x40081004">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="PU_PD" edc:nzwidth="0x2" edc:desc="These bits are used to enable an internal pull-up or pull-down resistor.">
              <edc:SFRFieldSemantic edc:cname="NONE" edc:desc="None. Pin tristates when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="UP" edc:desc="Pull Up Enabled" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="DOWN" edc:desc="Pull Down Enabled" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="REPEATER" edc:desc="Repeater mode. Pin is kept at previous voltage level when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="PWR_GATING" edc:nzwidth="0x2" edc:desc="The GPIO pin will be tristated when the selected power well is off."/>
            <edc:SFRFieldDef edc:cname="INTR_DET" edc:nzwidth="0x3" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="EDGE_EN" edc:nzwidth="0x1" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="OUT_BUFF_TYPE" edc:nzwidth="0x1" edc:desc="0 = Push-Pull, 1 = Open Drain"/>
            <edc:SFRFieldDef edc:cname="GPIO_DIR" edc:nzwidth="0x1" edc:desc="Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output"/>
            <edc:SFRFieldDef edc:cname="GPIO_OUT_SEL" edc:nzwidth="0x1" edc:desc="GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register."/>
            <edc:SFRFieldDef edc:cname="POL" edc:nzwidth="0x1" edc:desc="1=Inverted; 0=Non-inverted"/>
            <edc:SFRFieldDef edc:cname="MUX_CTRL" edc:nzwidth="0x3" edc:desc="00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3.">
              <edc:SFRFieldSemantic edc:cname="GPIO" edc:desc="GPIO function selected" edc:when="(field &amp; 0x7) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="FUNC1" edc:desc="Signal function 1 selected" edc:when="(field &amp; 0x7) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="FUNC2" edc:desc="Signal function 2 selected" edc:when="(field &amp; 0x7) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="FUNC3" edc:desc="Signal function 3 selected" edc:when="(field &amp; 0x7) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="INP_DIS" edc:nzwidth="0x1" edc:desc="GPIO input disable"/>
            <edc:SFRFieldDef edc:cname="ALT_GPIO_DATA" edc:nzwidth="0x1" edc:desc="GPIO Alternate Data Register."/>
            <edc:AdjustPoint edc:offset="0x7"/>
            <edc:SFRFieldDef edc:cname="GPIO_INP" edc:nzwidth="0x1" edc:desc="GPIO input from pin, independent of the Mux selection for the pin or the Direction."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL02" edc:nzwidth="0x20" edc:access="-------n-------nnnnnnnnnnnnnnnnn" edc:por="00000000000000001000000001000000" edc:mclr="00000000000000001000000001000000" edc:impl="0x101FFFF" edc:_addr="0x40081008">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="PU_PD" edc:nzwidth="0x2" edc:desc="These bits are used to enable an internal pull-up or pull-down resistor.">
              <edc:SFRFieldSemantic edc:cname="NONE" edc:desc="None. Pin tristates when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="UP" edc:desc="Pull Up Enabled" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="DOWN" edc:desc="Pull Down Enabled" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="REPEATER" edc:desc="Repeater mode. Pin is kept at previous voltage level when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="PWR_GATING" edc:nzwidth="0x2" edc:desc="The GPIO pin will be tristated when the selected power well is off."/>
            <edc:SFRFieldDef edc:cname="INTR_DET" edc:nzwidth="0x3" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="EDGE_EN" edc:nzwidth="0x1" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="OUT_BUFF_TYPE" edc:nzwidth="0x1" edc:desc="0 = Push-Pull, 1 = Open Drain"/>
            <edc:SFRFieldDef edc:cname="GPIO_DIR" edc:nzwidth="0x1" edc:desc="Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output"/>
            <edc:SFRFieldDef edc:cname="GPIO_OUT_SEL" edc:nzwidth="0x1" edc:desc="GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register."/>
            <edc:SFRFieldDef edc:cname="POL" edc:nzwidth="0x1" edc:desc="1=Inverted; 0=Non-inverted"/>
            <edc:SFRFieldDef edc:cname="MUX_CTRL" edc:nzwidth="0x3" edc:desc="00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3.">
              <edc:SFRFieldSemantic edc:cname="GPIO" edc:desc="GPIO function selected" edc:when="(field &amp; 0x7) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="FUNC1" edc:desc="Signal function 1 selected" edc:when="(field &amp; 0x7) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="FUNC2" edc:desc="Signal function 2 selected" edc:when="(field &amp; 0x7) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="FUNC3" edc:desc="Signal function 3 selected" edc:when="(field &amp; 0x7) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="INP_DIS" edc:nzwidth="0x1" edc:desc="GPIO input disable"/>
            <edc:SFRFieldDef edc:cname="ALT_GPIO_DATA" edc:nzwidth="0x1" edc:desc="GPIO Alternate Data Register."/>
            <edc:AdjustPoint edc:offset="0x7"/>
            <edc:SFRFieldDef edc:cname="GPIO_INP" edc:nzwidth="0x1" edc:desc="GPIO input from pin, independent of the Mux selection for the pin or the Direction."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL03" edc:nzwidth="0x20" edc:access="-------n-------nnnnnnnnnnnnnnnnn" edc:por="00000000000000001000000001000000" edc:mclr="00000000000000001000000001000000" edc:impl="0x101FFFF" edc:_addr="0x4008100C">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="PU_PD" edc:nzwidth="0x2" edc:desc="These bits are used to enable an internal pull-up or pull-down resistor.">
              <edc:SFRFieldSemantic edc:cname="NONE" edc:desc="None. Pin tristates when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="UP" edc:desc="Pull Up Enabled" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="DOWN" edc:desc="Pull Down Enabled" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="REPEATER" edc:desc="Repeater mode. Pin is kept at previous voltage level when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="PWR_GATING" edc:nzwidth="0x2" edc:desc="The GPIO pin will be tristated when the selected power well is off."/>
            <edc:SFRFieldDef edc:cname="INTR_DET" edc:nzwidth="0x3" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="EDGE_EN" edc:nzwidth="0x1" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="OUT_BUFF_TYPE" edc:nzwidth="0x1" edc:desc="0 = Push-Pull, 1 = Open Drain"/>
            <edc:SFRFieldDef edc:cname="GPIO_DIR" edc:nzwidth="0x1" edc:desc="Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output"/>
            <edc:SFRFieldDef edc:cname="GPIO_OUT_SEL" edc:nzwidth="0x1" edc:desc="GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register."/>
            <edc:SFRFieldDef edc:cname="POL" edc:nzwidth="0x1" edc:desc="1=Inverted; 0=Non-inverted"/>
            <edc:SFRFieldDef edc:cname="MUX_CTRL" edc:nzwidth="0x3" edc:desc="00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3.">
              <edc:SFRFieldSemantic edc:cname="GPIO" edc:desc="GPIO function selected" edc:when="(field &amp; 0x7) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="FUNC1" edc:desc="Signal function 1 selected" edc:when="(field &amp; 0x7) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="FUNC2" edc:desc="Signal function 2 selected" edc:when="(field &amp; 0x7) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="FUNC3" edc:desc="Signal function 3 selected" edc:when="(field &amp; 0x7) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="INP_DIS" edc:nzwidth="0x1" edc:desc="GPIO input disable"/>
            <edc:SFRFieldDef edc:cname="ALT_GPIO_DATA" edc:nzwidth="0x1" edc:desc="GPIO Alternate Data Register."/>
            <edc:AdjustPoint edc:offset="0x7"/>
            <edc:SFRFieldDef edc:cname="GPIO_INP" edc:nzwidth="0x1" edc:desc="GPIO input from pin, independent of the Mux selection for the pin or the Direction."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL04" edc:nzwidth="0x20" edc:access="-------n-------nnnnnnnnnnnnnnnnn" edc:por="00000000000000001000000001000000" edc:mclr="00000000000000001000000001000000" edc:impl="0x101FFFF" edc:_addr="0x40081010">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="PU_PD" edc:nzwidth="0x2" edc:desc="These bits are used to enable an internal pull-up or pull-down resistor.">
              <edc:SFRFieldSemantic edc:cname="NONE" edc:desc="None. Pin tristates when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="UP" edc:desc="Pull Up Enabled" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="DOWN" edc:desc="Pull Down Enabled" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="REPEATER" edc:desc="Repeater mode. Pin is kept at previous voltage level when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="PWR_GATING" edc:nzwidth="0x2" edc:desc="The GPIO pin will be tristated when the selected power well is off."/>
            <edc:SFRFieldDef edc:cname="INTR_DET" edc:nzwidth="0x3" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="EDGE_EN" edc:nzwidth="0x1" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="OUT_BUFF_TYPE" edc:nzwidth="0x1" edc:desc="0 = Push-Pull, 1 = Open Drain"/>
            <edc:SFRFieldDef edc:cname="GPIO_DIR" edc:nzwidth="0x1" edc:desc="Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output"/>
            <edc:SFRFieldDef edc:cname="GPIO_OUT_SEL" edc:nzwidth="0x1" edc:desc="GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register."/>
            <edc:SFRFieldDef edc:cname="POL" edc:nzwidth="0x1" edc:desc="1=Inverted; 0=Non-inverted"/>
            <edc:SFRFieldDef edc:cname="MUX_CTRL" edc:nzwidth="0x3" edc:desc="00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3.">
              <edc:SFRFieldSemantic edc:cname="GPIO" edc:desc="GPIO function selected" edc:when="(field &amp; 0x7) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="FUNC1" edc:desc="Signal function 1 selected" edc:when="(field &amp; 0x7) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="FUNC2" edc:desc="Signal function 2 selected" edc:when="(field &amp; 0x7) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="FUNC3" edc:desc="Signal function 3 selected" edc:when="(field &amp; 0x7) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="INP_DIS" edc:nzwidth="0x1" edc:desc="GPIO input disable"/>
            <edc:SFRFieldDef edc:cname="ALT_GPIO_DATA" edc:nzwidth="0x1" edc:desc="GPIO Alternate Data Register."/>
            <edc:AdjustPoint edc:offset="0x7"/>
            <edc:SFRFieldDef edc:cname="GPIO_INP" edc:nzwidth="0x1" edc:desc="GPIO input from pin, independent of the Mux selection for the pin or the Direction."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL05" edc:nzwidth="0x20" edc:access="-------n-------nnnnnnnnnnnnnnnnn" edc:por="00000000000000001000000001000000" edc:mclr="00000000000000001000000001000000" edc:impl="0x101FFFF" edc:_addr="0x40081014">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="PU_PD" edc:nzwidth="0x2" edc:desc="These bits are used to enable an internal pull-up or pull-down resistor.">
              <edc:SFRFieldSemantic edc:cname="NONE" edc:desc="None. Pin tristates when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="UP" edc:desc="Pull Up Enabled" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="DOWN" edc:desc="Pull Down Enabled" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="REPEATER" edc:desc="Repeater mode. Pin is kept at previous voltage level when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="PWR_GATING" edc:nzwidth="0x2" edc:desc="The GPIO pin will be tristated when the selected power well is off."/>
            <edc:SFRFieldDef edc:cname="INTR_DET" edc:nzwidth="0x3" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="EDGE_EN" edc:nzwidth="0x1" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="OUT_BUFF_TYPE" edc:nzwidth="0x1" edc:desc="0 = Push-Pull, 1 = Open Drain"/>
            <edc:SFRFieldDef edc:cname="GPIO_DIR" edc:nzwidth="0x1" edc:desc="Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output"/>
            <edc:SFRFieldDef edc:cname="GPIO_OUT_SEL" edc:nzwidth="0x1" edc:desc="GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register."/>
            <edc:SFRFieldDef edc:cname="POL" edc:nzwidth="0x1" edc:desc="1=Inverted; 0=Non-inverted"/>
            <edc:SFRFieldDef edc:cname="MUX_CTRL" edc:nzwidth="0x3" edc:desc="00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3.">
              <edc:SFRFieldSemantic edc:cname="GPIO" edc:desc="GPIO function selected" edc:when="(field &amp; 0x7) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="FUNC1" edc:desc="Signal function 1 selected" edc:when="(field &amp; 0x7) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="FUNC2" edc:desc="Signal function 2 selected" edc:when="(field &amp; 0x7) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="FUNC3" edc:desc="Signal function 3 selected" edc:when="(field &amp; 0x7) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="INP_DIS" edc:nzwidth="0x1" edc:desc="GPIO input disable"/>
            <edc:SFRFieldDef edc:cname="ALT_GPIO_DATA" edc:nzwidth="0x1" edc:desc="GPIO Alternate Data Register."/>
            <edc:AdjustPoint edc:offset="0x7"/>
            <edc:SFRFieldDef edc:cname="GPIO_INP" edc:nzwidth="0x1" edc:desc="GPIO input from pin, independent of the Mux selection for the pin or the Direction."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL06" edc:nzwidth="0x20" edc:access="-------n-------nnnnnnnnnnnnnnnnn" edc:por="00000000000000001000000001000000" edc:mclr="00000000000000001000000001000000" edc:impl="0x101FFFF" edc:_addr="0x40081018">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="PU_PD" edc:nzwidth="0x2" edc:desc="These bits are used to enable an internal pull-up or pull-down resistor.">
              <edc:SFRFieldSemantic edc:cname="NONE" edc:desc="None. Pin tristates when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="UP" edc:desc="Pull Up Enabled" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="DOWN" edc:desc="Pull Down Enabled" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="REPEATER" edc:desc="Repeater mode. Pin is kept at previous voltage level when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="PWR_GATING" edc:nzwidth="0x2" edc:desc="The GPIO pin will be tristated when the selected power well is off."/>
            <edc:SFRFieldDef edc:cname="INTR_DET" edc:nzwidth="0x3" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="EDGE_EN" edc:nzwidth="0x1" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="OUT_BUFF_TYPE" edc:nzwidth="0x1" edc:desc="0 = Push-Pull, 1 = Open Drain"/>
            <edc:SFRFieldDef edc:cname="GPIO_DIR" edc:nzwidth="0x1" edc:desc="Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output"/>
            <edc:SFRFieldDef edc:cname="GPIO_OUT_SEL" edc:nzwidth="0x1" edc:desc="GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register."/>
            <edc:SFRFieldDef edc:cname="POL" edc:nzwidth="0x1" edc:desc="1=Inverted; 0=Non-inverted"/>
            <edc:SFRFieldDef edc:cname="MUX_CTRL" edc:nzwidth="0x3" edc:desc="00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3.">
              <edc:SFRFieldSemantic edc:cname="GPIO" edc:desc="GPIO function selected" edc:when="(field &amp; 0x7) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="FUNC1" edc:desc="Signal function 1 selected" edc:when="(field &amp; 0x7) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="FUNC2" edc:desc="Signal function 2 selected" edc:when="(field &amp; 0x7) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="FUNC3" edc:desc="Signal function 3 selected" edc:when="(field &amp; 0x7) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="INP_DIS" edc:nzwidth="0x1" edc:desc="GPIO input disable"/>
            <edc:SFRFieldDef edc:cname="ALT_GPIO_DATA" edc:nzwidth="0x1" edc:desc="GPIO Alternate Data Register."/>
            <edc:AdjustPoint edc:offset="0x7"/>
            <edc:SFRFieldDef edc:cname="GPIO_INP" edc:nzwidth="0x1" edc:desc="GPIO input from pin, independent of the Mux selection for the pin or the Direction."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL07" edc:nzwidth="0x20" edc:access="-------n-------nnnnnnnnnnnnnnnnn" edc:por="00000000000000001000000001000000" edc:mclr="00000000000000001000000001000000" edc:impl="0x101FFFF" edc:_addr="0x4008101C">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="PU_PD" edc:nzwidth="0x2" edc:desc="These bits are used to enable an internal pull-up or pull-down resistor.">
              <edc:SFRFieldSemantic edc:cname="NONE" edc:desc="None. Pin tristates when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="UP" edc:desc="Pull Up Enabled" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="DOWN" edc:desc="Pull Down Enabled" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="REPEATER" edc:desc="Repeater mode. Pin is kept at previous voltage level when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="PWR_GATING" edc:nzwidth="0x2" edc:desc="The GPIO pin will be tristated when the selected power well is off."/>
            <edc:SFRFieldDef edc:cname="INTR_DET" edc:nzwidth="0x3" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="EDGE_EN" edc:nzwidth="0x1" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="OUT_BUFF_TYPE" edc:nzwidth="0x1" edc:desc="0 = Push-Pull, 1 = Open Drain"/>
            <edc:SFRFieldDef edc:cname="GPIO_DIR" edc:nzwidth="0x1" edc:desc="Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output"/>
            <edc:SFRFieldDef edc:cname="GPIO_OUT_SEL" edc:nzwidth="0x1" edc:desc="GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register."/>
            <edc:SFRFieldDef edc:cname="POL" edc:nzwidth="0x1" edc:desc="1=Inverted; 0=Non-inverted"/>
            <edc:SFRFieldDef edc:cname="MUX_CTRL" edc:nzwidth="0x3" edc:desc="00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3.">
              <edc:SFRFieldSemantic edc:cname="GPIO" edc:desc="GPIO function selected" edc:when="(field &amp; 0x7) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="FUNC1" edc:desc="Signal function 1 selected" edc:when="(field &amp; 0x7) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="FUNC2" edc:desc="Signal function 2 selected" edc:when="(field &amp; 0x7) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="FUNC3" edc:desc="Signal function 3 selected" edc:when="(field &amp; 0x7) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="INP_DIS" edc:nzwidth="0x1" edc:desc="GPIO input disable"/>
            <edc:SFRFieldDef edc:cname="ALT_GPIO_DATA" edc:nzwidth="0x1" edc:desc="GPIO Alternate Data Register."/>
            <edc:AdjustPoint edc:offset="0x7"/>
            <edc:SFRFieldDef edc:cname="GPIO_INP" edc:nzwidth="0x1" edc:desc="GPIO input from pin, independent of the Mux selection for the pin or the Direction."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL10" edc:nzwidth="0x20" edc:access="-------n-------nnnnnnnnnnnnnnnnn" edc:por="00000000000000001000000001000000" edc:mclr="00000000000000001000000001000000" edc:impl="0x101FFFF" edc:_addr="0x40081020">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="PU_PD" edc:nzwidth="0x2" edc:desc="These bits are used to enable an internal pull-up or pull-down resistor.">
              <edc:SFRFieldSemantic edc:cname="NONE" edc:desc="None. Pin tristates when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="UP" edc:desc="Pull Up Enabled" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="DOWN" edc:desc="Pull Down Enabled" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="REPEATER" edc:desc="Repeater mode. Pin is kept at previous voltage level when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="PWR_GATING" edc:nzwidth="0x2" edc:desc="The GPIO pin will be tristated when the selected power well is off."/>
            <edc:SFRFieldDef edc:cname="INTR_DET" edc:nzwidth="0x3" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="EDGE_EN" edc:nzwidth="0x1" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="OUT_BUFF_TYPE" edc:nzwidth="0x1" edc:desc="0 = Push-Pull, 1 = Open Drain"/>
            <edc:SFRFieldDef edc:cname="GPIO_DIR" edc:nzwidth="0x1" edc:desc="Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output"/>
            <edc:SFRFieldDef edc:cname="GPIO_OUT_SEL" edc:nzwidth="0x1" edc:desc="GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register."/>
            <edc:SFRFieldDef edc:cname="POL" edc:nzwidth="0x1" edc:desc="1=Inverted; 0=Non-inverted"/>
            <edc:SFRFieldDef edc:cname="MUX_CTRL" edc:nzwidth="0x3" edc:desc="00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3.">
              <edc:SFRFieldSemantic edc:cname="GPIO" edc:desc="GPIO function selected" edc:when="(field &amp; 0x7) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="FUNC1" edc:desc="Signal function 1 selected" edc:when="(field &amp; 0x7) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="FUNC2" edc:desc="Signal function 2 selected" edc:when="(field &amp; 0x7) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="FUNC3" edc:desc="Signal function 3 selected" edc:when="(field &amp; 0x7) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="INP_DIS" edc:nzwidth="0x1" edc:desc="GPIO input disable"/>
            <edc:SFRFieldDef edc:cname="ALT_GPIO_DATA" edc:nzwidth="0x1" edc:desc="GPIO Alternate Data Register."/>
            <edc:AdjustPoint edc:offset="0x7"/>
            <edc:SFRFieldDef edc:cname="GPIO_INP" edc:nzwidth="0x1" edc:desc="GPIO input from pin, independent of the Mux selection for the pin or the Direction."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL11" edc:nzwidth="0x20" edc:access="-------n-------nnnnnnnnnnnnnnnnn" edc:por="00000000000000001000000001000000" edc:mclr="00000000000000001000000001000000" edc:impl="0x101FFFF" edc:_addr="0x40081024">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="PU_PD" edc:nzwidth="0x2" edc:desc="These bits are used to enable an internal pull-up or pull-down resistor.">
              <edc:SFRFieldSemantic edc:cname="NONE" edc:desc="None. Pin tristates when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="UP" edc:desc="Pull Up Enabled" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="DOWN" edc:desc="Pull Down Enabled" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="REPEATER" edc:desc="Repeater mode. Pin is kept at previous voltage level when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="PWR_GATING" edc:nzwidth="0x2" edc:desc="The GPIO pin will be tristated when the selected power well is off."/>
            <edc:SFRFieldDef edc:cname="INTR_DET" edc:nzwidth="0x3" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="EDGE_EN" edc:nzwidth="0x1" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="OUT_BUFF_TYPE" edc:nzwidth="0x1" edc:desc="0 = Push-Pull, 1 = Open Drain"/>
            <edc:SFRFieldDef edc:cname="GPIO_DIR" edc:nzwidth="0x1" edc:desc="Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output"/>
            <edc:SFRFieldDef edc:cname="GPIO_OUT_SEL" edc:nzwidth="0x1" edc:desc="GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register."/>
            <edc:SFRFieldDef edc:cname="POL" edc:nzwidth="0x1" edc:desc="1=Inverted; 0=Non-inverted"/>
            <edc:SFRFieldDef edc:cname="MUX_CTRL" edc:nzwidth="0x3" edc:desc="00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3.">
              <edc:SFRFieldSemantic edc:cname="GPIO" edc:desc="GPIO function selected" edc:when="(field &amp; 0x7) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="FUNC1" edc:desc="Signal function 1 selected" edc:when="(field &amp; 0x7) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="FUNC2" edc:desc="Signal function 2 selected" edc:when="(field &amp; 0x7) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="FUNC3" edc:desc="Signal function 3 selected" edc:when="(field &amp; 0x7) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="INP_DIS" edc:nzwidth="0x1" edc:desc="GPIO input disable"/>
            <edc:SFRFieldDef edc:cname="ALT_GPIO_DATA" edc:nzwidth="0x1" edc:desc="GPIO Alternate Data Register."/>
            <edc:AdjustPoint edc:offset="0x7"/>
            <edc:SFRFieldDef edc:cname="GPIO_INP" edc:nzwidth="0x1" edc:desc="GPIO input from pin, independent of the Mux selection for the pin or the Direction."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL12" edc:nzwidth="0x20" edc:access="-------n-------nnnnnnnnnnnnnnnnn" edc:por="00000000000000001000000001000000" edc:mclr="00000000000000001000000001000000" edc:impl="0x101FFFF" edc:_addr="0x40081028">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="PU_PD" edc:nzwidth="0x2" edc:desc="These bits are used to enable an internal pull-up or pull-down resistor.">
              <edc:SFRFieldSemantic edc:cname="NONE" edc:desc="None. Pin tristates when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="UP" edc:desc="Pull Up Enabled" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="DOWN" edc:desc="Pull Down Enabled" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="REPEATER" edc:desc="Repeater mode. Pin is kept at previous voltage level when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="PWR_GATING" edc:nzwidth="0x2" edc:desc="The GPIO pin will be tristated when the selected power well is off."/>
            <edc:SFRFieldDef edc:cname="INTR_DET" edc:nzwidth="0x3" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="EDGE_EN" edc:nzwidth="0x1" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="OUT_BUFF_TYPE" edc:nzwidth="0x1" edc:desc="0 = Push-Pull, 1 = Open Drain"/>
            <edc:SFRFieldDef edc:cname="GPIO_DIR" edc:nzwidth="0x1" edc:desc="Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output"/>
            <edc:SFRFieldDef edc:cname="GPIO_OUT_SEL" edc:nzwidth="0x1" edc:desc="GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register."/>
            <edc:SFRFieldDef edc:cname="POL" edc:nzwidth="0x1" edc:desc="1=Inverted; 0=Non-inverted"/>
            <edc:SFRFieldDef edc:cname="MUX_CTRL" edc:nzwidth="0x3" edc:desc="00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3.">
              <edc:SFRFieldSemantic edc:cname="GPIO" edc:desc="GPIO function selected" edc:when="(field &amp; 0x7) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="FUNC1" edc:desc="Signal function 1 selected" edc:when="(field &amp; 0x7) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="FUNC2" edc:desc="Signal function 2 selected" edc:when="(field &amp; 0x7) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="FUNC3" edc:desc="Signal function 3 selected" edc:when="(field &amp; 0x7) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="INP_DIS" edc:nzwidth="0x1" edc:desc="GPIO input disable"/>
            <edc:SFRFieldDef edc:cname="ALT_GPIO_DATA" edc:nzwidth="0x1" edc:desc="GPIO Alternate Data Register."/>
            <edc:AdjustPoint edc:offset="0x7"/>
            <edc:SFRFieldDef edc:cname="GPIO_INP" edc:nzwidth="0x1" edc:desc="GPIO input from pin, independent of the Mux selection for the pin or the Direction."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL13" edc:nzwidth="0x20" edc:access="-------n-------nnnnnnnnnnnnnnnnn" edc:por="00000000000000001000000001000000" edc:mclr="00000000000000001000000001000000" edc:impl="0x101FFFF" edc:_addr="0x4008102C">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="PU_PD" edc:nzwidth="0x2" edc:desc="These bits are used to enable an internal pull-up or pull-down resistor.">
              <edc:SFRFieldSemantic edc:cname="NONE" edc:desc="None. Pin tristates when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="UP" edc:desc="Pull Up Enabled" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="DOWN" edc:desc="Pull Down Enabled" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="REPEATER" edc:desc="Repeater mode. Pin is kept at previous voltage level when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="PWR_GATING" edc:nzwidth="0x2" edc:desc="The GPIO pin will be tristated when the selected power well is off."/>
            <edc:SFRFieldDef edc:cname="INTR_DET" edc:nzwidth="0x3" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="EDGE_EN" edc:nzwidth="0x1" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="OUT_BUFF_TYPE" edc:nzwidth="0x1" edc:desc="0 = Push-Pull, 1 = Open Drain"/>
            <edc:SFRFieldDef edc:cname="GPIO_DIR" edc:nzwidth="0x1" edc:desc="Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output"/>
            <edc:SFRFieldDef edc:cname="GPIO_OUT_SEL" edc:nzwidth="0x1" edc:desc="GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register."/>
            <edc:SFRFieldDef edc:cname="POL" edc:nzwidth="0x1" edc:desc="1=Inverted; 0=Non-inverted"/>
            <edc:SFRFieldDef edc:cname="MUX_CTRL" edc:nzwidth="0x3" edc:desc="00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3.">
              <edc:SFRFieldSemantic edc:cname="GPIO" edc:desc="GPIO function selected" edc:when="(field &amp; 0x7) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="FUNC1" edc:desc="Signal function 1 selected" edc:when="(field &amp; 0x7) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="FUNC2" edc:desc="Signal function 2 selected" edc:when="(field &amp; 0x7) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="FUNC3" edc:desc="Signal function 3 selected" edc:when="(field &amp; 0x7) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="INP_DIS" edc:nzwidth="0x1" edc:desc="GPIO input disable"/>
            <edc:SFRFieldDef edc:cname="ALT_GPIO_DATA" edc:nzwidth="0x1" edc:desc="GPIO Alternate Data Register."/>
            <edc:AdjustPoint edc:offset="0x7"/>
            <edc:SFRFieldDef edc:cname="GPIO_INP" edc:nzwidth="0x1" edc:desc="GPIO input from pin, independent of the Mux selection for the pin or the Direction."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL14" edc:nzwidth="0x20" edc:access="-------n-------nnnnnnnnnnnnnnnnn" edc:por="00000000000000001000000001000000" edc:mclr="00000000000000001000000001000000" edc:impl="0x101FFFF" edc:_addr="0x40081030">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="PU_PD" edc:nzwidth="0x2" edc:desc="These bits are used to enable an internal pull-up or pull-down resistor.">
              <edc:SFRFieldSemantic edc:cname="NONE" edc:desc="None. Pin tristates when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="UP" edc:desc="Pull Up Enabled" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="DOWN" edc:desc="Pull Down Enabled" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="REPEATER" edc:desc="Repeater mode. Pin is kept at previous voltage level when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="PWR_GATING" edc:nzwidth="0x2" edc:desc="The GPIO pin will be tristated when the selected power well is off."/>
            <edc:SFRFieldDef edc:cname="INTR_DET" edc:nzwidth="0x3" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="EDGE_EN" edc:nzwidth="0x1" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="OUT_BUFF_TYPE" edc:nzwidth="0x1" edc:desc="0 = Push-Pull, 1 = Open Drain"/>
            <edc:SFRFieldDef edc:cname="GPIO_DIR" edc:nzwidth="0x1" edc:desc="Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output"/>
            <edc:SFRFieldDef edc:cname="GPIO_OUT_SEL" edc:nzwidth="0x1" edc:desc="GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register."/>
            <edc:SFRFieldDef edc:cname="POL" edc:nzwidth="0x1" edc:desc="1=Inverted; 0=Non-inverted"/>
            <edc:SFRFieldDef edc:cname="MUX_CTRL" edc:nzwidth="0x3" edc:desc="00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3.">
              <edc:SFRFieldSemantic edc:cname="GPIO" edc:desc="GPIO function selected" edc:when="(field &amp; 0x7) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="FUNC1" edc:desc="Signal function 1 selected" edc:when="(field &amp; 0x7) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="FUNC2" edc:desc="Signal function 2 selected" edc:when="(field &amp; 0x7) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="FUNC3" edc:desc="Signal function 3 selected" edc:when="(field &amp; 0x7) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="INP_DIS" edc:nzwidth="0x1" edc:desc="GPIO input disable"/>
            <edc:SFRFieldDef edc:cname="ALT_GPIO_DATA" edc:nzwidth="0x1" edc:desc="GPIO Alternate Data Register."/>
            <edc:AdjustPoint edc:offset="0x7"/>
            <edc:SFRFieldDef edc:cname="GPIO_INP" edc:nzwidth="0x1" edc:desc="GPIO input from pin, independent of the Mux selection for the pin or the Direction."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL15" edc:nzwidth="0x20" edc:access="-------n-------nnnnnnnnnnnnnnnnn" edc:por="00000000000000001000000001000000" edc:mclr="00000000000000001000000001000000" edc:impl="0x101FFFF" edc:_addr="0x40081034">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="PU_PD" edc:nzwidth="0x2" edc:desc="These bits are used to enable an internal pull-up or pull-down resistor.">
              <edc:SFRFieldSemantic edc:cname="NONE" edc:desc="None. Pin tristates when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="UP" edc:desc="Pull Up Enabled" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="DOWN" edc:desc="Pull Down Enabled" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="REPEATER" edc:desc="Repeater mode. Pin is kept at previous voltage level when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="PWR_GATING" edc:nzwidth="0x2" edc:desc="The GPIO pin will be tristated when the selected power well is off."/>
            <edc:SFRFieldDef edc:cname="INTR_DET" edc:nzwidth="0x3" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="EDGE_EN" edc:nzwidth="0x1" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="OUT_BUFF_TYPE" edc:nzwidth="0x1" edc:desc="0 = Push-Pull, 1 = Open Drain"/>
            <edc:SFRFieldDef edc:cname="GPIO_DIR" edc:nzwidth="0x1" edc:desc="Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output"/>
            <edc:SFRFieldDef edc:cname="GPIO_OUT_SEL" edc:nzwidth="0x1" edc:desc="GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register."/>
            <edc:SFRFieldDef edc:cname="POL" edc:nzwidth="0x1" edc:desc="1=Inverted; 0=Non-inverted"/>
            <edc:SFRFieldDef edc:cname="MUX_CTRL" edc:nzwidth="0x3" edc:desc="00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3.">
              <edc:SFRFieldSemantic edc:cname="GPIO" edc:desc="GPIO function selected" edc:when="(field &amp; 0x7) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="FUNC1" edc:desc="Signal function 1 selected" edc:when="(field &amp; 0x7) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="FUNC2" edc:desc="Signal function 2 selected" edc:when="(field &amp; 0x7) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="FUNC3" edc:desc="Signal function 3 selected" edc:when="(field &amp; 0x7) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="INP_DIS" edc:nzwidth="0x1" edc:desc="GPIO input disable"/>
            <edc:SFRFieldDef edc:cname="ALT_GPIO_DATA" edc:nzwidth="0x1" edc:desc="GPIO Alternate Data Register."/>
            <edc:AdjustPoint edc:offset="0x7"/>
            <edc:SFRFieldDef edc:cname="GPIO_INP" edc:nzwidth="0x1" edc:desc="GPIO input from pin, independent of the Mux selection for the pin or the Direction."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL16" edc:nzwidth="0x20" edc:access="-------n-------nnnnnnnnnnnnnnnnn" edc:por="00000000000000001000000001000000" edc:mclr="00000000000000001000000001000000" edc:impl="0x101FFFF" edc:_addr="0x40081038">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="PU_PD" edc:nzwidth="0x2" edc:desc="These bits are used to enable an internal pull-up or pull-down resistor.">
              <edc:SFRFieldSemantic edc:cname="NONE" edc:desc="None. Pin tristates when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="UP" edc:desc="Pull Up Enabled" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="DOWN" edc:desc="Pull Down Enabled" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="REPEATER" edc:desc="Repeater mode. Pin is kept at previous voltage level when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="PWR_GATING" edc:nzwidth="0x2" edc:desc="The GPIO pin will be tristated when the selected power well is off."/>
            <edc:SFRFieldDef edc:cname="INTR_DET" edc:nzwidth="0x3" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="EDGE_EN" edc:nzwidth="0x1" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="OUT_BUFF_TYPE" edc:nzwidth="0x1" edc:desc="0 = Push-Pull, 1 = Open Drain"/>
            <edc:SFRFieldDef edc:cname="GPIO_DIR" edc:nzwidth="0x1" edc:desc="Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output"/>
            <edc:SFRFieldDef edc:cname="GPIO_OUT_SEL" edc:nzwidth="0x1" edc:desc="GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register."/>
            <edc:SFRFieldDef edc:cname="POL" edc:nzwidth="0x1" edc:desc="1=Inverted; 0=Non-inverted"/>
            <edc:SFRFieldDef edc:cname="MUX_CTRL" edc:nzwidth="0x3" edc:desc="00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3.">
              <edc:SFRFieldSemantic edc:cname="GPIO" edc:desc="GPIO function selected" edc:when="(field &amp; 0x7) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="FUNC1" edc:desc="Signal function 1 selected" edc:when="(field &amp; 0x7) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="FUNC2" edc:desc="Signal function 2 selected" edc:when="(field &amp; 0x7) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="FUNC3" edc:desc="Signal function 3 selected" edc:when="(field &amp; 0x7) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="INP_DIS" edc:nzwidth="0x1" edc:desc="GPIO input disable"/>
            <edc:SFRFieldDef edc:cname="ALT_GPIO_DATA" edc:nzwidth="0x1" edc:desc="GPIO Alternate Data Register."/>
            <edc:AdjustPoint edc:offset="0x7"/>
            <edc:SFRFieldDef edc:cname="GPIO_INP" edc:nzwidth="0x1" edc:desc="GPIO input from pin, independent of the Mux selection for the pin or the Direction."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL17" edc:nzwidth="0x20" edc:access="-------n-------nnnnnnnnnnnnnnnnn" edc:por="00000000000000001000000001000000" edc:mclr="00000000000000001000000001000000" edc:impl="0x101FFFF" edc:_addr="0x4008103C">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="PU_PD" edc:nzwidth="0x2" edc:desc="These bits are used to enable an internal pull-up or pull-down resistor.">
              <edc:SFRFieldSemantic edc:cname="NONE" edc:desc="None. Pin tristates when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="UP" edc:desc="Pull Up Enabled" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="DOWN" edc:desc="Pull Down Enabled" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="REPEATER" edc:desc="Repeater mode. Pin is kept at previous voltage level when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="PWR_GATING" edc:nzwidth="0x2" edc:desc="The GPIO pin will be tristated when the selected power well is off."/>
            <edc:SFRFieldDef edc:cname="INTR_DET" edc:nzwidth="0x3" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="EDGE_EN" edc:nzwidth="0x1" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="OUT_BUFF_TYPE" edc:nzwidth="0x1" edc:desc="0 = Push-Pull, 1 = Open Drain"/>
            <edc:SFRFieldDef edc:cname="GPIO_DIR" edc:nzwidth="0x1" edc:desc="Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output"/>
            <edc:SFRFieldDef edc:cname="GPIO_OUT_SEL" edc:nzwidth="0x1" edc:desc="GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register."/>
            <edc:SFRFieldDef edc:cname="POL" edc:nzwidth="0x1" edc:desc="1=Inverted; 0=Non-inverted"/>
            <edc:SFRFieldDef edc:cname="MUX_CTRL" edc:nzwidth="0x3" edc:desc="00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3.">
              <edc:SFRFieldSemantic edc:cname="GPIO" edc:desc="GPIO function selected" edc:when="(field &amp; 0x7) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="FUNC1" edc:desc="Signal function 1 selected" edc:when="(field &amp; 0x7) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="FUNC2" edc:desc="Signal function 2 selected" edc:when="(field &amp; 0x7) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="FUNC3" edc:desc="Signal function 3 selected" edc:when="(field &amp; 0x7) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="INP_DIS" edc:nzwidth="0x1" edc:desc="GPIO input disable"/>
            <edc:SFRFieldDef edc:cname="ALT_GPIO_DATA" edc:nzwidth="0x1" edc:desc="GPIO Alternate Data Register."/>
            <edc:AdjustPoint edc:offset="0x7"/>
            <edc:SFRFieldDef edc:cname="GPIO_INP" edc:nzwidth="0x1" edc:desc="GPIO input from pin, independent of the Mux selection for the pin or the Direction."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL20" edc:nzwidth="0x20" edc:access="-------n-------nnnnnnnnnnnnnnnnn" edc:por="00000000000000001000000001000000" edc:mclr="00000000000000001000000001000000" edc:impl="0x101FFFF" edc:_addr="0x40081040">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="PU_PD" edc:nzwidth="0x2" edc:desc="These bits are used to enable an internal pull-up or pull-down resistor.">
              <edc:SFRFieldSemantic edc:cname="NONE" edc:desc="None. Pin tristates when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="UP" edc:desc="Pull Up Enabled" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="DOWN" edc:desc="Pull Down Enabled" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="REPEATER" edc:desc="Repeater mode. Pin is kept at previous voltage level when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="PWR_GATING" edc:nzwidth="0x2" edc:desc="The GPIO pin will be tristated when the selected power well is off."/>
            <edc:SFRFieldDef edc:cname="INTR_DET" edc:nzwidth="0x3" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="EDGE_EN" edc:nzwidth="0x1" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="OUT_BUFF_TYPE" edc:nzwidth="0x1" edc:desc="0 = Push-Pull, 1 = Open Drain"/>
            <edc:SFRFieldDef edc:cname="GPIO_DIR" edc:nzwidth="0x1" edc:desc="Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output"/>
            <edc:SFRFieldDef edc:cname="GPIO_OUT_SEL" edc:nzwidth="0x1" edc:desc="GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register."/>
            <edc:SFRFieldDef edc:cname="POL" edc:nzwidth="0x1" edc:desc="1=Inverted; 0=Non-inverted"/>
            <edc:SFRFieldDef edc:cname="MUX_CTRL" edc:nzwidth="0x3" edc:desc="00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3.">
              <edc:SFRFieldSemantic edc:cname="GPIO" edc:desc="GPIO function selected" edc:when="(field &amp; 0x7) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="FUNC1" edc:desc="Signal function 1 selected" edc:when="(field &amp; 0x7) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="FUNC2" edc:desc="Signal function 2 selected" edc:when="(field &amp; 0x7) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="FUNC3" edc:desc="Signal function 3 selected" edc:when="(field &amp; 0x7) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="INP_DIS" edc:nzwidth="0x1" edc:desc="GPIO input disable"/>
            <edc:SFRFieldDef edc:cname="ALT_GPIO_DATA" edc:nzwidth="0x1" edc:desc="GPIO Alternate Data Register."/>
            <edc:AdjustPoint edc:offset="0x7"/>
            <edc:SFRFieldDef edc:cname="GPIO_INP" edc:nzwidth="0x1" edc:desc="GPIO input from pin, independent of the Mux selection for the pin or the Direction."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL21" edc:nzwidth="0x20" edc:access="-------n-------nnnnnnnnnnnnnnnnn" edc:por="00000000000000001000000001000000" edc:mclr="00000000000000001000000001000000" edc:impl="0x101FFFF" edc:_addr="0x40081044">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="PU_PD" edc:nzwidth="0x2" edc:desc="These bits are used to enable an internal pull-up or pull-down resistor.">
              <edc:SFRFieldSemantic edc:cname="NONE" edc:desc="None. Pin tristates when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="UP" edc:desc="Pull Up Enabled" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="DOWN" edc:desc="Pull Down Enabled" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="REPEATER" edc:desc="Repeater mode. Pin is kept at previous voltage level when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="PWR_GATING" edc:nzwidth="0x2" edc:desc="The GPIO pin will be tristated when the selected power well is off."/>
            <edc:SFRFieldDef edc:cname="INTR_DET" edc:nzwidth="0x3" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="EDGE_EN" edc:nzwidth="0x1" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="OUT_BUFF_TYPE" edc:nzwidth="0x1" edc:desc="0 = Push-Pull, 1 = Open Drain"/>
            <edc:SFRFieldDef edc:cname="GPIO_DIR" edc:nzwidth="0x1" edc:desc="Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output"/>
            <edc:SFRFieldDef edc:cname="GPIO_OUT_SEL" edc:nzwidth="0x1" edc:desc="GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register."/>
            <edc:SFRFieldDef edc:cname="POL" edc:nzwidth="0x1" edc:desc="1=Inverted; 0=Non-inverted"/>
            <edc:SFRFieldDef edc:cname="MUX_CTRL" edc:nzwidth="0x3" edc:desc="00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3.">
              <edc:SFRFieldSemantic edc:cname="GPIO" edc:desc="GPIO function selected" edc:when="(field &amp; 0x7) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="FUNC1" edc:desc="Signal function 1 selected" edc:when="(field &amp; 0x7) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="FUNC2" edc:desc="Signal function 2 selected" edc:when="(field &amp; 0x7) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="FUNC3" edc:desc="Signal function 3 selected" edc:when="(field &amp; 0x7) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="INP_DIS" edc:nzwidth="0x1" edc:desc="GPIO input disable"/>
            <edc:SFRFieldDef edc:cname="ALT_GPIO_DATA" edc:nzwidth="0x1" edc:desc="GPIO Alternate Data Register."/>
            <edc:AdjustPoint edc:offset="0x7"/>
            <edc:SFRFieldDef edc:cname="GPIO_INP" edc:nzwidth="0x1" edc:desc="GPIO input from pin, independent of the Mux selection for the pin or the Direction."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL22" edc:nzwidth="0x20" edc:access="-------n-------nnnnnnnnnnnnnnnnn" edc:por="00000000000000001000000001000000" edc:mclr="00000000000000001000000001000000" edc:impl="0x101FFFF" edc:_addr="0x40081048">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="PU_PD" edc:nzwidth="0x2" edc:desc="These bits are used to enable an internal pull-up or pull-down resistor.">
              <edc:SFRFieldSemantic edc:cname="NONE" edc:desc="None. Pin tristates when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="UP" edc:desc="Pull Up Enabled" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="DOWN" edc:desc="Pull Down Enabled" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="REPEATER" edc:desc="Repeater mode. Pin is kept at previous voltage level when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="PWR_GATING" edc:nzwidth="0x2" edc:desc="The GPIO pin will be tristated when the selected power well is off."/>
            <edc:SFRFieldDef edc:cname="INTR_DET" edc:nzwidth="0x3" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="EDGE_EN" edc:nzwidth="0x1" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="OUT_BUFF_TYPE" edc:nzwidth="0x1" edc:desc="0 = Push-Pull, 1 = Open Drain"/>
            <edc:SFRFieldDef edc:cname="GPIO_DIR" edc:nzwidth="0x1" edc:desc="Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output"/>
            <edc:SFRFieldDef edc:cname="GPIO_OUT_SEL" edc:nzwidth="0x1" edc:desc="GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register."/>
            <edc:SFRFieldDef edc:cname="POL" edc:nzwidth="0x1" edc:desc="1=Inverted; 0=Non-inverted"/>
            <edc:SFRFieldDef edc:cname="MUX_CTRL" edc:nzwidth="0x3" edc:desc="00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3.">
              <edc:SFRFieldSemantic edc:cname="GPIO" edc:desc="GPIO function selected" edc:when="(field &amp; 0x7) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="FUNC1" edc:desc="Signal function 1 selected" edc:when="(field &amp; 0x7) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="FUNC2" edc:desc="Signal function 2 selected" edc:when="(field &amp; 0x7) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="FUNC3" edc:desc="Signal function 3 selected" edc:when="(field &amp; 0x7) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="INP_DIS" edc:nzwidth="0x1" edc:desc="GPIO input disable"/>
            <edc:SFRFieldDef edc:cname="ALT_GPIO_DATA" edc:nzwidth="0x1" edc:desc="GPIO Alternate Data Register."/>
            <edc:AdjustPoint edc:offset="0x7"/>
            <edc:SFRFieldDef edc:cname="GPIO_INP" edc:nzwidth="0x1" edc:desc="GPIO input from pin, independent of the Mux selection for the pin or the Direction."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL23" edc:nzwidth="0x20" edc:access="-------n-------nnnnnnnnnnnnnnnnn" edc:por="00000000000000001000000001000000" edc:mclr="00000000000000001000000001000000" edc:impl="0x101FFFF" edc:_addr="0x4008104C">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="PU_PD" edc:nzwidth="0x2" edc:desc="These bits are used to enable an internal pull-up or pull-down resistor.">
              <edc:SFRFieldSemantic edc:cname="NONE" edc:desc="None. Pin tristates when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="UP" edc:desc="Pull Up Enabled" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="DOWN" edc:desc="Pull Down Enabled" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="REPEATER" edc:desc="Repeater mode. Pin is kept at previous voltage level when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="PWR_GATING" edc:nzwidth="0x2" edc:desc="The GPIO pin will be tristated when the selected power well is off."/>
            <edc:SFRFieldDef edc:cname="INTR_DET" edc:nzwidth="0x3" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="EDGE_EN" edc:nzwidth="0x1" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="OUT_BUFF_TYPE" edc:nzwidth="0x1" edc:desc="0 = Push-Pull, 1 = Open Drain"/>
            <edc:SFRFieldDef edc:cname="GPIO_DIR" edc:nzwidth="0x1" edc:desc="Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output"/>
            <edc:SFRFieldDef edc:cname="GPIO_OUT_SEL" edc:nzwidth="0x1" edc:desc="GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register."/>
            <edc:SFRFieldDef edc:cname="POL" edc:nzwidth="0x1" edc:desc="1=Inverted; 0=Non-inverted"/>
            <edc:SFRFieldDef edc:cname="MUX_CTRL" edc:nzwidth="0x3" edc:desc="00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3.">
              <edc:SFRFieldSemantic edc:cname="GPIO" edc:desc="GPIO function selected" edc:when="(field &amp; 0x7) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="FUNC1" edc:desc="Signal function 1 selected" edc:when="(field &amp; 0x7) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="FUNC2" edc:desc="Signal function 2 selected" edc:when="(field &amp; 0x7) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="FUNC3" edc:desc="Signal function 3 selected" edc:when="(field &amp; 0x7) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="INP_DIS" edc:nzwidth="0x1" edc:desc="GPIO input disable"/>
            <edc:SFRFieldDef edc:cname="ALT_GPIO_DATA" edc:nzwidth="0x1" edc:desc="GPIO Alternate Data Register."/>
            <edc:AdjustPoint edc:offset="0x7"/>
            <edc:SFRFieldDef edc:cname="GPIO_INP" edc:nzwidth="0x1" edc:desc="GPIO input from pin, independent of the Mux selection for the pin or the Direction."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL24" edc:nzwidth="0x20" edc:access="-------n-------nnnnnnnnnnnnnnnnn" edc:por="00000000000000001000000001000000" edc:mclr="00000000000000001000000001000000" edc:impl="0x101FFFF" edc:_addr="0x40081050">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="PU_PD" edc:nzwidth="0x2" edc:desc="These bits are used to enable an internal pull-up or pull-down resistor.">
              <edc:SFRFieldSemantic edc:cname="NONE" edc:desc="None. Pin tristates when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="UP" edc:desc="Pull Up Enabled" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="DOWN" edc:desc="Pull Down Enabled" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="REPEATER" edc:desc="Repeater mode. Pin is kept at previous voltage level when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="PWR_GATING" edc:nzwidth="0x2" edc:desc="The GPIO pin will be tristated when the selected power well is off."/>
            <edc:SFRFieldDef edc:cname="INTR_DET" edc:nzwidth="0x3" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="EDGE_EN" edc:nzwidth="0x1" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="OUT_BUFF_TYPE" edc:nzwidth="0x1" edc:desc="0 = Push-Pull, 1 = Open Drain"/>
            <edc:SFRFieldDef edc:cname="GPIO_DIR" edc:nzwidth="0x1" edc:desc="Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output"/>
            <edc:SFRFieldDef edc:cname="GPIO_OUT_SEL" edc:nzwidth="0x1" edc:desc="GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register."/>
            <edc:SFRFieldDef edc:cname="POL" edc:nzwidth="0x1" edc:desc="1=Inverted; 0=Non-inverted"/>
            <edc:SFRFieldDef edc:cname="MUX_CTRL" edc:nzwidth="0x3" edc:desc="00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3.">
              <edc:SFRFieldSemantic edc:cname="GPIO" edc:desc="GPIO function selected" edc:when="(field &amp; 0x7) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="FUNC1" edc:desc="Signal function 1 selected" edc:when="(field &amp; 0x7) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="FUNC2" edc:desc="Signal function 2 selected" edc:when="(field &amp; 0x7) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="FUNC3" edc:desc="Signal function 3 selected" edc:when="(field &amp; 0x7) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="INP_DIS" edc:nzwidth="0x1" edc:desc="GPIO input disable"/>
            <edc:SFRFieldDef edc:cname="ALT_GPIO_DATA" edc:nzwidth="0x1" edc:desc="GPIO Alternate Data Register."/>
            <edc:AdjustPoint edc:offset="0x7"/>
            <edc:SFRFieldDef edc:cname="GPIO_INP" edc:nzwidth="0x1" edc:desc="GPIO input from pin, independent of the Mux selection for the pin or the Direction."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL25" edc:nzwidth="0x20" edc:access="-------n-------nnnnnnnnnnnnnnnnn" edc:por="00000000000000001000000001000000" edc:mclr="00000000000000001000000001000000" edc:impl="0x101FFFF" edc:_addr="0x40081054">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="PU_PD" edc:nzwidth="0x2" edc:desc="These bits are used to enable an internal pull-up or pull-down resistor.">
              <edc:SFRFieldSemantic edc:cname="NONE" edc:desc="None. Pin tristates when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="UP" edc:desc="Pull Up Enabled" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="DOWN" edc:desc="Pull Down Enabled" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="REPEATER" edc:desc="Repeater mode. Pin is kept at previous voltage level when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="PWR_GATING" edc:nzwidth="0x2" edc:desc="The GPIO pin will be tristated when the selected power well is off."/>
            <edc:SFRFieldDef edc:cname="INTR_DET" edc:nzwidth="0x3" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="EDGE_EN" edc:nzwidth="0x1" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="OUT_BUFF_TYPE" edc:nzwidth="0x1" edc:desc="0 = Push-Pull, 1 = Open Drain"/>
            <edc:SFRFieldDef edc:cname="GPIO_DIR" edc:nzwidth="0x1" edc:desc="Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output"/>
            <edc:SFRFieldDef edc:cname="GPIO_OUT_SEL" edc:nzwidth="0x1" edc:desc="GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register."/>
            <edc:SFRFieldDef edc:cname="POL" edc:nzwidth="0x1" edc:desc="1=Inverted; 0=Non-inverted"/>
            <edc:SFRFieldDef edc:cname="MUX_CTRL" edc:nzwidth="0x3" edc:desc="00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3.">
              <edc:SFRFieldSemantic edc:cname="GPIO" edc:desc="GPIO function selected" edc:when="(field &amp; 0x7) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="FUNC1" edc:desc="Signal function 1 selected" edc:when="(field &amp; 0x7) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="FUNC2" edc:desc="Signal function 2 selected" edc:when="(field &amp; 0x7) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="FUNC3" edc:desc="Signal function 3 selected" edc:when="(field &amp; 0x7) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="INP_DIS" edc:nzwidth="0x1" edc:desc="GPIO input disable"/>
            <edc:SFRFieldDef edc:cname="ALT_GPIO_DATA" edc:nzwidth="0x1" edc:desc="GPIO Alternate Data Register."/>
            <edc:AdjustPoint edc:offset="0x7"/>
            <edc:SFRFieldDef edc:cname="GPIO_INP" edc:nzwidth="0x1" edc:desc="GPIO input from pin, independent of the Mux selection for the pin or the Direction."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL26" edc:nzwidth="0x20" edc:access="-------n-------nnnnnnnnnnnnnnnnn" edc:por="00000000000000001000000001000000" edc:mclr="00000000000000001000000001000000" edc:impl="0x101FFFF" edc:_addr="0x40081058">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="PU_PD" edc:nzwidth="0x2" edc:desc="These bits are used to enable an internal pull-up or pull-down resistor.">
              <edc:SFRFieldSemantic edc:cname="NONE" edc:desc="None. Pin tristates when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="UP" edc:desc="Pull Up Enabled" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="DOWN" edc:desc="Pull Down Enabled" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="REPEATER" edc:desc="Repeater mode. Pin is kept at previous voltage level when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="PWR_GATING" edc:nzwidth="0x2" edc:desc="The GPIO pin will be tristated when the selected power well is off."/>
            <edc:SFRFieldDef edc:cname="INTR_DET" edc:nzwidth="0x3" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="EDGE_EN" edc:nzwidth="0x1" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="OUT_BUFF_TYPE" edc:nzwidth="0x1" edc:desc="0 = Push-Pull, 1 = Open Drain"/>
            <edc:SFRFieldDef edc:cname="GPIO_DIR" edc:nzwidth="0x1" edc:desc="Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output"/>
            <edc:SFRFieldDef edc:cname="GPIO_OUT_SEL" edc:nzwidth="0x1" edc:desc="GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register."/>
            <edc:SFRFieldDef edc:cname="POL" edc:nzwidth="0x1" edc:desc="1=Inverted; 0=Non-inverted"/>
            <edc:SFRFieldDef edc:cname="MUX_CTRL" edc:nzwidth="0x3" edc:desc="00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3.">
              <edc:SFRFieldSemantic edc:cname="GPIO" edc:desc="GPIO function selected" edc:when="(field &amp; 0x7) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="FUNC1" edc:desc="Signal function 1 selected" edc:when="(field &amp; 0x7) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="FUNC2" edc:desc="Signal function 2 selected" edc:when="(field &amp; 0x7) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="FUNC3" edc:desc="Signal function 3 selected" edc:when="(field &amp; 0x7) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="INP_DIS" edc:nzwidth="0x1" edc:desc="GPIO input disable"/>
            <edc:SFRFieldDef edc:cname="ALT_GPIO_DATA" edc:nzwidth="0x1" edc:desc="GPIO Alternate Data Register."/>
            <edc:AdjustPoint edc:offset="0x7"/>
            <edc:SFRFieldDef edc:cname="GPIO_INP" edc:nzwidth="0x1" edc:desc="GPIO input from pin, independent of the Mux selection for the pin or the Direction."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL27" edc:nzwidth="0x20" edc:access="-------n-------nnnnnnnnnnnnnnnnn" edc:por="00000000000000001000000001000000" edc:mclr="00000000000000001000000001000000" edc:impl="0x101FFFF" edc:_addr="0x4008105C">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="PU_PD" edc:nzwidth="0x2" edc:desc="These bits are used to enable an internal pull-up or pull-down resistor.">
              <edc:SFRFieldSemantic edc:cname="NONE" edc:desc="None. Pin tristates when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="UP" edc:desc="Pull Up Enabled" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="DOWN" edc:desc="Pull Down Enabled" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="REPEATER" edc:desc="Repeater mode. Pin is kept at previous voltage level when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="PWR_GATING" edc:nzwidth="0x2" edc:desc="The GPIO pin will be tristated when the selected power well is off."/>
            <edc:SFRFieldDef edc:cname="INTR_DET" edc:nzwidth="0x3" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="EDGE_EN" edc:nzwidth="0x1" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="OUT_BUFF_TYPE" edc:nzwidth="0x1" edc:desc="0 = Push-Pull, 1 = Open Drain"/>
            <edc:SFRFieldDef edc:cname="GPIO_DIR" edc:nzwidth="0x1" edc:desc="Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output"/>
            <edc:SFRFieldDef edc:cname="GPIO_OUT_SEL" edc:nzwidth="0x1" edc:desc="GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register."/>
            <edc:SFRFieldDef edc:cname="POL" edc:nzwidth="0x1" edc:desc="1=Inverted; 0=Non-inverted"/>
            <edc:SFRFieldDef edc:cname="MUX_CTRL" edc:nzwidth="0x3" edc:desc="00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3.">
              <edc:SFRFieldSemantic edc:cname="GPIO" edc:desc="GPIO function selected" edc:when="(field &amp; 0x7) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="FUNC1" edc:desc="Signal function 1 selected" edc:when="(field &amp; 0x7) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="FUNC2" edc:desc="Signal function 2 selected" edc:when="(field &amp; 0x7) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="FUNC3" edc:desc="Signal function 3 selected" edc:when="(field &amp; 0x7) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="INP_DIS" edc:nzwidth="0x1" edc:desc="GPIO input disable"/>
            <edc:SFRFieldDef edc:cname="ALT_GPIO_DATA" edc:nzwidth="0x1" edc:desc="GPIO Alternate Data Register."/>
            <edc:AdjustPoint edc:offset="0x7"/>
            <edc:SFRFieldDef edc:cname="GPIO_INP" edc:nzwidth="0x1" edc:desc="GPIO input from pin, independent of the Mux selection for the pin or the Direction."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL30" edc:nzwidth="0x20" edc:access="-------n-------nnnnnnnnnnnnnnnnn" edc:por="00000000000000001000000001000000" edc:mclr="00000000000000001000000001000000" edc:impl="0x101FFFF" edc:_addr="0x40081060">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="PU_PD" edc:nzwidth="0x2" edc:desc="These bits are used to enable an internal pull-up or pull-down resistor.">
              <edc:SFRFieldSemantic edc:cname="NONE" edc:desc="None. Pin tristates when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="UP" edc:desc="Pull Up Enabled" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="DOWN" edc:desc="Pull Down Enabled" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="REPEATER" edc:desc="Repeater mode. Pin is kept at previous voltage level when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="PWR_GATING" edc:nzwidth="0x2" edc:desc="The GPIO pin will be tristated when the selected power well is off."/>
            <edc:SFRFieldDef edc:cname="INTR_DET" edc:nzwidth="0x3" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="EDGE_EN" edc:nzwidth="0x1" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="OUT_BUFF_TYPE" edc:nzwidth="0x1" edc:desc="0 = Push-Pull, 1 = Open Drain"/>
            <edc:SFRFieldDef edc:cname="GPIO_DIR" edc:nzwidth="0x1" edc:desc="Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output"/>
            <edc:SFRFieldDef edc:cname="GPIO_OUT_SEL" edc:nzwidth="0x1" edc:desc="GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register."/>
            <edc:SFRFieldDef edc:cname="POL" edc:nzwidth="0x1" edc:desc="1=Inverted; 0=Non-inverted"/>
            <edc:SFRFieldDef edc:cname="MUX_CTRL" edc:nzwidth="0x3" edc:desc="00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3.">
              <edc:SFRFieldSemantic edc:cname="GPIO" edc:desc="GPIO function selected" edc:when="(field &amp; 0x7) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="FUNC1" edc:desc="Signal function 1 selected" edc:when="(field &amp; 0x7) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="FUNC2" edc:desc="Signal function 2 selected" edc:when="(field &amp; 0x7) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="FUNC3" edc:desc="Signal function 3 selected" edc:when="(field &amp; 0x7) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="INP_DIS" edc:nzwidth="0x1" edc:desc="GPIO input disable"/>
            <edc:SFRFieldDef edc:cname="ALT_GPIO_DATA" edc:nzwidth="0x1" edc:desc="GPIO Alternate Data Register."/>
            <edc:AdjustPoint edc:offset="0x7"/>
            <edc:SFRFieldDef edc:cname="GPIO_INP" edc:nzwidth="0x1" edc:desc="GPIO input from pin, independent of the Mux selection for the pin or the Direction."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL31" edc:nzwidth="0x20" edc:access="-------n-------nnnnnnnnnnnnnnnnn" edc:por="00000000000000001000000001000000" edc:mclr="00000000000000001000000001000000" edc:impl="0x101FFFF" edc:_addr="0x40081064">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="PU_PD" edc:nzwidth="0x2" edc:desc="These bits are used to enable an internal pull-up or pull-down resistor.">
              <edc:SFRFieldSemantic edc:cname="NONE" edc:desc="None. Pin tristates when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="UP" edc:desc="Pull Up Enabled" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="DOWN" edc:desc="Pull Down Enabled" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="REPEATER" edc:desc="Repeater mode. Pin is kept at previous voltage level when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="PWR_GATING" edc:nzwidth="0x2" edc:desc="The GPIO pin will be tristated when the selected power well is off."/>
            <edc:SFRFieldDef edc:cname="INTR_DET" edc:nzwidth="0x3" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="EDGE_EN" edc:nzwidth="0x1" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="OUT_BUFF_TYPE" edc:nzwidth="0x1" edc:desc="0 = Push-Pull, 1 = Open Drain"/>
            <edc:SFRFieldDef edc:cname="GPIO_DIR" edc:nzwidth="0x1" edc:desc="Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output"/>
            <edc:SFRFieldDef edc:cname="GPIO_OUT_SEL" edc:nzwidth="0x1" edc:desc="GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register."/>
            <edc:SFRFieldDef edc:cname="POL" edc:nzwidth="0x1" edc:desc="1=Inverted; 0=Non-inverted"/>
            <edc:SFRFieldDef edc:cname="MUX_CTRL" edc:nzwidth="0x3" edc:desc="00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3.">
              <edc:SFRFieldSemantic edc:cname="GPIO" edc:desc="GPIO function selected" edc:when="(field &amp; 0x7) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="FUNC1" edc:desc="Signal function 1 selected" edc:when="(field &amp; 0x7) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="FUNC2" edc:desc="Signal function 2 selected" edc:when="(field &amp; 0x7) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="FUNC3" edc:desc="Signal function 3 selected" edc:when="(field &amp; 0x7) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="INP_DIS" edc:nzwidth="0x1" edc:desc="GPIO input disable"/>
            <edc:SFRFieldDef edc:cname="ALT_GPIO_DATA" edc:nzwidth="0x1" edc:desc="GPIO Alternate Data Register."/>
            <edc:AdjustPoint edc:offset="0x7"/>
            <edc:SFRFieldDef edc:cname="GPIO_INP" edc:nzwidth="0x1" edc:desc="GPIO input from pin, independent of the Mux selection for the pin or the Direction."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL32" edc:nzwidth="0x20" edc:access="-------n-------nnnnnnnnnnnnnnnnn" edc:por="00000000000000001000000001000000" edc:mclr="00000000000000001000000001000000" edc:impl="0x101FFFF" edc:_addr="0x40081068">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="PU_PD" edc:nzwidth="0x2" edc:desc="These bits are used to enable an internal pull-up or pull-down resistor.">
              <edc:SFRFieldSemantic edc:cname="NONE" edc:desc="None. Pin tristates when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="UP" edc:desc="Pull Up Enabled" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="DOWN" edc:desc="Pull Down Enabled" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="REPEATER" edc:desc="Repeater mode. Pin is kept at previous voltage level when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="PWR_GATING" edc:nzwidth="0x2" edc:desc="The GPIO pin will be tristated when the selected power well is off."/>
            <edc:SFRFieldDef edc:cname="INTR_DET" edc:nzwidth="0x3" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="EDGE_EN" edc:nzwidth="0x1" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="OUT_BUFF_TYPE" edc:nzwidth="0x1" edc:desc="0 = Push-Pull, 1 = Open Drain"/>
            <edc:SFRFieldDef edc:cname="GPIO_DIR" edc:nzwidth="0x1" edc:desc="Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output"/>
            <edc:SFRFieldDef edc:cname="GPIO_OUT_SEL" edc:nzwidth="0x1" edc:desc="GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register."/>
            <edc:SFRFieldDef edc:cname="POL" edc:nzwidth="0x1" edc:desc="1=Inverted; 0=Non-inverted"/>
            <edc:SFRFieldDef edc:cname="MUX_CTRL" edc:nzwidth="0x3" edc:desc="00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3.">
              <edc:SFRFieldSemantic edc:cname="GPIO" edc:desc="GPIO function selected" edc:when="(field &amp; 0x7) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="FUNC1" edc:desc="Signal function 1 selected" edc:when="(field &amp; 0x7) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="FUNC2" edc:desc="Signal function 2 selected" edc:when="(field &amp; 0x7) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="FUNC3" edc:desc="Signal function 3 selected" edc:when="(field &amp; 0x7) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="INP_DIS" edc:nzwidth="0x1" edc:desc="GPIO input disable"/>
            <edc:SFRFieldDef edc:cname="ALT_GPIO_DATA" edc:nzwidth="0x1" edc:desc="GPIO Alternate Data Register."/>
            <edc:AdjustPoint edc:offset="0x7"/>
            <edc:SFRFieldDef edc:cname="GPIO_INP" edc:nzwidth="0x1" edc:desc="GPIO input from pin, independent of the Mux selection for the pin or the Direction."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL33" edc:nzwidth="0x20" edc:access="-------n-------nnnnnnnnnnnnnnnnn" edc:por="00000000000000001000000001000000" edc:mclr="00000000000000001000000001000000" edc:impl="0x101FFFF" edc:_addr="0x4008106C">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="PU_PD" edc:nzwidth="0x2" edc:desc="These bits are used to enable an internal pull-up or pull-down resistor.">
              <edc:SFRFieldSemantic edc:cname="NONE" edc:desc="None. Pin tristates when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="UP" edc:desc="Pull Up Enabled" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="DOWN" edc:desc="Pull Down Enabled" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="REPEATER" edc:desc="Repeater mode. Pin is kept at previous voltage level when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="PWR_GATING" edc:nzwidth="0x2" edc:desc="The GPIO pin will be tristated when the selected power well is off."/>
            <edc:SFRFieldDef edc:cname="INTR_DET" edc:nzwidth="0x3" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="EDGE_EN" edc:nzwidth="0x1" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="OUT_BUFF_TYPE" edc:nzwidth="0x1" edc:desc="0 = Push-Pull, 1 = Open Drain"/>
            <edc:SFRFieldDef edc:cname="GPIO_DIR" edc:nzwidth="0x1" edc:desc="Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output"/>
            <edc:SFRFieldDef edc:cname="GPIO_OUT_SEL" edc:nzwidth="0x1" edc:desc="GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register."/>
            <edc:SFRFieldDef edc:cname="POL" edc:nzwidth="0x1" edc:desc="1=Inverted; 0=Non-inverted"/>
            <edc:SFRFieldDef edc:cname="MUX_CTRL" edc:nzwidth="0x3" edc:desc="00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3.">
              <edc:SFRFieldSemantic edc:cname="GPIO" edc:desc="GPIO function selected" edc:when="(field &amp; 0x7) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="FUNC1" edc:desc="Signal function 1 selected" edc:when="(field &amp; 0x7) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="FUNC2" edc:desc="Signal function 2 selected" edc:when="(field &amp; 0x7) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="FUNC3" edc:desc="Signal function 3 selected" edc:when="(field &amp; 0x7) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="INP_DIS" edc:nzwidth="0x1" edc:desc="GPIO input disable"/>
            <edc:SFRFieldDef edc:cname="ALT_GPIO_DATA" edc:nzwidth="0x1" edc:desc="GPIO Alternate Data Register."/>
            <edc:AdjustPoint edc:offset="0x7"/>
            <edc:SFRFieldDef edc:cname="GPIO_INP" edc:nzwidth="0x1" edc:desc="GPIO input from pin, independent of the Mux selection for the pin or the Direction."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL34" edc:nzwidth="0x20" edc:access="-------n-------nnnnnnnnnnnnnnnnn" edc:por="00000000000000001000000001000000" edc:mclr="00000000000000001000000001000000" edc:impl="0x101FFFF" edc:_addr="0x40081070">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="PU_PD" edc:nzwidth="0x2" edc:desc="These bits are used to enable an internal pull-up or pull-down resistor.">
              <edc:SFRFieldSemantic edc:cname="NONE" edc:desc="None. Pin tristates when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="UP" edc:desc="Pull Up Enabled" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="DOWN" edc:desc="Pull Down Enabled" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="REPEATER" edc:desc="Repeater mode. Pin is kept at previous voltage level when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="PWR_GATING" edc:nzwidth="0x2" edc:desc="The GPIO pin will be tristated when the selected power well is off."/>
            <edc:SFRFieldDef edc:cname="INTR_DET" edc:nzwidth="0x3" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="EDGE_EN" edc:nzwidth="0x1" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="OUT_BUFF_TYPE" edc:nzwidth="0x1" edc:desc="0 = Push-Pull, 1 = Open Drain"/>
            <edc:SFRFieldDef edc:cname="GPIO_DIR" edc:nzwidth="0x1" edc:desc="Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output"/>
            <edc:SFRFieldDef edc:cname="GPIO_OUT_SEL" edc:nzwidth="0x1" edc:desc="GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register."/>
            <edc:SFRFieldDef edc:cname="POL" edc:nzwidth="0x1" edc:desc="1=Inverted; 0=Non-inverted"/>
            <edc:SFRFieldDef edc:cname="MUX_CTRL" edc:nzwidth="0x3" edc:desc="00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3.">
              <edc:SFRFieldSemantic edc:cname="GPIO" edc:desc="GPIO function selected" edc:when="(field &amp; 0x7) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="FUNC1" edc:desc="Signal function 1 selected" edc:when="(field &amp; 0x7) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="FUNC2" edc:desc="Signal function 2 selected" edc:when="(field &amp; 0x7) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="FUNC3" edc:desc="Signal function 3 selected" edc:when="(field &amp; 0x7) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="INP_DIS" edc:nzwidth="0x1" edc:desc="GPIO input disable"/>
            <edc:SFRFieldDef edc:cname="ALT_GPIO_DATA" edc:nzwidth="0x1" edc:desc="GPIO Alternate Data Register."/>
            <edc:AdjustPoint edc:offset="0x7"/>
            <edc:SFRFieldDef edc:cname="GPIO_INP" edc:nzwidth="0x1" edc:desc="GPIO input from pin, independent of the Mux selection for the pin or the Direction."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL35" edc:nzwidth="0x20" edc:access="-------n-------nnnnnnnnnnnnnnnnn" edc:por="00000000000000001000000001000000" edc:mclr="00000000000000001000000001000000" edc:impl="0x101FFFF" edc:_addr="0x40081074">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="PU_PD" edc:nzwidth="0x2" edc:desc="These bits are used to enable an internal pull-up or pull-down resistor.">
              <edc:SFRFieldSemantic edc:cname="NONE" edc:desc="None. Pin tristates when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="UP" edc:desc="Pull Up Enabled" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="DOWN" edc:desc="Pull Down Enabled" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="REPEATER" edc:desc="Repeater mode. Pin is kept at previous voltage level when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="PWR_GATING" edc:nzwidth="0x2" edc:desc="The GPIO pin will be tristated when the selected power well is off."/>
            <edc:SFRFieldDef edc:cname="INTR_DET" edc:nzwidth="0x3" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="EDGE_EN" edc:nzwidth="0x1" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="OUT_BUFF_TYPE" edc:nzwidth="0x1" edc:desc="0 = Push-Pull, 1 = Open Drain"/>
            <edc:SFRFieldDef edc:cname="GPIO_DIR" edc:nzwidth="0x1" edc:desc="Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output"/>
            <edc:SFRFieldDef edc:cname="GPIO_OUT_SEL" edc:nzwidth="0x1" edc:desc="GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register."/>
            <edc:SFRFieldDef edc:cname="POL" edc:nzwidth="0x1" edc:desc="1=Inverted; 0=Non-inverted"/>
            <edc:SFRFieldDef edc:cname="MUX_CTRL" edc:nzwidth="0x3" edc:desc="00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3.">
              <edc:SFRFieldSemantic edc:cname="GPIO" edc:desc="GPIO function selected" edc:when="(field &amp; 0x7) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="FUNC1" edc:desc="Signal function 1 selected" edc:when="(field &amp; 0x7) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="FUNC2" edc:desc="Signal function 2 selected" edc:when="(field &amp; 0x7) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="FUNC3" edc:desc="Signal function 3 selected" edc:when="(field &amp; 0x7) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="INP_DIS" edc:nzwidth="0x1" edc:desc="GPIO input disable"/>
            <edc:SFRFieldDef edc:cname="ALT_GPIO_DATA" edc:nzwidth="0x1" edc:desc="GPIO Alternate Data Register."/>
            <edc:AdjustPoint edc:offset="0x7"/>
            <edc:SFRFieldDef edc:cname="GPIO_INP" edc:nzwidth="0x1" edc:desc="GPIO input from pin, independent of the Mux selection for the pin or the Direction."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL36" edc:nzwidth="0x20" edc:access="-------n-------nnnnnnnnnnnnnnnnn" edc:por="00000000000000001000000001000000" edc:mclr="00000000000000001000000001000000" edc:impl="0x101FFFF" edc:_addr="0x40081078">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="PU_PD" edc:nzwidth="0x2" edc:desc="These bits are used to enable an internal pull-up or pull-down resistor.">
              <edc:SFRFieldSemantic edc:cname="NONE" edc:desc="None. Pin tristates when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="UP" edc:desc="Pull Up Enabled" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="DOWN" edc:desc="Pull Down Enabled" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="REPEATER" edc:desc="Repeater mode. Pin is kept at previous voltage level when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="PWR_GATING" edc:nzwidth="0x2" edc:desc="The GPIO pin will be tristated when the selected power well is off."/>
            <edc:SFRFieldDef edc:cname="INTR_DET" edc:nzwidth="0x3" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="EDGE_EN" edc:nzwidth="0x1" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="OUT_BUFF_TYPE" edc:nzwidth="0x1" edc:desc="0 = Push-Pull, 1 = Open Drain"/>
            <edc:SFRFieldDef edc:cname="GPIO_DIR" edc:nzwidth="0x1" edc:desc="Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output"/>
            <edc:SFRFieldDef edc:cname="GPIO_OUT_SEL" edc:nzwidth="0x1" edc:desc="GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register."/>
            <edc:SFRFieldDef edc:cname="POL" edc:nzwidth="0x1" edc:desc="1=Inverted; 0=Non-inverted"/>
            <edc:SFRFieldDef edc:cname="MUX_CTRL" edc:nzwidth="0x3" edc:desc="00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3.">
              <edc:SFRFieldSemantic edc:cname="GPIO" edc:desc="GPIO function selected" edc:when="(field &amp; 0x7) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="FUNC1" edc:desc="Signal function 1 selected" edc:when="(field &amp; 0x7) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="FUNC2" edc:desc="Signal function 2 selected" edc:when="(field &amp; 0x7) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="FUNC3" edc:desc="Signal function 3 selected" edc:when="(field &amp; 0x7) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="INP_DIS" edc:nzwidth="0x1" edc:desc="GPIO input disable"/>
            <edc:SFRFieldDef edc:cname="ALT_GPIO_DATA" edc:nzwidth="0x1" edc:desc="GPIO Alternate Data Register."/>
            <edc:AdjustPoint edc:offset="0x7"/>
            <edc:SFRFieldDef edc:cname="GPIO_INP" edc:nzwidth="0x1" edc:desc="GPIO input from pin, independent of the Mux selection for the pin or the Direction."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL37" edc:nzwidth="0x20" edc:access="-------n-------nnnnnnnnnnnnnnnnn" edc:por="00000000000000001000000001000000" edc:mclr="00000000000000001000000001000000" edc:impl="0x101FFFF" edc:_addr="0x4008107C">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="PU_PD" edc:nzwidth="0x2" edc:desc="These bits are used to enable an internal pull-up or pull-down resistor.">
              <edc:SFRFieldSemantic edc:cname="NONE" edc:desc="None. Pin tristates when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="UP" edc:desc="Pull Up Enabled" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="DOWN" edc:desc="Pull Down Enabled" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="REPEATER" edc:desc="Repeater mode. Pin is kept at previous voltage level when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="PWR_GATING" edc:nzwidth="0x2" edc:desc="The GPIO pin will be tristated when the selected power well is off."/>
            <edc:SFRFieldDef edc:cname="INTR_DET" edc:nzwidth="0x3" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="EDGE_EN" edc:nzwidth="0x1" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="OUT_BUFF_TYPE" edc:nzwidth="0x1" edc:desc="0 = Push-Pull, 1 = Open Drain"/>
            <edc:SFRFieldDef edc:cname="GPIO_DIR" edc:nzwidth="0x1" edc:desc="Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output"/>
            <edc:SFRFieldDef edc:cname="GPIO_OUT_SEL" edc:nzwidth="0x1" edc:desc="GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register."/>
            <edc:SFRFieldDef edc:cname="POL" edc:nzwidth="0x1" edc:desc="1=Inverted; 0=Non-inverted"/>
            <edc:SFRFieldDef edc:cname="MUX_CTRL" edc:nzwidth="0x3" edc:desc="00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3.">
              <edc:SFRFieldSemantic edc:cname="GPIO" edc:desc="GPIO function selected" edc:when="(field &amp; 0x7) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="FUNC1" edc:desc="Signal function 1 selected" edc:when="(field &amp; 0x7) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="FUNC2" edc:desc="Signal function 2 selected" edc:when="(field &amp; 0x7) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="FUNC3" edc:desc="Signal function 3 selected" edc:when="(field &amp; 0x7) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="INP_DIS" edc:nzwidth="0x1" edc:desc="GPIO input disable"/>
            <edc:SFRFieldDef edc:cname="ALT_GPIO_DATA" edc:nzwidth="0x1" edc:desc="GPIO Alternate Data Register."/>
            <edc:AdjustPoint edc:offset="0x7"/>
            <edc:SFRFieldDef edc:cname="GPIO_INP" edc:nzwidth="0x1" edc:desc="GPIO input from pin, independent of the Mux selection for the pin or the Direction."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL40" edc:nzwidth="0x20" edc:access="-------n-------nnnnnnnnnnnnnnnnn" edc:por="00000000000000001000000001000000" edc:mclr="00000000000000001000000001000000" edc:impl="0x101FFFF" edc:_addr="0x40081080">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="PU_PD" edc:nzwidth="0x2" edc:desc="These bits are used to enable an internal pull-up or pull-down resistor.">
              <edc:SFRFieldSemantic edc:cname="NONE" edc:desc="None. Pin tristates when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="UP" edc:desc="Pull Up Enabled" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="DOWN" edc:desc="Pull Down Enabled" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="REPEATER" edc:desc="Repeater mode. Pin is kept at previous voltage level when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="PWR_GATING" edc:nzwidth="0x2" edc:desc="The GPIO pin will be tristated when the selected power well is off."/>
            <edc:SFRFieldDef edc:cname="INTR_DET" edc:nzwidth="0x3" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="EDGE_EN" edc:nzwidth="0x1" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="OUT_BUFF_TYPE" edc:nzwidth="0x1" edc:desc="0 = Push-Pull, 1 = Open Drain"/>
            <edc:SFRFieldDef edc:cname="GPIO_DIR" edc:nzwidth="0x1" edc:desc="Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output"/>
            <edc:SFRFieldDef edc:cname="GPIO_OUT_SEL" edc:nzwidth="0x1" edc:desc="GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register."/>
            <edc:SFRFieldDef edc:cname="POL" edc:nzwidth="0x1" edc:desc="1=Inverted; 0=Non-inverted"/>
            <edc:SFRFieldDef edc:cname="MUX_CTRL" edc:nzwidth="0x3" edc:desc="00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3.">
              <edc:SFRFieldSemantic edc:cname="GPIO" edc:desc="GPIO function selected" edc:when="(field &amp; 0x7) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="FUNC1" edc:desc="Signal function 1 selected" edc:when="(field &amp; 0x7) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="FUNC2" edc:desc="Signal function 2 selected" edc:when="(field &amp; 0x7) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="FUNC3" edc:desc="Signal function 3 selected" edc:when="(field &amp; 0x7) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="INP_DIS" edc:nzwidth="0x1" edc:desc="GPIO input disable"/>
            <edc:SFRFieldDef edc:cname="ALT_GPIO_DATA" edc:nzwidth="0x1" edc:desc="GPIO Alternate Data Register."/>
            <edc:AdjustPoint edc:offset="0x7"/>
            <edc:SFRFieldDef edc:cname="GPIO_INP" edc:nzwidth="0x1" edc:desc="GPIO input from pin, independent of the Mux selection for the pin or the Direction."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL41" edc:nzwidth="0x20" edc:access="-------n-------nnnnnnnnnnnnnnnnn" edc:por="00000000000000001000000001000000" edc:mclr="00000000000000001000000001000000" edc:impl="0x101FFFF" edc:_addr="0x40081084">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="PU_PD" edc:nzwidth="0x2" edc:desc="These bits are used to enable an internal pull-up or pull-down resistor.">
              <edc:SFRFieldSemantic edc:cname="NONE" edc:desc="None. Pin tristates when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="UP" edc:desc="Pull Up Enabled" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="DOWN" edc:desc="Pull Down Enabled" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="REPEATER" edc:desc="Repeater mode. Pin is kept at previous voltage level when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="PWR_GATING" edc:nzwidth="0x2" edc:desc="The GPIO pin will be tristated when the selected power well is off."/>
            <edc:SFRFieldDef edc:cname="INTR_DET" edc:nzwidth="0x3" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="EDGE_EN" edc:nzwidth="0x1" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="OUT_BUFF_TYPE" edc:nzwidth="0x1" edc:desc="0 = Push-Pull, 1 = Open Drain"/>
            <edc:SFRFieldDef edc:cname="GPIO_DIR" edc:nzwidth="0x1" edc:desc="Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output"/>
            <edc:SFRFieldDef edc:cname="GPIO_OUT_SEL" edc:nzwidth="0x1" edc:desc="GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register."/>
            <edc:SFRFieldDef edc:cname="POL" edc:nzwidth="0x1" edc:desc="1=Inverted; 0=Non-inverted"/>
            <edc:SFRFieldDef edc:cname="MUX_CTRL" edc:nzwidth="0x3" edc:desc="00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3.">
              <edc:SFRFieldSemantic edc:cname="GPIO" edc:desc="GPIO function selected" edc:when="(field &amp; 0x7) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="FUNC1" edc:desc="Signal function 1 selected" edc:when="(field &amp; 0x7) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="FUNC2" edc:desc="Signal function 2 selected" edc:when="(field &amp; 0x7) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="FUNC3" edc:desc="Signal function 3 selected" edc:when="(field &amp; 0x7) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="INP_DIS" edc:nzwidth="0x1" edc:desc="GPIO input disable"/>
            <edc:SFRFieldDef edc:cname="ALT_GPIO_DATA" edc:nzwidth="0x1" edc:desc="GPIO Alternate Data Register."/>
            <edc:AdjustPoint edc:offset="0x7"/>
            <edc:SFRFieldDef edc:cname="GPIO_INP" edc:nzwidth="0x1" edc:desc="GPIO input from pin, independent of the Mux selection for the pin or the Direction."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL42" edc:nzwidth="0x20" edc:access="-------n-------nnnnnnnnnnnnnnnnn" edc:por="00000000000000001000000001000000" edc:mclr="00000000000000001000000001000000" edc:impl="0x101FFFF" edc:_addr="0x40081088">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="PU_PD" edc:nzwidth="0x2" edc:desc="These bits are used to enable an internal pull-up or pull-down resistor.">
              <edc:SFRFieldSemantic edc:cname="NONE" edc:desc="None. Pin tristates when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="UP" edc:desc="Pull Up Enabled" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="DOWN" edc:desc="Pull Down Enabled" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="REPEATER" edc:desc="Repeater mode. Pin is kept at previous voltage level when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="PWR_GATING" edc:nzwidth="0x2" edc:desc="The GPIO pin will be tristated when the selected power well is off."/>
            <edc:SFRFieldDef edc:cname="INTR_DET" edc:nzwidth="0x3" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="EDGE_EN" edc:nzwidth="0x1" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="OUT_BUFF_TYPE" edc:nzwidth="0x1" edc:desc="0 = Push-Pull, 1 = Open Drain"/>
            <edc:SFRFieldDef edc:cname="GPIO_DIR" edc:nzwidth="0x1" edc:desc="Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output"/>
            <edc:SFRFieldDef edc:cname="GPIO_OUT_SEL" edc:nzwidth="0x1" edc:desc="GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register."/>
            <edc:SFRFieldDef edc:cname="POL" edc:nzwidth="0x1" edc:desc="1=Inverted; 0=Non-inverted"/>
            <edc:SFRFieldDef edc:cname="MUX_CTRL" edc:nzwidth="0x3" edc:desc="00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3.">
              <edc:SFRFieldSemantic edc:cname="GPIO" edc:desc="GPIO function selected" edc:when="(field &amp; 0x7) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="FUNC1" edc:desc="Signal function 1 selected" edc:when="(field &amp; 0x7) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="FUNC2" edc:desc="Signal function 2 selected" edc:when="(field &amp; 0x7) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="FUNC3" edc:desc="Signal function 3 selected" edc:when="(field &amp; 0x7) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="INP_DIS" edc:nzwidth="0x1" edc:desc="GPIO input disable"/>
            <edc:SFRFieldDef edc:cname="ALT_GPIO_DATA" edc:nzwidth="0x1" edc:desc="GPIO Alternate Data Register."/>
            <edc:AdjustPoint edc:offset="0x7"/>
            <edc:SFRFieldDef edc:cname="GPIO_INP" edc:nzwidth="0x1" edc:desc="GPIO input from pin, independent of the Mux selection for the pin or the Direction."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL43" edc:nzwidth="0x20" edc:access="-------n-------nnnnnnnnnnnnnnnnn" edc:por="00000000000000001000000001000000" edc:mclr="00000000000000001000000001000000" edc:impl="0x101FFFF" edc:_addr="0x4008108C">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="PU_PD" edc:nzwidth="0x2" edc:desc="These bits are used to enable an internal pull-up or pull-down resistor.">
              <edc:SFRFieldSemantic edc:cname="NONE" edc:desc="None. Pin tristates when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="UP" edc:desc="Pull Up Enabled" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="DOWN" edc:desc="Pull Down Enabled" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="REPEATER" edc:desc="Repeater mode. Pin is kept at previous voltage level when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="PWR_GATING" edc:nzwidth="0x2" edc:desc="The GPIO pin will be tristated when the selected power well is off."/>
            <edc:SFRFieldDef edc:cname="INTR_DET" edc:nzwidth="0x3" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="EDGE_EN" edc:nzwidth="0x1" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="OUT_BUFF_TYPE" edc:nzwidth="0x1" edc:desc="0 = Push-Pull, 1 = Open Drain"/>
            <edc:SFRFieldDef edc:cname="GPIO_DIR" edc:nzwidth="0x1" edc:desc="Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output"/>
            <edc:SFRFieldDef edc:cname="GPIO_OUT_SEL" edc:nzwidth="0x1" edc:desc="GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register."/>
            <edc:SFRFieldDef edc:cname="POL" edc:nzwidth="0x1" edc:desc="1=Inverted; 0=Non-inverted"/>
            <edc:SFRFieldDef edc:cname="MUX_CTRL" edc:nzwidth="0x3" edc:desc="00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3.">
              <edc:SFRFieldSemantic edc:cname="GPIO" edc:desc="GPIO function selected" edc:when="(field &amp; 0x7) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="FUNC1" edc:desc="Signal function 1 selected" edc:when="(field &amp; 0x7) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="FUNC2" edc:desc="Signal function 2 selected" edc:when="(field &amp; 0x7) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="FUNC3" edc:desc="Signal function 3 selected" edc:when="(field &amp; 0x7) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="INP_DIS" edc:nzwidth="0x1" edc:desc="GPIO input disable"/>
            <edc:SFRFieldDef edc:cname="ALT_GPIO_DATA" edc:nzwidth="0x1" edc:desc="GPIO Alternate Data Register."/>
            <edc:AdjustPoint edc:offset="0x7"/>
            <edc:SFRFieldDef edc:cname="GPIO_INP" edc:nzwidth="0x1" edc:desc="GPIO input from pin, independent of the Mux selection for the pin or the Direction."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL44" edc:nzwidth="0x20" edc:access="-------n-------nnnnnnnnnnnnnnnnn" edc:por="00000000000000001000000001000000" edc:mclr="00000000000000001000000001000000" edc:impl="0x101FFFF" edc:_addr="0x40081090">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="PU_PD" edc:nzwidth="0x2" edc:desc="These bits are used to enable an internal pull-up or pull-down resistor.">
              <edc:SFRFieldSemantic edc:cname="NONE" edc:desc="None. Pin tristates when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="UP" edc:desc="Pull Up Enabled" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="DOWN" edc:desc="Pull Down Enabled" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="REPEATER" edc:desc="Repeater mode. Pin is kept at previous voltage level when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="PWR_GATING" edc:nzwidth="0x2" edc:desc="The GPIO pin will be tristated when the selected power well is off."/>
            <edc:SFRFieldDef edc:cname="INTR_DET" edc:nzwidth="0x3" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="EDGE_EN" edc:nzwidth="0x1" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="OUT_BUFF_TYPE" edc:nzwidth="0x1" edc:desc="0 = Push-Pull, 1 = Open Drain"/>
            <edc:SFRFieldDef edc:cname="GPIO_DIR" edc:nzwidth="0x1" edc:desc="Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output"/>
            <edc:SFRFieldDef edc:cname="GPIO_OUT_SEL" edc:nzwidth="0x1" edc:desc="GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register."/>
            <edc:SFRFieldDef edc:cname="POL" edc:nzwidth="0x1" edc:desc="1=Inverted; 0=Non-inverted"/>
            <edc:SFRFieldDef edc:cname="MUX_CTRL" edc:nzwidth="0x3" edc:desc="00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3.">
              <edc:SFRFieldSemantic edc:cname="GPIO" edc:desc="GPIO function selected" edc:when="(field &amp; 0x7) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="FUNC1" edc:desc="Signal function 1 selected" edc:when="(field &amp; 0x7) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="FUNC2" edc:desc="Signal function 2 selected" edc:when="(field &amp; 0x7) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="FUNC3" edc:desc="Signal function 3 selected" edc:when="(field &amp; 0x7) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="INP_DIS" edc:nzwidth="0x1" edc:desc="GPIO input disable"/>
            <edc:SFRFieldDef edc:cname="ALT_GPIO_DATA" edc:nzwidth="0x1" edc:desc="GPIO Alternate Data Register."/>
            <edc:AdjustPoint edc:offset="0x7"/>
            <edc:SFRFieldDef edc:cname="GPIO_INP" edc:nzwidth="0x1" edc:desc="GPIO input from pin, independent of the Mux selection for the pin or the Direction."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL45" edc:nzwidth="0x20" edc:access="-------n-------nnnnnnnnnnnnnnnnn" edc:por="00000000000000001000000001000000" edc:mclr="00000000000000001000000001000000" edc:impl="0x101FFFF" edc:_addr="0x40081094">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="PU_PD" edc:nzwidth="0x2" edc:desc="These bits are used to enable an internal pull-up or pull-down resistor.">
              <edc:SFRFieldSemantic edc:cname="NONE" edc:desc="None. Pin tristates when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="UP" edc:desc="Pull Up Enabled" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="DOWN" edc:desc="Pull Down Enabled" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="REPEATER" edc:desc="Repeater mode. Pin is kept at previous voltage level when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="PWR_GATING" edc:nzwidth="0x2" edc:desc="The GPIO pin will be tristated when the selected power well is off."/>
            <edc:SFRFieldDef edc:cname="INTR_DET" edc:nzwidth="0x3" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="EDGE_EN" edc:nzwidth="0x1" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="OUT_BUFF_TYPE" edc:nzwidth="0x1" edc:desc="0 = Push-Pull, 1 = Open Drain"/>
            <edc:SFRFieldDef edc:cname="GPIO_DIR" edc:nzwidth="0x1" edc:desc="Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output"/>
            <edc:SFRFieldDef edc:cname="GPIO_OUT_SEL" edc:nzwidth="0x1" edc:desc="GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register."/>
            <edc:SFRFieldDef edc:cname="POL" edc:nzwidth="0x1" edc:desc="1=Inverted; 0=Non-inverted"/>
            <edc:SFRFieldDef edc:cname="MUX_CTRL" edc:nzwidth="0x3" edc:desc="00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3.">
              <edc:SFRFieldSemantic edc:cname="GPIO" edc:desc="GPIO function selected" edc:when="(field &amp; 0x7) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="FUNC1" edc:desc="Signal function 1 selected" edc:when="(field &amp; 0x7) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="FUNC2" edc:desc="Signal function 2 selected" edc:when="(field &amp; 0x7) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="FUNC3" edc:desc="Signal function 3 selected" edc:when="(field &amp; 0x7) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="INP_DIS" edc:nzwidth="0x1" edc:desc="GPIO input disable"/>
            <edc:SFRFieldDef edc:cname="ALT_GPIO_DATA" edc:nzwidth="0x1" edc:desc="GPIO Alternate Data Register."/>
            <edc:AdjustPoint edc:offset="0x7"/>
            <edc:SFRFieldDef edc:cname="GPIO_INP" edc:nzwidth="0x1" edc:desc="GPIO input from pin, independent of the Mux selection for the pin or the Direction."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL46" edc:nzwidth="0x20" edc:access="-------n-------nnnnnnnnnnnnnnnnn" edc:por="00000000000000001000000001000000" edc:mclr="00000000000000001000000001000000" edc:impl="0x101FFFF" edc:_addr="0x40081098">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="PU_PD" edc:nzwidth="0x2" edc:desc="These bits are used to enable an internal pull-up or pull-down resistor.">
              <edc:SFRFieldSemantic edc:cname="NONE" edc:desc="None. Pin tristates when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="UP" edc:desc="Pull Up Enabled" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="DOWN" edc:desc="Pull Down Enabled" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="REPEATER" edc:desc="Repeater mode. Pin is kept at previous voltage level when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="PWR_GATING" edc:nzwidth="0x2" edc:desc="The GPIO pin will be tristated when the selected power well is off."/>
            <edc:SFRFieldDef edc:cname="INTR_DET" edc:nzwidth="0x3" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="EDGE_EN" edc:nzwidth="0x1" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="OUT_BUFF_TYPE" edc:nzwidth="0x1" edc:desc="0 = Push-Pull, 1 = Open Drain"/>
            <edc:SFRFieldDef edc:cname="GPIO_DIR" edc:nzwidth="0x1" edc:desc="Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output"/>
            <edc:SFRFieldDef edc:cname="GPIO_OUT_SEL" edc:nzwidth="0x1" edc:desc="GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register."/>
            <edc:SFRFieldDef edc:cname="POL" edc:nzwidth="0x1" edc:desc="1=Inverted; 0=Non-inverted"/>
            <edc:SFRFieldDef edc:cname="MUX_CTRL" edc:nzwidth="0x3" edc:desc="00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3.">
              <edc:SFRFieldSemantic edc:cname="GPIO" edc:desc="GPIO function selected" edc:when="(field &amp; 0x7) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="FUNC1" edc:desc="Signal function 1 selected" edc:when="(field &amp; 0x7) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="FUNC2" edc:desc="Signal function 2 selected" edc:when="(field &amp; 0x7) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="FUNC3" edc:desc="Signal function 3 selected" edc:when="(field &amp; 0x7) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="INP_DIS" edc:nzwidth="0x1" edc:desc="GPIO input disable"/>
            <edc:SFRFieldDef edc:cname="ALT_GPIO_DATA" edc:nzwidth="0x1" edc:desc="GPIO Alternate Data Register."/>
            <edc:AdjustPoint edc:offset="0x7"/>
            <edc:SFRFieldDef edc:cname="GPIO_INP" edc:nzwidth="0x1" edc:desc="GPIO input from pin, independent of the Mux selection for the pin or the Direction."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL47" edc:nzwidth="0x20" edc:access="-------n-------nnnnnnnnnnnnnnnnn" edc:por="00000000000000001000000001000000" edc:mclr="00000000000000001000000001000000" edc:impl="0x101FFFF" edc:_addr="0x4008109C">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="PU_PD" edc:nzwidth="0x2" edc:desc="These bits are used to enable an internal pull-up or pull-down resistor.">
              <edc:SFRFieldSemantic edc:cname="NONE" edc:desc="None. Pin tristates when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="UP" edc:desc="Pull Up Enabled" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="DOWN" edc:desc="Pull Down Enabled" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="REPEATER" edc:desc="Repeater mode. Pin is kept at previous voltage level when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="PWR_GATING" edc:nzwidth="0x2" edc:desc="The GPIO pin will be tristated when the selected power well is off."/>
            <edc:SFRFieldDef edc:cname="INTR_DET" edc:nzwidth="0x3" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="EDGE_EN" edc:nzwidth="0x1" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="OUT_BUFF_TYPE" edc:nzwidth="0x1" edc:desc="0 = Push-Pull, 1 = Open Drain"/>
            <edc:SFRFieldDef edc:cname="GPIO_DIR" edc:nzwidth="0x1" edc:desc="Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output"/>
            <edc:SFRFieldDef edc:cname="GPIO_OUT_SEL" edc:nzwidth="0x1" edc:desc="GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register."/>
            <edc:SFRFieldDef edc:cname="POL" edc:nzwidth="0x1" edc:desc="1=Inverted; 0=Non-inverted"/>
            <edc:SFRFieldDef edc:cname="MUX_CTRL" edc:nzwidth="0x3" edc:desc="00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3.">
              <edc:SFRFieldSemantic edc:cname="GPIO" edc:desc="GPIO function selected" edc:when="(field &amp; 0x7) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="FUNC1" edc:desc="Signal function 1 selected" edc:when="(field &amp; 0x7) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="FUNC2" edc:desc="Signal function 2 selected" edc:when="(field &amp; 0x7) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="FUNC3" edc:desc="Signal function 3 selected" edc:when="(field &amp; 0x7) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="INP_DIS" edc:nzwidth="0x1" edc:desc="GPIO input disable"/>
            <edc:SFRFieldDef edc:cname="ALT_GPIO_DATA" edc:nzwidth="0x1" edc:desc="GPIO Alternate Data Register."/>
            <edc:AdjustPoint edc:offset="0x7"/>
            <edc:SFRFieldDef edc:cname="GPIO_INP" edc:nzwidth="0x1" edc:desc="GPIO input from pin, independent of the Mux selection for the pin or the Direction."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL50" edc:nzwidth="0x20" edc:access="-------n-------nnnnnnnnnnnnnnnnn" edc:por="00000000000000001000000001000000" edc:mclr="00000000000000001000000001000000" edc:impl="0x101FFFF" edc:_addr="0x400810A0">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="PU_PD" edc:nzwidth="0x2" edc:desc="These bits are used to enable an internal pull-up or pull-down resistor.">
              <edc:SFRFieldSemantic edc:cname="NONE" edc:desc="None. Pin tristates when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="UP" edc:desc="Pull Up Enabled" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="DOWN" edc:desc="Pull Down Enabled" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="REPEATER" edc:desc="Repeater mode. Pin is kept at previous voltage level when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="PWR_GATING" edc:nzwidth="0x2" edc:desc="The GPIO pin will be tristated when the selected power well is off."/>
            <edc:SFRFieldDef edc:cname="INTR_DET" edc:nzwidth="0x3" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="EDGE_EN" edc:nzwidth="0x1" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="OUT_BUFF_TYPE" edc:nzwidth="0x1" edc:desc="0 = Push-Pull, 1 = Open Drain"/>
            <edc:SFRFieldDef edc:cname="GPIO_DIR" edc:nzwidth="0x1" edc:desc="Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output"/>
            <edc:SFRFieldDef edc:cname="GPIO_OUT_SEL" edc:nzwidth="0x1" edc:desc="GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register."/>
            <edc:SFRFieldDef edc:cname="POL" edc:nzwidth="0x1" edc:desc="1=Inverted; 0=Non-inverted"/>
            <edc:SFRFieldDef edc:cname="MUX_CTRL" edc:nzwidth="0x3" edc:desc="00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3.">
              <edc:SFRFieldSemantic edc:cname="GPIO" edc:desc="GPIO function selected" edc:when="(field &amp; 0x7) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="FUNC1" edc:desc="Signal function 1 selected" edc:when="(field &amp; 0x7) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="FUNC2" edc:desc="Signal function 2 selected" edc:when="(field &amp; 0x7) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="FUNC3" edc:desc="Signal function 3 selected" edc:when="(field &amp; 0x7) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="INP_DIS" edc:nzwidth="0x1" edc:desc="GPIO input disable"/>
            <edc:SFRFieldDef edc:cname="ALT_GPIO_DATA" edc:nzwidth="0x1" edc:desc="GPIO Alternate Data Register."/>
            <edc:AdjustPoint edc:offset="0x7"/>
            <edc:SFRFieldDef edc:cname="GPIO_INP" edc:nzwidth="0x1" edc:desc="GPIO input from pin, independent of the Mux selection for the pin or the Direction."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL51" edc:nzwidth="0x20" edc:access="-------n-------nnnnnnnnnnnnnnnnn" edc:por="00000000000000001000000001000000" edc:mclr="00000000000000001000000001000000" edc:impl="0x101FFFF" edc:_addr="0x400810A4">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="PU_PD" edc:nzwidth="0x2" edc:desc="These bits are used to enable an internal pull-up or pull-down resistor.">
              <edc:SFRFieldSemantic edc:cname="NONE" edc:desc="None. Pin tristates when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="UP" edc:desc="Pull Up Enabled" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="DOWN" edc:desc="Pull Down Enabled" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="REPEATER" edc:desc="Repeater mode. Pin is kept at previous voltage level when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="PWR_GATING" edc:nzwidth="0x2" edc:desc="The GPIO pin will be tristated when the selected power well is off."/>
            <edc:SFRFieldDef edc:cname="INTR_DET" edc:nzwidth="0x3" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="EDGE_EN" edc:nzwidth="0x1" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="OUT_BUFF_TYPE" edc:nzwidth="0x1" edc:desc="0 = Push-Pull, 1 = Open Drain"/>
            <edc:SFRFieldDef edc:cname="GPIO_DIR" edc:nzwidth="0x1" edc:desc="Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output"/>
            <edc:SFRFieldDef edc:cname="GPIO_OUT_SEL" edc:nzwidth="0x1" edc:desc="GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register."/>
            <edc:SFRFieldDef edc:cname="POL" edc:nzwidth="0x1" edc:desc="1=Inverted; 0=Non-inverted"/>
            <edc:SFRFieldDef edc:cname="MUX_CTRL" edc:nzwidth="0x3" edc:desc="00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3.">
              <edc:SFRFieldSemantic edc:cname="GPIO" edc:desc="GPIO function selected" edc:when="(field &amp; 0x7) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="FUNC1" edc:desc="Signal function 1 selected" edc:when="(field &amp; 0x7) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="FUNC2" edc:desc="Signal function 2 selected" edc:when="(field &amp; 0x7) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="FUNC3" edc:desc="Signal function 3 selected" edc:when="(field &amp; 0x7) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="INP_DIS" edc:nzwidth="0x1" edc:desc="GPIO input disable"/>
            <edc:SFRFieldDef edc:cname="ALT_GPIO_DATA" edc:nzwidth="0x1" edc:desc="GPIO Alternate Data Register."/>
            <edc:AdjustPoint edc:offset="0x7"/>
            <edc:SFRFieldDef edc:cname="GPIO_INP" edc:nzwidth="0x1" edc:desc="GPIO input from pin, independent of the Mux selection for the pin or the Direction."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL52" edc:nzwidth="0x20" edc:access="-------n-------nnnnnnnnnnnnnnnnn" edc:por="00000000000000001000000001000000" edc:mclr="00000000000000001000000001000000" edc:impl="0x101FFFF" edc:_addr="0x400810A8">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="PU_PD" edc:nzwidth="0x2" edc:desc="These bits are used to enable an internal pull-up or pull-down resistor.">
              <edc:SFRFieldSemantic edc:cname="NONE" edc:desc="None. Pin tristates when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="UP" edc:desc="Pull Up Enabled" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="DOWN" edc:desc="Pull Down Enabled" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="REPEATER" edc:desc="Repeater mode. Pin is kept at previous voltage level when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="PWR_GATING" edc:nzwidth="0x2" edc:desc="The GPIO pin will be tristated when the selected power well is off."/>
            <edc:SFRFieldDef edc:cname="INTR_DET" edc:nzwidth="0x3" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="EDGE_EN" edc:nzwidth="0x1" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="OUT_BUFF_TYPE" edc:nzwidth="0x1" edc:desc="0 = Push-Pull, 1 = Open Drain"/>
            <edc:SFRFieldDef edc:cname="GPIO_DIR" edc:nzwidth="0x1" edc:desc="Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output"/>
            <edc:SFRFieldDef edc:cname="GPIO_OUT_SEL" edc:nzwidth="0x1" edc:desc="GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register."/>
            <edc:SFRFieldDef edc:cname="POL" edc:nzwidth="0x1" edc:desc="1=Inverted; 0=Non-inverted"/>
            <edc:SFRFieldDef edc:cname="MUX_CTRL" edc:nzwidth="0x3" edc:desc="00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3.">
              <edc:SFRFieldSemantic edc:cname="GPIO" edc:desc="GPIO function selected" edc:when="(field &amp; 0x7) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="FUNC1" edc:desc="Signal function 1 selected" edc:when="(field &amp; 0x7) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="FUNC2" edc:desc="Signal function 2 selected" edc:when="(field &amp; 0x7) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="FUNC3" edc:desc="Signal function 3 selected" edc:when="(field &amp; 0x7) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="INP_DIS" edc:nzwidth="0x1" edc:desc="GPIO input disable"/>
            <edc:SFRFieldDef edc:cname="ALT_GPIO_DATA" edc:nzwidth="0x1" edc:desc="GPIO Alternate Data Register."/>
            <edc:AdjustPoint edc:offset="0x7"/>
            <edc:SFRFieldDef edc:cname="GPIO_INP" edc:nzwidth="0x1" edc:desc="GPIO input from pin, independent of the Mux selection for the pin or the Direction."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL53" edc:nzwidth="0x20" edc:access="-------n-------nnnnnnnnnnnnnnnnn" edc:por="00000000000000001000000001000000" edc:mclr="00000000000000001000000001000000" edc:impl="0x101FFFF" edc:_addr="0x400810AC">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="PU_PD" edc:nzwidth="0x2" edc:desc="These bits are used to enable an internal pull-up or pull-down resistor.">
              <edc:SFRFieldSemantic edc:cname="NONE" edc:desc="None. Pin tristates when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="UP" edc:desc="Pull Up Enabled" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="DOWN" edc:desc="Pull Down Enabled" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="REPEATER" edc:desc="Repeater mode. Pin is kept at previous voltage level when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="PWR_GATING" edc:nzwidth="0x2" edc:desc="The GPIO pin will be tristated when the selected power well is off."/>
            <edc:SFRFieldDef edc:cname="INTR_DET" edc:nzwidth="0x3" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="EDGE_EN" edc:nzwidth="0x1" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="OUT_BUFF_TYPE" edc:nzwidth="0x1" edc:desc="0 = Push-Pull, 1 = Open Drain"/>
            <edc:SFRFieldDef edc:cname="GPIO_DIR" edc:nzwidth="0x1" edc:desc="Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output"/>
            <edc:SFRFieldDef edc:cname="GPIO_OUT_SEL" edc:nzwidth="0x1" edc:desc="GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register."/>
            <edc:SFRFieldDef edc:cname="POL" edc:nzwidth="0x1" edc:desc="1=Inverted; 0=Non-inverted"/>
            <edc:SFRFieldDef edc:cname="MUX_CTRL" edc:nzwidth="0x3" edc:desc="00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3.">
              <edc:SFRFieldSemantic edc:cname="GPIO" edc:desc="GPIO function selected" edc:when="(field &amp; 0x7) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="FUNC1" edc:desc="Signal function 1 selected" edc:when="(field &amp; 0x7) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="FUNC2" edc:desc="Signal function 2 selected" edc:when="(field &amp; 0x7) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="FUNC3" edc:desc="Signal function 3 selected" edc:when="(field &amp; 0x7) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="INP_DIS" edc:nzwidth="0x1" edc:desc="GPIO input disable"/>
            <edc:SFRFieldDef edc:cname="ALT_GPIO_DATA" edc:nzwidth="0x1" edc:desc="GPIO Alternate Data Register."/>
            <edc:AdjustPoint edc:offset="0x7"/>
            <edc:SFRFieldDef edc:cname="GPIO_INP" edc:nzwidth="0x1" edc:desc="GPIO input from pin, independent of the Mux selection for the pin or the Direction."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL54" edc:nzwidth="0x20" edc:access="-------n-------nnnnnnnnnnnnnnnnn" edc:por="00000000000000001000000001000000" edc:mclr="00000000000000001000000001000000" edc:impl="0x101FFFF" edc:_addr="0x400810B0">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="PU_PD" edc:nzwidth="0x2" edc:desc="These bits are used to enable an internal pull-up or pull-down resistor.">
              <edc:SFRFieldSemantic edc:cname="NONE" edc:desc="None. Pin tristates when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="UP" edc:desc="Pull Up Enabled" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="DOWN" edc:desc="Pull Down Enabled" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="REPEATER" edc:desc="Repeater mode. Pin is kept at previous voltage level when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="PWR_GATING" edc:nzwidth="0x2" edc:desc="The GPIO pin will be tristated when the selected power well is off."/>
            <edc:SFRFieldDef edc:cname="INTR_DET" edc:nzwidth="0x3" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="EDGE_EN" edc:nzwidth="0x1" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="OUT_BUFF_TYPE" edc:nzwidth="0x1" edc:desc="0 = Push-Pull, 1 = Open Drain"/>
            <edc:SFRFieldDef edc:cname="GPIO_DIR" edc:nzwidth="0x1" edc:desc="Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output"/>
            <edc:SFRFieldDef edc:cname="GPIO_OUT_SEL" edc:nzwidth="0x1" edc:desc="GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register."/>
            <edc:SFRFieldDef edc:cname="POL" edc:nzwidth="0x1" edc:desc="1=Inverted; 0=Non-inverted"/>
            <edc:SFRFieldDef edc:cname="MUX_CTRL" edc:nzwidth="0x3" edc:desc="00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3.">
              <edc:SFRFieldSemantic edc:cname="GPIO" edc:desc="GPIO function selected" edc:when="(field &amp; 0x7) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="FUNC1" edc:desc="Signal function 1 selected" edc:when="(field &amp; 0x7) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="FUNC2" edc:desc="Signal function 2 selected" edc:when="(field &amp; 0x7) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="FUNC3" edc:desc="Signal function 3 selected" edc:when="(field &amp; 0x7) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="INP_DIS" edc:nzwidth="0x1" edc:desc="GPIO input disable"/>
            <edc:SFRFieldDef edc:cname="ALT_GPIO_DATA" edc:nzwidth="0x1" edc:desc="GPIO Alternate Data Register."/>
            <edc:AdjustPoint edc:offset="0x7"/>
            <edc:SFRFieldDef edc:cname="GPIO_INP" edc:nzwidth="0x1" edc:desc="GPIO input from pin, independent of the Mux selection for the pin or the Direction."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL55" edc:nzwidth="0x20" edc:access="-------n-------nnnnnnnnnnnnnnnnn" edc:por="00000000000000001000000001000000" edc:mclr="00000000000000001000000001000000" edc:impl="0x101FFFF" edc:_addr="0x400810B4">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="PU_PD" edc:nzwidth="0x2" edc:desc="These bits are used to enable an internal pull-up or pull-down resistor.">
              <edc:SFRFieldSemantic edc:cname="NONE" edc:desc="None. Pin tristates when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="UP" edc:desc="Pull Up Enabled" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="DOWN" edc:desc="Pull Down Enabled" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="REPEATER" edc:desc="Repeater mode. Pin is kept at previous voltage level when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="PWR_GATING" edc:nzwidth="0x2" edc:desc="The GPIO pin will be tristated when the selected power well is off."/>
            <edc:SFRFieldDef edc:cname="INTR_DET" edc:nzwidth="0x3" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="EDGE_EN" edc:nzwidth="0x1" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="OUT_BUFF_TYPE" edc:nzwidth="0x1" edc:desc="0 = Push-Pull, 1 = Open Drain"/>
            <edc:SFRFieldDef edc:cname="GPIO_DIR" edc:nzwidth="0x1" edc:desc="Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output"/>
            <edc:SFRFieldDef edc:cname="GPIO_OUT_SEL" edc:nzwidth="0x1" edc:desc="GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register."/>
            <edc:SFRFieldDef edc:cname="POL" edc:nzwidth="0x1" edc:desc="1=Inverted; 0=Non-inverted"/>
            <edc:SFRFieldDef edc:cname="MUX_CTRL" edc:nzwidth="0x3" edc:desc="00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3.">
              <edc:SFRFieldSemantic edc:cname="GPIO" edc:desc="GPIO function selected" edc:when="(field &amp; 0x7) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="FUNC1" edc:desc="Signal function 1 selected" edc:when="(field &amp; 0x7) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="FUNC2" edc:desc="Signal function 2 selected" edc:when="(field &amp; 0x7) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="FUNC3" edc:desc="Signal function 3 selected" edc:when="(field &amp; 0x7) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="INP_DIS" edc:nzwidth="0x1" edc:desc="GPIO input disable"/>
            <edc:SFRFieldDef edc:cname="ALT_GPIO_DATA" edc:nzwidth="0x1" edc:desc="GPIO Alternate Data Register."/>
            <edc:AdjustPoint edc:offset="0x7"/>
            <edc:SFRFieldDef edc:cname="GPIO_INP" edc:nzwidth="0x1" edc:desc="GPIO input from pin, independent of the Mux selection for the pin or the Direction."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL56" edc:nzwidth="0x20" edc:access="-------n-------nnnnnnnnnnnnnnnnn" edc:por="00000000000000001000000001000000" edc:mclr="00000000000000001000000001000000" edc:impl="0x101FFFF" edc:_addr="0x400810B8">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="PU_PD" edc:nzwidth="0x2" edc:desc="These bits are used to enable an internal pull-up or pull-down resistor.">
              <edc:SFRFieldSemantic edc:cname="NONE" edc:desc="None. Pin tristates when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="UP" edc:desc="Pull Up Enabled" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="DOWN" edc:desc="Pull Down Enabled" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="REPEATER" edc:desc="Repeater mode. Pin is kept at previous voltage level when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="PWR_GATING" edc:nzwidth="0x2" edc:desc="The GPIO pin will be tristated when the selected power well is off."/>
            <edc:SFRFieldDef edc:cname="INTR_DET" edc:nzwidth="0x3" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="EDGE_EN" edc:nzwidth="0x1" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="OUT_BUFF_TYPE" edc:nzwidth="0x1" edc:desc="0 = Push-Pull, 1 = Open Drain"/>
            <edc:SFRFieldDef edc:cname="GPIO_DIR" edc:nzwidth="0x1" edc:desc="Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output"/>
            <edc:SFRFieldDef edc:cname="GPIO_OUT_SEL" edc:nzwidth="0x1" edc:desc="GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register."/>
            <edc:SFRFieldDef edc:cname="POL" edc:nzwidth="0x1" edc:desc="1=Inverted; 0=Non-inverted"/>
            <edc:SFRFieldDef edc:cname="MUX_CTRL" edc:nzwidth="0x3" edc:desc="00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3.">
              <edc:SFRFieldSemantic edc:cname="GPIO" edc:desc="GPIO function selected" edc:when="(field &amp; 0x7) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="FUNC1" edc:desc="Signal function 1 selected" edc:when="(field &amp; 0x7) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="FUNC2" edc:desc="Signal function 2 selected" edc:when="(field &amp; 0x7) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="FUNC3" edc:desc="Signal function 3 selected" edc:when="(field &amp; 0x7) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="INP_DIS" edc:nzwidth="0x1" edc:desc="GPIO input disable"/>
            <edc:SFRFieldDef edc:cname="ALT_GPIO_DATA" edc:nzwidth="0x1" edc:desc="GPIO Alternate Data Register."/>
            <edc:AdjustPoint edc:offset="0x7"/>
            <edc:SFRFieldDef edc:cname="GPIO_INP" edc:nzwidth="0x1" edc:desc="GPIO input from pin, independent of the Mux selection for the pin or the Direction."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL57" edc:nzwidth="0x20" edc:access="-------n-------nnnnnnnnnnnnnnnnn" edc:por="00000000000000001000000001000000" edc:mclr="00000000000000001000000001000000" edc:impl="0x101FFFF" edc:_addr="0x400810BC">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="PU_PD" edc:nzwidth="0x2" edc:desc="These bits are used to enable an internal pull-up or pull-down resistor.">
              <edc:SFRFieldSemantic edc:cname="NONE" edc:desc="None. Pin tristates when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="UP" edc:desc="Pull Up Enabled" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="DOWN" edc:desc="Pull Down Enabled" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="REPEATER" edc:desc="Repeater mode. Pin is kept at previous voltage level when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="PWR_GATING" edc:nzwidth="0x2" edc:desc="The GPIO pin will be tristated when the selected power well is off."/>
            <edc:SFRFieldDef edc:cname="INTR_DET" edc:nzwidth="0x3" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="EDGE_EN" edc:nzwidth="0x1" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="OUT_BUFF_TYPE" edc:nzwidth="0x1" edc:desc="0 = Push-Pull, 1 = Open Drain"/>
            <edc:SFRFieldDef edc:cname="GPIO_DIR" edc:nzwidth="0x1" edc:desc="Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output"/>
            <edc:SFRFieldDef edc:cname="GPIO_OUT_SEL" edc:nzwidth="0x1" edc:desc="GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register."/>
            <edc:SFRFieldDef edc:cname="POL" edc:nzwidth="0x1" edc:desc="1=Inverted; 0=Non-inverted"/>
            <edc:SFRFieldDef edc:cname="MUX_CTRL" edc:nzwidth="0x3" edc:desc="00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3.">
              <edc:SFRFieldSemantic edc:cname="GPIO" edc:desc="GPIO function selected" edc:when="(field &amp; 0x7) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="FUNC1" edc:desc="Signal function 1 selected" edc:when="(field &amp; 0x7) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="FUNC2" edc:desc="Signal function 2 selected" edc:when="(field &amp; 0x7) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="FUNC3" edc:desc="Signal function 3 selected" edc:when="(field &amp; 0x7) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="INP_DIS" edc:nzwidth="0x1" edc:desc="GPIO input disable"/>
            <edc:SFRFieldDef edc:cname="ALT_GPIO_DATA" edc:nzwidth="0x1" edc:desc="GPIO Alternate Data Register."/>
            <edc:AdjustPoint edc:offset="0x7"/>
            <edc:SFRFieldDef edc:cname="GPIO_INP" edc:nzwidth="0x1" edc:desc="GPIO input from pin, independent of the Mux selection for the pin or the Direction."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL60" edc:nzwidth="0x20" edc:access="-------n-------nnnnnnnnnnnnnnnnn" edc:por="00000000000000001000000001000000" edc:mclr="00000000000000001000000001000000" edc:impl="0x101FFFF" edc:_addr="0x400810C0">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="PU_PD" edc:nzwidth="0x2" edc:desc="These bits are used to enable an internal pull-up or pull-down resistor.">
              <edc:SFRFieldSemantic edc:cname="NONE" edc:desc="None. Pin tristates when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="UP" edc:desc="Pull Up Enabled" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="DOWN" edc:desc="Pull Down Enabled" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="REPEATER" edc:desc="Repeater mode. Pin is kept at previous voltage level when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="PWR_GATING" edc:nzwidth="0x2" edc:desc="The GPIO pin will be tristated when the selected power well is off."/>
            <edc:SFRFieldDef edc:cname="INTR_DET" edc:nzwidth="0x3" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="EDGE_EN" edc:nzwidth="0x1" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="OUT_BUFF_TYPE" edc:nzwidth="0x1" edc:desc="0 = Push-Pull, 1 = Open Drain"/>
            <edc:SFRFieldDef edc:cname="GPIO_DIR" edc:nzwidth="0x1" edc:desc="Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output"/>
            <edc:SFRFieldDef edc:cname="GPIO_OUT_SEL" edc:nzwidth="0x1" edc:desc="GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register."/>
            <edc:SFRFieldDef edc:cname="POL" edc:nzwidth="0x1" edc:desc="1=Inverted; 0=Non-inverted"/>
            <edc:SFRFieldDef edc:cname="MUX_CTRL" edc:nzwidth="0x3" edc:desc="00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3.">
              <edc:SFRFieldSemantic edc:cname="GPIO" edc:desc="GPIO function selected" edc:when="(field &amp; 0x7) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="FUNC1" edc:desc="Signal function 1 selected" edc:when="(field &amp; 0x7) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="FUNC2" edc:desc="Signal function 2 selected" edc:when="(field &amp; 0x7) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="FUNC3" edc:desc="Signal function 3 selected" edc:when="(field &amp; 0x7) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="INP_DIS" edc:nzwidth="0x1" edc:desc="GPIO input disable"/>
            <edc:SFRFieldDef edc:cname="ALT_GPIO_DATA" edc:nzwidth="0x1" edc:desc="GPIO Alternate Data Register."/>
            <edc:AdjustPoint edc:offset="0x7"/>
            <edc:SFRFieldDef edc:cname="GPIO_INP" edc:nzwidth="0x1" edc:desc="GPIO input from pin, independent of the Mux selection for the pin or the Direction."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL61" edc:nzwidth="0x20" edc:access="-------n-------nnnnnnnnnnnnnnnnn" edc:por="00000000000000001000000001000000" edc:mclr="00000000000000001000000001000000" edc:impl="0x101FFFF" edc:_addr="0x400810C4">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="PU_PD" edc:nzwidth="0x2" edc:desc="These bits are used to enable an internal pull-up or pull-down resistor.">
              <edc:SFRFieldSemantic edc:cname="NONE" edc:desc="None. Pin tristates when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="UP" edc:desc="Pull Up Enabled" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="DOWN" edc:desc="Pull Down Enabled" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="REPEATER" edc:desc="Repeater mode. Pin is kept at previous voltage level when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="PWR_GATING" edc:nzwidth="0x2" edc:desc="The GPIO pin will be tristated when the selected power well is off."/>
            <edc:SFRFieldDef edc:cname="INTR_DET" edc:nzwidth="0x3" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="EDGE_EN" edc:nzwidth="0x1" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="OUT_BUFF_TYPE" edc:nzwidth="0x1" edc:desc="0 = Push-Pull, 1 = Open Drain"/>
            <edc:SFRFieldDef edc:cname="GPIO_DIR" edc:nzwidth="0x1" edc:desc="Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output"/>
            <edc:SFRFieldDef edc:cname="GPIO_OUT_SEL" edc:nzwidth="0x1" edc:desc="GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register."/>
            <edc:SFRFieldDef edc:cname="POL" edc:nzwidth="0x1" edc:desc="1=Inverted; 0=Non-inverted"/>
            <edc:SFRFieldDef edc:cname="MUX_CTRL" edc:nzwidth="0x3" edc:desc="00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3.">
              <edc:SFRFieldSemantic edc:cname="GPIO" edc:desc="GPIO function selected" edc:when="(field &amp; 0x7) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="FUNC1" edc:desc="Signal function 1 selected" edc:when="(field &amp; 0x7) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="FUNC2" edc:desc="Signal function 2 selected" edc:when="(field &amp; 0x7) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="FUNC3" edc:desc="Signal function 3 selected" edc:when="(field &amp; 0x7) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="INP_DIS" edc:nzwidth="0x1" edc:desc="GPIO input disable"/>
            <edc:SFRFieldDef edc:cname="ALT_GPIO_DATA" edc:nzwidth="0x1" edc:desc="GPIO Alternate Data Register."/>
            <edc:AdjustPoint edc:offset="0x7"/>
            <edc:SFRFieldDef edc:cname="GPIO_INP" edc:nzwidth="0x1" edc:desc="GPIO input from pin, independent of the Mux selection for the pin or the Direction."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL62" edc:nzwidth="0x20" edc:access="-------n-------nnnnnnnnnnnnnnnnn" edc:por="00000000000000001000000001000000" edc:mclr="00000000000000001000000001000000" edc:impl="0x101FFFF" edc:_addr="0x400810C8">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="PU_PD" edc:nzwidth="0x2" edc:desc="These bits are used to enable an internal pull-up or pull-down resistor.">
              <edc:SFRFieldSemantic edc:cname="NONE" edc:desc="None. Pin tristates when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="UP" edc:desc="Pull Up Enabled" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="DOWN" edc:desc="Pull Down Enabled" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="REPEATER" edc:desc="Repeater mode. Pin is kept at previous voltage level when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="PWR_GATING" edc:nzwidth="0x2" edc:desc="The GPIO pin will be tristated when the selected power well is off."/>
            <edc:SFRFieldDef edc:cname="INTR_DET" edc:nzwidth="0x3" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="EDGE_EN" edc:nzwidth="0x1" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="OUT_BUFF_TYPE" edc:nzwidth="0x1" edc:desc="0 = Push-Pull, 1 = Open Drain"/>
            <edc:SFRFieldDef edc:cname="GPIO_DIR" edc:nzwidth="0x1" edc:desc="Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output"/>
            <edc:SFRFieldDef edc:cname="GPIO_OUT_SEL" edc:nzwidth="0x1" edc:desc="GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register."/>
            <edc:SFRFieldDef edc:cname="POL" edc:nzwidth="0x1" edc:desc="1=Inverted; 0=Non-inverted"/>
            <edc:SFRFieldDef edc:cname="MUX_CTRL" edc:nzwidth="0x3" edc:desc="00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3.">
              <edc:SFRFieldSemantic edc:cname="GPIO" edc:desc="GPIO function selected" edc:when="(field &amp; 0x7) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="FUNC1" edc:desc="Signal function 1 selected" edc:when="(field &amp; 0x7) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="FUNC2" edc:desc="Signal function 2 selected" edc:when="(field &amp; 0x7) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="FUNC3" edc:desc="Signal function 3 selected" edc:when="(field &amp; 0x7) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="INP_DIS" edc:nzwidth="0x1" edc:desc="GPIO input disable"/>
            <edc:SFRFieldDef edc:cname="ALT_GPIO_DATA" edc:nzwidth="0x1" edc:desc="GPIO Alternate Data Register."/>
            <edc:AdjustPoint edc:offset="0x7"/>
            <edc:SFRFieldDef edc:cname="GPIO_INP" edc:nzwidth="0x1" edc:desc="GPIO input from pin, independent of the Mux selection for the pin or the Direction."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL63" edc:nzwidth="0x20" edc:access="-------n-------nnnnnnnnnnnnnnnnn" edc:por="00000000000000001000000001000000" edc:mclr="00000000000000001000000001000000" edc:impl="0x101FFFF" edc:_addr="0x400810CC">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="PU_PD" edc:nzwidth="0x2" edc:desc="These bits are used to enable an internal pull-up or pull-down resistor.">
              <edc:SFRFieldSemantic edc:cname="NONE" edc:desc="None. Pin tristates when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="UP" edc:desc="Pull Up Enabled" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="DOWN" edc:desc="Pull Down Enabled" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="REPEATER" edc:desc="Repeater mode. Pin is kept at previous voltage level when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="PWR_GATING" edc:nzwidth="0x2" edc:desc="The GPIO pin will be tristated when the selected power well is off."/>
            <edc:SFRFieldDef edc:cname="INTR_DET" edc:nzwidth="0x3" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="EDGE_EN" edc:nzwidth="0x1" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="OUT_BUFF_TYPE" edc:nzwidth="0x1" edc:desc="0 = Push-Pull, 1 = Open Drain"/>
            <edc:SFRFieldDef edc:cname="GPIO_DIR" edc:nzwidth="0x1" edc:desc="Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output"/>
            <edc:SFRFieldDef edc:cname="GPIO_OUT_SEL" edc:nzwidth="0x1" edc:desc="GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register."/>
            <edc:SFRFieldDef edc:cname="POL" edc:nzwidth="0x1" edc:desc="1=Inverted; 0=Non-inverted"/>
            <edc:SFRFieldDef edc:cname="MUX_CTRL" edc:nzwidth="0x3" edc:desc="00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3.">
              <edc:SFRFieldSemantic edc:cname="GPIO" edc:desc="GPIO function selected" edc:when="(field &amp; 0x7) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="FUNC1" edc:desc="Signal function 1 selected" edc:when="(field &amp; 0x7) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="FUNC2" edc:desc="Signal function 2 selected" edc:when="(field &amp; 0x7) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="FUNC3" edc:desc="Signal function 3 selected" edc:when="(field &amp; 0x7) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="INP_DIS" edc:nzwidth="0x1" edc:desc="GPIO input disable"/>
            <edc:SFRFieldDef edc:cname="ALT_GPIO_DATA" edc:nzwidth="0x1" edc:desc="GPIO Alternate Data Register."/>
            <edc:AdjustPoint edc:offset="0x7"/>
            <edc:SFRFieldDef edc:cname="GPIO_INP" edc:nzwidth="0x1" edc:desc="GPIO input from pin, independent of the Mux selection for the pin or the Direction."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL64" edc:nzwidth="0x20" edc:access="-------n-------nnnnnnnnnnnnnnnnn" edc:por="00000000000000001000000001000000" edc:mclr="00000000000000001000000001000000" edc:impl="0x101FFFF" edc:_addr="0x400810D0">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="PU_PD" edc:nzwidth="0x2" edc:desc="These bits are used to enable an internal pull-up or pull-down resistor.">
              <edc:SFRFieldSemantic edc:cname="NONE" edc:desc="None. Pin tristates when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="UP" edc:desc="Pull Up Enabled" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="DOWN" edc:desc="Pull Down Enabled" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="REPEATER" edc:desc="Repeater mode. Pin is kept at previous voltage level when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="PWR_GATING" edc:nzwidth="0x2" edc:desc="The GPIO pin will be tristated when the selected power well is off."/>
            <edc:SFRFieldDef edc:cname="INTR_DET" edc:nzwidth="0x3" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="EDGE_EN" edc:nzwidth="0x1" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="OUT_BUFF_TYPE" edc:nzwidth="0x1" edc:desc="0 = Push-Pull, 1 = Open Drain"/>
            <edc:SFRFieldDef edc:cname="GPIO_DIR" edc:nzwidth="0x1" edc:desc="Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output"/>
            <edc:SFRFieldDef edc:cname="GPIO_OUT_SEL" edc:nzwidth="0x1" edc:desc="GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register."/>
            <edc:SFRFieldDef edc:cname="POL" edc:nzwidth="0x1" edc:desc="1=Inverted; 0=Non-inverted"/>
            <edc:SFRFieldDef edc:cname="MUX_CTRL" edc:nzwidth="0x3" edc:desc="00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3.">
              <edc:SFRFieldSemantic edc:cname="GPIO" edc:desc="GPIO function selected" edc:when="(field &amp; 0x7) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="FUNC1" edc:desc="Signal function 1 selected" edc:when="(field &amp; 0x7) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="FUNC2" edc:desc="Signal function 2 selected" edc:when="(field &amp; 0x7) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="FUNC3" edc:desc="Signal function 3 selected" edc:when="(field &amp; 0x7) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="INP_DIS" edc:nzwidth="0x1" edc:desc="GPIO input disable"/>
            <edc:SFRFieldDef edc:cname="ALT_GPIO_DATA" edc:nzwidth="0x1" edc:desc="GPIO Alternate Data Register."/>
            <edc:AdjustPoint edc:offset="0x7"/>
            <edc:SFRFieldDef edc:cname="GPIO_INP" edc:nzwidth="0x1" edc:desc="GPIO input from pin, independent of the Mux selection for the pin or the Direction."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL65" edc:nzwidth="0x20" edc:access="-------n-------nnnnnnnnnnnnnnnnn" edc:por="00000000000000001000000001000000" edc:mclr="00000000000000001000000001000000" edc:impl="0x101FFFF" edc:_addr="0x400810D4">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="PU_PD" edc:nzwidth="0x2" edc:desc="These bits are used to enable an internal pull-up or pull-down resistor.">
              <edc:SFRFieldSemantic edc:cname="NONE" edc:desc="None. Pin tristates when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="UP" edc:desc="Pull Up Enabled" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="DOWN" edc:desc="Pull Down Enabled" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="REPEATER" edc:desc="Repeater mode. Pin is kept at previous voltage level when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="PWR_GATING" edc:nzwidth="0x2" edc:desc="The GPIO pin will be tristated when the selected power well is off."/>
            <edc:SFRFieldDef edc:cname="INTR_DET" edc:nzwidth="0x3" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="EDGE_EN" edc:nzwidth="0x1" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="OUT_BUFF_TYPE" edc:nzwidth="0x1" edc:desc="0 = Push-Pull, 1 = Open Drain"/>
            <edc:SFRFieldDef edc:cname="GPIO_DIR" edc:nzwidth="0x1" edc:desc="Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output"/>
            <edc:SFRFieldDef edc:cname="GPIO_OUT_SEL" edc:nzwidth="0x1" edc:desc="GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register."/>
            <edc:SFRFieldDef edc:cname="POL" edc:nzwidth="0x1" edc:desc="1=Inverted; 0=Non-inverted"/>
            <edc:SFRFieldDef edc:cname="MUX_CTRL" edc:nzwidth="0x3" edc:desc="00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3.">
              <edc:SFRFieldSemantic edc:cname="GPIO" edc:desc="GPIO function selected" edc:when="(field &amp; 0x7) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="FUNC1" edc:desc="Signal function 1 selected" edc:when="(field &amp; 0x7) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="FUNC2" edc:desc="Signal function 2 selected" edc:when="(field &amp; 0x7) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="FUNC3" edc:desc="Signal function 3 selected" edc:when="(field &amp; 0x7) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="INP_DIS" edc:nzwidth="0x1" edc:desc="GPIO input disable"/>
            <edc:SFRFieldDef edc:cname="ALT_GPIO_DATA" edc:nzwidth="0x1" edc:desc="GPIO Alternate Data Register."/>
            <edc:AdjustPoint edc:offset="0x7"/>
            <edc:SFRFieldDef edc:cname="GPIO_INP" edc:nzwidth="0x1" edc:desc="GPIO input from pin, independent of the Mux selection for the pin or the Direction."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL66" edc:nzwidth="0x20" edc:access="-------n-------nnnnnnnnnnnnnnnnn" edc:por="00000000000000001000000001000000" edc:mclr="00000000000000001000000001000000" edc:impl="0x101FFFF" edc:_addr="0x400810D8">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="PU_PD" edc:nzwidth="0x2" edc:desc="These bits are used to enable an internal pull-up or pull-down resistor.">
              <edc:SFRFieldSemantic edc:cname="NONE" edc:desc="None. Pin tristates when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="UP" edc:desc="Pull Up Enabled" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="DOWN" edc:desc="Pull Down Enabled" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="REPEATER" edc:desc="Repeater mode. Pin is kept at previous voltage level when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="PWR_GATING" edc:nzwidth="0x2" edc:desc="The GPIO pin will be tristated when the selected power well is off."/>
            <edc:SFRFieldDef edc:cname="INTR_DET" edc:nzwidth="0x3" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="EDGE_EN" edc:nzwidth="0x1" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="OUT_BUFF_TYPE" edc:nzwidth="0x1" edc:desc="0 = Push-Pull, 1 = Open Drain"/>
            <edc:SFRFieldDef edc:cname="GPIO_DIR" edc:nzwidth="0x1" edc:desc="Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output"/>
            <edc:SFRFieldDef edc:cname="GPIO_OUT_SEL" edc:nzwidth="0x1" edc:desc="GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register."/>
            <edc:SFRFieldDef edc:cname="POL" edc:nzwidth="0x1" edc:desc="1=Inverted; 0=Non-inverted"/>
            <edc:SFRFieldDef edc:cname="MUX_CTRL" edc:nzwidth="0x3" edc:desc="00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3.">
              <edc:SFRFieldSemantic edc:cname="GPIO" edc:desc="GPIO function selected" edc:when="(field &amp; 0x7) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="FUNC1" edc:desc="Signal function 1 selected" edc:when="(field &amp; 0x7) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="FUNC2" edc:desc="Signal function 2 selected" edc:when="(field &amp; 0x7) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="FUNC3" edc:desc="Signal function 3 selected" edc:when="(field &amp; 0x7) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="INP_DIS" edc:nzwidth="0x1" edc:desc="GPIO input disable"/>
            <edc:SFRFieldDef edc:cname="ALT_GPIO_DATA" edc:nzwidth="0x1" edc:desc="GPIO Alternate Data Register."/>
            <edc:AdjustPoint edc:offset="0x7"/>
            <edc:SFRFieldDef edc:cname="GPIO_INP" edc:nzwidth="0x1" edc:desc="GPIO input from pin, independent of the Mux selection for the pin or the Direction."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL67" edc:nzwidth="0x20" edc:access="-------n-------nnnnnnnnnnnnnnnnn" edc:por="00000000000000001000000001000000" edc:mclr="00000000000000001000000001000000" edc:impl="0x101FFFF" edc:_addr="0x400810DC">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="PU_PD" edc:nzwidth="0x2" edc:desc="These bits are used to enable an internal pull-up or pull-down resistor.">
              <edc:SFRFieldSemantic edc:cname="NONE" edc:desc="None. Pin tristates when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="UP" edc:desc="Pull Up Enabled" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="DOWN" edc:desc="Pull Down Enabled" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="REPEATER" edc:desc="Repeater mode. Pin is kept at previous voltage level when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="PWR_GATING" edc:nzwidth="0x2" edc:desc="The GPIO pin will be tristated when the selected power well is off."/>
            <edc:SFRFieldDef edc:cname="INTR_DET" edc:nzwidth="0x3" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="EDGE_EN" edc:nzwidth="0x1" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="OUT_BUFF_TYPE" edc:nzwidth="0x1" edc:desc="0 = Push-Pull, 1 = Open Drain"/>
            <edc:SFRFieldDef edc:cname="GPIO_DIR" edc:nzwidth="0x1" edc:desc="Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output"/>
            <edc:SFRFieldDef edc:cname="GPIO_OUT_SEL" edc:nzwidth="0x1" edc:desc="GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register."/>
            <edc:SFRFieldDef edc:cname="POL" edc:nzwidth="0x1" edc:desc="1=Inverted; 0=Non-inverted"/>
            <edc:SFRFieldDef edc:cname="MUX_CTRL" edc:nzwidth="0x3" edc:desc="00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3.">
              <edc:SFRFieldSemantic edc:cname="GPIO" edc:desc="GPIO function selected" edc:when="(field &amp; 0x7) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="FUNC1" edc:desc="Signal function 1 selected" edc:when="(field &amp; 0x7) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="FUNC2" edc:desc="Signal function 2 selected" edc:when="(field &amp; 0x7) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="FUNC3" edc:desc="Signal function 3 selected" edc:when="(field &amp; 0x7) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="INP_DIS" edc:nzwidth="0x1" edc:desc="GPIO input disable"/>
            <edc:SFRFieldDef edc:cname="ALT_GPIO_DATA" edc:nzwidth="0x1" edc:desc="GPIO Alternate Data Register."/>
            <edc:AdjustPoint edc:offset="0x7"/>
            <edc:SFRFieldDef edc:cname="GPIO_INP" edc:nzwidth="0x1" edc:desc="GPIO input from pin, independent of the Mux selection for the pin or the Direction."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL70" edc:nzwidth="0x20" edc:access="-------n-------nnnnnnnnnnnnnnnnn" edc:por="00000000000000001000000001000000" edc:mclr="00000000000000001000000001000000" edc:impl="0x101FFFF" edc:_addr="0x400810E0">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="PU_PD" edc:nzwidth="0x2" edc:desc="These bits are used to enable an internal pull-up or pull-down resistor.">
              <edc:SFRFieldSemantic edc:cname="NONE" edc:desc="None. Pin tristates when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="UP" edc:desc="Pull Up Enabled" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="DOWN" edc:desc="Pull Down Enabled" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="REPEATER" edc:desc="Repeater mode. Pin is kept at previous voltage level when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="PWR_GATING" edc:nzwidth="0x2" edc:desc="The GPIO pin will be tristated when the selected power well is off."/>
            <edc:SFRFieldDef edc:cname="INTR_DET" edc:nzwidth="0x3" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="EDGE_EN" edc:nzwidth="0x1" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="OUT_BUFF_TYPE" edc:nzwidth="0x1" edc:desc="0 = Push-Pull, 1 = Open Drain"/>
            <edc:SFRFieldDef edc:cname="GPIO_DIR" edc:nzwidth="0x1" edc:desc="Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output"/>
            <edc:SFRFieldDef edc:cname="GPIO_OUT_SEL" edc:nzwidth="0x1" edc:desc="GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register."/>
            <edc:SFRFieldDef edc:cname="POL" edc:nzwidth="0x1" edc:desc="1=Inverted; 0=Non-inverted"/>
            <edc:SFRFieldDef edc:cname="MUX_CTRL" edc:nzwidth="0x3" edc:desc="00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3.">
              <edc:SFRFieldSemantic edc:cname="GPIO" edc:desc="GPIO function selected" edc:when="(field &amp; 0x7) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="FUNC1" edc:desc="Signal function 1 selected" edc:when="(field &amp; 0x7) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="FUNC2" edc:desc="Signal function 2 selected" edc:when="(field &amp; 0x7) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="FUNC3" edc:desc="Signal function 3 selected" edc:when="(field &amp; 0x7) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="INP_DIS" edc:nzwidth="0x1" edc:desc="GPIO input disable"/>
            <edc:SFRFieldDef edc:cname="ALT_GPIO_DATA" edc:nzwidth="0x1" edc:desc="GPIO Alternate Data Register."/>
            <edc:AdjustPoint edc:offset="0x7"/>
            <edc:SFRFieldDef edc:cname="GPIO_INP" edc:nzwidth="0x1" edc:desc="GPIO input from pin, independent of the Mux selection for the pin or the Direction."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL71" edc:nzwidth="0x20" edc:access="-------n-------nnnnnnnnnnnnnnnnn" edc:por="00000000000000001000000001000000" edc:mclr="00000000000000001000000001000000" edc:impl="0x101FFFF" edc:_addr="0x400810E4">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="PU_PD" edc:nzwidth="0x2" edc:desc="These bits are used to enable an internal pull-up or pull-down resistor.">
              <edc:SFRFieldSemantic edc:cname="NONE" edc:desc="None. Pin tristates when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="UP" edc:desc="Pull Up Enabled" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="DOWN" edc:desc="Pull Down Enabled" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="REPEATER" edc:desc="Repeater mode. Pin is kept at previous voltage level when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="PWR_GATING" edc:nzwidth="0x2" edc:desc="The GPIO pin will be tristated when the selected power well is off."/>
            <edc:SFRFieldDef edc:cname="INTR_DET" edc:nzwidth="0x3" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="EDGE_EN" edc:nzwidth="0x1" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="OUT_BUFF_TYPE" edc:nzwidth="0x1" edc:desc="0 = Push-Pull, 1 = Open Drain"/>
            <edc:SFRFieldDef edc:cname="GPIO_DIR" edc:nzwidth="0x1" edc:desc="Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output"/>
            <edc:SFRFieldDef edc:cname="GPIO_OUT_SEL" edc:nzwidth="0x1" edc:desc="GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register."/>
            <edc:SFRFieldDef edc:cname="POL" edc:nzwidth="0x1" edc:desc="1=Inverted; 0=Non-inverted"/>
            <edc:SFRFieldDef edc:cname="MUX_CTRL" edc:nzwidth="0x3" edc:desc="00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3.">
              <edc:SFRFieldSemantic edc:cname="GPIO" edc:desc="GPIO function selected" edc:when="(field &amp; 0x7) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="FUNC1" edc:desc="Signal function 1 selected" edc:when="(field &amp; 0x7) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="FUNC2" edc:desc="Signal function 2 selected" edc:when="(field &amp; 0x7) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="FUNC3" edc:desc="Signal function 3 selected" edc:when="(field &amp; 0x7) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="INP_DIS" edc:nzwidth="0x1" edc:desc="GPIO input disable"/>
            <edc:SFRFieldDef edc:cname="ALT_GPIO_DATA" edc:nzwidth="0x1" edc:desc="GPIO Alternate Data Register."/>
            <edc:AdjustPoint edc:offset="0x7"/>
            <edc:SFRFieldDef edc:cname="GPIO_INP" edc:nzwidth="0x1" edc:desc="GPIO input from pin, independent of the Mux selection for the pin or the Direction."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL72" edc:nzwidth="0x20" edc:access="-------n-------nnnnnnnnnnnnnnnnn" edc:por="00000000000000001000000001000000" edc:mclr="00000000000000001000000001000000" edc:impl="0x101FFFF" edc:_addr="0x400810E8">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="PU_PD" edc:nzwidth="0x2" edc:desc="These bits are used to enable an internal pull-up or pull-down resistor.">
              <edc:SFRFieldSemantic edc:cname="NONE" edc:desc="None. Pin tristates when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="UP" edc:desc="Pull Up Enabled" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="DOWN" edc:desc="Pull Down Enabled" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="REPEATER" edc:desc="Repeater mode. Pin is kept at previous voltage level when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="PWR_GATING" edc:nzwidth="0x2" edc:desc="The GPIO pin will be tristated when the selected power well is off."/>
            <edc:SFRFieldDef edc:cname="INTR_DET" edc:nzwidth="0x3" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="EDGE_EN" edc:nzwidth="0x1" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="OUT_BUFF_TYPE" edc:nzwidth="0x1" edc:desc="0 = Push-Pull, 1 = Open Drain"/>
            <edc:SFRFieldDef edc:cname="GPIO_DIR" edc:nzwidth="0x1" edc:desc="Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output"/>
            <edc:SFRFieldDef edc:cname="GPIO_OUT_SEL" edc:nzwidth="0x1" edc:desc="GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register."/>
            <edc:SFRFieldDef edc:cname="POL" edc:nzwidth="0x1" edc:desc="1=Inverted; 0=Non-inverted"/>
            <edc:SFRFieldDef edc:cname="MUX_CTRL" edc:nzwidth="0x3" edc:desc="00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3.">
              <edc:SFRFieldSemantic edc:cname="GPIO" edc:desc="GPIO function selected" edc:when="(field &amp; 0x7) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="FUNC1" edc:desc="Signal function 1 selected" edc:when="(field &amp; 0x7) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="FUNC2" edc:desc="Signal function 2 selected" edc:when="(field &amp; 0x7) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="FUNC3" edc:desc="Signal function 3 selected" edc:when="(field &amp; 0x7) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="INP_DIS" edc:nzwidth="0x1" edc:desc="GPIO input disable"/>
            <edc:SFRFieldDef edc:cname="ALT_GPIO_DATA" edc:nzwidth="0x1" edc:desc="GPIO Alternate Data Register."/>
            <edc:AdjustPoint edc:offset="0x7"/>
            <edc:SFRFieldDef edc:cname="GPIO_INP" edc:nzwidth="0x1" edc:desc="GPIO input from pin, independent of the Mux selection for the pin or the Direction."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL73" edc:nzwidth="0x20" edc:access="-------n-------nnnnnnnnnnnnnnnnn" edc:por="00000000000000001000000001000000" edc:mclr="00000000000000001000000001000000" edc:impl="0x101FFFF" edc:_addr="0x400810EC">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="PU_PD" edc:nzwidth="0x2" edc:desc="These bits are used to enable an internal pull-up or pull-down resistor.">
              <edc:SFRFieldSemantic edc:cname="NONE" edc:desc="None. Pin tristates when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="UP" edc:desc="Pull Up Enabled" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="DOWN" edc:desc="Pull Down Enabled" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="REPEATER" edc:desc="Repeater mode. Pin is kept at previous voltage level when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="PWR_GATING" edc:nzwidth="0x2" edc:desc="The GPIO pin will be tristated when the selected power well is off."/>
            <edc:SFRFieldDef edc:cname="INTR_DET" edc:nzwidth="0x3" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="EDGE_EN" edc:nzwidth="0x1" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="OUT_BUFF_TYPE" edc:nzwidth="0x1" edc:desc="0 = Push-Pull, 1 = Open Drain"/>
            <edc:SFRFieldDef edc:cname="GPIO_DIR" edc:nzwidth="0x1" edc:desc="Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output"/>
            <edc:SFRFieldDef edc:cname="GPIO_OUT_SEL" edc:nzwidth="0x1" edc:desc="GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register."/>
            <edc:SFRFieldDef edc:cname="POL" edc:nzwidth="0x1" edc:desc="1=Inverted; 0=Non-inverted"/>
            <edc:SFRFieldDef edc:cname="MUX_CTRL" edc:nzwidth="0x3" edc:desc="00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3.">
              <edc:SFRFieldSemantic edc:cname="GPIO" edc:desc="GPIO function selected" edc:when="(field &amp; 0x7) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="FUNC1" edc:desc="Signal function 1 selected" edc:when="(field &amp; 0x7) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="FUNC2" edc:desc="Signal function 2 selected" edc:when="(field &amp; 0x7) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="FUNC3" edc:desc="Signal function 3 selected" edc:when="(field &amp; 0x7) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="INP_DIS" edc:nzwidth="0x1" edc:desc="GPIO input disable"/>
            <edc:SFRFieldDef edc:cname="ALT_GPIO_DATA" edc:nzwidth="0x1" edc:desc="GPIO Alternate Data Register."/>
            <edc:AdjustPoint edc:offset="0x7"/>
            <edc:SFRFieldDef edc:cname="GPIO_INP" edc:nzwidth="0x1" edc:desc="GPIO input from pin, independent of the Mux selection for the pin or the Direction."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL74" edc:nzwidth="0x20" edc:access="-------n-------nnnnnnnnnnnnnnnnn" edc:por="00000000000000001000000001000000" edc:mclr="00000000000000001000000001000000" edc:impl="0x101FFFF" edc:_addr="0x400810F0">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="PU_PD" edc:nzwidth="0x2" edc:desc="These bits are used to enable an internal pull-up or pull-down resistor.">
              <edc:SFRFieldSemantic edc:cname="NONE" edc:desc="None. Pin tristates when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="UP" edc:desc="Pull Up Enabled" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="DOWN" edc:desc="Pull Down Enabled" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="REPEATER" edc:desc="Repeater mode. Pin is kept at previous voltage level when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="PWR_GATING" edc:nzwidth="0x2" edc:desc="The GPIO pin will be tristated when the selected power well is off."/>
            <edc:SFRFieldDef edc:cname="INTR_DET" edc:nzwidth="0x3" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="EDGE_EN" edc:nzwidth="0x1" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="OUT_BUFF_TYPE" edc:nzwidth="0x1" edc:desc="0 = Push-Pull, 1 = Open Drain"/>
            <edc:SFRFieldDef edc:cname="GPIO_DIR" edc:nzwidth="0x1" edc:desc="Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output"/>
            <edc:SFRFieldDef edc:cname="GPIO_OUT_SEL" edc:nzwidth="0x1" edc:desc="GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register."/>
            <edc:SFRFieldDef edc:cname="POL" edc:nzwidth="0x1" edc:desc="1=Inverted; 0=Non-inverted"/>
            <edc:SFRFieldDef edc:cname="MUX_CTRL" edc:nzwidth="0x3" edc:desc="00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3.">
              <edc:SFRFieldSemantic edc:cname="GPIO" edc:desc="GPIO function selected" edc:when="(field &amp; 0x7) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="FUNC1" edc:desc="Signal function 1 selected" edc:when="(field &amp; 0x7) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="FUNC2" edc:desc="Signal function 2 selected" edc:when="(field &amp; 0x7) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="FUNC3" edc:desc="Signal function 3 selected" edc:when="(field &amp; 0x7) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="INP_DIS" edc:nzwidth="0x1" edc:desc="GPIO input disable"/>
            <edc:SFRFieldDef edc:cname="ALT_GPIO_DATA" edc:nzwidth="0x1" edc:desc="GPIO Alternate Data Register."/>
            <edc:AdjustPoint edc:offset="0x7"/>
            <edc:SFRFieldDef edc:cname="GPIO_INP" edc:nzwidth="0x1" edc:desc="GPIO input from pin, independent of the Mux selection for the pin or the Direction."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL75" edc:nzwidth="0x20" edc:access="-------n-------nnnnnnnnnnnnnnnnn" edc:por="00000000000000001000000001000000" edc:mclr="00000000000000001000000001000000" edc:impl="0x101FFFF" edc:_addr="0x400810F4">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="PU_PD" edc:nzwidth="0x2" edc:desc="These bits are used to enable an internal pull-up or pull-down resistor.">
              <edc:SFRFieldSemantic edc:cname="NONE" edc:desc="None. Pin tristates when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="UP" edc:desc="Pull Up Enabled" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="DOWN" edc:desc="Pull Down Enabled" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="REPEATER" edc:desc="Repeater mode. Pin is kept at previous voltage level when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="PWR_GATING" edc:nzwidth="0x2" edc:desc="The GPIO pin will be tristated when the selected power well is off."/>
            <edc:SFRFieldDef edc:cname="INTR_DET" edc:nzwidth="0x3" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="EDGE_EN" edc:nzwidth="0x1" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="OUT_BUFF_TYPE" edc:nzwidth="0x1" edc:desc="0 = Push-Pull, 1 = Open Drain"/>
            <edc:SFRFieldDef edc:cname="GPIO_DIR" edc:nzwidth="0x1" edc:desc="Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output"/>
            <edc:SFRFieldDef edc:cname="GPIO_OUT_SEL" edc:nzwidth="0x1" edc:desc="GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register."/>
            <edc:SFRFieldDef edc:cname="POL" edc:nzwidth="0x1" edc:desc="1=Inverted; 0=Non-inverted"/>
            <edc:SFRFieldDef edc:cname="MUX_CTRL" edc:nzwidth="0x3" edc:desc="00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3.">
              <edc:SFRFieldSemantic edc:cname="GPIO" edc:desc="GPIO function selected" edc:when="(field &amp; 0x7) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="FUNC1" edc:desc="Signal function 1 selected" edc:when="(field &amp; 0x7) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="FUNC2" edc:desc="Signal function 2 selected" edc:when="(field &amp; 0x7) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="FUNC3" edc:desc="Signal function 3 selected" edc:when="(field &amp; 0x7) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="INP_DIS" edc:nzwidth="0x1" edc:desc="GPIO input disable"/>
            <edc:SFRFieldDef edc:cname="ALT_GPIO_DATA" edc:nzwidth="0x1" edc:desc="GPIO Alternate Data Register."/>
            <edc:AdjustPoint edc:offset="0x7"/>
            <edc:SFRFieldDef edc:cname="GPIO_INP" edc:nzwidth="0x1" edc:desc="GPIO input from pin, independent of the Mux selection for the pin or the Direction."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL76" edc:nzwidth="0x20" edc:access="-------n-------nnnnnnnnnnnnnnnnn" edc:por="00000000000000001000000001000000" edc:mclr="00000000000000001000000001000000" edc:impl="0x101FFFF" edc:_addr="0x400810F8">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="PU_PD" edc:nzwidth="0x2" edc:desc="These bits are used to enable an internal pull-up or pull-down resistor.">
              <edc:SFRFieldSemantic edc:cname="NONE" edc:desc="None. Pin tristates when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="UP" edc:desc="Pull Up Enabled" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="DOWN" edc:desc="Pull Down Enabled" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="REPEATER" edc:desc="Repeater mode. Pin is kept at previous voltage level when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="PWR_GATING" edc:nzwidth="0x2" edc:desc="The GPIO pin will be tristated when the selected power well is off."/>
            <edc:SFRFieldDef edc:cname="INTR_DET" edc:nzwidth="0x3" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="EDGE_EN" edc:nzwidth="0x1" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="OUT_BUFF_TYPE" edc:nzwidth="0x1" edc:desc="0 = Push-Pull, 1 = Open Drain"/>
            <edc:SFRFieldDef edc:cname="GPIO_DIR" edc:nzwidth="0x1" edc:desc="Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output"/>
            <edc:SFRFieldDef edc:cname="GPIO_OUT_SEL" edc:nzwidth="0x1" edc:desc="GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register."/>
            <edc:SFRFieldDef edc:cname="POL" edc:nzwidth="0x1" edc:desc="1=Inverted; 0=Non-inverted"/>
            <edc:SFRFieldDef edc:cname="MUX_CTRL" edc:nzwidth="0x3" edc:desc="00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3.">
              <edc:SFRFieldSemantic edc:cname="GPIO" edc:desc="GPIO function selected" edc:when="(field &amp; 0x7) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="FUNC1" edc:desc="Signal function 1 selected" edc:when="(field &amp; 0x7) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="FUNC2" edc:desc="Signal function 2 selected" edc:when="(field &amp; 0x7) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="FUNC3" edc:desc="Signal function 3 selected" edc:when="(field &amp; 0x7) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="INP_DIS" edc:nzwidth="0x1" edc:desc="GPIO input disable"/>
            <edc:SFRFieldDef edc:cname="ALT_GPIO_DATA" edc:nzwidth="0x1" edc:desc="GPIO Alternate Data Register."/>
            <edc:AdjustPoint edc:offset="0x7"/>
            <edc:SFRFieldDef edc:cname="GPIO_INP" edc:nzwidth="0x1" edc:desc="GPIO input from pin, independent of the Mux selection for the pin or the Direction."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL77" edc:nzwidth="0x20" edc:access="-------n-------nnnnnnnnnnnnnnnnn" edc:por="00000000000000001000000001000000" edc:mclr="00000000000000001000000001000000" edc:impl="0x101FFFF" edc:_addr="0x400810FC">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="PU_PD" edc:nzwidth="0x2" edc:desc="These bits are used to enable an internal pull-up or pull-down resistor.">
              <edc:SFRFieldSemantic edc:cname="NONE" edc:desc="None. Pin tristates when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="UP" edc:desc="Pull Up Enabled" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="DOWN" edc:desc="Pull Down Enabled" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="REPEATER" edc:desc="Repeater mode. Pin is kept at previous voltage level when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="PWR_GATING" edc:nzwidth="0x2" edc:desc="The GPIO pin will be tristated when the selected power well is off."/>
            <edc:SFRFieldDef edc:cname="INTR_DET" edc:nzwidth="0x3" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="EDGE_EN" edc:nzwidth="0x1" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="OUT_BUFF_TYPE" edc:nzwidth="0x1" edc:desc="0 = Push-Pull, 1 = Open Drain"/>
            <edc:SFRFieldDef edc:cname="GPIO_DIR" edc:nzwidth="0x1" edc:desc="Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output"/>
            <edc:SFRFieldDef edc:cname="GPIO_OUT_SEL" edc:nzwidth="0x1" edc:desc="GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register."/>
            <edc:SFRFieldDef edc:cname="POL" edc:nzwidth="0x1" edc:desc="1=Inverted; 0=Non-inverted"/>
            <edc:SFRFieldDef edc:cname="MUX_CTRL" edc:nzwidth="0x3" edc:desc="00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3.">
              <edc:SFRFieldSemantic edc:cname="GPIO" edc:desc="GPIO function selected" edc:when="(field &amp; 0x7) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="FUNC1" edc:desc="Signal function 1 selected" edc:when="(field &amp; 0x7) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="FUNC2" edc:desc="Signal function 2 selected" edc:when="(field &amp; 0x7) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="FUNC3" edc:desc="Signal function 3 selected" edc:when="(field &amp; 0x7) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="INP_DIS" edc:nzwidth="0x1" edc:desc="GPIO input disable"/>
            <edc:SFRFieldDef edc:cname="ALT_GPIO_DATA" edc:nzwidth="0x1" edc:desc="GPIO Alternate Data Register."/>
            <edc:AdjustPoint edc:offset="0x7"/>
            <edc:SFRFieldDef edc:cname="GPIO_INP" edc:nzwidth="0x1" edc:desc="GPIO input from pin, independent of the Mux selection for the pin or the Direction."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL100" edc:nzwidth="0x20" edc:access="-------n-------nnnnnnnnnnnnnnnnn" edc:por="00000000000000001000000001000000" edc:mclr="00000000000000001000000001000000" edc:impl="0x101FFFF" edc:_addr="0x40081100">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="PU_PD" edc:nzwidth="0x2" edc:desc="These bits are used to enable an internal pull-up or pull-down resistor.">
              <edc:SFRFieldSemantic edc:cname="NONE" edc:desc="None. Pin tristates when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="UP" edc:desc="Pull Up Enabled" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="DOWN" edc:desc="Pull Down Enabled" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="REPEATER" edc:desc="Repeater mode. Pin is kept at previous voltage level when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="PWR_GATING" edc:nzwidth="0x2" edc:desc="The GPIO pin will be tristated when the selected power well is off."/>
            <edc:SFRFieldDef edc:cname="INTR_DET" edc:nzwidth="0x3" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="EDGE_EN" edc:nzwidth="0x1" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="OUT_BUFF_TYPE" edc:nzwidth="0x1" edc:desc="0 = Push-Pull, 1 = Open Drain"/>
            <edc:SFRFieldDef edc:cname="GPIO_DIR" edc:nzwidth="0x1" edc:desc="Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output"/>
            <edc:SFRFieldDef edc:cname="GPIO_OUT_SEL" edc:nzwidth="0x1" edc:desc="GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register."/>
            <edc:SFRFieldDef edc:cname="POL" edc:nzwidth="0x1" edc:desc="1=Inverted; 0=Non-inverted"/>
            <edc:SFRFieldDef edc:cname="MUX_CTRL" edc:nzwidth="0x3" edc:desc="00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3.">
              <edc:SFRFieldSemantic edc:cname="GPIO" edc:desc="GPIO function selected" edc:when="(field &amp; 0x7) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="FUNC1" edc:desc="Signal function 1 selected" edc:when="(field &amp; 0x7) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="FUNC2" edc:desc="Signal function 2 selected" edc:when="(field &amp; 0x7) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="FUNC3" edc:desc="Signal function 3 selected" edc:when="(field &amp; 0x7) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="INP_DIS" edc:nzwidth="0x1" edc:desc="GPIO input disable"/>
            <edc:SFRFieldDef edc:cname="ALT_GPIO_DATA" edc:nzwidth="0x1" edc:desc="GPIO Alternate Data Register."/>
            <edc:AdjustPoint edc:offset="0x7"/>
            <edc:SFRFieldDef edc:cname="GPIO_INP" edc:nzwidth="0x1" edc:desc="GPIO input from pin, independent of the Mux selection for the pin or the Direction."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL101" edc:nzwidth="0x20" edc:access="-------n-------nnnnnnnnnnnnnnnnn" edc:por="00000000000000001000000001000000" edc:mclr="00000000000000001000000001000000" edc:impl="0x101FFFF" edc:_addr="0x40081104">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="PU_PD" edc:nzwidth="0x2" edc:desc="These bits are used to enable an internal pull-up or pull-down resistor.">
              <edc:SFRFieldSemantic edc:cname="NONE" edc:desc="None. Pin tristates when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="UP" edc:desc="Pull Up Enabled" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="DOWN" edc:desc="Pull Down Enabled" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="REPEATER" edc:desc="Repeater mode. Pin is kept at previous voltage level when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="PWR_GATING" edc:nzwidth="0x2" edc:desc="The GPIO pin will be tristated when the selected power well is off."/>
            <edc:SFRFieldDef edc:cname="INTR_DET" edc:nzwidth="0x3" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="EDGE_EN" edc:nzwidth="0x1" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="OUT_BUFF_TYPE" edc:nzwidth="0x1" edc:desc="0 = Push-Pull, 1 = Open Drain"/>
            <edc:SFRFieldDef edc:cname="GPIO_DIR" edc:nzwidth="0x1" edc:desc="Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output"/>
            <edc:SFRFieldDef edc:cname="GPIO_OUT_SEL" edc:nzwidth="0x1" edc:desc="GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register."/>
            <edc:SFRFieldDef edc:cname="POL" edc:nzwidth="0x1" edc:desc="1=Inverted; 0=Non-inverted"/>
            <edc:SFRFieldDef edc:cname="MUX_CTRL" edc:nzwidth="0x3" edc:desc="00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3.">
              <edc:SFRFieldSemantic edc:cname="GPIO" edc:desc="GPIO function selected" edc:when="(field &amp; 0x7) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="FUNC1" edc:desc="Signal function 1 selected" edc:when="(field &amp; 0x7) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="FUNC2" edc:desc="Signal function 2 selected" edc:when="(field &amp; 0x7) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="FUNC3" edc:desc="Signal function 3 selected" edc:when="(field &amp; 0x7) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="INP_DIS" edc:nzwidth="0x1" edc:desc="GPIO input disable"/>
            <edc:SFRFieldDef edc:cname="ALT_GPIO_DATA" edc:nzwidth="0x1" edc:desc="GPIO Alternate Data Register."/>
            <edc:AdjustPoint edc:offset="0x7"/>
            <edc:SFRFieldDef edc:cname="GPIO_INP" edc:nzwidth="0x1" edc:desc="GPIO input from pin, independent of the Mux selection for the pin or the Direction."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL102" edc:nzwidth="0x20" edc:access="-------n-------nnnnnnnnnnnnnnnnn" edc:por="00000000000000001000000001000000" edc:mclr="00000000000000001000000001000000" edc:impl="0x101FFFF" edc:_addr="0x40081108">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="PU_PD" edc:nzwidth="0x2" edc:desc="These bits are used to enable an internal pull-up or pull-down resistor.">
              <edc:SFRFieldSemantic edc:cname="NONE" edc:desc="None. Pin tristates when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="UP" edc:desc="Pull Up Enabled" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="DOWN" edc:desc="Pull Down Enabled" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="REPEATER" edc:desc="Repeater mode. Pin is kept at previous voltage level when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="PWR_GATING" edc:nzwidth="0x2" edc:desc="The GPIO pin will be tristated when the selected power well is off."/>
            <edc:SFRFieldDef edc:cname="INTR_DET" edc:nzwidth="0x3" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="EDGE_EN" edc:nzwidth="0x1" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="OUT_BUFF_TYPE" edc:nzwidth="0x1" edc:desc="0 = Push-Pull, 1 = Open Drain"/>
            <edc:SFRFieldDef edc:cname="GPIO_DIR" edc:nzwidth="0x1" edc:desc="Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output"/>
            <edc:SFRFieldDef edc:cname="GPIO_OUT_SEL" edc:nzwidth="0x1" edc:desc="GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register."/>
            <edc:SFRFieldDef edc:cname="POL" edc:nzwidth="0x1" edc:desc="1=Inverted; 0=Non-inverted"/>
            <edc:SFRFieldDef edc:cname="MUX_CTRL" edc:nzwidth="0x3" edc:desc="00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3.">
              <edc:SFRFieldSemantic edc:cname="GPIO" edc:desc="GPIO function selected" edc:when="(field &amp; 0x7) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="FUNC1" edc:desc="Signal function 1 selected" edc:when="(field &amp; 0x7) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="FUNC2" edc:desc="Signal function 2 selected" edc:when="(field &amp; 0x7) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="FUNC3" edc:desc="Signal function 3 selected" edc:when="(field &amp; 0x7) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="INP_DIS" edc:nzwidth="0x1" edc:desc="GPIO input disable"/>
            <edc:SFRFieldDef edc:cname="ALT_GPIO_DATA" edc:nzwidth="0x1" edc:desc="GPIO Alternate Data Register."/>
            <edc:AdjustPoint edc:offset="0x7"/>
            <edc:SFRFieldDef edc:cname="GPIO_INP" edc:nzwidth="0x1" edc:desc="GPIO input from pin, independent of the Mux selection for the pin or the Direction."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL103" edc:nzwidth="0x20" edc:access="-------n-------nnnnnnnnnnnnnnnnn" edc:por="00000000000000001000000001000000" edc:mclr="00000000000000001000000001000000" edc:impl="0x101FFFF" edc:_addr="0x4008110C">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="PU_PD" edc:nzwidth="0x2" edc:desc="These bits are used to enable an internal pull-up or pull-down resistor.">
              <edc:SFRFieldSemantic edc:cname="NONE" edc:desc="None. Pin tristates when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="UP" edc:desc="Pull Up Enabled" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="DOWN" edc:desc="Pull Down Enabled" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="REPEATER" edc:desc="Repeater mode. Pin is kept at previous voltage level when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="PWR_GATING" edc:nzwidth="0x2" edc:desc="The GPIO pin will be tristated when the selected power well is off."/>
            <edc:SFRFieldDef edc:cname="INTR_DET" edc:nzwidth="0x3" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="EDGE_EN" edc:nzwidth="0x1" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="OUT_BUFF_TYPE" edc:nzwidth="0x1" edc:desc="0 = Push-Pull, 1 = Open Drain"/>
            <edc:SFRFieldDef edc:cname="GPIO_DIR" edc:nzwidth="0x1" edc:desc="Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output"/>
            <edc:SFRFieldDef edc:cname="GPIO_OUT_SEL" edc:nzwidth="0x1" edc:desc="GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register."/>
            <edc:SFRFieldDef edc:cname="POL" edc:nzwidth="0x1" edc:desc="1=Inverted; 0=Non-inverted"/>
            <edc:SFRFieldDef edc:cname="MUX_CTRL" edc:nzwidth="0x3" edc:desc="00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3.">
              <edc:SFRFieldSemantic edc:cname="GPIO" edc:desc="GPIO function selected" edc:when="(field &amp; 0x7) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="FUNC1" edc:desc="Signal function 1 selected" edc:when="(field &amp; 0x7) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="FUNC2" edc:desc="Signal function 2 selected" edc:when="(field &amp; 0x7) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="FUNC3" edc:desc="Signal function 3 selected" edc:when="(field &amp; 0x7) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="INP_DIS" edc:nzwidth="0x1" edc:desc="GPIO input disable"/>
            <edc:SFRFieldDef edc:cname="ALT_GPIO_DATA" edc:nzwidth="0x1" edc:desc="GPIO Alternate Data Register."/>
            <edc:AdjustPoint edc:offset="0x7"/>
            <edc:SFRFieldDef edc:cname="GPIO_INP" edc:nzwidth="0x1" edc:desc="GPIO input from pin, independent of the Mux selection for the pin or the Direction."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL104" edc:nzwidth="0x20" edc:access="-------n-------nnnnnnnnnnnnnnnnn" edc:por="00000000000000001000000001000000" edc:mclr="00000000000000001000000001000000" edc:impl="0x101FFFF" edc:_addr="0x40081110">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="PU_PD" edc:nzwidth="0x2" edc:desc="These bits are used to enable an internal pull-up or pull-down resistor.">
              <edc:SFRFieldSemantic edc:cname="NONE" edc:desc="None. Pin tristates when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="UP" edc:desc="Pull Up Enabled" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="DOWN" edc:desc="Pull Down Enabled" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="REPEATER" edc:desc="Repeater mode. Pin is kept at previous voltage level when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="PWR_GATING" edc:nzwidth="0x2" edc:desc="The GPIO pin will be tristated when the selected power well is off."/>
            <edc:SFRFieldDef edc:cname="INTR_DET" edc:nzwidth="0x3" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="EDGE_EN" edc:nzwidth="0x1" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="OUT_BUFF_TYPE" edc:nzwidth="0x1" edc:desc="0 = Push-Pull, 1 = Open Drain"/>
            <edc:SFRFieldDef edc:cname="GPIO_DIR" edc:nzwidth="0x1" edc:desc="Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output"/>
            <edc:SFRFieldDef edc:cname="GPIO_OUT_SEL" edc:nzwidth="0x1" edc:desc="GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register."/>
            <edc:SFRFieldDef edc:cname="POL" edc:nzwidth="0x1" edc:desc="1=Inverted; 0=Non-inverted"/>
            <edc:SFRFieldDef edc:cname="MUX_CTRL" edc:nzwidth="0x3" edc:desc="00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3.">
              <edc:SFRFieldSemantic edc:cname="GPIO" edc:desc="GPIO function selected" edc:when="(field &amp; 0x7) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="FUNC1" edc:desc="Signal function 1 selected" edc:when="(field &amp; 0x7) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="FUNC2" edc:desc="Signal function 2 selected" edc:when="(field &amp; 0x7) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="FUNC3" edc:desc="Signal function 3 selected" edc:when="(field &amp; 0x7) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="INP_DIS" edc:nzwidth="0x1" edc:desc="GPIO input disable"/>
            <edc:SFRFieldDef edc:cname="ALT_GPIO_DATA" edc:nzwidth="0x1" edc:desc="GPIO Alternate Data Register."/>
            <edc:AdjustPoint edc:offset="0x7"/>
            <edc:SFRFieldDef edc:cname="GPIO_INP" edc:nzwidth="0x1" edc:desc="GPIO input from pin, independent of the Mux selection for the pin or the Direction."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL105" edc:nzwidth="0x20" edc:access="-------n-------nnnnnnnnnnnnnnnnn" edc:por="00000000000000001000000001000000" edc:mclr="00000000000000001000000001000000" edc:impl="0x101FFFF" edc:_addr="0x40081114">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="PU_PD" edc:nzwidth="0x2" edc:desc="These bits are used to enable an internal pull-up or pull-down resistor.">
              <edc:SFRFieldSemantic edc:cname="NONE" edc:desc="None. Pin tristates when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="UP" edc:desc="Pull Up Enabled" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="DOWN" edc:desc="Pull Down Enabled" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="REPEATER" edc:desc="Repeater mode. Pin is kept at previous voltage level when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="PWR_GATING" edc:nzwidth="0x2" edc:desc="The GPIO pin will be tristated when the selected power well is off."/>
            <edc:SFRFieldDef edc:cname="INTR_DET" edc:nzwidth="0x3" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="EDGE_EN" edc:nzwidth="0x1" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="OUT_BUFF_TYPE" edc:nzwidth="0x1" edc:desc="0 = Push-Pull, 1 = Open Drain"/>
            <edc:SFRFieldDef edc:cname="GPIO_DIR" edc:nzwidth="0x1" edc:desc="Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output"/>
            <edc:SFRFieldDef edc:cname="GPIO_OUT_SEL" edc:nzwidth="0x1" edc:desc="GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register."/>
            <edc:SFRFieldDef edc:cname="POL" edc:nzwidth="0x1" edc:desc="1=Inverted; 0=Non-inverted"/>
            <edc:SFRFieldDef edc:cname="MUX_CTRL" edc:nzwidth="0x3" edc:desc="00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3.">
              <edc:SFRFieldSemantic edc:cname="GPIO" edc:desc="GPIO function selected" edc:when="(field &amp; 0x7) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="FUNC1" edc:desc="Signal function 1 selected" edc:when="(field &amp; 0x7) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="FUNC2" edc:desc="Signal function 2 selected" edc:when="(field &amp; 0x7) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="FUNC3" edc:desc="Signal function 3 selected" edc:when="(field &amp; 0x7) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="INP_DIS" edc:nzwidth="0x1" edc:desc="GPIO input disable"/>
            <edc:SFRFieldDef edc:cname="ALT_GPIO_DATA" edc:nzwidth="0x1" edc:desc="GPIO Alternate Data Register."/>
            <edc:AdjustPoint edc:offset="0x7"/>
            <edc:SFRFieldDef edc:cname="GPIO_INP" edc:nzwidth="0x1" edc:desc="GPIO input from pin, independent of the Mux selection for the pin or the Direction."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL106" edc:nzwidth="0x20" edc:access="-------n-------nnnnnnnnnnnnnnnnn" edc:por="00000000000000001000000001000000" edc:mclr="00000000000000001000000001000000" edc:impl="0x101FFFF" edc:_addr="0x40081118">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="PU_PD" edc:nzwidth="0x2" edc:desc="These bits are used to enable an internal pull-up or pull-down resistor.">
              <edc:SFRFieldSemantic edc:cname="NONE" edc:desc="None. Pin tristates when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="UP" edc:desc="Pull Up Enabled" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="DOWN" edc:desc="Pull Down Enabled" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="REPEATER" edc:desc="Repeater mode. Pin is kept at previous voltage level when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="PWR_GATING" edc:nzwidth="0x2" edc:desc="The GPIO pin will be tristated when the selected power well is off."/>
            <edc:SFRFieldDef edc:cname="INTR_DET" edc:nzwidth="0x3" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="EDGE_EN" edc:nzwidth="0x1" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="OUT_BUFF_TYPE" edc:nzwidth="0x1" edc:desc="0 = Push-Pull, 1 = Open Drain"/>
            <edc:SFRFieldDef edc:cname="GPIO_DIR" edc:nzwidth="0x1" edc:desc="Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output"/>
            <edc:SFRFieldDef edc:cname="GPIO_OUT_SEL" edc:nzwidth="0x1" edc:desc="GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register."/>
            <edc:SFRFieldDef edc:cname="POL" edc:nzwidth="0x1" edc:desc="1=Inverted; 0=Non-inverted"/>
            <edc:SFRFieldDef edc:cname="MUX_CTRL" edc:nzwidth="0x3" edc:desc="00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3.">
              <edc:SFRFieldSemantic edc:cname="GPIO" edc:desc="GPIO function selected" edc:when="(field &amp; 0x7) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="FUNC1" edc:desc="Signal function 1 selected" edc:when="(field &amp; 0x7) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="FUNC2" edc:desc="Signal function 2 selected" edc:when="(field &amp; 0x7) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="FUNC3" edc:desc="Signal function 3 selected" edc:when="(field &amp; 0x7) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="INP_DIS" edc:nzwidth="0x1" edc:desc="GPIO input disable"/>
            <edc:SFRFieldDef edc:cname="ALT_GPIO_DATA" edc:nzwidth="0x1" edc:desc="GPIO Alternate Data Register."/>
            <edc:AdjustPoint edc:offset="0x7"/>
            <edc:SFRFieldDef edc:cname="GPIO_INP" edc:nzwidth="0x1" edc:desc="GPIO input from pin, independent of the Mux selection for the pin or the Direction."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL107" edc:nzwidth="0x20" edc:access="-------n-------nnnnnnnnnnnnnnnnn" edc:por="00000000000000001000000001000000" edc:mclr="00000000000000001000000001000000" edc:impl="0x101FFFF" edc:_addr="0x4008111C">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="PU_PD" edc:nzwidth="0x2" edc:desc="These bits are used to enable an internal pull-up or pull-down resistor.">
              <edc:SFRFieldSemantic edc:cname="NONE" edc:desc="None. Pin tristates when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="UP" edc:desc="Pull Up Enabled" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="DOWN" edc:desc="Pull Down Enabled" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="REPEATER" edc:desc="Repeater mode. Pin is kept at previous voltage level when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="PWR_GATING" edc:nzwidth="0x2" edc:desc="The GPIO pin will be tristated when the selected power well is off."/>
            <edc:SFRFieldDef edc:cname="INTR_DET" edc:nzwidth="0x3" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="EDGE_EN" edc:nzwidth="0x1" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="OUT_BUFF_TYPE" edc:nzwidth="0x1" edc:desc="0 = Push-Pull, 1 = Open Drain"/>
            <edc:SFRFieldDef edc:cname="GPIO_DIR" edc:nzwidth="0x1" edc:desc="Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output"/>
            <edc:SFRFieldDef edc:cname="GPIO_OUT_SEL" edc:nzwidth="0x1" edc:desc="GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register."/>
            <edc:SFRFieldDef edc:cname="POL" edc:nzwidth="0x1" edc:desc="1=Inverted; 0=Non-inverted"/>
            <edc:SFRFieldDef edc:cname="MUX_CTRL" edc:nzwidth="0x3" edc:desc="00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3.">
              <edc:SFRFieldSemantic edc:cname="GPIO" edc:desc="GPIO function selected" edc:when="(field &amp; 0x7) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="FUNC1" edc:desc="Signal function 1 selected" edc:when="(field &amp; 0x7) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="FUNC2" edc:desc="Signal function 2 selected" edc:when="(field &amp; 0x7) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="FUNC3" edc:desc="Signal function 3 selected" edc:when="(field &amp; 0x7) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="INP_DIS" edc:nzwidth="0x1" edc:desc="GPIO input disable"/>
            <edc:SFRFieldDef edc:cname="ALT_GPIO_DATA" edc:nzwidth="0x1" edc:desc="GPIO Alternate Data Register."/>
            <edc:AdjustPoint edc:offset="0x7"/>
            <edc:SFRFieldDef edc:cname="GPIO_INP" edc:nzwidth="0x1" edc:desc="GPIO input from pin, independent of the Mux selection for the pin or the Direction."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL110" edc:nzwidth="0x20" edc:access="-------n-------nnnnnnnnnnnnnnnnn" edc:por="00000000000000001000000001000000" edc:mclr="00000000000000001000000001000000" edc:impl="0x101FFFF" edc:_addr="0x40081120">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="PU_PD" edc:nzwidth="0x2" edc:desc="These bits are used to enable an internal pull-up or pull-down resistor.">
              <edc:SFRFieldSemantic edc:cname="NONE" edc:desc="None. Pin tristates when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="UP" edc:desc="Pull Up Enabled" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="DOWN" edc:desc="Pull Down Enabled" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="REPEATER" edc:desc="Repeater mode. Pin is kept at previous voltage level when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="PWR_GATING" edc:nzwidth="0x2" edc:desc="The GPIO pin will be tristated when the selected power well is off."/>
            <edc:SFRFieldDef edc:cname="INTR_DET" edc:nzwidth="0x3" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="EDGE_EN" edc:nzwidth="0x1" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="OUT_BUFF_TYPE" edc:nzwidth="0x1" edc:desc="0 = Push-Pull, 1 = Open Drain"/>
            <edc:SFRFieldDef edc:cname="GPIO_DIR" edc:nzwidth="0x1" edc:desc="Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output"/>
            <edc:SFRFieldDef edc:cname="GPIO_OUT_SEL" edc:nzwidth="0x1" edc:desc="GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register."/>
            <edc:SFRFieldDef edc:cname="POL" edc:nzwidth="0x1" edc:desc="1=Inverted; 0=Non-inverted"/>
            <edc:SFRFieldDef edc:cname="MUX_CTRL" edc:nzwidth="0x3" edc:desc="00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3.">
              <edc:SFRFieldSemantic edc:cname="GPIO" edc:desc="GPIO function selected" edc:when="(field &amp; 0x7) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="FUNC1" edc:desc="Signal function 1 selected" edc:when="(field &amp; 0x7) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="FUNC2" edc:desc="Signal function 2 selected" edc:when="(field &amp; 0x7) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="FUNC3" edc:desc="Signal function 3 selected" edc:when="(field &amp; 0x7) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="INP_DIS" edc:nzwidth="0x1" edc:desc="GPIO input disable"/>
            <edc:SFRFieldDef edc:cname="ALT_GPIO_DATA" edc:nzwidth="0x1" edc:desc="GPIO Alternate Data Register."/>
            <edc:AdjustPoint edc:offset="0x7"/>
            <edc:SFRFieldDef edc:cname="GPIO_INP" edc:nzwidth="0x1" edc:desc="GPIO input from pin, independent of the Mux selection for the pin or the Direction."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL111" edc:nzwidth="0x20" edc:access="-------n-------nnnnnnnnnnnnnnnnn" edc:por="00000000000000001000000001000000" edc:mclr="00000000000000001000000001000000" edc:impl="0x101FFFF" edc:_addr="0x40081124">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="PU_PD" edc:nzwidth="0x2" edc:desc="These bits are used to enable an internal pull-up or pull-down resistor.">
              <edc:SFRFieldSemantic edc:cname="NONE" edc:desc="None. Pin tristates when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="UP" edc:desc="Pull Up Enabled" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="DOWN" edc:desc="Pull Down Enabled" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="REPEATER" edc:desc="Repeater mode. Pin is kept at previous voltage level when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="PWR_GATING" edc:nzwidth="0x2" edc:desc="The GPIO pin will be tristated when the selected power well is off."/>
            <edc:SFRFieldDef edc:cname="INTR_DET" edc:nzwidth="0x3" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="EDGE_EN" edc:nzwidth="0x1" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="OUT_BUFF_TYPE" edc:nzwidth="0x1" edc:desc="0 = Push-Pull, 1 = Open Drain"/>
            <edc:SFRFieldDef edc:cname="GPIO_DIR" edc:nzwidth="0x1" edc:desc="Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output"/>
            <edc:SFRFieldDef edc:cname="GPIO_OUT_SEL" edc:nzwidth="0x1" edc:desc="GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register."/>
            <edc:SFRFieldDef edc:cname="POL" edc:nzwidth="0x1" edc:desc="1=Inverted; 0=Non-inverted"/>
            <edc:SFRFieldDef edc:cname="MUX_CTRL" edc:nzwidth="0x3" edc:desc="00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3.">
              <edc:SFRFieldSemantic edc:cname="GPIO" edc:desc="GPIO function selected" edc:when="(field &amp; 0x7) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="FUNC1" edc:desc="Signal function 1 selected" edc:when="(field &amp; 0x7) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="FUNC2" edc:desc="Signal function 2 selected" edc:when="(field &amp; 0x7) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="FUNC3" edc:desc="Signal function 3 selected" edc:when="(field &amp; 0x7) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="INP_DIS" edc:nzwidth="0x1" edc:desc="GPIO input disable"/>
            <edc:SFRFieldDef edc:cname="ALT_GPIO_DATA" edc:nzwidth="0x1" edc:desc="GPIO Alternate Data Register."/>
            <edc:AdjustPoint edc:offset="0x7"/>
            <edc:SFRFieldDef edc:cname="GPIO_INP" edc:nzwidth="0x1" edc:desc="GPIO input from pin, independent of the Mux selection for the pin or the Direction."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL112" edc:nzwidth="0x20" edc:access="-------n-------nnnnnnnnnnnnnnnnn" edc:por="00000000000000001000000001000000" edc:mclr="00000000000000001000000001000000" edc:impl="0x101FFFF" edc:_addr="0x40081128">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="PU_PD" edc:nzwidth="0x2" edc:desc="These bits are used to enable an internal pull-up or pull-down resistor.">
              <edc:SFRFieldSemantic edc:cname="NONE" edc:desc="None. Pin tristates when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="UP" edc:desc="Pull Up Enabled" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="DOWN" edc:desc="Pull Down Enabled" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="REPEATER" edc:desc="Repeater mode. Pin is kept at previous voltage level when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="PWR_GATING" edc:nzwidth="0x2" edc:desc="The GPIO pin will be tristated when the selected power well is off."/>
            <edc:SFRFieldDef edc:cname="INTR_DET" edc:nzwidth="0x3" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="EDGE_EN" edc:nzwidth="0x1" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="OUT_BUFF_TYPE" edc:nzwidth="0x1" edc:desc="0 = Push-Pull, 1 = Open Drain"/>
            <edc:SFRFieldDef edc:cname="GPIO_DIR" edc:nzwidth="0x1" edc:desc="Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output"/>
            <edc:SFRFieldDef edc:cname="GPIO_OUT_SEL" edc:nzwidth="0x1" edc:desc="GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register."/>
            <edc:SFRFieldDef edc:cname="POL" edc:nzwidth="0x1" edc:desc="1=Inverted; 0=Non-inverted"/>
            <edc:SFRFieldDef edc:cname="MUX_CTRL" edc:nzwidth="0x3" edc:desc="00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3.">
              <edc:SFRFieldSemantic edc:cname="GPIO" edc:desc="GPIO function selected" edc:when="(field &amp; 0x7) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="FUNC1" edc:desc="Signal function 1 selected" edc:when="(field &amp; 0x7) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="FUNC2" edc:desc="Signal function 2 selected" edc:when="(field &amp; 0x7) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="FUNC3" edc:desc="Signal function 3 selected" edc:when="(field &amp; 0x7) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="INP_DIS" edc:nzwidth="0x1" edc:desc="GPIO input disable"/>
            <edc:SFRFieldDef edc:cname="ALT_GPIO_DATA" edc:nzwidth="0x1" edc:desc="GPIO Alternate Data Register."/>
            <edc:AdjustPoint edc:offset="0x7"/>
            <edc:SFRFieldDef edc:cname="GPIO_INP" edc:nzwidth="0x1" edc:desc="GPIO input from pin, independent of the Mux selection for the pin or the Direction."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL113" edc:nzwidth="0x20" edc:access="-------n-------nnnnnnnnnnnnnnnnn" edc:por="00000000000000001000000001000000" edc:mclr="00000000000000001000000001000000" edc:impl="0x101FFFF" edc:_addr="0x4008112C">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="PU_PD" edc:nzwidth="0x2" edc:desc="These bits are used to enable an internal pull-up or pull-down resistor.">
              <edc:SFRFieldSemantic edc:cname="NONE" edc:desc="None. Pin tristates when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="UP" edc:desc="Pull Up Enabled" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="DOWN" edc:desc="Pull Down Enabled" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="REPEATER" edc:desc="Repeater mode. Pin is kept at previous voltage level when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="PWR_GATING" edc:nzwidth="0x2" edc:desc="The GPIO pin will be tristated when the selected power well is off."/>
            <edc:SFRFieldDef edc:cname="INTR_DET" edc:nzwidth="0x3" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="EDGE_EN" edc:nzwidth="0x1" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="OUT_BUFF_TYPE" edc:nzwidth="0x1" edc:desc="0 = Push-Pull, 1 = Open Drain"/>
            <edc:SFRFieldDef edc:cname="GPIO_DIR" edc:nzwidth="0x1" edc:desc="Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output"/>
            <edc:SFRFieldDef edc:cname="GPIO_OUT_SEL" edc:nzwidth="0x1" edc:desc="GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register."/>
            <edc:SFRFieldDef edc:cname="POL" edc:nzwidth="0x1" edc:desc="1=Inverted; 0=Non-inverted"/>
            <edc:SFRFieldDef edc:cname="MUX_CTRL" edc:nzwidth="0x3" edc:desc="00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3.">
              <edc:SFRFieldSemantic edc:cname="GPIO" edc:desc="GPIO function selected" edc:when="(field &amp; 0x7) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="FUNC1" edc:desc="Signal function 1 selected" edc:when="(field &amp; 0x7) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="FUNC2" edc:desc="Signal function 2 selected" edc:when="(field &amp; 0x7) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="FUNC3" edc:desc="Signal function 3 selected" edc:when="(field &amp; 0x7) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="INP_DIS" edc:nzwidth="0x1" edc:desc="GPIO input disable"/>
            <edc:SFRFieldDef edc:cname="ALT_GPIO_DATA" edc:nzwidth="0x1" edc:desc="GPIO Alternate Data Register."/>
            <edc:AdjustPoint edc:offset="0x7"/>
            <edc:SFRFieldDef edc:cname="GPIO_INP" edc:nzwidth="0x1" edc:desc="GPIO input from pin, independent of the Mux selection for the pin or the Direction."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL114" edc:nzwidth="0x20" edc:access="-------n-------nnnnnnnnnnnnnnnnn" edc:por="00000000000000001000000001000000" edc:mclr="00000000000000001000000001000000" edc:impl="0x101FFFF" edc:_addr="0x40081130">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="PU_PD" edc:nzwidth="0x2" edc:desc="These bits are used to enable an internal pull-up or pull-down resistor.">
              <edc:SFRFieldSemantic edc:cname="NONE" edc:desc="None. Pin tristates when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="UP" edc:desc="Pull Up Enabled" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="DOWN" edc:desc="Pull Down Enabled" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="REPEATER" edc:desc="Repeater mode. Pin is kept at previous voltage level when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="PWR_GATING" edc:nzwidth="0x2" edc:desc="The GPIO pin will be tristated when the selected power well is off."/>
            <edc:SFRFieldDef edc:cname="INTR_DET" edc:nzwidth="0x3" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="EDGE_EN" edc:nzwidth="0x1" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="OUT_BUFF_TYPE" edc:nzwidth="0x1" edc:desc="0 = Push-Pull, 1 = Open Drain"/>
            <edc:SFRFieldDef edc:cname="GPIO_DIR" edc:nzwidth="0x1" edc:desc="Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output"/>
            <edc:SFRFieldDef edc:cname="GPIO_OUT_SEL" edc:nzwidth="0x1" edc:desc="GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register."/>
            <edc:SFRFieldDef edc:cname="POL" edc:nzwidth="0x1" edc:desc="1=Inverted; 0=Non-inverted"/>
            <edc:SFRFieldDef edc:cname="MUX_CTRL" edc:nzwidth="0x3" edc:desc="00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3.">
              <edc:SFRFieldSemantic edc:cname="GPIO" edc:desc="GPIO function selected" edc:when="(field &amp; 0x7) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="FUNC1" edc:desc="Signal function 1 selected" edc:when="(field &amp; 0x7) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="FUNC2" edc:desc="Signal function 2 selected" edc:when="(field &amp; 0x7) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="FUNC3" edc:desc="Signal function 3 selected" edc:when="(field &amp; 0x7) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="INP_DIS" edc:nzwidth="0x1" edc:desc="GPIO input disable"/>
            <edc:SFRFieldDef edc:cname="ALT_GPIO_DATA" edc:nzwidth="0x1" edc:desc="GPIO Alternate Data Register."/>
            <edc:AdjustPoint edc:offset="0x7"/>
            <edc:SFRFieldDef edc:cname="GPIO_INP" edc:nzwidth="0x1" edc:desc="GPIO input from pin, independent of the Mux selection for the pin or the Direction."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL115" edc:nzwidth="0x20" edc:access="-------n-------nnnnnnnnnnnnnnnnn" edc:por="00000000000000001000000001000000" edc:mclr="00000000000000001000000001000000" edc:impl="0x101FFFF" edc:_addr="0x40081134">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="PU_PD" edc:nzwidth="0x2" edc:desc="These bits are used to enable an internal pull-up or pull-down resistor.">
              <edc:SFRFieldSemantic edc:cname="NONE" edc:desc="None. Pin tristates when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="UP" edc:desc="Pull Up Enabled" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="DOWN" edc:desc="Pull Down Enabled" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="REPEATER" edc:desc="Repeater mode. Pin is kept at previous voltage level when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="PWR_GATING" edc:nzwidth="0x2" edc:desc="The GPIO pin will be tristated when the selected power well is off."/>
            <edc:SFRFieldDef edc:cname="INTR_DET" edc:nzwidth="0x3" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="EDGE_EN" edc:nzwidth="0x1" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="OUT_BUFF_TYPE" edc:nzwidth="0x1" edc:desc="0 = Push-Pull, 1 = Open Drain"/>
            <edc:SFRFieldDef edc:cname="GPIO_DIR" edc:nzwidth="0x1" edc:desc="Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output"/>
            <edc:SFRFieldDef edc:cname="GPIO_OUT_SEL" edc:nzwidth="0x1" edc:desc="GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register."/>
            <edc:SFRFieldDef edc:cname="POL" edc:nzwidth="0x1" edc:desc="1=Inverted; 0=Non-inverted"/>
            <edc:SFRFieldDef edc:cname="MUX_CTRL" edc:nzwidth="0x3" edc:desc="00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3.">
              <edc:SFRFieldSemantic edc:cname="GPIO" edc:desc="GPIO function selected" edc:when="(field &amp; 0x7) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="FUNC1" edc:desc="Signal function 1 selected" edc:when="(field &amp; 0x7) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="FUNC2" edc:desc="Signal function 2 selected" edc:when="(field &amp; 0x7) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="FUNC3" edc:desc="Signal function 3 selected" edc:when="(field &amp; 0x7) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="INP_DIS" edc:nzwidth="0x1" edc:desc="GPIO input disable"/>
            <edc:SFRFieldDef edc:cname="ALT_GPIO_DATA" edc:nzwidth="0x1" edc:desc="GPIO Alternate Data Register."/>
            <edc:AdjustPoint edc:offset="0x7"/>
            <edc:SFRFieldDef edc:cname="GPIO_INP" edc:nzwidth="0x1" edc:desc="GPIO input from pin, independent of the Mux selection for the pin or the Direction."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL116" edc:nzwidth="0x20" edc:access="-------n-------nnnnnnnnnnnnnnnnn" edc:por="00000000000000001000000001000000" edc:mclr="00000000000000001000000001000000" edc:impl="0x101FFFF" edc:_addr="0x40081138">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="PU_PD" edc:nzwidth="0x2" edc:desc="These bits are used to enable an internal pull-up or pull-down resistor.">
              <edc:SFRFieldSemantic edc:cname="NONE" edc:desc="None. Pin tristates when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="UP" edc:desc="Pull Up Enabled" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="DOWN" edc:desc="Pull Down Enabled" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="REPEATER" edc:desc="Repeater mode. Pin is kept at previous voltage level when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="PWR_GATING" edc:nzwidth="0x2" edc:desc="The GPIO pin will be tristated when the selected power well is off."/>
            <edc:SFRFieldDef edc:cname="INTR_DET" edc:nzwidth="0x3" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="EDGE_EN" edc:nzwidth="0x1" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="OUT_BUFF_TYPE" edc:nzwidth="0x1" edc:desc="0 = Push-Pull, 1 = Open Drain"/>
            <edc:SFRFieldDef edc:cname="GPIO_DIR" edc:nzwidth="0x1" edc:desc="Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output"/>
            <edc:SFRFieldDef edc:cname="GPIO_OUT_SEL" edc:nzwidth="0x1" edc:desc="GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register."/>
            <edc:SFRFieldDef edc:cname="POL" edc:nzwidth="0x1" edc:desc="1=Inverted; 0=Non-inverted"/>
            <edc:SFRFieldDef edc:cname="MUX_CTRL" edc:nzwidth="0x3" edc:desc="00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3.">
              <edc:SFRFieldSemantic edc:cname="GPIO" edc:desc="GPIO function selected" edc:when="(field &amp; 0x7) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="FUNC1" edc:desc="Signal function 1 selected" edc:when="(field &amp; 0x7) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="FUNC2" edc:desc="Signal function 2 selected" edc:when="(field &amp; 0x7) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="FUNC3" edc:desc="Signal function 3 selected" edc:when="(field &amp; 0x7) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="INP_DIS" edc:nzwidth="0x1" edc:desc="GPIO input disable"/>
            <edc:SFRFieldDef edc:cname="ALT_GPIO_DATA" edc:nzwidth="0x1" edc:desc="GPIO Alternate Data Register."/>
            <edc:AdjustPoint edc:offset="0x7"/>
            <edc:SFRFieldDef edc:cname="GPIO_INP" edc:nzwidth="0x1" edc:desc="GPIO input from pin, independent of the Mux selection for the pin or the Direction."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL117" edc:nzwidth="0x20" edc:access="-------n-------nnnnnnnnnnnnnnnnn" edc:por="00000000000000001000000001000000" edc:mclr="00000000000000001000000001000000" edc:impl="0x101FFFF" edc:_addr="0x4008113C">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="PU_PD" edc:nzwidth="0x2" edc:desc="These bits are used to enable an internal pull-up or pull-down resistor.">
              <edc:SFRFieldSemantic edc:cname="NONE" edc:desc="None. Pin tristates when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="UP" edc:desc="Pull Up Enabled" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="DOWN" edc:desc="Pull Down Enabled" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="REPEATER" edc:desc="Repeater mode. Pin is kept at previous voltage level when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="PWR_GATING" edc:nzwidth="0x2" edc:desc="The GPIO pin will be tristated when the selected power well is off."/>
            <edc:SFRFieldDef edc:cname="INTR_DET" edc:nzwidth="0x3" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="EDGE_EN" edc:nzwidth="0x1" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="OUT_BUFF_TYPE" edc:nzwidth="0x1" edc:desc="0 = Push-Pull, 1 = Open Drain"/>
            <edc:SFRFieldDef edc:cname="GPIO_DIR" edc:nzwidth="0x1" edc:desc="Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output"/>
            <edc:SFRFieldDef edc:cname="GPIO_OUT_SEL" edc:nzwidth="0x1" edc:desc="GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register."/>
            <edc:SFRFieldDef edc:cname="POL" edc:nzwidth="0x1" edc:desc="1=Inverted; 0=Non-inverted"/>
            <edc:SFRFieldDef edc:cname="MUX_CTRL" edc:nzwidth="0x3" edc:desc="00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3.">
              <edc:SFRFieldSemantic edc:cname="GPIO" edc:desc="GPIO function selected" edc:when="(field &amp; 0x7) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="FUNC1" edc:desc="Signal function 1 selected" edc:when="(field &amp; 0x7) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="FUNC2" edc:desc="Signal function 2 selected" edc:when="(field &amp; 0x7) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="FUNC3" edc:desc="Signal function 3 selected" edc:when="(field &amp; 0x7) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="INP_DIS" edc:nzwidth="0x1" edc:desc="GPIO input disable"/>
            <edc:SFRFieldDef edc:cname="ALT_GPIO_DATA" edc:nzwidth="0x1" edc:desc="GPIO Alternate Data Register."/>
            <edc:AdjustPoint edc:offset="0x7"/>
            <edc:SFRFieldDef edc:cname="GPIO_INP" edc:nzwidth="0x1" edc:desc="GPIO input from pin, independent of the Mux selection for the pin or the Direction."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL120" edc:nzwidth="0x20" edc:access="-------n-------nnnnnnnnnnnnnnnnn" edc:por="00000000000000001000000001000000" edc:mclr="00000000000000001000000001000000" edc:impl="0x101FFFF" edc:_addr="0x40081140">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="PU_PD" edc:nzwidth="0x2" edc:desc="These bits are used to enable an internal pull-up or pull-down resistor.">
              <edc:SFRFieldSemantic edc:cname="NONE" edc:desc="None. Pin tristates when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="UP" edc:desc="Pull Up Enabled" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="DOWN" edc:desc="Pull Down Enabled" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="REPEATER" edc:desc="Repeater mode. Pin is kept at previous voltage level when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="PWR_GATING" edc:nzwidth="0x2" edc:desc="The GPIO pin will be tristated when the selected power well is off."/>
            <edc:SFRFieldDef edc:cname="INTR_DET" edc:nzwidth="0x3" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="EDGE_EN" edc:nzwidth="0x1" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="OUT_BUFF_TYPE" edc:nzwidth="0x1" edc:desc="0 = Push-Pull, 1 = Open Drain"/>
            <edc:SFRFieldDef edc:cname="GPIO_DIR" edc:nzwidth="0x1" edc:desc="Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output"/>
            <edc:SFRFieldDef edc:cname="GPIO_OUT_SEL" edc:nzwidth="0x1" edc:desc="GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register."/>
            <edc:SFRFieldDef edc:cname="POL" edc:nzwidth="0x1" edc:desc="1=Inverted; 0=Non-inverted"/>
            <edc:SFRFieldDef edc:cname="MUX_CTRL" edc:nzwidth="0x3" edc:desc="00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3.">
              <edc:SFRFieldSemantic edc:cname="GPIO" edc:desc="GPIO function selected" edc:when="(field &amp; 0x7) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="FUNC1" edc:desc="Signal function 1 selected" edc:when="(field &amp; 0x7) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="FUNC2" edc:desc="Signal function 2 selected" edc:when="(field &amp; 0x7) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="FUNC3" edc:desc="Signal function 3 selected" edc:when="(field &amp; 0x7) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="INP_DIS" edc:nzwidth="0x1" edc:desc="GPIO input disable"/>
            <edc:SFRFieldDef edc:cname="ALT_GPIO_DATA" edc:nzwidth="0x1" edc:desc="GPIO Alternate Data Register."/>
            <edc:AdjustPoint edc:offset="0x7"/>
            <edc:SFRFieldDef edc:cname="GPIO_INP" edc:nzwidth="0x1" edc:desc="GPIO input from pin, independent of the Mux selection for the pin or the Direction."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL121" edc:nzwidth="0x20" edc:access="-------n-------nnnnnnnnnnnnnnnnn" edc:por="00000000000000001000000001000000" edc:mclr="00000000000000001000000001000000" edc:impl="0x101FFFF" edc:_addr="0x40081144">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="PU_PD" edc:nzwidth="0x2" edc:desc="These bits are used to enable an internal pull-up or pull-down resistor.">
              <edc:SFRFieldSemantic edc:cname="NONE" edc:desc="None. Pin tristates when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="UP" edc:desc="Pull Up Enabled" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="DOWN" edc:desc="Pull Down Enabled" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="REPEATER" edc:desc="Repeater mode. Pin is kept at previous voltage level when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="PWR_GATING" edc:nzwidth="0x2" edc:desc="The GPIO pin will be tristated when the selected power well is off."/>
            <edc:SFRFieldDef edc:cname="INTR_DET" edc:nzwidth="0x3" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="EDGE_EN" edc:nzwidth="0x1" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="OUT_BUFF_TYPE" edc:nzwidth="0x1" edc:desc="0 = Push-Pull, 1 = Open Drain"/>
            <edc:SFRFieldDef edc:cname="GPIO_DIR" edc:nzwidth="0x1" edc:desc="Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output"/>
            <edc:SFRFieldDef edc:cname="GPIO_OUT_SEL" edc:nzwidth="0x1" edc:desc="GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register."/>
            <edc:SFRFieldDef edc:cname="POL" edc:nzwidth="0x1" edc:desc="1=Inverted; 0=Non-inverted"/>
            <edc:SFRFieldDef edc:cname="MUX_CTRL" edc:nzwidth="0x3" edc:desc="00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3.">
              <edc:SFRFieldSemantic edc:cname="GPIO" edc:desc="GPIO function selected" edc:when="(field &amp; 0x7) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="FUNC1" edc:desc="Signal function 1 selected" edc:when="(field &amp; 0x7) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="FUNC2" edc:desc="Signal function 2 selected" edc:when="(field &amp; 0x7) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="FUNC3" edc:desc="Signal function 3 selected" edc:when="(field &amp; 0x7) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="INP_DIS" edc:nzwidth="0x1" edc:desc="GPIO input disable"/>
            <edc:SFRFieldDef edc:cname="ALT_GPIO_DATA" edc:nzwidth="0x1" edc:desc="GPIO Alternate Data Register."/>
            <edc:AdjustPoint edc:offset="0x7"/>
            <edc:SFRFieldDef edc:cname="GPIO_INP" edc:nzwidth="0x1" edc:desc="GPIO input from pin, independent of the Mux selection for the pin or the Direction."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL122" edc:nzwidth="0x20" edc:access="-------n-------nnnnnnnnnnnnnnnnn" edc:por="00000000000000001000000001000000" edc:mclr="00000000000000001000000001000000" edc:impl="0x101FFFF" edc:_addr="0x40081148">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="PU_PD" edc:nzwidth="0x2" edc:desc="These bits are used to enable an internal pull-up or pull-down resistor.">
              <edc:SFRFieldSemantic edc:cname="NONE" edc:desc="None. Pin tristates when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="UP" edc:desc="Pull Up Enabled" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="DOWN" edc:desc="Pull Down Enabled" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="REPEATER" edc:desc="Repeater mode. Pin is kept at previous voltage level when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="PWR_GATING" edc:nzwidth="0x2" edc:desc="The GPIO pin will be tristated when the selected power well is off."/>
            <edc:SFRFieldDef edc:cname="INTR_DET" edc:nzwidth="0x3" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="EDGE_EN" edc:nzwidth="0x1" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="OUT_BUFF_TYPE" edc:nzwidth="0x1" edc:desc="0 = Push-Pull, 1 = Open Drain"/>
            <edc:SFRFieldDef edc:cname="GPIO_DIR" edc:nzwidth="0x1" edc:desc="Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output"/>
            <edc:SFRFieldDef edc:cname="GPIO_OUT_SEL" edc:nzwidth="0x1" edc:desc="GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register."/>
            <edc:SFRFieldDef edc:cname="POL" edc:nzwidth="0x1" edc:desc="1=Inverted; 0=Non-inverted"/>
            <edc:SFRFieldDef edc:cname="MUX_CTRL" edc:nzwidth="0x3" edc:desc="00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3.">
              <edc:SFRFieldSemantic edc:cname="GPIO" edc:desc="GPIO function selected" edc:when="(field &amp; 0x7) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="FUNC1" edc:desc="Signal function 1 selected" edc:when="(field &amp; 0x7) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="FUNC2" edc:desc="Signal function 2 selected" edc:when="(field &amp; 0x7) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="FUNC3" edc:desc="Signal function 3 selected" edc:when="(field &amp; 0x7) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="INP_DIS" edc:nzwidth="0x1" edc:desc="GPIO input disable"/>
            <edc:SFRFieldDef edc:cname="ALT_GPIO_DATA" edc:nzwidth="0x1" edc:desc="GPIO Alternate Data Register."/>
            <edc:AdjustPoint edc:offset="0x7"/>
            <edc:SFRFieldDef edc:cname="GPIO_INP" edc:nzwidth="0x1" edc:desc="GPIO input from pin, independent of the Mux selection for the pin or the Direction."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL123" edc:nzwidth="0x20" edc:access="-------n-------nnnnnnnnnnnnnnnnn" edc:por="00000000000000001000000001000000" edc:mclr="00000000000000001000000001000000" edc:impl="0x101FFFF" edc:_addr="0x4008114C">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="PU_PD" edc:nzwidth="0x2" edc:desc="These bits are used to enable an internal pull-up or pull-down resistor.">
              <edc:SFRFieldSemantic edc:cname="NONE" edc:desc="None. Pin tristates when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="UP" edc:desc="Pull Up Enabled" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="DOWN" edc:desc="Pull Down Enabled" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="REPEATER" edc:desc="Repeater mode. Pin is kept at previous voltage level when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="PWR_GATING" edc:nzwidth="0x2" edc:desc="The GPIO pin will be tristated when the selected power well is off."/>
            <edc:SFRFieldDef edc:cname="INTR_DET" edc:nzwidth="0x3" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="EDGE_EN" edc:nzwidth="0x1" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="OUT_BUFF_TYPE" edc:nzwidth="0x1" edc:desc="0 = Push-Pull, 1 = Open Drain"/>
            <edc:SFRFieldDef edc:cname="GPIO_DIR" edc:nzwidth="0x1" edc:desc="Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output"/>
            <edc:SFRFieldDef edc:cname="GPIO_OUT_SEL" edc:nzwidth="0x1" edc:desc="GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register."/>
            <edc:SFRFieldDef edc:cname="POL" edc:nzwidth="0x1" edc:desc="1=Inverted; 0=Non-inverted"/>
            <edc:SFRFieldDef edc:cname="MUX_CTRL" edc:nzwidth="0x3" edc:desc="00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3.">
              <edc:SFRFieldSemantic edc:cname="GPIO" edc:desc="GPIO function selected" edc:when="(field &amp; 0x7) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="FUNC1" edc:desc="Signal function 1 selected" edc:when="(field &amp; 0x7) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="FUNC2" edc:desc="Signal function 2 selected" edc:when="(field &amp; 0x7) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="FUNC3" edc:desc="Signal function 3 selected" edc:when="(field &amp; 0x7) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="INP_DIS" edc:nzwidth="0x1" edc:desc="GPIO input disable"/>
            <edc:SFRFieldDef edc:cname="ALT_GPIO_DATA" edc:nzwidth="0x1" edc:desc="GPIO Alternate Data Register."/>
            <edc:AdjustPoint edc:offset="0x7"/>
            <edc:SFRFieldDef edc:cname="GPIO_INP" edc:nzwidth="0x1" edc:desc="GPIO input from pin, independent of the Mux selection for the pin or the Direction."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL124" edc:nzwidth="0x20" edc:access="-------n-------nnnnnnnnnnnnnnnnn" edc:por="00000000000000001000000001000000" edc:mclr="00000000000000001000000001000000" edc:impl="0x101FFFF" edc:_addr="0x40081150">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="PU_PD" edc:nzwidth="0x2" edc:desc="These bits are used to enable an internal pull-up or pull-down resistor.">
              <edc:SFRFieldSemantic edc:cname="NONE" edc:desc="None. Pin tristates when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="UP" edc:desc="Pull Up Enabled" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="DOWN" edc:desc="Pull Down Enabled" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="REPEATER" edc:desc="Repeater mode. Pin is kept at previous voltage level when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="PWR_GATING" edc:nzwidth="0x2" edc:desc="The GPIO pin will be tristated when the selected power well is off."/>
            <edc:SFRFieldDef edc:cname="INTR_DET" edc:nzwidth="0x3" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="EDGE_EN" edc:nzwidth="0x1" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="OUT_BUFF_TYPE" edc:nzwidth="0x1" edc:desc="0 = Push-Pull, 1 = Open Drain"/>
            <edc:SFRFieldDef edc:cname="GPIO_DIR" edc:nzwidth="0x1" edc:desc="Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output"/>
            <edc:SFRFieldDef edc:cname="GPIO_OUT_SEL" edc:nzwidth="0x1" edc:desc="GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register."/>
            <edc:SFRFieldDef edc:cname="POL" edc:nzwidth="0x1" edc:desc="1=Inverted; 0=Non-inverted"/>
            <edc:SFRFieldDef edc:cname="MUX_CTRL" edc:nzwidth="0x3" edc:desc="00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3.">
              <edc:SFRFieldSemantic edc:cname="GPIO" edc:desc="GPIO function selected" edc:when="(field &amp; 0x7) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="FUNC1" edc:desc="Signal function 1 selected" edc:when="(field &amp; 0x7) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="FUNC2" edc:desc="Signal function 2 selected" edc:when="(field &amp; 0x7) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="FUNC3" edc:desc="Signal function 3 selected" edc:when="(field &amp; 0x7) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="INP_DIS" edc:nzwidth="0x1" edc:desc="GPIO input disable"/>
            <edc:SFRFieldDef edc:cname="ALT_GPIO_DATA" edc:nzwidth="0x1" edc:desc="GPIO Alternate Data Register."/>
            <edc:AdjustPoint edc:offset="0x7"/>
            <edc:SFRFieldDef edc:cname="GPIO_INP" edc:nzwidth="0x1" edc:desc="GPIO input from pin, independent of the Mux selection for the pin or the Direction."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL125" edc:nzwidth="0x20" edc:access="-------n-------nnnnnnnnnnnnnnnnn" edc:por="00000000000000001000000001000000" edc:mclr="00000000000000001000000001000000" edc:impl="0x101FFFF" edc:_addr="0x40081154">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="PU_PD" edc:nzwidth="0x2" edc:desc="These bits are used to enable an internal pull-up or pull-down resistor.">
              <edc:SFRFieldSemantic edc:cname="NONE" edc:desc="None. Pin tristates when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="UP" edc:desc="Pull Up Enabled" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="DOWN" edc:desc="Pull Down Enabled" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="REPEATER" edc:desc="Repeater mode. Pin is kept at previous voltage level when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="PWR_GATING" edc:nzwidth="0x2" edc:desc="The GPIO pin will be tristated when the selected power well is off."/>
            <edc:SFRFieldDef edc:cname="INTR_DET" edc:nzwidth="0x3" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="EDGE_EN" edc:nzwidth="0x1" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="OUT_BUFF_TYPE" edc:nzwidth="0x1" edc:desc="0 = Push-Pull, 1 = Open Drain"/>
            <edc:SFRFieldDef edc:cname="GPIO_DIR" edc:nzwidth="0x1" edc:desc="Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output"/>
            <edc:SFRFieldDef edc:cname="GPIO_OUT_SEL" edc:nzwidth="0x1" edc:desc="GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register."/>
            <edc:SFRFieldDef edc:cname="POL" edc:nzwidth="0x1" edc:desc="1=Inverted; 0=Non-inverted"/>
            <edc:SFRFieldDef edc:cname="MUX_CTRL" edc:nzwidth="0x3" edc:desc="00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3.">
              <edc:SFRFieldSemantic edc:cname="GPIO" edc:desc="GPIO function selected" edc:when="(field &amp; 0x7) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="FUNC1" edc:desc="Signal function 1 selected" edc:when="(field &amp; 0x7) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="FUNC2" edc:desc="Signal function 2 selected" edc:when="(field &amp; 0x7) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="FUNC3" edc:desc="Signal function 3 selected" edc:when="(field &amp; 0x7) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="INP_DIS" edc:nzwidth="0x1" edc:desc="GPIO input disable"/>
            <edc:SFRFieldDef edc:cname="ALT_GPIO_DATA" edc:nzwidth="0x1" edc:desc="GPIO Alternate Data Register."/>
            <edc:AdjustPoint edc:offset="0x7"/>
            <edc:SFRFieldDef edc:cname="GPIO_INP" edc:nzwidth="0x1" edc:desc="GPIO input from pin, independent of the Mux selection for the pin or the Direction."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL126" edc:nzwidth="0x20" edc:access="-------n-------nnnnnnnnnnnnnnnnn" edc:por="00000000000000001000000001000000" edc:mclr="00000000000000001000000001000000" edc:impl="0x101FFFF" edc:_addr="0x40081158">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="PU_PD" edc:nzwidth="0x2" edc:desc="These bits are used to enable an internal pull-up or pull-down resistor.">
              <edc:SFRFieldSemantic edc:cname="NONE" edc:desc="None. Pin tristates when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="UP" edc:desc="Pull Up Enabled" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="DOWN" edc:desc="Pull Down Enabled" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="REPEATER" edc:desc="Repeater mode. Pin is kept at previous voltage level when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="PWR_GATING" edc:nzwidth="0x2" edc:desc="The GPIO pin will be tristated when the selected power well is off."/>
            <edc:SFRFieldDef edc:cname="INTR_DET" edc:nzwidth="0x3" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="EDGE_EN" edc:nzwidth="0x1" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="OUT_BUFF_TYPE" edc:nzwidth="0x1" edc:desc="0 = Push-Pull, 1 = Open Drain"/>
            <edc:SFRFieldDef edc:cname="GPIO_DIR" edc:nzwidth="0x1" edc:desc="Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output"/>
            <edc:SFRFieldDef edc:cname="GPIO_OUT_SEL" edc:nzwidth="0x1" edc:desc="GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register."/>
            <edc:SFRFieldDef edc:cname="POL" edc:nzwidth="0x1" edc:desc="1=Inverted; 0=Non-inverted"/>
            <edc:SFRFieldDef edc:cname="MUX_CTRL" edc:nzwidth="0x3" edc:desc="00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3.">
              <edc:SFRFieldSemantic edc:cname="GPIO" edc:desc="GPIO function selected" edc:when="(field &amp; 0x7) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="FUNC1" edc:desc="Signal function 1 selected" edc:when="(field &amp; 0x7) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="FUNC2" edc:desc="Signal function 2 selected" edc:when="(field &amp; 0x7) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="FUNC3" edc:desc="Signal function 3 selected" edc:when="(field &amp; 0x7) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="INP_DIS" edc:nzwidth="0x1" edc:desc="GPIO input disable"/>
            <edc:SFRFieldDef edc:cname="ALT_GPIO_DATA" edc:nzwidth="0x1" edc:desc="GPIO Alternate Data Register."/>
            <edc:AdjustPoint edc:offset="0x7"/>
            <edc:SFRFieldDef edc:cname="GPIO_INP" edc:nzwidth="0x1" edc:desc="GPIO input from pin, independent of the Mux selection for the pin or the Direction."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL127" edc:nzwidth="0x20" edc:access="-------n-------nnnnnnnnnnnnnnnnn" edc:por="00000000000000001000000001000000" edc:mclr="00000000000000001000000001000000" edc:impl="0x101FFFF" edc:_addr="0x4008115C">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="PU_PD" edc:nzwidth="0x2" edc:desc="These bits are used to enable an internal pull-up or pull-down resistor.">
              <edc:SFRFieldSemantic edc:cname="NONE" edc:desc="None. Pin tristates when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="UP" edc:desc="Pull Up Enabled" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="DOWN" edc:desc="Pull Down Enabled" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="REPEATER" edc:desc="Repeater mode. Pin is kept at previous voltage level when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="PWR_GATING" edc:nzwidth="0x2" edc:desc="The GPIO pin will be tristated when the selected power well is off."/>
            <edc:SFRFieldDef edc:cname="INTR_DET" edc:nzwidth="0x3" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="EDGE_EN" edc:nzwidth="0x1" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="OUT_BUFF_TYPE" edc:nzwidth="0x1" edc:desc="0 = Push-Pull, 1 = Open Drain"/>
            <edc:SFRFieldDef edc:cname="GPIO_DIR" edc:nzwidth="0x1" edc:desc="Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output"/>
            <edc:SFRFieldDef edc:cname="GPIO_OUT_SEL" edc:nzwidth="0x1" edc:desc="GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register."/>
            <edc:SFRFieldDef edc:cname="POL" edc:nzwidth="0x1" edc:desc="1=Inverted; 0=Non-inverted"/>
            <edc:SFRFieldDef edc:cname="MUX_CTRL" edc:nzwidth="0x3" edc:desc="00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3.">
              <edc:SFRFieldSemantic edc:cname="GPIO" edc:desc="GPIO function selected" edc:when="(field &amp; 0x7) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="FUNC1" edc:desc="Signal function 1 selected" edc:when="(field &amp; 0x7) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="FUNC2" edc:desc="Signal function 2 selected" edc:when="(field &amp; 0x7) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="FUNC3" edc:desc="Signal function 3 selected" edc:when="(field &amp; 0x7) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="INP_DIS" edc:nzwidth="0x1" edc:desc="GPIO input disable"/>
            <edc:SFRFieldDef edc:cname="ALT_GPIO_DATA" edc:nzwidth="0x1" edc:desc="GPIO Alternate Data Register."/>
            <edc:AdjustPoint edc:offset="0x7"/>
            <edc:SFRFieldDef edc:cname="GPIO_INP" edc:nzwidth="0x1" edc:desc="GPIO input from pin, independent of the Mux selection for the pin or the Direction."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL130" edc:nzwidth="0x20" edc:access="-------n-------nnnnnnnnnnnnnnnnn" edc:por="00000000000000001000000001000000" edc:mclr="00000000000000001000000001000000" edc:impl="0x101FFFF" edc:_addr="0x40081160">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="PU_PD" edc:nzwidth="0x2" edc:desc="These bits are used to enable an internal pull-up or pull-down resistor.">
              <edc:SFRFieldSemantic edc:cname="NONE" edc:desc="None. Pin tristates when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="UP" edc:desc="Pull Up Enabled" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="DOWN" edc:desc="Pull Down Enabled" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="REPEATER" edc:desc="Repeater mode. Pin is kept at previous voltage level when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="PWR_GATING" edc:nzwidth="0x2" edc:desc="The GPIO pin will be tristated when the selected power well is off."/>
            <edc:SFRFieldDef edc:cname="INTR_DET" edc:nzwidth="0x3" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="EDGE_EN" edc:nzwidth="0x1" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="OUT_BUFF_TYPE" edc:nzwidth="0x1" edc:desc="0 = Push-Pull, 1 = Open Drain"/>
            <edc:SFRFieldDef edc:cname="GPIO_DIR" edc:nzwidth="0x1" edc:desc="Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output"/>
            <edc:SFRFieldDef edc:cname="GPIO_OUT_SEL" edc:nzwidth="0x1" edc:desc="GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register."/>
            <edc:SFRFieldDef edc:cname="POL" edc:nzwidth="0x1" edc:desc="1=Inverted; 0=Non-inverted"/>
            <edc:SFRFieldDef edc:cname="MUX_CTRL" edc:nzwidth="0x3" edc:desc="00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3.">
              <edc:SFRFieldSemantic edc:cname="GPIO" edc:desc="GPIO function selected" edc:when="(field &amp; 0x7) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="FUNC1" edc:desc="Signal function 1 selected" edc:when="(field &amp; 0x7) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="FUNC2" edc:desc="Signal function 2 selected" edc:when="(field &amp; 0x7) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="FUNC3" edc:desc="Signal function 3 selected" edc:when="(field &amp; 0x7) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="INP_DIS" edc:nzwidth="0x1" edc:desc="GPIO input disable"/>
            <edc:SFRFieldDef edc:cname="ALT_GPIO_DATA" edc:nzwidth="0x1" edc:desc="GPIO Alternate Data Register."/>
            <edc:AdjustPoint edc:offset="0x7"/>
            <edc:SFRFieldDef edc:cname="GPIO_INP" edc:nzwidth="0x1" edc:desc="GPIO input from pin, independent of the Mux selection for the pin or the Direction."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL131" edc:nzwidth="0x20" edc:access="-------n-------nnnnnnnnnnnnnnnnn" edc:por="00000000000000001000000001000000" edc:mclr="00000000000000001000000001000000" edc:impl="0x101FFFF" edc:_addr="0x40081164">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="PU_PD" edc:nzwidth="0x2" edc:desc="These bits are used to enable an internal pull-up or pull-down resistor.">
              <edc:SFRFieldSemantic edc:cname="NONE" edc:desc="None. Pin tristates when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="UP" edc:desc="Pull Up Enabled" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="DOWN" edc:desc="Pull Down Enabled" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="REPEATER" edc:desc="Repeater mode. Pin is kept at previous voltage level when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="PWR_GATING" edc:nzwidth="0x2" edc:desc="The GPIO pin will be tristated when the selected power well is off."/>
            <edc:SFRFieldDef edc:cname="INTR_DET" edc:nzwidth="0x3" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="EDGE_EN" edc:nzwidth="0x1" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="OUT_BUFF_TYPE" edc:nzwidth="0x1" edc:desc="0 = Push-Pull, 1 = Open Drain"/>
            <edc:SFRFieldDef edc:cname="GPIO_DIR" edc:nzwidth="0x1" edc:desc="Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output"/>
            <edc:SFRFieldDef edc:cname="GPIO_OUT_SEL" edc:nzwidth="0x1" edc:desc="GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register."/>
            <edc:SFRFieldDef edc:cname="POL" edc:nzwidth="0x1" edc:desc="1=Inverted; 0=Non-inverted"/>
            <edc:SFRFieldDef edc:cname="MUX_CTRL" edc:nzwidth="0x3" edc:desc="00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3.">
              <edc:SFRFieldSemantic edc:cname="GPIO" edc:desc="GPIO function selected" edc:when="(field &amp; 0x7) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="FUNC1" edc:desc="Signal function 1 selected" edc:when="(field &amp; 0x7) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="FUNC2" edc:desc="Signal function 2 selected" edc:when="(field &amp; 0x7) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="FUNC3" edc:desc="Signal function 3 selected" edc:when="(field &amp; 0x7) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="INP_DIS" edc:nzwidth="0x1" edc:desc="GPIO input disable"/>
            <edc:SFRFieldDef edc:cname="ALT_GPIO_DATA" edc:nzwidth="0x1" edc:desc="GPIO Alternate Data Register."/>
            <edc:AdjustPoint edc:offset="0x7"/>
            <edc:SFRFieldDef edc:cname="GPIO_INP" edc:nzwidth="0x1" edc:desc="GPIO input from pin, independent of the Mux selection for the pin or the Direction."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL132" edc:nzwidth="0x20" edc:access="-------n-------nnnnnnnnnnnnnnnnn" edc:por="00000000000000001000000001000000" edc:mclr="00000000000000001000000001000000" edc:impl="0x101FFFF" edc:_addr="0x40081168">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="PU_PD" edc:nzwidth="0x2" edc:desc="These bits are used to enable an internal pull-up or pull-down resistor.">
              <edc:SFRFieldSemantic edc:cname="NONE" edc:desc="None. Pin tristates when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="UP" edc:desc="Pull Up Enabled" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="DOWN" edc:desc="Pull Down Enabled" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="REPEATER" edc:desc="Repeater mode. Pin is kept at previous voltage level when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="PWR_GATING" edc:nzwidth="0x2" edc:desc="The GPIO pin will be tristated when the selected power well is off."/>
            <edc:SFRFieldDef edc:cname="INTR_DET" edc:nzwidth="0x3" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="EDGE_EN" edc:nzwidth="0x1" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="OUT_BUFF_TYPE" edc:nzwidth="0x1" edc:desc="0 = Push-Pull, 1 = Open Drain"/>
            <edc:SFRFieldDef edc:cname="GPIO_DIR" edc:nzwidth="0x1" edc:desc="Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output"/>
            <edc:SFRFieldDef edc:cname="GPIO_OUT_SEL" edc:nzwidth="0x1" edc:desc="GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register."/>
            <edc:SFRFieldDef edc:cname="POL" edc:nzwidth="0x1" edc:desc="1=Inverted; 0=Non-inverted"/>
            <edc:SFRFieldDef edc:cname="MUX_CTRL" edc:nzwidth="0x3" edc:desc="00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3.">
              <edc:SFRFieldSemantic edc:cname="GPIO" edc:desc="GPIO function selected" edc:when="(field &amp; 0x7) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="FUNC1" edc:desc="Signal function 1 selected" edc:when="(field &amp; 0x7) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="FUNC2" edc:desc="Signal function 2 selected" edc:when="(field &amp; 0x7) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="FUNC3" edc:desc="Signal function 3 selected" edc:when="(field &amp; 0x7) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="INP_DIS" edc:nzwidth="0x1" edc:desc="GPIO input disable"/>
            <edc:SFRFieldDef edc:cname="ALT_GPIO_DATA" edc:nzwidth="0x1" edc:desc="GPIO Alternate Data Register."/>
            <edc:AdjustPoint edc:offset="0x7"/>
            <edc:SFRFieldDef edc:cname="GPIO_INP" edc:nzwidth="0x1" edc:desc="GPIO input from pin, independent of the Mux selection for the pin or the Direction."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL133" edc:nzwidth="0x20" edc:access="-------n-------nnnnnnnnnnnnnnnnn" edc:por="00000000000000001000000001000000" edc:mclr="00000000000000001000000001000000" edc:impl="0x101FFFF" edc:_addr="0x4008116C">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="PU_PD" edc:nzwidth="0x2" edc:desc="These bits are used to enable an internal pull-up or pull-down resistor.">
              <edc:SFRFieldSemantic edc:cname="NONE" edc:desc="None. Pin tristates when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="UP" edc:desc="Pull Up Enabled" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="DOWN" edc:desc="Pull Down Enabled" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="REPEATER" edc:desc="Repeater mode. Pin is kept at previous voltage level when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="PWR_GATING" edc:nzwidth="0x2" edc:desc="The GPIO pin will be tristated when the selected power well is off."/>
            <edc:SFRFieldDef edc:cname="INTR_DET" edc:nzwidth="0x3" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="EDGE_EN" edc:nzwidth="0x1" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="OUT_BUFF_TYPE" edc:nzwidth="0x1" edc:desc="0 = Push-Pull, 1 = Open Drain"/>
            <edc:SFRFieldDef edc:cname="GPIO_DIR" edc:nzwidth="0x1" edc:desc="Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output"/>
            <edc:SFRFieldDef edc:cname="GPIO_OUT_SEL" edc:nzwidth="0x1" edc:desc="GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register."/>
            <edc:SFRFieldDef edc:cname="POL" edc:nzwidth="0x1" edc:desc="1=Inverted; 0=Non-inverted"/>
            <edc:SFRFieldDef edc:cname="MUX_CTRL" edc:nzwidth="0x3" edc:desc="00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3.">
              <edc:SFRFieldSemantic edc:cname="GPIO" edc:desc="GPIO function selected" edc:when="(field &amp; 0x7) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="FUNC1" edc:desc="Signal function 1 selected" edc:when="(field &amp; 0x7) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="FUNC2" edc:desc="Signal function 2 selected" edc:when="(field &amp; 0x7) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="FUNC3" edc:desc="Signal function 3 selected" edc:when="(field &amp; 0x7) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="INP_DIS" edc:nzwidth="0x1" edc:desc="GPIO input disable"/>
            <edc:SFRFieldDef edc:cname="ALT_GPIO_DATA" edc:nzwidth="0x1" edc:desc="GPIO Alternate Data Register."/>
            <edc:AdjustPoint edc:offset="0x7"/>
            <edc:SFRFieldDef edc:cname="GPIO_INP" edc:nzwidth="0x1" edc:desc="GPIO input from pin, independent of the Mux selection for the pin or the Direction."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL134" edc:nzwidth="0x20" edc:access="-------n-------nnnnnnnnnnnnnnnnn" edc:por="00000000000000001000000001000000" edc:mclr="00000000000000001000000001000000" edc:impl="0x101FFFF" edc:_addr="0x40081170">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="PU_PD" edc:nzwidth="0x2" edc:desc="These bits are used to enable an internal pull-up or pull-down resistor.">
              <edc:SFRFieldSemantic edc:cname="NONE" edc:desc="None. Pin tristates when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="UP" edc:desc="Pull Up Enabled" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="DOWN" edc:desc="Pull Down Enabled" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="REPEATER" edc:desc="Repeater mode. Pin is kept at previous voltage level when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="PWR_GATING" edc:nzwidth="0x2" edc:desc="The GPIO pin will be tristated when the selected power well is off."/>
            <edc:SFRFieldDef edc:cname="INTR_DET" edc:nzwidth="0x3" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="EDGE_EN" edc:nzwidth="0x1" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="OUT_BUFF_TYPE" edc:nzwidth="0x1" edc:desc="0 = Push-Pull, 1 = Open Drain"/>
            <edc:SFRFieldDef edc:cname="GPIO_DIR" edc:nzwidth="0x1" edc:desc="Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output"/>
            <edc:SFRFieldDef edc:cname="GPIO_OUT_SEL" edc:nzwidth="0x1" edc:desc="GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register."/>
            <edc:SFRFieldDef edc:cname="POL" edc:nzwidth="0x1" edc:desc="1=Inverted; 0=Non-inverted"/>
            <edc:SFRFieldDef edc:cname="MUX_CTRL" edc:nzwidth="0x3" edc:desc="00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3.">
              <edc:SFRFieldSemantic edc:cname="GPIO" edc:desc="GPIO function selected" edc:when="(field &amp; 0x7) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="FUNC1" edc:desc="Signal function 1 selected" edc:when="(field &amp; 0x7) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="FUNC2" edc:desc="Signal function 2 selected" edc:when="(field &amp; 0x7) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="FUNC3" edc:desc="Signal function 3 selected" edc:when="(field &amp; 0x7) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="INP_DIS" edc:nzwidth="0x1" edc:desc="GPIO input disable"/>
            <edc:SFRFieldDef edc:cname="ALT_GPIO_DATA" edc:nzwidth="0x1" edc:desc="GPIO Alternate Data Register."/>
            <edc:AdjustPoint edc:offset="0x7"/>
            <edc:SFRFieldDef edc:cname="GPIO_INP" edc:nzwidth="0x1" edc:desc="GPIO input from pin, independent of the Mux selection for the pin or the Direction."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL135" edc:nzwidth="0x20" edc:access="-------n-------nnnnnnnnnnnnnnnnn" edc:por="00000000000000001000000001000000" edc:mclr="00000000000000001000000001000000" edc:impl="0x101FFFF" edc:_addr="0x40081174">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="PU_PD" edc:nzwidth="0x2" edc:desc="These bits are used to enable an internal pull-up or pull-down resistor.">
              <edc:SFRFieldSemantic edc:cname="NONE" edc:desc="None. Pin tristates when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="UP" edc:desc="Pull Up Enabled" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="DOWN" edc:desc="Pull Down Enabled" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="REPEATER" edc:desc="Repeater mode. Pin is kept at previous voltage level when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="PWR_GATING" edc:nzwidth="0x2" edc:desc="The GPIO pin will be tristated when the selected power well is off."/>
            <edc:SFRFieldDef edc:cname="INTR_DET" edc:nzwidth="0x3" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="EDGE_EN" edc:nzwidth="0x1" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="OUT_BUFF_TYPE" edc:nzwidth="0x1" edc:desc="0 = Push-Pull, 1 = Open Drain"/>
            <edc:SFRFieldDef edc:cname="GPIO_DIR" edc:nzwidth="0x1" edc:desc="Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output"/>
            <edc:SFRFieldDef edc:cname="GPIO_OUT_SEL" edc:nzwidth="0x1" edc:desc="GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register."/>
            <edc:SFRFieldDef edc:cname="POL" edc:nzwidth="0x1" edc:desc="1=Inverted; 0=Non-inverted"/>
            <edc:SFRFieldDef edc:cname="MUX_CTRL" edc:nzwidth="0x3" edc:desc="00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3.">
              <edc:SFRFieldSemantic edc:cname="GPIO" edc:desc="GPIO function selected" edc:when="(field &amp; 0x7) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="FUNC1" edc:desc="Signal function 1 selected" edc:when="(field &amp; 0x7) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="FUNC2" edc:desc="Signal function 2 selected" edc:when="(field &amp; 0x7) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="FUNC3" edc:desc="Signal function 3 selected" edc:when="(field &amp; 0x7) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="INP_DIS" edc:nzwidth="0x1" edc:desc="GPIO input disable"/>
            <edc:SFRFieldDef edc:cname="ALT_GPIO_DATA" edc:nzwidth="0x1" edc:desc="GPIO Alternate Data Register."/>
            <edc:AdjustPoint edc:offset="0x7"/>
            <edc:SFRFieldDef edc:cname="GPIO_INP" edc:nzwidth="0x1" edc:desc="GPIO input from pin, independent of the Mux selection for the pin or the Direction."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL136" edc:nzwidth="0x20" edc:access="-------n-------nnnnnnnnnnnnnnnnn" edc:por="00000000000000001000000001000000" edc:mclr="00000000000000001000000001000000" edc:impl="0x101FFFF" edc:_addr="0x40081178">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="PU_PD" edc:nzwidth="0x2" edc:desc="These bits are used to enable an internal pull-up or pull-down resistor.">
              <edc:SFRFieldSemantic edc:cname="NONE" edc:desc="None. Pin tristates when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="UP" edc:desc="Pull Up Enabled" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="DOWN" edc:desc="Pull Down Enabled" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="REPEATER" edc:desc="Repeater mode. Pin is kept at previous voltage level when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="PWR_GATING" edc:nzwidth="0x2" edc:desc="The GPIO pin will be tristated when the selected power well is off."/>
            <edc:SFRFieldDef edc:cname="INTR_DET" edc:nzwidth="0x3" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="EDGE_EN" edc:nzwidth="0x1" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="OUT_BUFF_TYPE" edc:nzwidth="0x1" edc:desc="0 = Push-Pull, 1 = Open Drain"/>
            <edc:SFRFieldDef edc:cname="GPIO_DIR" edc:nzwidth="0x1" edc:desc="Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output"/>
            <edc:SFRFieldDef edc:cname="GPIO_OUT_SEL" edc:nzwidth="0x1" edc:desc="GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register."/>
            <edc:SFRFieldDef edc:cname="POL" edc:nzwidth="0x1" edc:desc="1=Inverted; 0=Non-inverted"/>
            <edc:SFRFieldDef edc:cname="MUX_CTRL" edc:nzwidth="0x3" edc:desc="00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3.">
              <edc:SFRFieldSemantic edc:cname="GPIO" edc:desc="GPIO function selected" edc:when="(field &amp; 0x7) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="FUNC1" edc:desc="Signal function 1 selected" edc:when="(field &amp; 0x7) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="FUNC2" edc:desc="Signal function 2 selected" edc:when="(field &amp; 0x7) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="FUNC3" edc:desc="Signal function 3 selected" edc:when="(field &amp; 0x7) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="INP_DIS" edc:nzwidth="0x1" edc:desc="GPIO input disable"/>
            <edc:SFRFieldDef edc:cname="ALT_GPIO_DATA" edc:nzwidth="0x1" edc:desc="GPIO Alternate Data Register."/>
            <edc:AdjustPoint edc:offset="0x7"/>
            <edc:SFRFieldDef edc:cname="GPIO_INP" edc:nzwidth="0x1" edc:desc="GPIO input from pin, independent of the Mux selection for the pin or the Direction."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL137" edc:nzwidth="0x20" edc:access="-------n-------nnnnnnnnnnnnnnnnn" edc:por="00000000000000001000000001000000" edc:mclr="00000000000000001000000001000000" edc:impl="0x101FFFF" edc:_addr="0x4008117C">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="PU_PD" edc:nzwidth="0x2" edc:desc="These bits are used to enable an internal pull-up or pull-down resistor.">
              <edc:SFRFieldSemantic edc:cname="NONE" edc:desc="None. Pin tristates when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="UP" edc:desc="Pull Up Enabled" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="DOWN" edc:desc="Pull Down Enabled" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="REPEATER" edc:desc="Repeater mode. Pin is kept at previous voltage level when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="PWR_GATING" edc:nzwidth="0x2" edc:desc="The GPIO pin will be tristated when the selected power well is off."/>
            <edc:SFRFieldDef edc:cname="INTR_DET" edc:nzwidth="0x3" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="EDGE_EN" edc:nzwidth="0x1" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="OUT_BUFF_TYPE" edc:nzwidth="0x1" edc:desc="0 = Push-Pull, 1 = Open Drain"/>
            <edc:SFRFieldDef edc:cname="GPIO_DIR" edc:nzwidth="0x1" edc:desc="Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output"/>
            <edc:SFRFieldDef edc:cname="GPIO_OUT_SEL" edc:nzwidth="0x1" edc:desc="GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register."/>
            <edc:SFRFieldDef edc:cname="POL" edc:nzwidth="0x1" edc:desc="1=Inverted; 0=Non-inverted"/>
            <edc:SFRFieldDef edc:cname="MUX_CTRL" edc:nzwidth="0x3" edc:desc="00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3.">
              <edc:SFRFieldSemantic edc:cname="GPIO" edc:desc="GPIO function selected" edc:when="(field &amp; 0x7) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="FUNC1" edc:desc="Signal function 1 selected" edc:when="(field &amp; 0x7) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="FUNC2" edc:desc="Signal function 2 selected" edc:when="(field &amp; 0x7) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="FUNC3" edc:desc="Signal function 3 selected" edc:when="(field &amp; 0x7) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="INP_DIS" edc:nzwidth="0x1" edc:desc="GPIO input disable"/>
            <edc:SFRFieldDef edc:cname="ALT_GPIO_DATA" edc:nzwidth="0x1" edc:desc="GPIO Alternate Data Register."/>
            <edc:AdjustPoint edc:offset="0x7"/>
            <edc:SFRFieldDef edc:cname="GPIO_INP" edc:nzwidth="0x1" edc:desc="GPIO input from pin, independent of the Mux selection for the pin or the Direction."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL140" edc:nzwidth="0x20" edc:access="-------n-------nnnnnnnnnnnnnnnnn" edc:por="00000000000000001000000001000000" edc:mclr="00000000000000001000000001000000" edc:impl="0x101FFFF" edc:_addr="0x40081180">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="PU_PD" edc:nzwidth="0x2" edc:desc="These bits are used to enable an internal pull-up or pull-down resistor.">
              <edc:SFRFieldSemantic edc:cname="NONE" edc:desc="None. Pin tristates when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="UP" edc:desc="Pull Up Enabled" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="DOWN" edc:desc="Pull Down Enabled" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="REPEATER" edc:desc="Repeater mode. Pin is kept at previous voltage level when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="PWR_GATING" edc:nzwidth="0x2" edc:desc="The GPIO pin will be tristated when the selected power well is off."/>
            <edc:SFRFieldDef edc:cname="INTR_DET" edc:nzwidth="0x3" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="EDGE_EN" edc:nzwidth="0x1" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="OUT_BUFF_TYPE" edc:nzwidth="0x1" edc:desc="0 = Push-Pull, 1 = Open Drain"/>
            <edc:SFRFieldDef edc:cname="GPIO_DIR" edc:nzwidth="0x1" edc:desc="Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output"/>
            <edc:SFRFieldDef edc:cname="GPIO_OUT_SEL" edc:nzwidth="0x1" edc:desc="GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register."/>
            <edc:SFRFieldDef edc:cname="POL" edc:nzwidth="0x1" edc:desc="1=Inverted; 0=Non-inverted"/>
            <edc:SFRFieldDef edc:cname="MUX_CTRL" edc:nzwidth="0x3" edc:desc="00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3.">
              <edc:SFRFieldSemantic edc:cname="GPIO" edc:desc="GPIO function selected" edc:when="(field &amp; 0x7) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="FUNC1" edc:desc="Signal function 1 selected" edc:when="(field &amp; 0x7) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="FUNC2" edc:desc="Signal function 2 selected" edc:when="(field &amp; 0x7) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="FUNC3" edc:desc="Signal function 3 selected" edc:when="(field &amp; 0x7) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="INP_DIS" edc:nzwidth="0x1" edc:desc="GPIO input disable"/>
            <edc:SFRFieldDef edc:cname="ALT_GPIO_DATA" edc:nzwidth="0x1" edc:desc="GPIO Alternate Data Register."/>
            <edc:AdjustPoint edc:offset="0x7"/>
            <edc:SFRFieldDef edc:cname="GPIO_INP" edc:nzwidth="0x1" edc:desc="GPIO input from pin, independent of the Mux selection for the pin or the Direction."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL141" edc:nzwidth="0x20" edc:access="-------n-------nnnnnnnnnnnnnnnnn" edc:por="00000000000000001000000001000000" edc:mclr="00000000000000001000000001000000" edc:impl="0x101FFFF" edc:_addr="0x40081184">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="PU_PD" edc:nzwidth="0x2" edc:desc="These bits are used to enable an internal pull-up or pull-down resistor.">
              <edc:SFRFieldSemantic edc:cname="NONE" edc:desc="None. Pin tristates when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="UP" edc:desc="Pull Up Enabled" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="DOWN" edc:desc="Pull Down Enabled" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="REPEATER" edc:desc="Repeater mode. Pin is kept at previous voltage level when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="PWR_GATING" edc:nzwidth="0x2" edc:desc="The GPIO pin will be tristated when the selected power well is off."/>
            <edc:SFRFieldDef edc:cname="INTR_DET" edc:nzwidth="0x3" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="EDGE_EN" edc:nzwidth="0x1" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="OUT_BUFF_TYPE" edc:nzwidth="0x1" edc:desc="0 = Push-Pull, 1 = Open Drain"/>
            <edc:SFRFieldDef edc:cname="GPIO_DIR" edc:nzwidth="0x1" edc:desc="Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output"/>
            <edc:SFRFieldDef edc:cname="GPIO_OUT_SEL" edc:nzwidth="0x1" edc:desc="GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register."/>
            <edc:SFRFieldDef edc:cname="POL" edc:nzwidth="0x1" edc:desc="1=Inverted; 0=Non-inverted"/>
            <edc:SFRFieldDef edc:cname="MUX_CTRL" edc:nzwidth="0x3" edc:desc="00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3.">
              <edc:SFRFieldSemantic edc:cname="GPIO" edc:desc="GPIO function selected" edc:when="(field &amp; 0x7) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="FUNC1" edc:desc="Signal function 1 selected" edc:when="(field &amp; 0x7) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="FUNC2" edc:desc="Signal function 2 selected" edc:when="(field &amp; 0x7) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="FUNC3" edc:desc="Signal function 3 selected" edc:when="(field &amp; 0x7) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="INP_DIS" edc:nzwidth="0x1" edc:desc="GPIO input disable"/>
            <edc:SFRFieldDef edc:cname="ALT_GPIO_DATA" edc:nzwidth="0x1" edc:desc="GPIO Alternate Data Register."/>
            <edc:AdjustPoint edc:offset="0x7"/>
            <edc:SFRFieldDef edc:cname="GPIO_INP" edc:nzwidth="0x1" edc:desc="GPIO input from pin, independent of the Mux selection for the pin or the Direction."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL142" edc:nzwidth="0x20" edc:access="-------n-------nnnnnnnnnnnnnnnnn" edc:por="00000000000000001000000001000000" edc:mclr="00000000000000001000000001000000" edc:impl="0x101FFFF" edc:_addr="0x40081188">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="PU_PD" edc:nzwidth="0x2" edc:desc="These bits are used to enable an internal pull-up or pull-down resistor.">
              <edc:SFRFieldSemantic edc:cname="NONE" edc:desc="None. Pin tristates when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="UP" edc:desc="Pull Up Enabled" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="DOWN" edc:desc="Pull Down Enabled" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="REPEATER" edc:desc="Repeater mode. Pin is kept at previous voltage level when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="PWR_GATING" edc:nzwidth="0x2" edc:desc="The GPIO pin will be tristated when the selected power well is off."/>
            <edc:SFRFieldDef edc:cname="INTR_DET" edc:nzwidth="0x3" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="EDGE_EN" edc:nzwidth="0x1" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="OUT_BUFF_TYPE" edc:nzwidth="0x1" edc:desc="0 = Push-Pull, 1 = Open Drain"/>
            <edc:SFRFieldDef edc:cname="GPIO_DIR" edc:nzwidth="0x1" edc:desc="Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output"/>
            <edc:SFRFieldDef edc:cname="GPIO_OUT_SEL" edc:nzwidth="0x1" edc:desc="GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register."/>
            <edc:SFRFieldDef edc:cname="POL" edc:nzwidth="0x1" edc:desc="1=Inverted; 0=Non-inverted"/>
            <edc:SFRFieldDef edc:cname="MUX_CTRL" edc:nzwidth="0x3" edc:desc="00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3.">
              <edc:SFRFieldSemantic edc:cname="GPIO" edc:desc="GPIO function selected" edc:when="(field &amp; 0x7) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="FUNC1" edc:desc="Signal function 1 selected" edc:when="(field &amp; 0x7) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="FUNC2" edc:desc="Signal function 2 selected" edc:when="(field &amp; 0x7) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="FUNC3" edc:desc="Signal function 3 selected" edc:when="(field &amp; 0x7) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="INP_DIS" edc:nzwidth="0x1" edc:desc="GPIO input disable"/>
            <edc:SFRFieldDef edc:cname="ALT_GPIO_DATA" edc:nzwidth="0x1" edc:desc="GPIO Alternate Data Register."/>
            <edc:AdjustPoint edc:offset="0x7"/>
            <edc:SFRFieldDef edc:cname="GPIO_INP" edc:nzwidth="0x1" edc:desc="GPIO input from pin, independent of the Mux selection for the pin or the Direction."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL143" edc:nzwidth="0x20" edc:access="-------n-------nnnnnnnnnnnnnnnnn" edc:por="00000000000000001000000001000000" edc:mclr="00000000000000001000000001000000" edc:impl="0x101FFFF" edc:_addr="0x4008118C">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="PU_PD" edc:nzwidth="0x2" edc:desc="These bits are used to enable an internal pull-up or pull-down resistor.">
              <edc:SFRFieldSemantic edc:cname="NONE" edc:desc="None. Pin tristates when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="UP" edc:desc="Pull Up Enabled" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="DOWN" edc:desc="Pull Down Enabled" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="REPEATER" edc:desc="Repeater mode. Pin is kept at previous voltage level when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="PWR_GATING" edc:nzwidth="0x2" edc:desc="The GPIO pin will be tristated when the selected power well is off."/>
            <edc:SFRFieldDef edc:cname="INTR_DET" edc:nzwidth="0x3" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="EDGE_EN" edc:nzwidth="0x1" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="OUT_BUFF_TYPE" edc:nzwidth="0x1" edc:desc="0 = Push-Pull, 1 = Open Drain"/>
            <edc:SFRFieldDef edc:cname="GPIO_DIR" edc:nzwidth="0x1" edc:desc="Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output"/>
            <edc:SFRFieldDef edc:cname="GPIO_OUT_SEL" edc:nzwidth="0x1" edc:desc="GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register."/>
            <edc:SFRFieldDef edc:cname="POL" edc:nzwidth="0x1" edc:desc="1=Inverted; 0=Non-inverted"/>
            <edc:SFRFieldDef edc:cname="MUX_CTRL" edc:nzwidth="0x3" edc:desc="00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3.">
              <edc:SFRFieldSemantic edc:cname="GPIO" edc:desc="GPIO function selected" edc:when="(field &amp; 0x7) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="FUNC1" edc:desc="Signal function 1 selected" edc:when="(field &amp; 0x7) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="FUNC2" edc:desc="Signal function 2 selected" edc:when="(field &amp; 0x7) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="FUNC3" edc:desc="Signal function 3 selected" edc:when="(field &amp; 0x7) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="INP_DIS" edc:nzwidth="0x1" edc:desc="GPIO input disable"/>
            <edc:SFRFieldDef edc:cname="ALT_GPIO_DATA" edc:nzwidth="0x1" edc:desc="GPIO Alternate Data Register."/>
            <edc:AdjustPoint edc:offset="0x7"/>
            <edc:SFRFieldDef edc:cname="GPIO_INP" edc:nzwidth="0x1" edc:desc="GPIO input from pin, independent of the Mux selection for the pin or the Direction."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL144" edc:nzwidth="0x20" edc:access="-------n-------nnnnnnnnnnnnnnnnn" edc:por="00000000000000001000000001000000" edc:mclr="00000000000000001000000001000000" edc:impl="0x101FFFF" edc:_addr="0x40081190">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="PU_PD" edc:nzwidth="0x2" edc:desc="These bits are used to enable an internal pull-up or pull-down resistor.">
              <edc:SFRFieldSemantic edc:cname="NONE" edc:desc="None. Pin tristates when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="UP" edc:desc="Pull Up Enabled" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="DOWN" edc:desc="Pull Down Enabled" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="REPEATER" edc:desc="Repeater mode. Pin is kept at previous voltage level when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="PWR_GATING" edc:nzwidth="0x2" edc:desc="The GPIO pin will be tristated when the selected power well is off."/>
            <edc:SFRFieldDef edc:cname="INTR_DET" edc:nzwidth="0x3" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="EDGE_EN" edc:nzwidth="0x1" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="OUT_BUFF_TYPE" edc:nzwidth="0x1" edc:desc="0 = Push-Pull, 1 = Open Drain"/>
            <edc:SFRFieldDef edc:cname="GPIO_DIR" edc:nzwidth="0x1" edc:desc="Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output"/>
            <edc:SFRFieldDef edc:cname="GPIO_OUT_SEL" edc:nzwidth="0x1" edc:desc="GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register."/>
            <edc:SFRFieldDef edc:cname="POL" edc:nzwidth="0x1" edc:desc="1=Inverted; 0=Non-inverted"/>
            <edc:SFRFieldDef edc:cname="MUX_CTRL" edc:nzwidth="0x3" edc:desc="00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3.">
              <edc:SFRFieldSemantic edc:cname="GPIO" edc:desc="GPIO function selected" edc:when="(field &amp; 0x7) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="FUNC1" edc:desc="Signal function 1 selected" edc:when="(field &amp; 0x7) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="FUNC2" edc:desc="Signal function 2 selected" edc:when="(field &amp; 0x7) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="FUNC3" edc:desc="Signal function 3 selected" edc:when="(field &amp; 0x7) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="INP_DIS" edc:nzwidth="0x1" edc:desc="GPIO input disable"/>
            <edc:SFRFieldDef edc:cname="ALT_GPIO_DATA" edc:nzwidth="0x1" edc:desc="GPIO Alternate Data Register."/>
            <edc:AdjustPoint edc:offset="0x7"/>
            <edc:SFRFieldDef edc:cname="GPIO_INP" edc:nzwidth="0x1" edc:desc="GPIO input from pin, independent of the Mux selection for the pin or the Direction."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL145" edc:nzwidth="0x20" edc:access="-------n-------nnnnnnnnnnnnnnnnn" edc:por="00000000000000001000000001000000" edc:mclr="00000000000000001000000001000000" edc:impl="0x101FFFF" edc:_addr="0x40081194">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="PU_PD" edc:nzwidth="0x2" edc:desc="These bits are used to enable an internal pull-up or pull-down resistor.">
              <edc:SFRFieldSemantic edc:cname="NONE" edc:desc="None. Pin tristates when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="UP" edc:desc="Pull Up Enabled" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="DOWN" edc:desc="Pull Down Enabled" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="REPEATER" edc:desc="Repeater mode. Pin is kept at previous voltage level when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="PWR_GATING" edc:nzwidth="0x2" edc:desc="The GPIO pin will be tristated when the selected power well is off."/>
            <edc:SFRFieldDef edc:cname="INTR_DET" edc:nzwidth="0x3" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="EDGE_EN" edc:nzwidth="0x1" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="OUT_BUFF_TYPE" edc:nzwidth="0x1" edc:desc="0 = Push-Pull, 1 = Open Drain"/>
            <edc:SFRFieldDef edc:cname="GPIO_DIR" edc:nzwidth="0x1" edc:desc="Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output"/>
            <edc:SFRFieldDef edc:cname="GPIO_OUT_SEL" edc:nzwidth="0x1" edc:desc="GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register."/>
            <edc:SFRFieldDef edc:cname="POL" edc:nzwidth="0x1" edc:desc="1=Inverted; 0=Non-inverted"/>
            <edc:SFRFieldDef edc:cname="MUX_CTRL" edc:nzwidth="0x3" edc:desc="00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3.">
              <edc:SFRFieldSemantic edc:cname="GPIO" edc:desc="GPIO function selected" edc:when="(field &amp; 0x7) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="FUNC1" edc:desc="Signal function 1 selected" edc:when="(field &amp; 0x7) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="FUNC2" edc:desc="Signal function 2 selected" edc:when="(field &amp; 0x7) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="FUNC3" edc:desc="Signal function 3 selected" edc:when="(field &amp; 0x7) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="INP_DIS" edc:nzwidth="0x1" edc:desc="GPIO input disable"/>
            <edc:SFRFieldDef edc:cname="ALT_GPIO_DATA" edc:nzwidth="0x1" edc:desc="GPIO Alternate Data Register."/>
            <edc:AdjustPoint edc:offset="0x7"/>
            <edc:SFRFieldDef edc:cname="GPIO_INP" edc:nzwidth="0x1" edc:desc="GPIO input from pin, independent of the Mux selection for the pin or the Direction."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL146" edc:nzwidth="0x20" edc:access="-------n-------nnnnnnnnnnnnnnnnn" edc:por="00000000000000001000000001000000" edc:mclr="00000000000000001000000001000000" edc:impl="0x101FFFF" edc:_addr="0x40081198">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="PU_PD" edc:nzwidth="0x2" edc:desc="These bits are used to enable an internal pull-up or pull-down resistor.">
              <edc:SFRFieldSemantic edc:cname="NONE" edc:desc="None. Pin tristates when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="UP" edc:desc="Pull Up Enabled" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="DOWN" edc:desc="Pull Down Enabled" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="REPEATER" edc:desc="Repeater mode. Pin is kept at previous voltage level when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="PWR_GATING" edc:nzwidth="0x2" edc:desc="The GPIO pin will be tristated when the selected power well is off."/>
            <edc:SFRFieldDef edc:cname="INTR_DET" edc:nzwidth="0x3" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="EDGE_EN" edc:nzwidth="0x1" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="OUT_BUFF_TYPE" edc:nzwidth="0x1" edc:desc="0 = Push-Pull, 1 = Open Drain"/>
            <edc:SFRFieldDef edc:cname="GPIO_DIR" edc:nzwidth="0x1" edc:desc="Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output"/>
            <edc:SFRFieldDef edc:cname="GPIO_OUT_SEL" edc:nzwidth="0x1" edc:desc="GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register."/>
            <edc:SFRFieldDef edc:cname="POL" edc:nzwidth="0x1" edc:desc="1=Inverted; 0=Non-inverted"/>
            <edc:SFRFieldDef edc:cname="MUX_CTRL" edc:nzwidth="0x3" edc:desc="00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3.">
              <edc:SFRFieldSemantic edc:cname="GPIO" edc:desc="GPIO function selected" edc:when="(field &amp; 0x7) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="FUNC1" edc:desc="Signal function 1 selected" edc:when="(field &amp; 0x7) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="FUNC2" edc:desc="Signal function 2 selected" edc:when="(field &amp; 0x7) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="FUNC3" edc:desc="Signal function 3 selected" edc:when="(field &amp; 0x7) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="INP_DIS" edc:nzwidth="0x1" edc:desc="GPIO input disable"/>
            <edc:SFRFieldDef edc:cname="ALT_GPIO_DATA" edc:nzwidth="0x1" edc:desc="GPIO Alternate Data Register."/>
            <edc:AdjustPoint edc:offset="0x7"/>
            <edc:SFRFieldDef edc:cname="GPIO_INP" edc:nzwidth="0x1" edc:desc="GPIO input from pin, independent of the Mux selection for the pin or the Direction."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL147" edc:nzwidth="0x20" edc:access="-------n-------nnnnnnnnnnnnnnnnn" edc:por="00000000000000001000000001000000" edc:mclr="00000000000000001000000001000000" edc:impl="0x101FFFF" edc:_addr="0x4008119C">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="PU_PD" edc:nzwidth="0x2" edc:desc="These bits are used to enable an internal pull-up or pull-down resistor.">
              <edc:SFRFieldSemantic edc:cname="NONE" edc:desc="None. Pin tristates when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="UP" edc:desc="Pull Up Enabled" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="DOWN" edc:desc="Pull Down Enabled" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="REPEATER" edc:desc="Repeater mode. Pin is kept at previous voltage level when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="PWR_GATING" edc:nzwidth="0x2" edc:desc="The GPIO pin will be tristated when the selected power well is off."/>
            <edc:SFRFieldDef edc:cname="INTR_DET" edc:nzwidth="0x3" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="EDGE_EN" edc:nzwidth="0x1" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="OUT_BUFF_TYPE" edc:nzwidth="0x1" edc:desc="0 = Push-Pull, 1 = Open Drain"/>
            <edc:SFRFieldDef edc:cname="GPIO_DIR" edc:nzwidth="0x1" edc:desc="Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output"/>
            <edc:SFRFieldDef edc:cname="GPIO_OUT_SEL" edc:nzwidth="0x1" edc:desc="GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register."/>
            <edc:SFRFieldDef edc:cname="POL" edc:nzwidth="0x1" edc:desc="1=Inverted; 0=Non-inverted"/>
            <edc:SFRFieldDef edc:cname="MUX_CTRL" edc:nzwidth="0x3" edc:desc="00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3.">
              <edc:SFRFieldSemantic edc:cname="GPIO" edc:desc="GPIO function selected" edc:when="(field &amp; 0x7) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="FUNC1" edc:desc="Signal function 1 selected" edc:when="(field &amp; 0x7) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="FUNC2" edc:desc="Signal function 2 selected" edc:when="(field &amp; 0x7) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="FUNC3" edc:desc="Signal function 3 selected" edc:when="(field &amp; 0x7) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="INP_DIS" edc:nzwidth="0x1" edc:desc="GPIO input disable"/>
            <edc:SFRFieldDef edc:cname="ALT_GPIO_DATA" edc:nzwidth="0x1" edc:desc="GPIO Alternate Data Register."/>
            <edc:AdjustPoint edc:offset="0x7"/>
            <edc:SFRFieldDef edc:cname="GPIO_INP" edc:nzwidth="0x1" edc:desc="GPIO input from pin, independent of the Mux selection for the pin or the Direction."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL150" edc:nzwidth="0x20" edc:access="-------n-------nnnnnnnnnnnnnnnnn" edc:por="00000000000000001000000001000000" edc:mclr="00000000000000001000000001000000" edc:impl="0x101FFFF" edc:_addr="0x400811A0">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="PU_PD" edc:nzwidth="0x2" edc:desc="These bits are used to enable an internal pull-up or pull-down resistor.">
              <edc:SFRFieldSemantic edc:cname="NONE" edc:desc="None. Pin tristates when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="UP" edc:desc="Pull Up Enabled" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="DOWN" edc:desc="Pull Down Enabled" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="REPEATER" edc:desc="Repeater mode. Pin is kept at previous voltage level when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="PWR_GATING" edc:nzwidth="0x2" edc:desc="The GPIO pin will be tristated when the selected power well is off."/>
            <edc:SFRFieldDef edc:cname="INTR_DET" edc:nzwidth="0x3" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="EDGE_EN" edc:nzwidth="0x1" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="OUT_BUFF_TYPE" edc:nzwidth="0x1" edc:desc="0 = Push-Pull, 1 = Open Drain"/>
            <edc:SFRFieldDef edc:cname="GPIO_DIR" edc:nzwidth="0x1" edc:desc="Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output"/>
            <edc:SFRFieldDef edc:cname="GPIO_OUT_SEL" edc:nzwidth="0x1" edc:desc="GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register."/>
            <edc:SFRFieldDef edc:cname="POL" edc:nzwidth="0x1" edc:desc="1=Inverted; 0=Non-inverted"/>
            <edc:SFRFieldDef edc:cname="MUX_CTRL" edc:nzwidth="0x3" edc:desc="00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3.">
              <edc:SFRFieldSemantic edc:cname="GPIO" edc:desc="GPIO function selected" edc:when="(field &amp; 0x7) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="FUNC1" edc:desc="Signal function 1 selected" edc:when="(field &amp; 0x7) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="FUNC2" edc:desc="Signal function 2 selected" edc:when="(field &amp; 0x7) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="FUNC3" edc:desc="Signal function 3 selected" edc:when="(field &amp; 0x7) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="INP_DIS" edc:nzwidth="0x1" edc:desc="GPIO input disable"/>
            <edc:SFRFieldDef edc:cname="ALT_GPIO_DATA" edc:nzwidth="0x1" edc:desc="GPIO Alternate Data Register."/>
            <edc:AdjustPoint edc:offset="0x7"/>
            <edc:SFRFieldDef edc:cname="GPIO_INP" edc:nzwidth="0x1" edc:desc="GPIO input from pin, independent of the Mux selection for the pin or the Direction."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL151" edc:nzwidth="0x20" edc:access="-------n-------nnnnnnnnnnnnnnnnn" edc:por="00000000000000001000000001000000" edc:mclr="00000000000000001000000001000000" edc:impl="0x101FFFF" edc:_addr="0x400811A4">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="PU_PD" edc:nzwidth="0x2" edc:desc="These bits are used to enable an internal pull-up or pull-down resistor.">
              <edc:SFRFieldSemantic edc:cname="NONE" edc:desc="None. Pin tristates when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="UP" edc:desc="Pull Up Enabled" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="DOWN" edc:desc="Pull Down Enabled" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="REPEATER" edc:desc="Repeater mode. Pin is kept at previous voltage level when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="PWR_GATING" edc:nzwidth="0x2" edc:desc="The GPIO pin will be tristated when the selected power well is off."/>
            <edc:SFRFieldDef edc:cname="INTR_DET" edc:nzwidth="0x3" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="EDGE_EN" edc:nzwidth="0x1" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="OUT_BUFF_TYPE" edc:nzwidth="0x1" edc:desc="0 = Push-Pull, 1 = Open Drain"/>
            <edc:SFRFieldDef edc:cname="GPIO_DIR" edc:nzwidth="0x1" edc:desc="Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output"/>
            <edc:SFRFieldDef edc:cname="GPIO_OUT_SEL" edc:nzwidth="0x1" edc:desc="GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register."/>
            <edc:SFRFieldDef edc:cname="POL" edc:nzwidth="0x1" edc:desc="1=Inverted; 0=Non-inverted"/>
            <edc:SFRFieldDef edc:cname="MUX_CTRL" edc:nzwidth="0x3" edc:desc="00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3.">
              <edc:SFRFieldSemantic edc:cname="GPIO" edc:desc="GPIO function selected" edc:when="(field &amp; 0x7) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="FUNC1" edc:desc="Signal function 1 selected" edc:when="(field &amp; 0x7) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="FUNC2" edc:desc="Signal function 2 selected" edc:when="(field &amp; 0x7) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="FUNC3" edc:desc="Signal function 3 selected" edc:when="(field &amp; 0x7) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="INP_DIS" edc:nzwidth="0x1" edc:desc="GPIO input disable"/>
            <edc:SFRFieldDef edc:cname="ALT_GPIO_DATA" edc:nzwidth="0x1" edc:desc="GPIO Alternate Data Register."/>
            <edc:AdjustPoint edc:offset="0x7"/>
            <edc:SFRFieldDef edc:cname="GPIO_INP" edc:nzwidth="0x1" edc:desc="GPIO input from pin, independent of the Mux selection for the pin or the Direction."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL152" edc:nzwidth="0x20" edc:access="-------n-------nnnnnnnnnnnnnnnnn" edc:por="00000000000000001000000001000000" edc:mclr="00000000000000001000000001000000" edc:impl="0x101FFFF" edc:_addr="0x400811A8">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="PU_PD" edc:nzwidth="0x2" edc:desc="These bits are used to enable an internal pull-up or pull-down resistor.">
              <edc:SFRFieldSemantic edc:cname="NONE" edc:desc="None. Pin tristates when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="UP" edc:desc="Pull Up Enabled" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="DOWN" edc:desc="Pull Down Enabled" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="REPEATER" edc:desc="Repeater mode. Pin is kept at previous voltage level when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="PWR_GATING" edc:nzwidth="0x2" edc:desc="The GPIO pin will be tristated when the selected power well is off."/>
            <edc:SFRFieldDef edc:cname="INTR_DET" edc:nzwidth="0x3" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="EDGE_EN" edc:nzwidth="0x1" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="OUT_BUFF_TYPE" edc:nzwidth="0x1" edc:desc="0 = Push-Pull, 1 = Open Drain"/>
            <edc:SFRFieldDef edc:cname="GPIO_DIR" edc:nzwidth="0x1" edc:desc="Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output"/>
            <edc:SFRFieldDef edc:cname="GPIO_OUT_SEL" edc:nzwidth="0x1" edc:desc="GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register."/>
            <edc:SFRFieldDef edc:cname="POL" edc:nzwidth="0x1" edc:desc="1=Inverted; 0=Non-inverted"/>
            <edc:SFRFieldDef edc:cname="MUX_CTRL" edc:nzwidth="0x3" edc:desc="00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3.">
              <edc:SFRFieldSemantic edc:cname="GPIO" edc:desc="GPIO function selected" edc:when="(field &amp; 0x7) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="FUNC1" edc:desc="Signal function 1 selected" edc:when="(field &amp; 0x7) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="FUNC2" edc:desc="Signal function 2 selected" edc:when="(field &amp; 0x7) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="FUNC3" edc:desc="Signal function 3 selected" edc:when="(field &amp; 0x7) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="INP_DIS" edc:nzwidth="0x1" edc:desc="GPIO input disable"/>
            <edc:SFRFieldDef edc:cname="ALT_GPIO_DATA" edc:nzwidth="0x1" edc:desc="GPIO Alternate Data Register."/>
            <edc:AdjustPoint edc:offset="0x7"/>
            <edc:SFRFieldDef edc:cname="GPIO_INP" edc:nzwidth="0x1" edc:desc="GPIO input from pin, independent of the Mux selection for the pin or the Direction."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL153" edc:nzwidth="0x20" edc:access="-------n-------nnnnnnnnnnnnnnnnn" edc:por="00000000000000001000000001000000" edc:mclr="00000000000000001000000001000000" edc:impl="0x101FFFF" edc:_addr="0x400811AC">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="PU_PD" edc:nzwidth="0x2" edc:desc="These bits are used to enable an internal pull-up or pull-down resistor.">
              <edc:SFRFieldSemantic edc:cname="NONE" edc:desc="None. Pin tristates when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="UP" edc:desc="Pull Up Enabled" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="DOWN" edc:desc="Pull Down Enabled" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="REPEATER" edc:desc="Repeater mode. Pin is kept at previous voltage level when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="PWR_GATING" edc:nzwidth="0x2" edc:desc="The GPIO pin will be tristated when the selected power well is off."/>
            <edc:SFRFieldDef edc:cname="INTR_DET" edc:nzwidth="0x3" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="EDGE_EN" edc:nzwidth="0x1" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="OUT_BUFF_TYPE" edc:nzwidth="0x1" edc:desc="0 = Push-Pull, 1 = Open Drain"/>
            <edc:SFRFieldDef edc:cname="GPIO_DIR" edc:nzwidth="0x1" edc:desc="Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output"/>
            <edc:SFRFieldDef edc:cname="GPIO_OUT_SEL" edc:nzwidth="0x1" edc:desc="GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register."/>
            <edc:SFRFieldDef edc:cname="POL" edc:nzwidth="0x1" edc:desc="1=Inverted; 0=Non-inverted"/>
            <edc:SFRFieldDef edc:cname="MUX_CTRL" edc:nzwidth="0x3" edc:desc="00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3.">
              <edc:SFRFieldSemantic edc:cname="GPIO" edc:desc="GPIO function selected" edc:when="(field &amp; 0x7) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="FUNC1" edc:desc="Signal function 1 selected" edc:when="(field &amp; 0x7) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="FUNC2" edc:desc="Signal function 2 selected" edc:when="(field &amp; 0x7) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="FUNC3" edc:desc="Signal function 3 selected" edc:when="(field &amp; 0x7) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="INP_DIS" edc:nzwidth="0x1" edc:desc="GPIO input disable"/>
            <edc:SFRFieldDef edc:cname="ALT_GPIO_DATA" edc:nzwidth="0x1" edc:desc="GPIO Alternate Data Register."/>
            <edc:AdjustPoint edc:offset="0x7"/>
            <edc:SFRFieldDef edc:cname="GPIO_INP" edc:nzwidth="0x1" edc:desc="GPIO input from pin, independent of the Mux selection for the pin or the Direction."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL154" edc:nzwidth="0x20" edc:access="-------n-------nnnnnnnnnnnnnnnnn" edc:por="00000000000000001000000001000000" edc:mclr="00000000000000001000000001000000" edc:impl="0x101FFFF" edc:_addr="0x400811B0">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="PU_PD" edc:nzwidth="0x2" edc:desc="These bits are used to enable an internal pull-up or pull-down resistor.">
              <edc:SFRFieldSemantic edc:cname="NONE" edc:desc="None. Pin tristates when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="UP" edc:desc="Pull Up Enabled" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="DOWN" edc:desc="Pull Down Enabled" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="REPEATER" edc:desc="Repeater mode. Pin is kept at previous voltage level when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="PWR_GATING" edc:nzwidth="0x2" edc:desc="The GPIO pin will be tristated when the selected power well is off."/>
            <edc:SFRFieldDef edc:cname="INTR_DET" edc:nzwidth="0x3" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="EDGE_EN" edc:nzwidth="0x1" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="OUT_BUFF_TYPE" edc:nzwidth="0x1" edc:desc="0 = Push-Pull, 1 = Open Drain"/>
            <edc:SFRFieldDef edc:cname="GPIO_DIR" edc:nzwidth="0x1" edc:desc="Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output"/>
            <edc:SFRFieldDef edc:cname="GPIO_OUT_SEL" edc:nzwidth="0x1" edc:desc="GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register."/>
            <edc:SFRFieldDef edc:cname="POL" edc:nzwidth="0x1" edc:desc="1=Inverted; 0=Non-inverted"/>
            <edc:SFRFieldDef edc:cname="MUX_CTRL" edc:nzwidth="0x3" edc:desc="00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3.">
              <edc:SFRFieldSemantic edc:cname="GPIO" edc:desc="GPIO function selected" edc:when="(field &amp; 0x7) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="FUNC1" edc:desc="Signal function 1 selected" edc:when="(field &amp; 0x7) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="FUNC2" edc:desc="Signal function 2 selected" edc:when="(field &amp; 0x7) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="FUNC3" edc:desc="Signal function 3 selected" edc:when="(field &amp; 0x7) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="INP_DIS" edc:nzwidth="0x1" edc:desc="GPIO input disable"/>
            <edc:SFRFieldDef edc:cname="ALT_GPIO_DATA" edc:nzwidth="0x1" edc:desc="GPIO Alternate Data Register."/>
            <edc:AdjustPoint edc:offset="0x7"/>
            <edc:SFRFieldDef edc:cname="GPIO_INP" edc:nzwidth="0x1" edc:desc="GPIO input from pin, independent of the Mux selection for the pin or the Direction."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL155" edc:nzwidth="0x20" edc:access="-------n-------nnnnnnnnnnnnnnnnn" edc:por="00000000000000001000000001000000" edc:mclr="00000000000000001000000001000000" edc:impl="0x101FFFF" edc:_addr="0x400811B4">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="PU_PD" edc:nzwidth="0x2" edc:desc="These bits are used to enable an internal pull-up or pull-down resistor.">
              <edc:SFRFieldSemantic edc:cname="NONE" edc:desc="None. Pin tristates when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="UP" edc:desc="Pull Up Enabled" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="DOWN" edc:desc="Pull Down Enabled" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="REPEATER" edc:desc="Repeater mode. Pin is kept at previous voltage level when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="PWR_GATING" edc:nzwidth="0x2" edc:desc="The GPIO pin will be tristated when the selected power well is off."/>
            <edc:SFRFieldDef edc:cname="INTR_DET" edc:nzwidth="0x3" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="EDGE_EN" edc:nzwidth="0x1" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="OUT_BUFF_TYPE" edc:nzwidth="0x1" edc:desc="0 = Push-Pull, 1 = Open Drain"/>
            <edc:SFRFieldDef edc:cname="GPIO_DIR" edc:nzwidth="0x1" edc:desc="Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output"/>
            <edc:SFRFieldDef edc:cname="GPIO_OUT_SEL" edc:nzwidth="0x1" edc:desc="GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register."/>
            <edc:SFRFieldDef edc:cname="POL" edc:nzwidth="0x1" edc:desc="1=Inverted; 0=Non-inverted"/>
            <edc:SFRFieldDef edc:cname="MUX_CTRL" edc:nzwidth="0x3" edc:desc="00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3.">
              <edc:SFRFieldSemantic edc:cname="GPIO" edc:desc="GPIO function selected" edc:when="(field &amp; 0x7) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="FUNC1" edc:desc="Signal function 1 selected" edc:when="(field &amp; 0x7) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="FUNC2" edc:desc="Signal function 2 selected" edc:when="(field &amp; 0x7) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="FUNC3" edc:desc="Signal function 3 selected" edc:when="(field &amp; 0x7) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="INP_DIS" edc:nzwidth="0x1" edc:desc="GPIO input disable"/>
            <edc:SFRFieldDef edc:cname="ALT_GPIO_DATA" edc:nzwidth="0x1" edc:desc="GPIO Alternate Data Register."/>
            <edc:AdjustPoint edc:offset="0x7"/>
            <edc:SFRFieldDef edc:cname="GPIO_INP" edc:nzwidth="0x1" edc:desc="GPIO input from pin, independent of the Mux selection for the pin or the Direction."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL156" edc:nzwidth="0x20" edc:access="-------n-------nnnnnnnnnnnnnnnnn" edc:por="00000000000000001000000001000000" edc:mclr="00000000000000001000000001000000" edc:impl="0x101FFFF" edc:_addr="0x400811B8">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="PU_PD" edc:nzwidth="0x2" edc:desc="These bits are used to enable an internal pull-up or pull-down resistor.">
              <edc:SFRFieldSemantic edc:cname="NONE" edc:desc="None. Pin tristates when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="UP" edc:desc="Pull Up Enabled" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="DOWN" edc:desc="Pull Down Enabled" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="REPEATER" edc:desc="Repeater mode. Pin is kept at previous voltage level when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="PWR_GATING" edc:nzwidth="0x2" edc:desc="The GPIO pin will be tristated when the selected power well is off."/>
            <edc:SFRFieldDef edc:cname="INTR_DET" edc:nzwidth="0x3" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="EDGE_EN" edc:nzwidth="0x1" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="OUT_BUFF_TYPE" edc:nzwidth="0x1" edc:desc="0 = Push-Pull, 1 = Open Drain"/>
            <edc:SFRFieldDef edc:cname="GPIO_DIR" edc:nzwidth="0x1" edc:desc="Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output"/>
            <edc:SFRFieldDef edc:cname="GPIO_OUT_SEL" edc:nzwidth="0x1" edc:desc="GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register."/>
            <edc:SFRFieldDef edc:cname="POL" edc:nzwidth="0x1" edc:desc="1=Inverted; 0=Non-inverted"/>
            <edc:SFRFieldDef edc:cname="MUX_CTRL" edc:nzwidth="0x3" edc:desc="00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3.">
              <edc:SFRFieldSemantic edc:cname="GPIO" edc:desc="GPIO function selected" edc:when="(field &amp; 0x7) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="FUNC1" edc:desc="Signal function 1 selected" edc:when="(field &amp; 0x7) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="FUNC2" edc:desc="Signal function 2 selected" edc:when="(field &amp; 0x7) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="FUNC3" edc:desc="Signal function 3 selected" edc:when="(field &amp; 0x7) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="INP_DIS" edc:nzwidth="0x1" edc:desc="GPIO input disable"/>
            <edc:SFRFieldDef edc:cname="ALT_GPIO_DATA" edc:nzwidth="0x1" edc:desc="GPIO Alternate Data Register."/>
            <edc:AdjustPoint edc:offset="0x7"/>
            <edc:SFRFieldDef edc:cname="GPIO_INP" edc:nzwidth="0x1" edc:desc="GPIO input from pin, independent of the Mux selection for the pin or the Direction."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL157" edc:nzwidth="0x20" edc:access="-------n-------nnnnnnnnnnnnnnnnn" edc:por="00000000000000001000000001000000" edc:mclr="00000000000000001000000001000000" edc:impl="0x101FFFF" edc:_addr="0x400811BC">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="PU_PD" edc:nzwidth="0x2" edc:desc="These bits are used to enable an internal pull-up or pull-down resistor.">
              <edc:SFRFieldSemantic edc:cname="NONE" edc:desc="None. Pin tristates when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="UP" edc:desc="Pull Up Enabled" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="DOWN" edc:desc="Pull Down Enabled" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="REPEATER" edc:desc="Repeater mode. Pin is kept at previous voltage level when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="PWR_GATING" edc:nzwidth="0x2" edc:desc="The GPIO pin will be tristated when the selected power well is off."/>
            <edc:SFRFieldDef edc:cname="INTR_DET" edc:nzwidth="0x3" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="EDGE_EN" edc:nzwidth="0x1" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="OUT_BUFF_TYPE" edc:nzwidth="0x1" edc:desc="0 = Push-Pull, 1 = Open Drain"/>
            <edc:SFRFieldDef edc:cname="GPIO_DIR" edc:nzwidth="0x1" edc:desc="Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output"/>
            <edc:SFRFieldDef edc:cname="GPIO_OUT_SEL" edc:nzwidth="0x1" edc:desc="GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register."/>
            <edc:SFRFieldDef edc:cname="POL" edc:nzwidth="0x1" edc:desc="1=Inverted; 0=Non-inverted"/>
            <edc:SFRFieldDef edc:cname="MUX_CTRL" edc:nzwidth="0x3" edc:desc="00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3.">
              <edc:SFRFieldSemantic edc:cname="GPIO" edc:desc="GPIO function selected" edc:when="(field &amp; 0x7) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="FUNC1" edc:desc="Signal function 1 selected" edc:when="(field &amp; 0x7) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="FUNC2" edc:desc="Signal function 2 selected" edc:when="(field &amp; 0x7) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="FUNC3" edc:desc="Signal function 3 selected" edc:when="(field &amp; 0x7) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="INP_DIS" edc:nzwidth="0x1" edc:desc="GPIO input disable"/>
            <edc:SFRFieldDef edc:cname="ALT_GPIO_DATA" edc:nzwidth="0x1" edc:desc="GPIO Alternate Data Register."/>
            <edc:AdjustPoint edc:offset="0x7"/>
            <edc:SFRFieldDef edc:cname="GPIO_INP" edc:nzwidth="0x1" edc:desc="GPIO input from pin, independent of the Mux selection for the pin or the Direction."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL160" edc:nzwidth="0x20" edc:access="-------n-------nnnnnnnnnnnnnnnnn" edc:por="00000000000000001000000001000000" edc:mclr="00000000000000001000000001000000" edc:impl="0x101FFFF" edc:_addr="0x400811C0">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="PU_PD" edc:nzwidth="0x2" edc:desc="These bits are used to enable an internal pull-up or pull-down resistor.">
              <edc:SFRFieldSemantic edc:cname="NONE" edc:desc="None. Pin tristates when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="UP" edc:desc="Pull Up Enabled" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="DOWN" edc:desc="Pull Down Enabled" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="REPEATER" edc:desc="Repeater mode. Pin is kept at previous voltage level when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="PWR_GATING" edc:nzwidth="0x2" edc:desc="The GPIO pin will be tristated when the selected power well is off."/>
            <edc:SFRFieldDef edc:cname="INTR_DET" edc:nzwidth="0x3" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="EDGE_EN" edc:nzwidth="0x1" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="OUT_BUFF_TYPE" edc:nzwidth="0x1" edc:desc="0 = Push-Pull, 1 = Open Drain"/>
            <edc:SFRFieldDef edc:cname="GPIO_DIR" edc:nzwidth="0x1" edc:desc="Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output"/>
            <edc:SFRFieldDef edc:cname="GPIO_OUT_SEL" edc:nzwidth="0x1" edc:desc="GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register."/>
            <edc:SFRFieldDef edc:cname="POL" edc:nzwidth="0x1" edc:desc="1=Inverted; 0=Non-inverted"/>
            <edc:SFRFieldDef edc:cname="MUX_CTRL" edc:nzwidth="0x3" edc:desc="00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3.">
              <edc:SFRFieldSemantic edc:cname="GPIO" edc:desc="GPIO function selected" edc:when="(field &amp; 0x7) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="FUNC1" edc:desc="Signal function 1 selected" edc:when="(field &amp; 0x7) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="FUNC2" edc:desc="Signal function 2 selected" edc:when="(field &amp; 0x7) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="FUNC3" edc:desc="Signal function 3 selected" edc:when="(field &amp; 0x7) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="INP_DIS" edc:nzwidth="0x1" edc:desc="GPIO input disable"/>
            <edc:SFRFieldDef edc:cname="ALT_GPIO_DATA" edc:nzwidth="0x1" edc:desc="GPIO Alternate Data Register."/>
            <edc:AdjustPoint edc:offset="0x7"/>
            <edc:SFRFieldDef edc:cname="GPIO_INP" edc:nzwidth="0x1" edc:desc="GPIO input from pin, independent of the Mux selection for the pin or the Direction."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL161" edc:nzwidth="0x20" edc:access="-------n-------nnnnnnnnnnnnnnnnn" edc:por="00000000000000001000000001000000" edc:mclr="00000000000000001000000001000000" edc:impl="0x101FFFF" edc:_addr="0x400811C4">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="PU_PD" edc:nzwidth="0x2" edc:desc="These bits are used to enable an internal pull-up or pull-down resistor.">
              <edc:SFRFieldSemantic edc:cname="NONE" edc:desc="None. Pin tristates when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="UP" edc:desc="Pull Up Enabled" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="DOWN" edc:desc="Pull Down Enabled" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="REPEATER" edc:desc="Repeater mode. Pin is kept at previous voltage level when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="PWR_GATING" edc:nzwidth="0x2" edc:desc="The GPIO pin will be tristated when the selected power well is off."/>
            <edc:SFRFieldDef edc:cname="INTR_DET" edc:nzwidth="0x3" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="EDGE_EN" edc:nzwidth="0x1" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="OUT_BUFF_TYPE" edc:nzwidth="0x1" edc:desc="0 = Push-Pull, 1 = Open Drain"/>
            <edc:SFRFieldDef edc:cname="GPIO_DIR" edc:nzwidth="0x1" edc:desc="Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output"/>
            <edc:SFRFieldDef edc:cname="GPIO_OUT_SEL" edc:nzwidth="0x1" edc:desc="GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register."/>
            <edc:SFRFieldDef edc:cname="POL" edc:nzwidth="0x1" edc:desc="1=Inverted; 0=Non-inverted"/>
            <edc:SFRFieldDef edc:cname="MUX_CTRL" edc:nzwidth="0x3" edc:desc="00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3.">
              <edc:SFRFieldSemantic edc:cname="GPIO" edc:desc="GPIO function selected" edc:when="(field &amp; 0x7) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="FUNC1" edc:desc="Signal function 1 selected" edc:when="(field &amp; 0x7) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="FUNC2" edc:desc="Signal function 2 selected" edc:when="(field &amp; 0x7) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="FUNC3" edc:desc="Signal function 3 selected" edc:when="(field &amp; 0x7) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="INP_DIS" edc:nzwidth="0x1" edc:desc="GPIO input disable"/>
            <edc:SFRFieldDef edc:cname="ALT_GPIO_DATA" edc:nzwidth="0x1" edc:desc="GPIO Alternate Data Register."/>
            <edc:AdjustPoint edc:offset="0x7"/>
            <edc:SFRFieldDef edc:cname="GPIO_INP" edc:nzwidth="0x1" edc:desc="GPIO input from pin, independent of the Mux selection for the pin or the Direction."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL162" edc:nzwidth="0x20" edc:access="-------n-------nnnnnnnnnnnnnnnnn" edc:por="00000000000000001000000001000000" edc:mclr="00000000000000001000000001000000" edc:impl="0x101FFFF" edc:_addr="0x400811C8">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="PU_PD" edc:nzwidth="0x2" edc:desc="These bits are used to enable an internal pull-up or pull-down resistor.">
              <edc:SFRFieldSemantic edc:cname="NONE" edc:desc="None. Pin tristates when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="UP" edc:desc="Pull Up Enabled" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="DOWN" edc:desc="Pull Down Enabled" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="REPEATER" edc:desc="Repeater mode. Pin is kept at previous voltage level when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="PWR_GATING" edc:nzwidth="0x2" edc:desc="The GPIO pin will be tristated when the selected power well is off."/>
            <edc:SFRFieldDef edc:cname="INTR_DET" edc:nzwidth="0x3" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="EDGE_EN" edc:nzwidth="0x1" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="OUT_BUFF_TYPE" edc:nzwidth="0x1" edc:desc="0 = Push-Pull, 1 = Open Drain"/>
            <edc:SFRFieldDef edc:cname="GPIO_DIR" edc:nzwidth="0x1" edc:desc="Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output"/>
            <edc:SFRFieldDef edc:cname="GPIO_OUT_SEL" edc:nzwidth="0x1" edc:desc="GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register."/>
            <edc:SFRFieldDef edc:cname="POL" edc:nzwidth="0x1" edc:desc="1=Inverted; 0=Non-inverted"/>
            <edc:SFRFieldDef edc:cname="MUX_CTRL" edc:nzwidth="0x3" edc:desc="00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3.">
              <edc:SFRFieldSemantic edc:cname="GPIO" edc:desc="GPIO function selected" edc:when="(field &amp; 0x7) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="FUNC1" edc:desc="Signal function 1 selected" edc:when="(field &amp; 0x7) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="FUNC2" edc:desc="Signal function 2 selected" edc:when="(field &amp; 0x7) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="FUNC3" edc:desc="Signal function 3 selected" edc:when="(field &amp; 0x7) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="INP_DIS" edc:nzwidth="0x1" edc:desc="GPIO input disable"/>
            <edc:SFRFieldDef edc:cname="ALT_GPIO_DATA" edc:nzwidth="0x1" edc:desc="GPIO Alternate Data Register."/>
            <edc:AdjustPoint edc:offset="0x7"/>
            <edc:SFRFieldDef edc:cname="GPIO_INP" edc:nzwidth="0x1" edc:desc="GPIO input from pin, independent of the Mux selection for the pin or the Direction."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL163" edc:nzwidth="0x20" edc:access="-------n-------nnnnnnnnnnnnnnnnn" edc:por="00000000000000001000000001000000" edc:mclr="00000000000000001000000001000000" edc:impl="0x101FFFF" edc:_addr="0x400811CC">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="PU_PD" edc:nzwidth="0x2" edc:desc="These bits are used to enable an internal pull-up or pull-down resistor.">
              <edc:SFRFieldSemantic edc:cname="NONE" edc:desc="None. Pin tristates when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="UP" edc:desc="Pull Up Enabled" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="DOWN" edc:desc="Pull Down Enabled" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="REPEATER" edc:desc="Repeater mode. Pin is kept at previous voltage level when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="PWR_GATING" edc:nzwidth="0x2" edc:desc="The GPIO pin will be tristated when the selected power well is off."/>
            <edc:SFRFieldDef edc:cname="INTR_DET" edc:nzwidth="0x3" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="EDGE_EN" edc:nzwidth="0x1" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="OUT_BUFF_TYPE" edc:nzwidth="0x1" edc:desc="0 = Push-Pull, 1 = Open Drain"/>
            <edc:SFRFieldDef edc:cname="GPIO_DIR" edc:nzwidth="0x1" edc:desc="Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output"/>
            <edc:SFRFieldDef edc:cname="GPIO_OUT_SEL" edc:nzwidth="0x1" edc:desc="GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register."/>
            <edc:SFRFieldDef edc:cname="POL" edc:nzwidth="0x1" edc:desc="1=Inverted; 0=Non-inverted"/>
            <edc:SFRFieldDef edc:cname="MUX_CTRL" edc:nzwidth="0x3" edc:desc="00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3.">
              <edc:SFRFieldSemantic edc:cname="GPIO" edc:desc="GPIO function selected" edc:when="(field &amp; 0x7) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="FUNC1" edc:desc="Signal function 1 selected" edc:when="(field &amp; 0x7) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="FUNC2" edc:desc="Signal function 2 selected" edc:when="(field &amp; 0x7) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="FUNC3" edc:desc="Signal function 3 selected" edc:when="(field &amp; 0x7) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="INP_DIS" edc:nzwidth="0x1" edc:desc="GPIO input disable"/>
            <edc:SFRFieldDef edc:cname="ALT_GPIO_DATA" edc:nzwidth="0x1" edc:desc="GPIO Alternate Data Register."/>
            <edc:AdjustPoint edc:offset="0x7"/>
            <edc:SFRFieldDef edc:cname="GPIO_INP" edc:nzwidth="0x1" edc:desc="GPIO input from pin, independent of the Mux selection for the pin or the Direction."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL164" edc:nzwidth="0x20" edc:access="-------n-------nnnnnnnnnnnnnnnnn" edc:por="00000000000000001000000001000000" edc:mclr="00000000000000001000000001000000" edc:impl="0x101FFFF" edc:_addr="0x400811D0">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="PU_PD" edc:nzwidth="0x2" edc:desc="These bits are used to enable an internal pull-up or pull-down resistor.">
              <edc:SFRFieldSemantic edc:cname="NONE" edc:desc="None. Pin tristates when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="UP" edc:desc="Pull Up Enabled" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="DOWN" edc:desc="Pull Down Enabled" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="REPEATER" edc:desc="Repeater mode. Pin is kept at previous voltage level when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="PWR_GATING" edc:nzwidth="0x2" edc:desc="The GPIO pin will be tristated when the selected power well is off."/>
            <edc:SFRFieldDef edc:cname="INTR_DET" edc:nzwidth="0x3" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="EDGE_EN" edc:nzwidth="0x1" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="OUT_BUFF_TYPE" edc:nzwidth="0x1" edc:desc="0 = Push-Pull, 1 = Open Drain"/>
            <edc:SFRFieldDef edc:cname="GPIO_DIR" edc:nzwidth="0x1" edc:desc="Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output"/>
            <edc:SFRFieldDef edc:cname="GPIO_OUT_SEL" edc:nzwidth="0x1" edc:desc="GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register."/>
            <edc:SFRFieldDef edc:cname="POL" edc:nzwidth="0x1" edc:desc="1=Inverted; 0=Non-inverted"/>
            <edc:SFRFieldDef edc:cname="MUX_CTRL" edc:nzwidth="0x3" edc:desc="00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3.">
              <edc:SFRFieldSemantic edc:cname="GPIO" edc:desc="GPIO function selected" edc:when="(field &amp; 0x7) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="FUNC1" edc:desc="Signal function 1 selected" edc:when="(field &amp; 0x7) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="FUNC2" edc:desc="Signal function 2 selected" edc:when="(field &amp; 0x7) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="FUNC3" edc:desc="Signal function 3 selected" edc:when="(field &amp; 0x7) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="INP_DIS" edc:nzwidth="0x1" edc:desc="GPIO input disable"/>
            <edc:SFRFieldDef edc:cname="ALT_GPIO_DATA" edc:nzwidth="0x1" edc:desc="GPIO Alternate Data Register."/>
            <edc:AdjustPoint edc:offset="0x7"/>
            <edc:SFRFieldDef edc:cname="GPIO_INP" edc:nzwidth="0x1" edc:desc="GPIO input from pin, independent of the Mux selection for the pin or the Direction."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL165" edc:nzwidth="0x20" edc:access="-------n-------nnnnnnnnnnnnnnnnn" edc:por="00000000000000001000000001000000" edc:mclr="00000000000000001000000001000000" edc:impl="0x101FFFF" edc:_addr="0x400811D4">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="PU_PD" edc:nzwidth="0x2" edc:desc="These bits are used to enable an internal pull-up or pull-down resistor.">
              <edc:SFRFieldSemantic edc:cname="NONE" edc:desc="None. Pin tristates when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="UP" edc:desc="Pull Up Enabled" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="DOWN" edc:desc="Pull Down Enabled" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="REPEATER" edc:desc="Repeater mode. Pin is kept at previous voltage level when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="PWR_GATING" edc:nzwidth="0x2" edc:desc="The GPIO pin will be tristated when the selected power well is off."/>
            <edc:SFRFieldDef edc:cname="INTR_DET" edc:nzwidth="0x3" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="EDGE_EN" edc:nzwidth="0x1" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="OUT_BUFF_TYPE" edc:nzwidth="0x1" edc:desc="0 = Push-Pull, 1 = Open Drain"/>
            <edc:SFRFieldDef edc:cname="GPIO_DIR" edc:nzwidth="0x1" edc:desc="Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output"/>
            <edc:SFRFieldDef edc:cname="GPIO_OUT_SEL" edc:nzwidth="0x1" edc:desc="GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register."/>
            <edc:SFRFieldDef edc:cname="POL" edc:nzwidth="0x1" edc:desc="1=Inverted; 0=Non-inverted"/>
            <edc:SFRFieldDef edc:cname="MUX_CTRL" edc:nzwidth="0x3" edc:desc="00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3.">
              <edc:SFRFieldSemantic edc:cname="GPIO" edc:desc="GPIO function selected" edc:when="(field &amp; 0x7) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="FUNC1" edc:desc="Signal function 1 selected" edc:when="(field &amp; 0x7) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="FUNC2" edc:desc="Signal function 2 selected" edc:when="(field &amp; 0x7) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="FUNC3" edc:desc="Signal function 3 selected" edc:when="(field &amp; 0x7) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="INP_DIS" edc:nzwidth="0x1" edc:desc="GPIO input disable"/>
            <edc:SFRFieldDef edc:cname="ALT_GPIO_DATA" edc:nzwidth="0x1" edc:desc="GPIO Alternate Data Register."/>
            <edc:AdjustPoint edc:offset="0x7"/>
            <edc:SFRFieldDef edc:cname="GPIO_INP" edc:nzwidth="0x1" edc:desc="GPIO input from pin, independent of the Mux selection for the pin or the Direction."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL166" edc:nzwidth="0x20" edc:access="-------n-------nnnnnnnnnnnnnnnnn" edc:por="00000000000000001000000001000000" edc:mclr="00000000000000001000000001000000" edc:impl="0x101FFFF" edc:_addr="0x400811D8">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="PU_PD" edc:nzwidth="0x2" edc:desc="These bits are used to enable an internal pull-up or pull-down resistor.">
              <edc:SFRFieldSemantic edc:cname="NONE" edc:desc="None. Pin tristates when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="UP" edc:desc="Pull Up Enabled" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="DOWN" edc:desc="Pull Down Enabled" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="REPEATER" edc:desc="Repeater mode. Pin is kept at previous voltage level when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="PWR_GATING" edc:nzwidth="0x2" edc:desc="The GPIO pin will be tristated when the selected power well is off."/>
            <edc:SFRFieldDef edc:cname="INTR_DET" edc:nzwidth="0x3" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="EDGE_EN" edc:nzwidth="0x1" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="OUT_BUFF_TYPE" edc:nzwidth="0x1" edc:desc="0 = Push-Pull, 1 = Open Drain"/>
            <edc:SFRFieldDef edc:cname="GPIO_DIR" edc:nzwidth="0x1" edc:desc="Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output"/>
            <edc:SFRFieldDef edc:cname="GPIO_OUT_SEL" edc:nzwidth="0x1" edc:desc="GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register."/>
            <edc:SFRFieldDef edc:cname="POL" edc:nzwidth="0x1" edc:desc="1=Inverted; 0=Non-inverted"/>
            <edc:SFRFieldDef edc:cname="MUX_CTRL" edc:nzwidth="0x3" edc:desc="00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3.">
              <edc:SFRFieldSemantic edc:cname="GPIO" edc:desc="GPIO function selected" edc:when="(field &amp; 0x7) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="FUNC1" edc:desc="Signal function 1 selected" edc:when="(field &amp; 0x7) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="FUNC2" edc:desc="Signal function 2 selected" edc:when="(field &amp; 0x7) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="FUNC3" edc:desc="Signal function 3 selected" edc:when="(field &amp; 0x7) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="INP_DIS" edc:nzwidth="0x1" edc:desc="GPIO input disable"/>
            <edc:SFRFieldDef edc:cname="ALT_GPIO_DATA" edc:nzwidth="0x1" edc:desc="GPIO Alternate Data Register."/>
            <edc:AdjustPoint edc:offset="0x7"/>
            <edc:SFRFieldDef edc:cname="GPIO_INP" edc:nzwidth="0x1" edc:desc="GPIO input from pin, independent of the Mux selection for the pin or the Direction."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL167" edc:nzwidth="0x20" edc:access="-------n-------nnnnnnnnnnnnnnnnn" edc:por="00000000000000001000000001000000" edc:mclr="00000000000000001000000001000000" edc:impl="0x101FFFF" edc:_addr="0x400811DC">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="PU_PD" edc:nzwidth="0x2" edc:desc="These bits are used to enable an internal pull-up or pull-down resistor.">
              <edc:SFRFieldSemantic edc:cname="NONE" edc:desc="None. Pin tristates when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="UP" edc:desc="Pull Up Enabled" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="DOWN" edc:desc="Pull Down Enabled" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="REPEATER" edc:desc="Repeater mode. Pin is kept at previous voltage level when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="PWR_GATING" edc:nzwidth="0x2" edc:desc="The GPIO pin will be tristated when the selected power well is off."/>
            <edc:SFRFieldDef edc:cname="INTR_DET" edc:nzwidth="0x3" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="EDGE_EN" edc:nzwidth="0x1" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="OUT_BUFF_TYPE" edc:nzwidth="0x1" edc:desc="0 = Push-Pull, 1 = Open Drain"/>
            <edc:SFRFieldDef edc:cname="GPIO_DIR" edc:nzwidth="0x1" edc:desc="Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output"/>
            <edc:SFRFieldDef edc:cname="GPIO_OUT_SEL" edc:nzwidth="0x1" edc:desc="GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register."/>
            <edc:SFRFieldDef edc:cname="POL" edc:nzwidth="0x1" edc:desc="1=Inverted; 0=Non-inverted"/>
            <edc:SFRFieldDef edc:cname="MUX_CTRL" edc:nzwidth="0x3" edc:desc="00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3.">
              <edc:SFRFieldSemantic edc:cname="GPIO" edc:desc="GPIO function selected" edc:when="(field &amp; 0x7) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="FUNC1" edc:desc="Signal function 1 selected" edc:when="(field &amp; 0x7) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="FUNC2" edc:desc="Signal function 2 selected" edc:when="(field &amp; 0x7) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="FUNC3" edc:desc="Signal function 3 selected" edc:when="(field &amp; 0x7) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="INP_DIS" edc:nzwidth="0x1" edc:desc="GPIO input disable"/>
            <edc:SFRFieldDef edc:cname="ALT_GPIO_DATA" edc:nzwidth="0x1" edc:desc="GPIO Alternate Data Register."/>
            <edc:AdjustPoint edc:offset="0x7"/>
            <edc:SFRFieldDef edc:cname="GPIO_INP" edc:nzwidth="0x1" edc:desc="GPIO input from pin, independent of the Mux selection for the pin or the Direction."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL170" edc:nzwidth="0x20" edc:access="-------n-------nnnnnnnnnnnnnnnnn" edc:por="00000000000000001000000001000000" edc:mclr="00000000000000001000000001000000" edc:impl="0x101FFFF" edc:_addr="0x400811E0">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="PU_PD" edc:nzwidth="0x2" edc:desc="These bits are used to enable an internal pull-up or pull-down resistor.">
              <edc:SFRFieldSemantic edc:cname="NONE" edc:desc="None. Pin tristates when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="UP" edc:desc="Pull Up Enabled" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="DOWN" edc:desc="Pull Down Enabled" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="REPEATER" edc:desc="Repeater mode. Pin is kept at previous voltage level when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="PWR_GATING" edc:nzwidth="0x2" edc:desc="The GPIO pin will be tristated when the selected power well is off."/>
            <edc:SFRFieldDef edc:cname="INTR_DET" edc:nzwidth="0x3" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="EDGE_EN" edc:nzwidth="0x1" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="OUT_BUFF_TYPE" edc:nzwidth="0x1" edc:desc="0 = Push-Pull, 1 = Open Drain"/>
            <edc:SFRFieldDef edc:cname="GPIO_DIR" edc:nzwidth="0x1" edc:desc="Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output"/>
            <edc:SFRFieldDef edc:cname="GPIO_OUT_SEL" edc:nzwidth="0x1" edc:desc="GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register."/>
            <edc:SFRFieldDef edc:cname="POL" edc:nzwidth="0x1" edc:desc="1=Inverted; 0=Non-inverted"/>
            <edc:SFRFieldDef edc:cname="MUX_CTRL" edc:nzwidth="0x3" edc:desc="00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3.">
              <edc:SFRFieldSemantic edc:cname="GPIO" edc:desc="GPIO function selected" edc:when="(field &amp; 0x7) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="FUNC1" edc:desc="Signal function 1 selected" edc:when="(field &amp; 0x7) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="FUNC2" edc:desc="Signal function 2 selected" edc:when="(field &amp; 0x7) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="FUNC3" edc:desc="Signal function 3 selected" edc:when="(field &amp; 0x7) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="INP_DIS" edc:nzwidth="0x1" edc:desc="GPIO input disable"/>
            <edc:SFRFieldDef edc:cname="ALT_GPIO_DATA" edc:nzwidth="0x1" edc:desc="GPIO Alternate Data Register."/>
            <edc:AdjustPoint edc:offset="0x7"/>
            <edc:SFRFieldDef edc:cname="GPIO_INP" edc:nzwidth="0x1" edc:desc="GPIO input from pin, independent of the Mux selection for the pin or the Direction."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL171" edc:nzwidth="0x20" edc:access="-------n-------nnnnnnnnnnnnnnnnn" edc:por="00000000000000001000000001000000" edc:mclr="00000000000000001000000001000000" edc:impl="0x101FFFF" edc:_addr="0x400811E4">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="PU_PD" edc:nzwidth="0x2" edc:desc="These bits are used to enable an internal pull-up or pull-down resistor.">
              <edc:SFRFieldSemantic edc:cname="NONE" edc:desc="None. Pin tristates when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="UP" edc:desc="Pull Up Enabled" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="DOWN" edc:desc="Pull Down Enabled" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="REPEATER" edc:desc="Repeater mode. Pin is kept at previous voltage level when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="PWR_GATING" edc:nzwidth="0x2" edc:desc="The GPIO pin will be tristated when the selected power well is off."/>
            <edc:SFRFieldDef edc:cname="INTR_DET" edc:nzwidth="0x3" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="EDGE_EN" edc:nzwidth="0x1" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="OUT_BUFF_TYPE" edc:nzwidth="0x1" edc:desc="0 = Push-Pull, 1 = Open Drain"/>
            <edc:SFRFieldDef edc:cname="GPIO_DIR" edc:nzwidth="0x1" edc:desc="Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output"/>
            <edc:SFRFieldDef edc:cname="GPIO_OUT_SEL" edc:nzwidth="0x1" edc:desc="GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register."/>
            <edc:SFRFieldDef edc:cname="POL" edc:nzwidth="0x1" edc:desc="1=Inverted; 0=Non-inverted"/>
            <edc:SFRFieldDef edc:cname="MUX_CTRL" edc:nzwidth="0x3" edc:desc="00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3.">
              <edc:SFRFieldSemantic edc:cname="GPIO" edc:desc="GPIO function selected" edc:when="(field &amp; 0x7) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="FUNC1" edc:desc="Signal function 1 selected" edc:when="(field &amp; 0x7) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="FUNC2" edc:desc="Signal function 2 selected" edc:when="(field &amp; 0x7) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="FUNC3" edc:desc="Signal function 3 selected" edc:when="(field &amp; 0x7) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="INP_DIS" edc:nzwidth="0x1" edc:desc="GPIO input disable"/>
            <edc:SFRFieldDef edc:cname="ALT_GPIO_DATA" edc:nzwidth="0x1" edc:desc="GPIO Alternate Data Register."/>
            <edc:AdjustPoint edc:offset="0x7"/>
            <edc:SFRFieldDef edc:cname="GPIO_INP" edc:nzwidth="0x1" edc:desc="GPIO input from pin, independent of the Mux selection for the pin or the Direction."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL172" edc:nzwidth="0x20" edc:access="-------n-------nnnnnnnnnnnnnnnnn" edc:por="00000000000000001000000001000000" edc:mclr="00000000000000001000000001000000" edc:impl="0x101FFFF" edc:_addr="0x400811E8">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="PU_PD" edc:nzwidth="0x2" edc:desc="These bits are used to enable an internal pull-up or pull-down resistor.">
              <edc:SFRFieldSemantic edc:cname="NONE" edc:desc="None. Pin tristates when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="UP" edc:desc="Pull Up Enabled" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="DOWN" edc:desc="Pull Down Enabled" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="REPEATER" edc:desc="Repeater mode. Pin is kept at previous voltage level when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="PWR_GATING" edc:nzwidth="0x2" edc:desc="The GPIO pin will be tristated when the selected power well is off."/>
            <edc:SFRFieldDef edc:cname="INTR_DET" edc:nzwidth="0x3" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="EDGE_EN" edc:nzwidth="0x1" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="OUT_BUFF_TYPE" edc:nzwidth="0x1" edc:desc="0 = Push-Pull, 1 = Open Drain"/>
            <edc:SFRFieldDef edc:cname="GPIO_DIR" edc:nzwidth="0x1" edc:desc="Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output"/>
            <edc:SFRFieldDef edc:cname="GPIO_OUT_SEL" edc:nzwidth="0x1" edc:desc="GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register."/>
            <edc:SFRFieldDef edc:cname="POL" edc:nzwidth="0x1" edc:desc="1=Inverted; 0=Non-inverted"/>
            <edc:SFRFieldDef edc:cname="MUX_CTRL" edc:nzwidth="0x3" edc:desc="00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3.">
              <edc:SFRFieldSemantic edc:cname="GPIO" edc:desc="GPIO function selected" edc:when="(field &amp; 0x7) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="FUNC1" edc:desc="Signal function 1 selected" edc:when="(field &amp; 0x7) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="FUNC2" edc:desc="Signal function 2 selected" edc:when="(field &amp; 0x7) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="FUNC3" edc:desc="Signal function 3 selected" edc:when="(field &amp; 0x7) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="INP_DIS" edc:nzwidth="0x1" edc:desc="GPIO input disable"/>
            <edc:SFRFieldDef edc:cname="ALT_GPIO_DATA" edc:nzwidth="0x1" edc:desc="GPIO Alternate Data Register."/>
            <edc:AdjustPoint edc:offset="0x7"/>
            <edc:SFRFieldDef edc:cname="GPIO_INP" edc:nzwidth="0x1" edc:desc="GPIO input from pin, independent of the Mux selection for the pin or the Direction."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL173" edc:nzwidth="0x20" edc:access="-------n-------nnnnnnnnnnnnnnnnn" edc:por="00000000000000001000000001000000" edc:mclr="00000000000000001000000001000000" edc:impl="0x101FFFF" edc:_addr="0x400811EC">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="PU_PD" edc:nzwidth="0x2" edc:desc="These bits are used to enable an internal pull-up or pull-down resistor.">
              <edc:SFRFieldSemantic edc:cname="NONE" edc:desc="None. Pin tristates when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="UP" edc:desc="Pull Up Enabled" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="DOWN" edc:desc="Pull Down Enabled" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="REPEATER" edc:desc="Repeater mode. Pin is kept at previous voltage level when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="PWR_GATING" edc:nzwidth="0x2" edc:desc="The GPIO pin will be tristated when the selected power well is off."/>
            <edc:SFRFieldDef edc:cname="INTR_DET" edc:nzwidth="0x3" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="EDGE_EN" edc:nzwidth="0x1" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="OUT_BUFF_TYPE" edc:nzwidth="0x1" edc:desc="0 = Push-Pull, 1 = Open Drain"/>
            <edc:SFRFieldDef edc:cname="GPIO_DIR" edc:nzwidth="0x1" edc:desc="Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output"/>
            <edc:SFRFieldDef edc:cname="GPIO_OUT_SEL" edc:nzwidth="0x1" edc:desc="GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register."/>
            <edc:SFRFieldDef edc:cname="POL" edc:nzwidth="0x1" edc:desc="1=Inverted; 0=Non-inverted"/>
            <edc:SFRFieldDef edc:cname="MUX_CTRL" edc:nzwidth="0x3" edc:desc="00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3.">
              <edc:SFRFieldSemantic edc:cname="GPIO" edc:desc="GPIO function selected" edc:when="(field &amp; 0x7) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="FUNC1" edc:desc="Signal function 1 selected" edc:when="(field &amp; 0x7) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="FUNC2" edc:desc="Signal function 2 selected" edc:when="(field &amp; 0x7) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="FUNC3" edc:desc="Signal function 3 selected" edc:when="(field &amp; 0x7) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="INP_DIS" edc:nzwidth="0x1" edc:desc="GPIO input disable"/>
            <edc:SFRFieldDef edc:cname="ALT_GPIO_DATA" edc:nzwidth="0x1" edc:desc="GPIO Alternate Data Register."/>
            <edc:AdjustPoint edc:offset="0x7"/>
            <edc:SFRFieldDef edc:cname="GPIO_INP" edc:nzwidth="0x1" edc:desc="GPIO input from pin, independent of the Mux selection for the pin or the Direction."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL174" edc:nzwidth="0x20" edc:access="-------n-------nnnnnnnnnnnnnnnnn" edc:por="00000000000000001000000001000000" edc:mclr="00000000000000001000000001000000" edc:impl="0x101FFFF" edc:_addr="0x400811F0">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="PU_PD" edc:nzwidth="0x2" edc:desc="These bits are used to enable an internal pull-up or pull-down resistor.">
              <edc:SFRFieldSemantic edc:cname="NONE" edc:desc="None. Pin tristates when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="UP" edc:desc="Pull Up Enabled" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="DOWN" edc:desc="Pull Down Enabled" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="REPEATER" edc:desc="Repeater mode. Pin is kept at previous voltage level when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="PWR_GATING" edc:nzwidth="0x2" edc:desc="The GPIO pin will be tristated when the selected power well is off."/>
            <edc:SFRFieldDef edc:cname="INTR_DET" edc:nzwidth="0x3" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="EDGE_EN" edc:nzwidth="0x1" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="OUT_BUFF_TYPE" edc:nzwidth="0x1" edc:desc="0 = Push-Pull, 1 = Open Drain"/>
            <edc:SFRFieldDef edc:cname="GPIO_DIR" edc:nzwidth="0x1" edc:desc="Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output"/>
            <edc:SFRFieldDef edc:cname="GPIO_OUT_SEL" edc:nzwidth="0x1" edc:desc="GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register."/>
            <edc:SFRFieldDef edc:cname="POL" edc:nzwidth="0x1" edc:desc="1=Inverted; 0=Non-inverted"/>
            <edc:SFRFieldDef edc:cname="MUX_CTRL" edc:nzwidth="0x3" edc:desc="00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3.">
              <edc:SFRFieldSemantic edc:cname="GPIO" edc:desc="GPIO function selected" edc:when="(field &amp; 0x7) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="FUNC1" edc:desc="Signal function 1 selected" edc:when="(field &amp; 0x7) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="FUNC2" edc:desc="Signal function 2 selected" edc:when="(field &amp; 0x7) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="FUNC3" edc:desc="Signal function 3 selected" edc:when="(field &amp; 0x7) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="INP_DIS" edc:nzwidth="0x1" edc:desc="GPIO input disable"/>
            <edc:SFRFieldDef edc:cname="ALT_GPIO_DATA" edc:nzwidth="0x1" edc:desc="GPIO Alternate Data Register."/>
            <edc:AdjustPoint edc:offset="0x7"/>
            <edc:SFRFieldDef edc:cname="GPIO_INP" edc:nzwidth="0x1" edc:desc="GPIO input from pin, independent of the Mux selection for the pin or the Direction."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL175" edc:nzwidth="0x20" edc:access="-------n-------nnnnnnnnnnnnnnnnn" edc:por="00000000000000001000000001000000" edc:mclr="00000000000000001000000001000000" edc:impl="0x101FFFF" edc:_addr="0x400811F4">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="PU_PD" edc:nzwidth="0x2" edc:desc="These bits are used to enable an internal pull-up or pull-down resistor.">
              <edc:SFRFieldSemantic edc:cname="NONE" edc:desc="None. Pin tristates when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="UP" edc:desc="Pull Up Enabled" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="DOWN" edc:desc="Pull Down Enabled" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="REPEATER" edc:desc="Repeater mode. Pin is kept at previous voltage level when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="PWR_GATING" edc:nzwidth="0x2" edc:desc="The GPIO pin will be tristated when the selected power well is off."/>
            <edc:SFRFieldDef edc:cname="INTR_DET" edc:nzwidth="0x3" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="EDGE_EN" edc:nzwidth="0x1" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="OUT_BUFF_TYPE" edc:nzwidth="0x1" edc:desc="0 = Push-Pull, 1 = Open Drain"/>
            <edc:SFRFieldDef edc:cname="GPIO_DIR" edc:nzwidth="0x1" edc:desc="Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output"/>
            <edc:SFRFieldDef edc:cname="GPIO_OUT_SEL" edc:nzwidth="0x1" edc:desc="GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register."/>
            <edc:SFRFieldDef edc:cname="POL" edc:nzwidth="0x1" edc:desc="1=Inverted; 0=Non-inverted"/>
            <edc:SFRFieldDef edc:cname="MUX_CTRL" edc:nzwidth="0x3" edc:desc="00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3.">
              <edc:SFRFieldSemantic edc:cname="GPIO" edc:desc="GPIO function selected" edc:when="(field &amp; 0x7) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="FUNC1" edc:desc="Signal function 1 selected" edc:when="(field &amp; 0x7) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="FUNC2" edc:desc="Signal function 2 selected" edc:when="(field &amp; 0x7) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="FUNC3" edc:desc="Signal function 3 selected" edc:when="(field &amp; 0x7) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="INP_DIS" edc:nzwidth="0x1" edc:desc="GPIO input disable"/>
            <edc:SFRFieldDef edc:cname="ALT_GPIO_DATA" edc:nzwidth="0x1" edc:desc="GPIO Alternate Data Register."/>
            <edc:AdjustPoint edc:offset="0x7"/>
            <edc:SFRFieldDef edc:cname="GPIO_INP" edc:nzwidth="0x1" edc:desc="GPIO input from pin, independent of the Mux selection for the pin or the Direction."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL176" edc:nzwidth="0x20" edc:access="-------n-------nnnnnnnnnnnnnnnnn" edc:por="00000000000000001000000001000000" edc:mclr="00000000000000001000000001000000" edc:impl="0x101FFFF" edc:_addr="0x400811F8">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="PU_PD" edc:nzwidth="0x2" edc:desc="These bits are used to enable an internal pull-up or pull-down resistor.">
              <edc:SFRFieldSemantic edc:cname="NONE" edc:desc="None. Pin tristates when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="UP" edc:desc="Pull Up Enabled" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="DOWN" edc:desc="Pull Down Enabled" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="REPEATER" edc:desc="Repeater mode. Pin is kept at previous voltage level when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="PWR_GATING" edc:nzwidth="0x2" edc:desc="The GPIO pin will be tristated when the selected power well is off."/>
            <edc:SFRFieldDef edc:cname="INTR_DET" edc:nzwidth="0x3" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="EDGE_EN" edc:nzwidth="0x1" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="OUT_BUFF_TYPE" edc:nzwidth="0x1" edc:desc="0 = Push-Pull, 1 = Open Drain"/>
            <edc:SFRFieldDef edc:cname="GPIO_DIR" edc:nzwidth="0x1" edc:desc="Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output"/>
            <edc:SFRFieldDef edc:cname="GPIO_OUT_SEL" edc:nzwidth="0x1" edc:desc="GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register."/>
            <edc:SFRFieldDef edc:cname="POL" edc:nzwidth="0x1" edc:desc="1=Inverted; 0=Non-inverted"/>
            <edc:SFRFieldDef edc:cname="MUX_CTRL" edc:nzwidth="0x3" edc:desc="00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3.">
              <edc:SFRFieldSemantic edc:cname="GPIO" edc:desc="GPIO function selected" edc:when="(field &amp; 0x7) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="FUNC1" edc:desc="Signal function 1 selected" edc:when="(field &amp; 0x7) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="FUNC2" edc:desc="Signal function 2 selected" edc:when="(field &amp; 0x7) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="FUNC3" edc:desc="Signal function 3 selected" edc:when="(field &amp; 0x7) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="INP_DIS" edc:nzwidth="0x1" edc:desc="GPIO input disable"/>
            <edc:SFRFieldDef edc:cname="ALT_GPIO_DATA" edc:nzwidth="0x1" edc:desc="GPIO Alternate Data Register."/>
            <edc:AdjustPoint edc:offset="0x7"/>
            <edc:SFRFieldDef edc:cname="GPIO_INP" edc:nzwidth="0x1" edc:desc="GPIO input from pin, independent of the Mux selection for the pin or the Direction."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL177" edc:nzwidth="0x20" edc:access="-------n-------nnnnnnnnnnnnnnnnn" edc:por="00000000000000001000000001000000" edc:mclr="00000000000000001000000001000000" edc:impl="0x101FFFF" edc:_addr="0x400811FC">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="PU_PD" edc:nzwidth="0x2" edc:desc="These bits are used to enable an internal pull-up or pull-down resistor.">
              <edc:SFRFieldSemantic edc:cname="NONE" edc:desc="None. Pin tristates when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="UP" edc:desc="Pull Up Enabled" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="DOWN" edc:desc="Pull Down Enabled" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="REPEATER" edc:desc="Repeater mode. Pin is kept at previous voltage level when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="PWR_GATING" edc:nzwidth="0x2" edc:desc="The GPIO pin will be tristated when the selected power well is off."/>
            <edc:SFRFieldDef edc:cname="INTR_DET" edc:nzwidth="0x3" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="EDGE_EN" edc:nzwidth="0x1" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="OUT_BUFF_TYPE" edc:nzwidth="0x1" edc:desc="0 = Push-Pull, 1 = Open Drain"/>
            <edc:SFRFieldDef edc:cname="GPIO_DIR" edc:nzwidth="0x1" edc:desc="Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output"/>
            <edc:SFRFieldDef edc:cname="GPIO_OUT_SEL" edc:nzwidth="0x1" edc:desc="GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register."/>
            <edc:SFRFieldDef edc:cname="POL" edc:nzwidth="0x1" edc:desc="1=Inverted; 0=Non-inverted"/>
            <edc:SFRFieldDef edc:cname="MUX_CTRL" edc:nzwidth="0x3" edc:desc="00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3.">
              <edc:SFRFieldSemantic edc:cname="GPIO" edc:desc="GPIO function selected" edc:when="(field &amp; 0x7) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="FUNC1" edc:desc="Signal function 1 selected" edc:when="(field &amp; 0x7) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="FUNC2" edc:desc="Signal function 2 selected" edc:when="(field &amp; 0x7) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="FUNC3" edc:desc="Signal function 3 selected" edc:when="(field &amp; 0x7) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="INP_DIS" edc:nzwidth="0x1" edc:desc="GPIO input disable"/>
            <edc:SFRFieldDef edc:cname="ALT_GPIO_DATA" edc:nzwidth="0x1" edc:desc="GPIO Alternate Data Register."/>
            <edc:AdjustPoint edc:offset="0x7"/>
            <edc:SFRFieldDef edc:cname="GPIO_INP" edc:nzwidth="0x1" edc:desc="GPIO input from pin, independent of the Mux selection for the pin or the Direction."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL200" edc:nzwidth="0x20" edc:access="-------n-------nnnnnnnnnnnnnnnnn" edc:por="00000000000000001000000001000000" edc:mclr="00000000000000001000000001000000" edc:impl="0x101FFFF" edc:_addr="0x40081200">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="PU_PD" edc:nzwidth="0x2" edc:desc="These bits are used to enable an internal pull-up or pull-down resistor.">
              <edc:SFRFieldSemantic edc:cname="NONE" edc:desc="None. Pin tristates when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="UP" edc:desc="Pull Up Enabled" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="DOWN" edc:desc="Pull Down Enabled" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="REPEATER" edc:desc="Repeater mode. Pin is kept at previous voltage level when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="PWR_GATING" edc:nzwidth="0x2" edc:desc="The GPIO pin will be tristated when the selected power well is off."/>
            <edc:SFRFieldDef edc:cname="INTR_DET" edc:nzwidth="0x3" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="EDGE_EN" edc:nzwidth="0x1" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="OUT_BUFF_TYPE" edc:nzwidth="0x1" edc:desc="0 = Push-Pull, 1 = Open Drain"/>
            <edc:SFRFieldDef edc:cname="GPIO_DIR" edc:nzwidth="0x1" edc:desc="Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output"/>
            <edc:SFRFieldDef edc:cname="GPIO_OUT_SEL" edc:nzwidth="0x1" edc:desc="GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register."/>
            <edc:SFRFieldDef edc:cname="POL" edc:nzwidth="0x1" edc:desc="1=Inverted; 0=Non-inverted"/>
            <edc:SFRFieldDef edc:cname="MUX_CTRL" edc:nzwidth="0x3" edc:desc="00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3.">
              <edc:SFRFieldSemantic edc:cname="GPIO" edc:desc="GPIO function selected" edc:when="(field &amp; 0x7) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="FUNC1" edc:desc="Signal function 1 selected" edc:when="(field &amp; 0x7) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="FUNC2" edc:desc="Signal function 2 selected" edc:when="(field &amp; 0x7) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="FUNC3" edc:desc="Signal function 3 selected" edc:when="(field &amp; 0x7) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="INP_DIS" edc:nzwidth="0x1" edc:desc="GPIO input disable"/>
            <edc:SFRFieldDef edc:cname="ALT_GPIO_DATA" edc:nzwidth="0x1" edc:desc="GPIO Alternate Data Register."/>
            <edc:AdjustPoint edc:offset="0x7"/>
            <edc:SFRFieldDef edc:cname="GPIO_INP" edc:nzwidth="0x1" edc:desc="GPIO input from pin, independent of the Mux selection for the pin or the Direction."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL201" edc:nzwidth="0x20" edc:access="-------n-------nnnnnnnnnnnnnnnnn" edc:por="00000000000000001000000001000000" edc:mclr="00000000000000001000000001000000" edc:impl="0x101FFFF" edc:_addr="0x40081204">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="PU_PD" edc:nzwidth="0x2" edc:desc="These bits are used to enable an internal pull-up or pull-down resistor.">
              <edc:SFRFieldSemantic edc:cname="NONE" edc:desc="None. Pin tristates when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="UP" edc:desc="Pull Up Enabled" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="DOWN" edc:desc="Pull Down Enabled" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="REPEATER" edc:desc="Repeater mode. Pin is kept at previous voltage level when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="PWR_GATING" edc:nzwidth="0x2" edc:desc="The GPIO pin will be tristated when the selected power well is off."/>
            <edc:SFRFieldDef edc:cname="INTR_DET" edc:nzwidth="0x3" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="EDGE_EN" edc:nzwidth="0x1" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="OUT_BUFF_TYPE" edc:nzwidth="0x1" edc:desc="0 = Push-Pull, 1 = Open Drain"/>
            <edc:SFRFieldDef edc:cname="GPIO_DIR" edc:nzwidth="0x1" edc:desc="Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output"/>
            <edc:SFRFieldDef edc:cname="GPIO_OUT_SEL" edc:nzwidth="0x1" edc:desc="GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register."/>
            <edc:SFRFieldDef edc:cname="POL" edc:nzwidth="0x1" edc:desc="1=Inverted; 0=Non-inverted"/>
            <edc:SFRFieldDef edc:cname="MUX_CTRL" edc:nzwidth="0x3" edc:desc="00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3.">
              <edc:SFRFieldSemantic edc:cname="GPIO" edc:desc="GPIO function selected" edc:when="(field &amp; 0x7) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="FUNC1" edc:desc="Signal function 1 selected" edc:when="(field &amp; 0x7) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="FUNC2" edc:desc="Signal function 2 selected" edc:when="(field &amp; 0x7) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="FUNC3" edc:desc="Signal function 3 selected" edc:when="(field &amp; 0x7) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="INP_DIS" edc:nzwidth="0x1" edc:desc="GPIO input disable"/>
            <edc:SFRFieldDef edc:cname="ALT_GPIO_DATA" edc:nzwidth="0x1" edc:desc="GPIO Alternate Data Register."/>
            <edc:AdjustPoint edc:offset="0x7"/>
            <edc:SFRFieldDef edc:cname="GPIO_INP" edc:nzwidth="0x1" edc:desc="GPIO input from pin, independent of the Mux selection for the pin or the Direction."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL202" edc:nzwidth="0x20" edc:access="-------n-------nnnnnnnnnnnnnnnnn" edc:por="00000000000000001000000001000000" edc:mclr="00000000000000001000000001000000" edc:impl="0x101FFFF" edc:_addr="0x40081208">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="PU_PD" edc:nzwidth="0x2" edc:desc="These bits are used to enable an internal pull-up or pull-down resistor.">
              <edc:SFRFieldSemantic edc:cname="NONE" edc:desc="None. Pin tristates when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="UP" edc:desc="Pull Up Enabled" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="DOWN" edc:desc="Pull Down Enabled" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="REPEATER" edc:desc="Repeater mode. Pin is kept at previous voltage level when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="PWR_GATING" edc:nzwidth="0x2" edc:desc="The GPIO pin will be tristated when the selected power well is off."/>
            <edc:SFRFieldDef edc:cname="INTR_DET" edc:nzwidth="0x3" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="EDGE_EN" edc:nzwidth="0x1" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="OUT_BUFF_TYPE" edc:nzwidth="0x1" edc:desc="0 = Push-Pull, 1 = Open Drain"/>
            <edc:SFRFieldDef edc:cname="GPIO_DIR" edc:nzwidth="0x1" edc:desc="Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output"/>
            <edc:SFRFieldDef edc:cname="GPIO_OUT_SEL" edc:nzwidth="0x1" edc:desc="GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register."/>
            <edc:SFRFieldDef edc:cname="POL" edc:nzwidth="0x1" edc:desc="1=Inverted; 0=Non-inverted"/>
            <edc:SFRFieldDef edc:cname="MUX_CTRL" edc:nzwidth="0x3" edc:desc="00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3.">
              <edc:SFRFieldSemantic edc:cname="GPIO" edc:desc="GPIO function selected" edc:when="(field &amp; 0x7) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="FUNC1" edc:desc="Signal function 1 selected" edc:when="(field &amp; 0x7) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="FUNC2" edc:desc="Signal function 2 selected" edc:when="(field &amp; 0x7) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="FUNC3" edc:desc="Signal function 3 selected" edc:when="(field &amp; 0x7) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="INP_DIS" edc:nzwidth="0x1" edc:desc="GPIO input disable"/>
            <edc:SFRFieldDef edc:cname="ALT_GPIO_DATA" edc:nzwidth="0x1" edc:desc="GPIO Alternate Data Register."/>
            <edc:AdjustPoint edc:offset="0x7"/>
            <edc:SFRFieldDef edc:cname="GPIO_INP" edc:nzwidth="0x1" edc:desc="GPIO input from pin, independent of the Mux selection for the pin or the Direction."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL203" edc:nzwidth="0x20" edc:access="-------n-------nnnnnnnnnnnnnnnnn" edc:por="00000000000000001000000001000000" edc:mclr="00000000000000001000000001000000" edc:impl="0x101FFFF" edc:_addr="0x4008120C">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="PU_PD" edc:nzwidth="0x2" edc:desc="These bits are used to enable an internal pull-up or pull-down resistor.">
              <edc:SFRFieldSemantic edc:cname="NONE" edc:desc="None. Pin tristates when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="UP" edc:desc="Pull Up Enabled" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="DOWN" edc:desc="Pull Down Enabled" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="REPEATER" edc:desc="Repeater mode. Pin is kept at previous voltage level when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="PWR_GATING" edc:nzwidth="0x2" edc:desc="The GPIO pin will be tristated when the selected power well is off."/>
            <edc:SFRFieldDef edc:cname="INTR_DET" edc:nzwidth="0x3" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="EDGE_EN" edc:nzwidth="0x1" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="OUT_BUFF_TYPE" edc:nzwidth="0x1" edc:desc="0 = Push-Pull, 1 = Open Drain"/>
            <edc:SFRFieldDef edc:cname="GPIO_DIR" edc:nzwidth="0x1" edc:desc="Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output"/>
            <edc:SFRFieldDef edc:cname="GPIO_OUT_SEL" edc:nzwidth="0x1" edc:desc="GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register."/>
            <edc:SFRFieldDef edc:cname="POL" edc:nzwidth="0x1" edc:desc="1=Inverted; 0=Non-inverted"/>
            <edc:SFRFieldDef edc:cname="MUX_CTRL" edc:nzwidth="0x3" edc:desc="00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3.">
              <edc:SFRFieldSemantic edc:cname="GPIO" edc:desc="GPIO function selected" edc:when="(field &amp; 0x7) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="FUNC1" edc:desc="Signal function 1 selected" edc:when="(field &amp; 0x7) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="FUNC2" edc:desc="Signal function 2 selected" edc:when="(field &amp; 0x7) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="FUNC3" edc:desc="Signal function 3 selected" edc:when="(field &amp; 0x7) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="INP_DIS" edc:nzwidth="0x1" edc:desc="GPIO input disable"/>
            <edc:SFRFieldDef edc:cname="ALT_GPIO_DATA" edc:nzwidth="0x1" edc:desc="GPIO Alternate Data Register."/>
            <edc:AdjustPoint edc:offset="0x7"/>
            <edc:SFRFieldDef edc:cname="GPIO_INP" edc:nzwidth="0x1" edc:desc="GPIO input from pin, independent of the Mux selection for the pin or the Direction."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL204" edc:nzwidth="0x20" edc:access="-------n-------nnnnnnnnnnnnnnnnn" edc:por="00000000000000001000000001000000" edc:mclr="00000000000000001000000001000000" edc:impl="0x101FFFF" edc:_addr="0x40081210">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="PU_PD" edc:nzwidth="0x2" edc:desc="These bits are used to enable an internal pull-up or pull-down resistor.">
              <edc:SFRFieldSemantic edc:cname="NONE" edc:desc="None. Pin tristates when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="UP" edc:desc="Pull Up Enabled" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="DOWN" edc:desc="Pull Down Enabled" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="REPEATER" edc:desc="Repeater mode. Pin is kept at previous voltage level when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="PWR_GATING" edc:nzwidth="0x2" edc:desc="The GPIO pin will be tristated when the selected power well is off."/>
            <edc:SFRFieldDef edc:cname="INTR_DET" edc:nzwidth="0x3" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="EDGE_EN" edc:nzwidth="0x1" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="OUT_BUFF_TYPE" edc:nzwidth="0x1" edc:desc="0 = Push-Pull, 1 = Open Drain"/>
            <edc:SFRFieldDef edc:cname="GPIO_DIR" edc:nzwidth="0x1" edc:desc="Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output"/>
            <edc:SFRFieldDef edc:cname="GPIO_OUT_SEL" edc:nzwidth="0x1" edc:desc="GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register."/>
            <edc:SFRFieldDef edc:cname="POL" edc:nzwidth="0x1" edc:desc="1=Inverted; 0=Non-inverted"/>
            <edc:SFRFieldDef edc:cname="MUX_CTRL" edc:nzwidth="0x3" edc:desc="00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3.">
              <edc:SFRFieldSemantic edc:cname="GPIO" edc:desc="GPIO function selected" edc:when="(field &amp; 0x7) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="FUNC1" edc:desc="Signal function 1 selected" edc:when="(field &amp; 0x7) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="FUNC2" edc:desc="Signal function 2 selected" edc:when="(field &amp; 0x7) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="FUNC3" edc:desc="Signal function 3 selected" edc:when="(field &amp; 0x7) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="INP_DIS" edc:nzwidth="0x1" edc:desc="GPIO input disable"/>
            <edc:SFRFieldDef edc:cname="ALT_GPIO_DATA" edc:nzwidth="0x1" edc:desc="GPIO Alternate Data Register."/>
            <edc:AdjustPoint edc:offset="0x7"/>
            <edc:SFRFieldDef edc:cname="GPIO_INP" edc:nzwidth="0x1" edc:desc="GPIO input from pin, independent of the Mux selection for the pin or the Direction."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL205" edc:nzwidth="0x20" edc:access="-------n-------nnnnnnnnnnnnnnnnn" edc:por="00000000000000001000000001000000" edc:mclr="00000000000000001000000001000000" edc:impl="0x101FFFF" edc:_addr="0x40081214">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="PU_PD" edc:nzwidth="0x2" edc:desc="These bits are used to enable an internal pull-up or pull-down resistor.">
              <edc:SFRFieldSemantic edc:cname="NONE" edc:desc="None. Pin tristates when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="UP" edc:desc="Pull Up Enabled" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="DOWN" edc:desc="Pull Down Enabled" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="REPEATER" edc:desc="Repeater mode. Pin is kept at previous voltage level when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="PWR_GATING" edc:nzwidth="0x2" edc:desc="The GPIO pin will be tristated when the selected power well is off."/>
            <edc:SFRFieldDef edc:cname="INTR_DET" edc:nzwidth="0x3" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="EDGE_EN" edc:nzwidth="0x1" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="OUT_BUFF_TYPE" edc:nzwidth="0x1" edc:desc="0 = Push-Pull, 1 = Open Drain"/>
            <edc:SFRFieldDef edc:cname="GPIO_DIR" edc:nzwidth="0x1" edc:desc="Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output"/>
            <edc:SFRFieldDef edc:cname="GPIO_OUT_SEL" edc:nzwidth="0x1" edc:desc="GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register."/>
            <edc:SFRFieldDef edc:cname="POL" edc:nzwidth="0x1" edc:desc="1=Inverted; 0=Non-inverted"/>
            <edc:SFRFieldDef edc:cname="MUX_CTRL" edc:nzwidth="0x3" edc:desc="00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3.">
              <edc:SFRFieldSemantic edc:cname="GPIO" edc:desc="GPIO function selected" edc:when="(field &amp; 0x7) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="FUNC1" edc:desc="Signal function 1 selected" edc:when="(field &amp; 0x7) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="FUNC2" edc:desc="Signal function 2 selected" edc:when="(field &amp; 0x7) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="FUNC3" edc:desc="Signal function 3 selected" edc:when="(field &amp; 0x7) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="INP_DIS" edc:nzwidth="0x1" edc:desc="GPIO input disable"/>
            <edc:SFRFieldDef edc:cname="ALT_GPIO_DATA" edc:nzwidth="0x1" edc:desc="GPIO Alternate Data Register."/>
            <edc:AdjustPoint edc:offset="0x7"/>
            <edc:SFRFieldDef edc:cname="GPIO_INP" edc:nzwidth="0x1" edc:desc="GPIO input from pin, independent of the Mux selection for the pin or the Direction."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL206" edc:nzwidth="0x20" edc:access="-------n-------nnnnnnnnnnnnnnnnn" edc:por="00000000000000001000000001000000" edc:mclr="00000000000000001000000001000000" edc:impl="0x101FFFF" edc:_addr="0x40081218">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="PU_PD" edc:nzwidth="0x2" edc:desc="These bits are used to enable an internal pull-up or pull-down resistor.">
              <edc:SFRFieldSemantic edc:cname="NONE" edc:desc="None. Pin tristates when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="UP" edc:desc="Pull Up Enabled" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="DOWN" edc:desc="Pull Down Enabled" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="REPEATER" edc:desc="Repeater mode. Pin is kept at previous voltage level when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="PWR_GATING" edc:nzwidth="0x2" edc:desc="The GPIO pin will be tristated when the selected power well is off."/>
            <edc:SFRFieldDef edc:cname="INTR_DET" edc:nzwidth="0x3" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="EDGE_EN" edc:nzwidth="0x1" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="OUT_BUFF_TYPE" edc:nzwidth="0x1" edc:desc="0 = Push-Pull, 1 = Open Drain"/>
            <edc:SFRFieldDef edc:cname="GPIO_DIR" edc:nzwidth="0x1" edc:desc="Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output"/>
            <edc:SFRFieldDef edc:cname="GPIO_OUT_SEL" edc:nzwidth="0x1" edc:desc="GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register."/>
            <edc:SFRFieldDef edc:cname="POL" edc:nzwidth="0x1" edc:desc="1=Inverted; 0=Non-inverted"/>
            <edc:SFRFieldDef edc:cname="MUX_CTRL" edc:nzwidth="0x3" edc:desc="00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3.">
              <edc:SFRFieldSemantic edc:cname="GPIO" edc:desc="GPIO function selected" edc:when="(field &amp; 0x7) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="FUNC1" edc:desc="Signal function 1 selected" edc:when="(field &amp; 0x7) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="FUNC2" edc:desc="Signal function 2 selected" edc:when="(field &amp; 0x7) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="FUNC3" edc:desc="Signal function 3 selected" edc:when="(field &amp; 0x7) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="INP_DIS" edc:nzwidth="0x1" edc:desc="GPIO input disable"/>
            <edc:SFRFieldDef edc:cname="ALT_GPIO_DATA" edc:nzwidth="0x1" edc:desc="GPIO Alternate Data Register."/>
            <edc:AdjustPoint edc:offset="0x7"/>
            <edc:SFRFieldDef edc:cname="GPIO_INP" edc:nzwidth="0x1" edc:desc="GPIO input from pin, independent of the Mux selection for the pin or the Direction."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL207" edc:nzwidth="0x20" edc:access="-------n-------nnnnnnnnnnnnnnnnn" edc:por="00000000000000001000000001000000" edc:mclr="00000000000000001000000001000000" edc:impl="0x101FFFF" edc:_addr="0x4008121C">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="PU_PD" edc:nzwidth="0x2" edc:desc="These bits are used to enable an internal pull-up or pull-down resistor.">
              <edc:SFRFieldSemantic edc:cname="NONE" edc:desc="None. Pin tristates when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="UP" edc:desc="Pull Up Enabled" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="DOWN" edc:desc="Pull Down Enabled" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="REPEATER" edc:desc="Repeater mode. Pin is kept at previous voltage level when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="PWR_GATING" edc:nzwidth="0x2" edc:desc="The GPIO pin will be tristated when the selected power well is off."/>
            <edc:SFRFieldDef edc:cname="INTR_DET" edc:nzwidth="0x3" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="EDGE_EN" edc:nzwidth="0x1" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="OUT_BUFF_TYPE" edc:nzwidth="0x1" edc:desc="0 = Push-Pull, 1 = Open Drain"/>
            <edc:SFRFieldDef edc:cname="GPIO_DIR" edc:nzwidth="0x1" edc:desc="Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output"/>
            <edc:SFRFieldDef edc:cname="GPIO_OUT_SEL" edc:nzwidth="0x1" edc:desc="GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register."/>
            <edc:SFRFieldDef edc:cname="POL" edc:nzwidth="0x1" edc:desc="1=Inverted; 0=Non-inverted"/>
            <edc:SFRFieldDef edc:cname="MUX_CTRL" edc:nzwidth="0x3" edc:desc="00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3.">
              <edc:SFRFieldSemantic edc:cname="GPIO" edc:desc="GPIO function selected" edc:when="(field &amp; 0x7) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="FUNC1" edc:desc="Signal function 1 selected" edc:when="(field &amp; 0x7) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="FUNC2" edc:desc="Signal function 2 selected" edc:when="(field &amp; 0x7) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="FUNC3" edc:desc="Signal function 3 selected" edc:when="(field &amp; 0x7) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="INP_DIS" edc:nzwidth="0x1" edc:desc="GPIO input disable"/>
            <edc:SFRFieldDef edc:cname="ALT_GPIO_DATA" edc:nzwidth="0x1" edc:desc="GPIO Alternate Data Register."/>
            <edc:AdjustPoint edc:offset="0x7"/>
            <edc:SFRFieldDef edc:cname="GPIO_INP" edc:nzwidth="0x1" edc:desc="GPIO input from pin, independent of the Mux selection for the pin or the Direction."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL210" edc:nzwidth="0x20" edc:access="-------n-------nnnnnnnnnnnnnnnnn" edc:por="00000000000000001000000001000000" edc:mclr="00000000000000001000000001000000" edc:impl="0x101FFFF" edc:_addr="0x40081220">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="PU_PD" edc:nzwidth="0x2" edc:desc="These bits are used to enable an internal pull-up or pull-down resistor.">
              <edc:SFRFieldSemantic edc:cname="NONE" edc:desc="None. Pin tristates when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="UP" edc:desc="Pull Up Enabled" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="DOWN" edc:desc="Pull Down Enabled" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="REPEATER" edc:desc="Repeater mode. Pin is kept at previous voltage level when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="PWR_GATING" edc:nzwidth="0x2" edc:desc="The GPIO pin will be tristated when the selected power well is off."/>
            <edc:SFRFieldDef edc:cname="INTR_DET" edc:nzwidth="0x3" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="EDGE_EN" edc:nzwidth="0x1" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="OUT_BUFF_TYPE" edc:nzwidth="0x1" edc:desc="0 = Push-Pull, 1 = Open Drain"/>
            <edc:SFRFieldDef edc:cname="GPIO_DIR" edc:nzwidth="0x1" edc:desc="Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output"/>
            <edc:SFRFieldDef edc:cname="GPIO_OUT_SEL" edc:nzwidth="0x1" edc:desc="GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register."/>
            <edc:SFRFieldDef edc:cname="POL" edc:nzwidth="0x1" edc:desc="1=Inverted; 0=Non-inverted"/>
            <edc:SFRFieldDef edc:cname="MUX_CTRL" edc:nzwidth="0x3" edc:desc="00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3.">
              <edc:SFRFieldSemantic edc:cname="GPIO" edc:desc="GPIO function selected" edc:when="(field &amp; 0x7) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="FUNC1" edc:desc="Signal function 1 selected" edc:when="(field &amp; 0x7) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="FUNC2" edc:desc="Signal function 2 selected" edc:when="(field &amp; 0x7) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="FUNC3" edc:desc="Signal function 3 selected" edc:when="(field &amp; 0x7) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="INP_DIS" edc:nzwidth="0x1" edc:desc="GPIO input disable"/>
            <edc:SFRFieldDef edc:cname="ALT_GPIO_DATA" edc:nzwidth="0x1" edc:desc="GPIO Alternate Data Register."/>
            <edc:AdjustPoint edc:offset="0x7"/>
            <edc:SFRFieldDef edc:cname="GPIO_INP" edc:nzwidth="0x1" edc:desc="GPIO input from pin, independent of the Mux selection for the pin or the Direction."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL211" edc:nzwidth="0x20" edc:access="-------n-------nnnnnnnnnnnnnnnnn" edc:por="00000000000000001000000001000000" edc:mclr="00000000000000001000000001000000" edc:impl="0x101FFFF" edc:_addr="0x40081224">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="PU_PD" edc:nzwidth="0x2" edc:desc="These bits are used to enable an internal pull-up or pull-down resistor.">
              <edc:SFRFieldSemantic edc:cname="NONE" edc:desc="None. Pin tristates when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="UP" edc:desc="Pull Up Enabled" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="DOWN" edc:desc="Pull Down Enabled" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="REPEATER" edc:desc="Repeater mode. Pin is kept at previous voltage level when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="PWR_GATING" edc:nzwidth="0x2" edc:desc="The GPIO pin will be tristated when the selected power well is off."/>
            <edc:SFRFieldDef edc:cname="INTR_DET" edc:nzwidth="0x3" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="EDGE_EN" edc:nzwidth="0x1" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="OUT_BUFF_TYPE" edc:nzwidth="0x1" edc:desc="0 = Push-Pull, 1 = Open Drain"/>
            <edc:SFRFieldDef edc:cname="GPIO_DIR" edc:nzwidth="0x1" edc:desc="Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output"/>
            <edc:SFRFieldDef edc:cname="GPIO_OUT_SEL" edc:nzwidth="0x1" edc:desc="GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register."/>
            <edc:SFRFieldDef edc:cname="POL" edc:nzwidth="0x1" edc:desc="1=Inverted; 0=Non-inverted"/>
            <edc:SFRFieldDef edc:cname="MUX_CTRL" edc:nzwidth="0x3" edc:desc="00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3.">
              <edc:SFRFieldSemantic edc:cname="GPIO" edc:desc="GPIO function selected" edc:when="(field &amp; 0x7) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="FUNC1" edc:desc="Signal function 1 selected" edc:when="(field &amp; 0x7) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="FUNC2" edc:desc="Signal function 2 selected" edc:when="(field &amp; 0x7) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="FUNC3" edc:desc="Signal function 3 selected" edc:when="(field &amp; 0x7) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="INP_DIS" edc:nzwidth="0x1" edc:desc="GPIO input disable"/>
            <edc:SFRFieldDef edc:cname="ALT_GPIO_DATA" edc:nzwidth="0x1" edc:desc="GPIO Alternate Data Register."/>
            <edc:AdjustPoint edc:offset="0x7"/>
            <edc:SFRFieldDef edc:cname="GPIO_INP" edc:nzwidth="0x1" edc:desc="GPIO input from pin, independent of the Mux selection for the pin or the Direction."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL212" edc:nzwidth="0x20" edc:access="-------n-------nnnnnnnnnnnnnnnnn" edc:por="00000000000000001000000001000000" edc:mclr="00000000000000001000000001000000" edc:impl="0x101FFFF" edc:_addr="0x40081228">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="PU_PD" edc:nzwidth="0x2" edc:desc="These bits are used to enable an internal pull-up or pull-down resistor.">
              <edc:SFRFieldSemantic edc:cname="NONE" edc:desc="None. Pin tristates when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="UP" edc:desc="Pull Up Enabled" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="DOWN" edc:desc="Pull Down Enabled" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="REPEATER" edc:desc="Repeater mode. Pin is kept at previous voltage level when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="PWR_GATING" edc:nzwidth="0x2" edc:desc="The GPIO pin will be tristated when the selected power well is off."/>
            <edc:SFRFieldDef edc:cname="INTR_DET" edc:nzwidth="0x3" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="EDGE_EN" edc:nzwidth="0x1" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="OUT_BUFF_TYPE" edc:nzwidth="0x1" edc:desc="0 = Push-Pull, 1 = Open Drain"/>
            <edc:SFRFieldDef edc:cname="GPIO_DIR" edc:nzwidth="0x1" edc:desc="Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output"/>
            <edc:SFRFieldDef edc:cname="GPIO_OUT_SEL" edc:nzwidth="0x1" edc:desc="GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register."/>
            <edc:SFRFieldDef edc:cname="POL" edc:nzwidth="0x1" edc:desc="1=Inverted; 0=Non-inverted"/>
            <edc:SFRFieldDef edc:cname="MUX_CTRL" edc:nzwidth="0x3" edc:desc="00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3.">
              <edc:SFRFieldSemantic edc:cname="GPIO" edc:desc="GPIO function selected" edc:when="(field &amp; 0x7) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="FUNC1" edc:desc="Signal function 1 selected" edc:when="(field &amp; 0x7) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="FUNC2" edc:desc="Signal function 2 selected" edc:when="(field &amp; 0x7) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="FUNC3" edc:desc="Signal function 3 selected" edc:when="(field &amp; 0x7) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="INP_DIS" edc:nzwidth="0x1" edc:desc="GPIO input disable"/>
            <edc:SFRFieldDef edc:cname="ALT_GPIO_DATA" edc:nzwidth="0x1" edc:desc="GPIO Alternate Data Register."/>
            <edc:AdjustPoint edc:offset="0x7"/>
            <edc:SFRFieldDef edc:cname="GPIO_INP" edc:nzwidth="0x1" edc:desc="GPIO input from pin, independent of the Mux selection for the pin or the Direction."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL213" edc:nzwidth="0x20" edc:access="-------n-------nnnnnnnnnnnnnnnnn" edc:por="00000000000000001000000001000000" edc:mclr="00000000000000001000000001000000" edc:impl="0x101FFFF" edc:_addr="0x4008122C">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="PU_PD" edc:nzwidth="0x2" edc:desc="These bits are used to enable an internal pull-up or pull-down resistor.">
              <edc:SFRFieldSemantic edc:cname="NONE" edc:desc="None. Pin tristates when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="UP" edc:desc="Pull Up Enabled" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="DOWN" edc:desc="Pull Down Enabled" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="REPEATER" edc:desc="Repeater mode. Pin is kept at previous voltage level when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="PWR_GATING" edc:nzwidth="0x2" edc:desc="The GPIO pin will be tristated when the selected power well is off."/>
            <edc:SFRFieldDef edc:cname="INTR_DET" edc:nzwidth="0x3" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="EDGE_EN" edc:nzwidth="0x1" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="OUT_BUFF_TYPE" edc:nzwidth="0x1" edc:desc="0 = Push-Pull, 1 = Open Drain"/>
            <edc:SFRFieldDef edc:cname="GPIO_DIR" edc:nzwidth="0x1" edc:desc="Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output"/>
            <edc:SFRFieldDef edc:cname="GPIO_OUT_SEL" edc:nzwidth="0x1" edc:desc="GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register."/>
            <edc:SFRFieldDef edc:cname="POL" edc:nzwidth="0x1" edc:desc="1=Inverted; 0=Non-inverted"/>
            <edc:SFRFieldDef edc:cname="MUX_CTRL" edc:nzwidth="0x3" edc:desc="00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3.">
              <edc:SFRFieldSemantic edc:cname="GPIO" edc:desc="GPIO function selected" edc:when="(field &amp; 0x7) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="FUNC1" edc:desc="Signal function 1 selected" edc:when="(field &amp; 0x7) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="FUNC2" edc:desc="Signal function 2 selected" edc:when="(field &amp; 0x7) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="FUNC3" edc:desc="Signal function 3 selected" edc:when="(field &amp; 0x7) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="INP_DIS" edc:nzwidth="0x1" edc:desc="GPIO input disable"/>
            <edc:SFRFieldDef edc:cname="ALT_GPIO_DATA" edc:nzwidth="0x1" edc:desc="GPIO Alternate Data Register."/>
            <edc:AdjustPoint edc:offset="0x7"/>
            <edc:SFRFieldDef edc:cname="GPIO_INP" edc:nzwidth="0x1" edc:desc="GPIO input from pin, independent of the Mux selection for the pin or the Direction."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL214" edc:nzwidth="0x20" edc:access="-------n-------nnnnnnnnnnnnnnnnn" edc:por="00000000000000001000000001000000" edc:mclr="00000000000000001000000001000000" edc:impl="0x101FFFF" edc:_addr="0x40081230">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="PU_PD" edc:nzwidth="0x2" edc:desc="These bits are used to enable an internal pull-up or pull-down resistor.">
              <edc:SFRFieldSemantic edc:cname="NONE" edc:desc="None. Pin tristates when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="UP" edc:desc="Pull Up Enabled" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="DOWN" edc:desc="Pull Down Enabled" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="REPEATER" edc:desc="Repeater mode. Pin is kept at previous voltage level when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="PWR_GATING" edc:nzwidth="0x2" edc:desc="The GPIO pin will be tristated when the selected power well is off."/>
            <edc:SFRFieldDef edc:cname="INTR_DET" edc:nzwidth="0x3" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="EDGE_EN" edc:nzwidth="0x1" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="OUT_BUFF_TYPE" edc:nzwidth="0x1" edc:desc="0 = Push-Pull, 1 = Open Drain"/>
            <edc:SFRFieldDef edc:cname="GPIO_DIR" edc:nzwidth="0x1" edc:desc="Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output"/>
            <edc:SFRFieldDef edc:cname="GPIO_OUT_SEL" edc:nzwidth="0x1" edc:desc="GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register."/>
            <edc:SFRFieldDef edc:cname="POL" edc:nzwidth="0x1" edc:desc="1=Inverted; 0=Non-inverted"/>
            <edc:SFRFieldDef edc:cname="MUX_CTRL" edc:nzwidth="0x3" edc:desc="00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3.">
              <edc:SFRFieldSemantic edc:cname="GPIO" edc:desc="GPIO function selected" edc:when="(field &amp; 0x7) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="FUNC1" edc:desc="Signal function 1 selected" edc:when="(field &amp; 0x7) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="FUNC2" edc:desc="Signal function 2 selected" edc:when="(field &amp; 0x7) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="FUNC3" edc:desc="Signal function 3 selected" edc:when="(field &amp; 0x7) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="INP_DIS" edc:nzwidth="0x1" edc:desc="GPIO input disable"/>
            <edc:SFRFieldDef edc:cname="ALT_GPIO_DATA" edc:nzwidth="0x1" edc:desc="GPIO Alternate Data Register."/>
            <edc:AdjustPoint edc:offset="0x7"/>
            <edc:SFRFieldDef edc:cname="GPIO_INP" edc:nzwidth="0x1" edc:desc="GPIO input from pin, independent of the Mux selection for the pin or the Direction."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL215" edc:nzwidth="0x20" edc:access="-------n-------nnnnnnnnnnnnnnnnn" edc:por="00000000000000001000000001000000" edc:mclr="00000000000000001000000001000000" edc:impl="0x101FFFF" edc:_addr="0x40081234">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="PU_PD" edc:nzwidth="0x2" edc:desc="These bits are used to enable an internal pull-up or pull-down resistor.">
              <edc:SFRFieldSemantic edc:cname="NONE" edc:desc="None. Pin tristates when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="UP" edc:desc="Pull Up Enabled" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="DOWN" edc:desc="Pull Down Enabled" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="REPEATER" edc:desc="Repeater mode. Pin is kept at previous voltage level when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="PWR_GATING" edc:nzwidth="0x2" edc:desc="The GPIO pin will be tristated when the selected power well is off."/>
            <edc:SFRFieldDef edc:cname="INTR_DET" edc:nzwidth="0x3" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="EDGE_EN" edc:nzwidth="0x1" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="OUT_BUFF_TYPE" edc:nzwidth="0x1" edc:desc="0 = Push-Pull, 1 = Open Drain"/>
            <edc:SFRFieldDef edc:cname="GPIO_DIR" edc:nzwidth="0x1" edc:desc="Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output"/>
            <edc:SFRFieldDef edc:cname="GPIO_OUT_SEL" edc:nzwidth="0x1" edc:desc="GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register."/>
            <edc:SFRFieldDef edc:cname="POL" edc:nzwidth="0x1" edc:desc="1=Inverted; 0=Non-inverted"/>
            <edc:SFRFieldDef edc:cname="MUX_CTRL" edc:nzwidth="0x3" edc:desc="00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3.">
              <edc:SFRFieldSemantic edc:cname="GPIO" edc:desc="GPIO function selected" edc:when="(field &amp; 0x7) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="FUNC1" edc:desc="Signal function 1 selected" edc:when="(field &amp; 0x7) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="FUNC2" edc:desc="Signal function 2 selected" edc:when="(field &amp; 0x7) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="FUNC3" edc:desc="Signal function 3 selected" edc:when="(field &amp; 0x7) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="INP_DIS" edc:nzwidth="0x1" edc:desc="GPIO input disable"/>
            <edc:SFRFieldDef edc:cname="ALT_GPIO_DATA" edc:nzwidth="0x1" edc:desc="GPIO Alternate Data Register."/>
            <edc:AdjustPoint edc:offset="0x7"/>
            <edc:SFRFieldDef edc:cname="GPIO_INP" edc:nzwidth="0x1" edc:desc="GPIO input from pin, independent of the Mux selection for the pin or the Direction."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL216" edc:nzwidth="0x20" edc:access="-------n-------nnnnnnnnnnnnnnnnn" edc:por="00000000000000001000000001000000" edc:mclr="00000000000000001000000001000000" edc:impl="0x101FFFF" edc:_addr="0x40081238">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="PU_PD" edc:nzwidth="0x2" edc:desc="These bits are used to enable an internal pull-up or pull-down resistor.">
              <edc:SFRFieldSemantic edc:cname="NONE" edc:desc="None. Pin tristates when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="UP" edc:desc="Pull Up Enabled" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="DOWN" edc:desc="Pull Down Enabled" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="REPEATER" edc:desc="Repeater mode. Pin is kept at previous voltage level when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="PWR_GATING" edc:nzwidth="0x2" edc:desc="The GPIO pin will be tristated when the selected power well is off."/>
            <edc:SFRFieldDef edc:cname="INTR_DET" edc:nzwidth="0x3" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="EDGE_EN" edc:nzwidth="0x1" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="OUT_BUFF_TYPE" edc:nzwidth="0x1" edc:desc="0 = Push-Pull, 1 = Open Drain"/>
            <edc:SFRFieldDef edc:cname="GPIO_DIR" edc:nzwidth="0x1" edc:desc="Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output"/>
            <edc:SFRFieldDef edc:cname="GPIO_OUT_SEL" edc:nzwidth="0x1" edc:desc="GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register."/>
            <edc:SFRFieldDef edc:cname="POL" edc:nzwidth="0x1" edc:desc="1=Inverted; 0=Non-inverted"/>
            <edc:SFRFieldDef edc:cname="MUX_CTRL" edc:nzwidth="0x3" edc:desc="00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3.">
              <edc:SFRFieldSemantic edc:cname="GPIO" edc:desc="GPIO function selected" edc:when="(field &amp; 0x7) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="FUNC1" edc:desc="Signal function 1 selected" edc:when="(field &amp; 0x7) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="FUNC2" edc:desc="Signal function 2 selected" edc:when="(field &amp; 0x7) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="FUNC3" edc:desc="Signal function 3 selected" edc:when="(field &amp; 0x7) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="INP_DIS" edc:nzwidth="0x1" edc:desc="GPIO input disable"/>
            <edc:SFRFieldDef edc:cname="ALT_GPIO_DATA" edc:nzwidth="0x1" edc:desc="GPIO Alternate Data Register."/>
            <edc:AdjustPoint edc:offset="0x7"/>
            <edc:SFRFieldDef edc:cname="GPIO_INP" edc:nzwidth="0x1" edc:desc="GPIO input from pin, independent of the Mux selection for the pin or the Direction."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL217" edc:nzwidth="0x20" edc:access="-------n-------nnnnnnnnnnnnnnnnn" edc:por="00000000000000001000000001000000" edc:mclr="00000000000000001000000001000000" edc:impl="0x101FFFF" edc:_addr="0x4008123C">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="PU_PD" edc:nzwidth="0x2" edc:desc="These bits are used to enable an internal pull-up or pull-down resistor.">
              <edc:SFRFieldSemantic edc:cname="NONE" edc:desc="None. Pin tristates when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="UP" edc:desc="Pull Up Enabled" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="DOWN" edc:desc="Pull Down Enabled" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="REPEATER" edc:desc="Repeater mode. Pin is kept at previous voltage level when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="PWR_GATING" edc:nzwidth="0x2" edc:desc="The GPIO pin will be tristated when the selected power well is off."/>
            <edc:SFRFieldDef edc:cname="INTR_DET" edc:nzwidth="0x3" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="EDGE_EN" edc:nzwidth="0x1" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="OUT_BUFF_TYPE" edc:nzwidth="0x1" edc:desc="0 = Push-Pull, 1 = Open Drain"/>
            <edc:SFRFieldDef edc:cname="GPIO_DIR" edc:nzwidth="0x1" edc:desc="Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output"/>
            <edc:SFRFieldDef edc:cname="GPIO_OUT_SEL" edc:nzwidth="0x1" edc:desc="GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register."/>
            <edc:SFRFieldDef edc:cname="POL" edc:nzwidth="0x1" edc:desc="1=Inverted; 0=Non-inverted"/>
            <edc:SFRFieldDef edc:cname="MUX_CTRL" edc:nzwidth="0x3" edc:desc="00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3.">
              <edc:SFRFieldSemantic edc:cname="GPIO" edc:desc="GPIO function selected" edc:when="(field &amp; 0x7) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="FUNC1" edc:desc="Signal function 1 selected" edc:when="(field &amp; 0x7) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="FUNC2" edc:desc="Signal function 2 selected" edc:when="(field &amp; 0x7) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="FUNC3" edc:desc="Signal function 3 selected" edc:when="(field &amp; 0x7) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="INP_DIS" edc:nzwidth="0x1" edc:desc="GPIO input disable"/>
            <edc:SFRFieldDef edc:cname="ALT_GPIO_DATA" edc:nzwidth="0x1" edc:desc="GPIO Alternate Data Register."/>
            <edc:AdjustPoint edc:offset="0x7"/>
            <edc:SFRFieldDef edc:cname="GPIO_INP" edc:nzwidth="0x1" edc:desc="GPIO input from pin, independent of the Mux selection for the pin or the Direction."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL220" edc:nzwidth="0x20" edc:access="-------n-------nnnnnnnnnnnnnnnnn" edc:por="00000000000000001000000001000000" edc:mclr="00000000000000001000000001000000" edc:impl="0x101FFFF" edc:_addr="0x40081240">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="PU_PD" edc:nzwidth="0x2" edc:desc="These bits are used to enable an internal pull-up or pull-down resistor.">
              <edc:SFRFieldSemantic edc:cname="NONE" edc:desc="None. Pin tristates when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="UP" edc:desc="Pull Up Enabled" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="DOWN" edc:desc="Pull Down Enabled" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="REPEATER" edc:desc="Repeater mode. Pin is kept at previous voltage level when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="PWR_GATING" edc:nzwidth="0x2" edc:desc="The GPIO pin will be tristated when the selected power well is off."/>
            <edc:SFRFieldDef edc:cname="INTR_DET" edc:nzwidth="0x3" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="EDGE_EN" edc:nzwidth="0x1" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="OUT_BUFF_TYPE" edc:nzwidth="0x1" edc:desc="0 = Push-Pull, 1 = Open Drain"/>
            <edc:SFRFieldDef edc:cname="GPIO_DIR" edc:nzwidth="0x1" edc:desc="Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output"/>
            <edc:SFRFieldDef edc:cname="GPIO_OUT_SEL" edc:nzwidth="0x1" edc:desc="GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register."/>
            <edc:SFRFieldDef edc:cname="POL" edc:nzwidth="0x1" edc:desc="1=Inverted; 0=Non-inverted"/>
            <edc:SFRFieldDef edc:cname="MUX_CTRL" edc:nzwidth="0x3" edc:desc="00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3.">
              <edc:SFRFieldSemantic edc:cname="GPIO" edc:desc="GPIO function selected" edc:when="(field &amp; 0x7) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="FUNC1" edc:desc="Signal function 1 selected" edc:when="(field &amp; 0x7) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="FUNC2" edc:desc="Signal function 2 selected" edc:when="(field &amp; 0x7) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="FUNC3" edc:desc="Signal function 3 selected" edc:when="(field &amp; 0x7) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="INP_DIS" edc:nzwidth="0x1" edc:desc="GPIO input disable"/>
            <edc:SFRFieldDef edc:cname="ALT_GPIO_DATA" edc:nzwidth="0x1" edc:desc="GPIO Alternate Data Register."/>
            <edc:AdjustPoint edc:offset="0x7"/>
            <edc:SFRFieldDef edc:cname="GPIO_INP" edc:nzwidth="0x1" edc:desc="GPIO input from pin, independent of the Mux selection for the pin or the Direction."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL221" edc:nzwidth="0x20" edc:access="-------n-------nnnnnnnnnnnnnnnnn" edc:por="00000000000000001000000001000000" edc:mclr="00000000000000001000000001000000" edc:impl="0x101FFFF" edc:_addr="0x40081244">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="PU_PD" edc:nzwidth="0x2" edc:desc="These bits are used to enable an internal pull-up or pull-down resistor.">
              <edc:SFRFieldSemantic edc:cname="NONE" edc:desc="None. Pin tristates when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="UP" edc:desc="Pull Up Enabled" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="DOWN" edc:desc="Pull Down Enabled" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="REPEATER" edc:desc="Repeater mode. Pin is kept at previous voltage level when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="PWR_GATING" edc:nzwidth="0x2" edc:desc="The GPIO pin will be tristated when the selected power well is off."/>
            <edc:SFRFieldDef edc:cname="INTR_DET" edc:nzwidth="0x3" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="EDGE_EN" edc:nzwidth="0x1" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="OUT_BUFF_TYPE" edc:nzwidth="0x1" edc:desc="0 = Push-Pull, 1 = Open Drain"/>
            <edc:SFRFieldDef edc:cname="GPIO_DIR" edc:nzwidth="0x1" edc:desc="Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output"/>
            <edc:SFRFieldDef edc:cname="GPIO_OUT_SEL" edc:nzwidth="0x1" edc:desc="GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register."/>
            <edc:SFRFieldDef edc:cname="POL" edc:nzwidth="0x1" edc:desc="1=Inverted; 0=Non-inverted"/>
            <edc:SFRFieldDef edc:cname="MUX_CTRL" edc:nzwidth="0x3" edc:desc="00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3.">
              <edc:SFRFieldSemantic edc:cname="GPIO" edc:desc="GPIO function selected" edc:when="(field &amp; 0x7) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="FUNC1" edc:desc="Signal function 1 selected" edc:when="(field &amp; 0x7) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="FUNC2" edc:desc="Signal function 2 selected" edc:when="(field &amp; 0x7) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="FUNC3" edc:desc="Signal function 3 selected" edc:when="(field &amp; 0x7) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="INP_DIS" edc:nzwidth="0x1" edc:desc="GPIO input disable"/>
            <edc:SFRFieldDef edc:cname="ALT_GPIO_DATA" edc:nzwidth="0x1" edc:desc="GPIO Alternate Data Register."/>
            <edc:AdjustPoint edc:offset="0x7"/>
            <edc:SFRFieldDef edc:cname="GPIO_INP" edc:nzwidth="0x1" edc:desc="GPIO input from pin, independent of the Mux selection for the pin or the Direction."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL222" edc:nzwidth="0x20" edc:access="-------n-------nnnnnnnnnnnnnnnnn" edc:por="00000000000000001000000001000000" edc:mclr="00000000000000001000000001000000" edc:impl="0x101FFFF" edc:_addr="0x40081248">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="PU_PD" edc:nzwidth="0x2" edc:desc="These bits are used to enable an internal pull-up or pull-down resistor.">
              <edc:SFRFieldSemantic edc:cname="NONE" edc:desc="None. Pin tristates when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="UP" edc:desc="Pull Up Enabled" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="DOWN" edc:desc="Pull Down Enabled" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="REPEATER" edc:desc="Repeater mode. Pin is kept at previous voltage level when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="PWR_GATING" edc:nzwidth="0x2" edc:desc="The GPIO pin will be tristated when the selected power well is off."/>
            <edc:SFRFieldDef edc:cname="INTR_DET" edc:nzwidth="0x3" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="EDGE_EN" edc:nzwidth="0x1" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="OUT_BUFF_TYPE" edc:nzwidth="0x1" edc:desc="0 = Push-Pull, 1 = Open Drain"/>
            <edc:SFRFieldDef edc:cname="GPIO_DIR" edc:nzwidth="0x1" edc:desc="Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output"/>
            <edc:SFRFieldDef edc:cname="GPIO_OUT_SEL" edc:nzwidth="0x1" edc:desc="GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register."/>
            <edc:SFRFieldDef edc:cname="POL" edc:nzwidth="0x1" edc:desc="1=Inverted; 0=Non-inverted"/>
            <edc:SFRFieldDef edc:cname="MUX_CTRL" edc:nzwidth="0x3" edc:desc="00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3.">
              <edc:SFRFieldSemantic edc:cname="GPIO" edc:desc="GPIO function selected" edc:when="(field &amp; 0x7) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="FUNC1" edc:desc="Signal function 1 selected" edc:when="(field &amp; 0x7) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="FUNC2" edc:desc="Signal function 2 selected" edc:when="(field &amp; 0x7) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="FUNC3" edc:desc="Signal function 3 selected" edc:when="(field &amp; 0x7) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="INP_DIS" edc:nzwidth="0x1" edc:desc="GPIO input disable"/>
            <edc:SFRFieldDef edc:cname="ALT_GPIO_DATA" edc:nzwidth="0x1" edc:desc="GPIO Alternate Data Register."/>
            <edc:AdjustPoint edc:offset="0x7"/>
            <edc:SFRFieldDef edc:cname="GPIO_INP" edc:nzwidth="0x1" edc:desc="GPIO input from pin, independent of the Mux selection for the pin or the Direction."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL223" edc:nzwidth="0x20" edc:access="-------n-------nnnnnnnnnnnnnnnnn" edc:por="00000000000000001000000001000000" edc:mclr="00000000000000001000000001000000" edc:impl="0x101FFFF" edc:_addr="0x4008124C">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="PU_PD" edc:nzwidth="0x2" edc:desc="These bits are used to enable an internal pull-up or pull-down resistor.">
              <edc:SFRFieldSemantic edc:cname="NONE" edc:desc="None. Pin tristates when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="UP" edc:desc="Pull Up Enabled" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="DOWN" edc:desc="Pull Down Enabled" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="REPEATER" edc:desc="Repeater mode. Pin is kept at previous voltage level when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="PWR_GATING" edc:nzwidth="0x2" edc:desc="The GPIO pin will be tristated when the selected power well is off."/>
            <edc:SFRFieldDef edc:cname="INTR_DET" edc:nzwidth="0x3" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="EDGE_EN" edc:nzwidth="0x1" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="OUT_BUFF_TYPE" edc:nzwidth="0x1" edc:desc="0 = Push-Pull, 1 = Open Drain"/>
            <edc:SFRFieldDef edc:cname="GPIO_DIR" edc:nzwidth="0x1" edc:desc="Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output"/>
            <edc:SFRFieldDef edc:cname="GPIO_OUT_SEL" edc:nzwidth="0x1" edc:desc="GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register."/>
            <edc:SFRFieldDef edc:cname="POL" edc:nzwidth="0x1" edc:desc="1=Inverted; 0=Non-inverted"/>
            <edc:SFRFieldDef edc:cname="MUX_CTRL" edc:nzwidth="0x3" edc:desc="00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3.">
              <edc:SFRFieldSemantic edc:cname="GPIO" edc:desc="GPIO function selected" edc:when="(field &amp; 0x7) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="FUNC1" edc:desc="Signal function 1 selected" edc:when="(field &amp; 0x7) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="FUNC2" edc:desc="Signal function 2 selected" edc:when="(field &amp; 0x7) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="FUNC3" edc:desc="Signal function 3 selected" edc:when="(field &amp; 0x7) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="INP_DIS" edc:nzwidth="0x1" edc:desc="GPIO input disable"/>
            <edc:SFRFieldDef edc:cname="ALT_GPIO_DATA" edc:nzwidth="0x1" edc:desc="GPIO Alternate Data Register."/>
            <edc:AdjustPoint edc:offset="0x7"/>
            <edc:SFRFieldDef edc:cname="GPIO_INP" edc:nzwidth="0x1" edc:desc="GPIO input from pin, independent of the Mux selection for the pin or the Direction."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL224" edc:nzwidth="0x20" edc:access="-------n-------nnnnnnnnnnnnnnnnn" edc:por="00000000000000001000000001000000" edc:mclr="00000000000000001000000001000000" edc:impl="0x101FFFF" edc:_addr="0x40081250">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="PU_PD" edc:nzwidth="0x2" edc:desc="These bits are used to enable an internal pull-up or pull-down resistor.">
              <edc:SFRFieldSemantic edc:cname="NONE" edc:desc="None. Pin tristates when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="UP" edc:desc="Pull Up Enabled" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="DOWN" edc:desc="Pull Down Enabled" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="REPEATER" edc:desc="Repeater mode. Pin is kept at previous voltage level when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="PWR_GATING" edc:nzwidth="0x2" edc:desc="The GPIO pin will be tristated when the selected power well is off."/>
            <edc:SFRFieldDef edc:cname="INTR_DET" edc:nzwidth="0x3" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="EDGE_EN" edc:nzwidth="0x1" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="OUT_BUFF_TYPE" edc:nzwidth="0x1" edc:desc="0 = Push-Pull, 1 = Open Drain"/>
            <edc:SFRFieldDef edc:cname="GPIO_DIR" edc:nzwidth="0x1" edc:desc="Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output"/>
            <edc:SFRFieldDef edc:cname="GPIO_OUT_SEL" edc:nzwidth="0x1" edc:desc="GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register."/>
            <edc:SFRFieldDef edc:cname="POL" edc:nzwidth="0x1" edc:desc="1=Inverted; 0=Non-inverted"/>
            <edc:SFRFieldDef edc:cname="MUX_CTRL" edc:nzwidth="0x3" edc:desc="00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3.">
              <edc:SFRFieldSemantic edc:cname="GPIO" edc:desc="GPIO function selected" edc:when="(field &amp; 0x7) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="FUNC1" edc:desc="Signal function 1 selected" edc:when="(field &amp; 0x7) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="FUNC2" edc:desc="Signal function 2 selected" edc:when="(field &amp; 0x7) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="FUNC3" edc:desc="Signal function 3 selected" edc:when="(field &amp; 0x7) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="INP_DIS" edc:nzwidth="0x1" edc:desc="GPIO input disable"/>
            <edc:SFRFieldDef edc:cname="ALT_GPIO_DATA" edc:nzwidth="0x1" edc:desc="GPIO Alternate Data Register."/>
            <edc:AdjustPoint edc:offset="0x7"/>
            <edc:SFRFieldDef edc:cname="GPIO_INP" edc:nzwidth="0x1" edc:desc="GPIO input from pin, independent of the Mux selection for the pin or the Direction."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL225" edc:nzwidth="0x20" edc:access="-------n-------nnnnnnnnnnnnnnnnn" edc:por="00000000000000001000000001000000" edc:mclr="00000000000000001000000001000000" edc:impl="0x101FFFF" edc:_addr="0x40081254">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="PU_PD" edc:nzwidth="0x2" edc:desc="These bits are used to enable an internal pull-up or pull-down resistor.">
              <edc:SFRFieldSemantic edc:cname="NONE" edc:desc="None. Pin tristates when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="UP" edc:desc="Pull Up Enabled" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="DOWN" edc:desc="Pull Down Enabled" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="REPEATER" edc:desc="Repeater mode. Pin is kept at previous voltage level when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="PWR_GATING" edc:nzwidth="0x2" edc:desc="The GPIO pin will be tristated when the selected power well is off."/>
            <edc:SFRFieldDef edc:cname="INTR_DET" edc:nzwidth="0x3" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="EDGE_EN" edc:nzwidth="0x1" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="OUT_BUFF_TYPE" edc:nzwidth="0x1" edc:desc="0 = Push-Pull, 1 = Open Drain"/>
            <edc:SFRFieldDef edc:cname="GPIO_DIR" edc:nzwidth="0x1" edc:desc="Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output"/>
            <edc:SFRFieldDef edc:cname="GPIO_OUT_SEL" edc:nzwidth="0x1" edc:desc="GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register."/>
            <edc:SFRFieldDef edc:cname="POL" edc:nzwidth="0x1" edc:desc="1=Inverted; 0=Non-inverted"/>
            <edc:SFRFieldDef edc:cname="MUX_CTRL" edc:nzwidth="0x3" edc:desc="00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3.">
              <edc:SFRFieldSemantic edc:cname="GPIO" edc:desc="GPIO function selected" edc:when="(field &amp; 0x7) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="FUNC1" edc:desc="Signal function 1 selected" edc:when="(field &amp; 0x7) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="FUNC2" edc:desc="Signal function 2 selected" edc:when="(field &amp; 0x7) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="FUNC3" edc:desc="Signal function 3 selected" edc:when="(field &amp; 0x7) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="INP_DIS" edc:nzwidth="0x1" edc:desc="GPIO input disable"/>
            <edc:SFRFieldDef edc:cname="ALT_GPIO_DATA" edc:nzwidth="0x1" edc:desc="GPIO Alternate Data Register."/>
            <edc:AdjustPoint edc:offset="0x7"/>
            <edc:SFRFieldDef edc:cname="GPIO_INP" edc:nzwidth="0x1" edc:desc="GPIO input from pin, independent of the Mux selection for the pin or the Direction."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL226" edc:nzwidth="0x20" edc:access="-------n-------nnnnnnnnnnnnnnnnn" edc:por="00000000000000001000000001000000" edc:mclr="00000000000000001000000001000000" edc:impl="0x101FFFF" edc:_addr="0x40081258">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="PU_PD" edc:nzwidth="0x2" edc:desc="These bits are used to enable an internal pull-up or pull-down resistor.">
              <edc:SFRFieldSemantic edc:cname="NONE" edc:desc="None. Pin tristates when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="UP" edc:desc="Pull Up Enabled" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="DOWN" edc:desc="Pull Down Enabled" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="REPEATER" edc:desc="Repeater mode. Pin is kept at previous voltage level when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="PWR_GATING" edc:nzwidth="0x2" edc:desc="The GPIO pin will be tristated when the selected power well is off."/>
            <edc:SFRFieldDef edc:cname="INTR_DET" edc:nzwidth="0x3" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="EDGE_EN" edc:nzwidth="0x1" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="OUT_BUFF_TYPE" edc:nzwidth="0x1" edc:desc="0 = Push-Pull, 1 = Open Drain"/>
            <edc:SFRFieldDef edc:cname="GPIO_DIR" edc:nzwidth="0x1" edc:desc="Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output"/>
            <edc:SFRFieldDef edc:cname="GPIO_OUT_SEL" edc:nzwidth="0x1" edc:desc="GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register."/>
            <edc:SFRFieldDef edc:cname="POL" edc:nzwidth="0x1" edc:desc="1=Inverted; 0=Non-inverted"/>
            <edc:SFRFieldDef edc:cname="MUX_CTRL" edc:nzwidth="0x3" edc:desc="00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3.">
              <edc:SFRFieldSemantic edc:cname="GPIO" edc:desc="GPIO function selected" edc:when="(field &amp; 0x7) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="FUNC1" edc:desc="Signal function 1 selected" edc:when="(field &amp; 0x7) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="FUNC2" edc:desc="Signal function 2 selected" edc:when="(field &amp; 0x7) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="FUNC3" edc:desc="Signal function 3 selected" edc:when="(field &amp; 0x7) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="INP_DIS" edc:nzwidth="0x1" edc:desc="GPIO input disable"/>
            <edc:SFRFieldDef edc:cname="ALT_GPIO_DATA" edc:nzwidth="0x1" edc:desc="GPIO Alternate Data Register."/>
            <edc:AdjustPoint edc:offset="0x7"/>
            <edc:SFRFieldDef edc:cname="GPIO_INP" edc:nzwidth="0x1" edc:desc="GPIO input from pin, independent of the Mux selection for the pin or the Direction."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL227" edc:nzwidth="0x20" edc:access="-------n-------nnnnnnnnnnnnnnnnn" edc:por="00000000000000001000000001000000" edc:mclr="00000000000000001000000001000000" edc:impl="0x101FFFF" edc:_addr="0x4008125C">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="PU_PD" edc:nzwidth="0x2" edc:desc="These bits are used to enable an internal pull-up or pull-down resistor.">
              <edc:SFRFieldSemantic edc:cname="NONE" edc:desc="None. Pin tristates when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="UP" edc:desc="Pull Up Enabled" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="DOWN" edc:desc="Pull Down Enabled" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="REPEATER" edc:desc="Repeater mode. Pin is kept at previous voltage level when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="PWR_GATING" edc:nzwidth="0x2" edc:desc="The GPIO pin will be tristated when the selected power well is off."/>
            <edc:SFRFieldDef edc:cname="INTR_DET" edc:nzwidth="0x3" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="EDGE_EN" edc:nzwidth="0x1" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="OUT_BUFF_TYPE" edc:nzwidth="0x1" edc:desc="0 = Push-Pull, 1 = Open Drain"/>
            <edc:SFRFieldDef edc:cname="GPIO_DIR" edc:nzwidth="0x1" edc:desc="Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output"/>
            <edc:SFRFieldDef edc:cname="GPIO_OUT_SEL" edc:nzwidth="0x1" edc:desc="GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register."/>
            <edc:SFRFieldDef edc:cname="POL" edc:nzwidth="0x1" edc:desc="1=Inverted; 0=Non-inverted"/>
            <edc:SFRFieldDef edc:cname="MUX_CTRL" edc:nzwidth="0x3" edc:desc="00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3.">
              <edc:SFRFieldSemantic edc:cname="GPIO" edc:desc="GPIO function selected" edc:when="(field &amp; 0x7) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="FUNC1" edc:desc="Signal function 1 selected" edc:when="(field &amp; 0x7) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="FUNC2" edc:desc="Signal function 2 selected" edc:when="(field &amp; 0x7) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="FUNC3" edc:desc="Signal function 3 selected" edc:when="(field &amp; 0x7) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="INP_DIS" edc:nzwidth="0x1" edc:desc="GPIO input disable"/>
            <edc:SFRFieldDef edc:cname="ALT_GPIO_DATA" edc:nzwidth="0x1" edc:desc="GPIO Alternate Data Register."/>
            <edc:AdjustPoint edc:offset="0x7"/>
            <edc:SFRFieldDef edc:cname="GPIO_INP" edc:nzwidth="0x1" edc:desc="GPIO input from pin, independent of the Mux selection for the pin or the Direction."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL230" edc:nzwidth="0x20" edc:access="-------n-------nnnnnnnnnnnnnnnnn" edc:por="00000000000000001000000001000000" edc:mclr="00000000000000001000000001000000" edc:impl="0x101FFFF" edc:_addr="0x40081260">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="PU_PD" edc:nzwidth="0x2" edc:desc="These bits are used to enable an internal pull-up or pull-down resistor.">
              <edc:SFRFieldSemantic edc:cname="NONE" edc:desc="None. Pin tristates when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="UP" edc:desc="Pull Up Enabled" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="DOWN" edc:desc="Pull Down Enabled" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="REPEATER" edc:desc="Repeater mode. Pin is kept at previous voltage level when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="PWR_GATING" edc:nzwidth="0x2" edc:desc="The GPIO pin will be tristated when the selected power well is off."/>
            <edc:SFRFieldDef edc:cname="INTR_DET" edc:nzwidth="0x3" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="EDGE_EN" edc:nzwidth="0x1" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="OUT_BUFF_TYPE" edc:nzwidth="0x1" edc:desc="0 = Push-Pull, 1 = Open Drain"/>
            <edc:SFRFieldDef edc:cname="GPIO_DIR" edc:nzwidth="0x1" edc:desc="Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output"/>
            <edc:SFRFieldDef edc:cname="GPIO_OUT_SEL" edc:nzwidth="0x1" edc:desc="GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register."/>
            <edc:SFRFieldDef edc:cname="POL" edc:nzwidth="0x1" edc:desc="1=Inverted; 0=Non-inverted"/>
            <edc:SFRFieldDef edc:cname="MUX_CTRL" edc:nzwidth="0x3" edc:desc="00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3.">
              <edc:SFRFieldSemantic edc:cname="GPIO" edc:desc="GPIO function selected" edc:when="(field &amp; 0x7) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="FUNC1" edc:desc="Signal function 1 selected" edc:when="(field &amp; 0x7) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="FUNC2" edc:desc="Signal function 2 selected" edc:when="(field &amp; 0x7) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="FUNC3" edc:desc="Signal function 3 selected" edc:when="(field &amp; 0x7) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="INP_DIS" edc:nzwidth="0x1" edc:desc="GPIO input disable"/>
            <edc:SFRFieldDef edc:cname="ALT_GPIO_DATA" edc:nzwidth="0x1" edc:desc="GPIO Alternate Data Register."/>
            <edc:AdjustPoint edc:offset="0x7"/>
            <edc:SFRFieldDef edc:cname="GPIO_INP" edc:nzwidth="0x1" edc:desc="GPIO input from pin, independent of the Mux selection for the pin or the Direction."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL231" edc:nzwidth="0x20" edc:access="-------n-------nnnnnnnnnnnnnnnnn" edc:por="00000000000000001000000001000000" edc:mclr="00000000000000001000000001000000" edc:impl="0x101FFFF" edc:_addr="0x40081264">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="PU_PD" edc:nzwidth="0x2" edc:desc="These bits are used to enable an internal pull-up or pull-down resistor.">
              <edc:SFRFieldSemantic edc:cname="NONE" edc:desc="None. Pin tristates when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="UP" edc:desc="Pull Up Enabled" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="DOWN" edc:desc="Pull Down Enabled" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="REPEATER" edc:desc="Repeater mode. Pin is kept at previous voltage level when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="PWR_GATING" edc:nzwidth="0x2" edc:desc="The GPIO pin will be tristated when the selected power well is off."/>
            <edc:SFRFieldDef edc:cname="INTR_DET" edc:nzwidth="0x3" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="EDGE_EN" edc:nzwidth="0x1" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="OUT_BUFF_TYPE" edc:nzwidth="0x1" edc:desc="0 = Push-Pull, 1 = Open Drain"/>
            <edc:SFRFieldDef edc:cname="GPIO_DIR" edc:nzwidth="0x1" edc:desc="Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output"/>
            <edc:SFRFieldDef edc:cname="GPIO_OUT_SEL" edc:nzwidth="0x1" edc:desc="GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register."/>
            <edc:SFRFieldDef edc:cname="POL" edc:nzwidth="0x1" edc:desc="1=Inverted; 0=Non-inverted"/>
            <edc:SFRFieldDef edc:cname="MUX_CTRL" edc:nzwidth="0x3" edc:desc="00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3.">
              <edc:SFRFieldSemantic edc:cname="GPIO" edc:desc="GPIO function selected" edc:when="(field &amp; 0x7) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="FUNC1" edc:desc="Signal function 1 selected" edc:when="(field &amp; 0x7) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="FUNC2" edc:desc="Signal function 2 selected" edc:when="(field &amp; 0x7) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="FUNC3" edc:desc="Signal function 3 selected" edc:when="(field &amp; 0x7) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="INP_DIS" edc:nzwidth="0x1" edc:desc="GPIO input disable"/>
            <edc:SFRFieldDef edc:cname="ALT_GPIO_DATA" edc:nzwidth="0x1" edc:desc="GPIO Alternate Data Register."/>
            <edc:AdjustPoint edc:offset="0x7"/>
            <edc:SFRFieldDef edc:cname="GPIO_INP" edc:nzwidth="0x1" edc:desc="GPIO input from pin, independent of the Mux selection for the pin or the Direction."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL232" edc:nzwidth="0x20" edc:access="-------n-------nnnnnnnnnnnnnnnnn" edc:por="00000000000000001000000001000000" edc:mclr="00000000000000001000000001000000" edc:impl="0x101FFFF" edc:_addr="0x40081268">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="PU_PD" edc:nzwidth="0x2" edc:desc="These bits are used to enable an internal pull-up or pull-down resistor.">
              <edc:SFRFieldSemantic edc:cname="NONE" edc:desc="None. Pin tristates when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="UP" edc:desc="Pull Up Enabled" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="DOWN" edc:desc="Pull Down Enabled" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="REPEATER" edc:desc="Repeater mode. Pin is kept at previous voltage level when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="PWR_GATING" edc:nzwidth="0x2" edc:desc="The GPIO pin will be tristated when the selected power well is off."/>
            <edc:SFRFieldDef edc:cname="INTR_DET" edc:nzwidth="0x3" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="EDGE_EN" edc:nzwidth="0x1" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="OUT_BUFF_TYPE" edc:nzwidth="0x1" edc:desc="0 = Push-Pull, 1 = Open Drain"/>
            <edc:SFRFieldDef edc:cname="GPIO_DIR" edc:nzwidth="0x1" edc:desc="Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output"/>
            <edc:SFRFieldDef edc:cname="GPIO_OUT_SEL" edc:nzwidth="0x1" edc:desc="GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register."/>
            <edc:SFRFieldDef edc:cname="POL" edc:nzwidth="0x1" edc:desc="1=Inverted; 0=Non-inverted"/>
            <edc:SFRFieldDef edc:cname="MUX_CTRL" edc:nzwidth="0x3" edc:desc="00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3.">
              <edc:SFRFieldSemantic edc:cname="GPIO" edc:desc="GPIO function selected" edc:when="(field &amp; 0x7) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="FUNC1" edc:desc="Signal function 1 selected" edc:when="(field &amp; 0x7) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="FUNC2" edc:desc="Signal function 2 selected" edc:when="(field &amp; 0x7) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="FUNC3" edc:desc="Signal function 3 selected" edc:when="(field &amp; 0x7) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="INP_DIS" edc:nzwidth="0x1" edc:desc="GPIO input disable"/>
            <edc:SFRFieldDef edc:cname="ALT_GPIO_DATA" edc:nzwidth="0x1" edc:desc="GPIO Alternate Data Register."/>
            <edc:AdjustPoint edc:offset="0x7"/>
            <edc:SFRFieldDef edc:cname="GPIO_INP" edc:nzwidth="0x1" edc:desc="GPIO input from pin, independent of the Mux selection for the pin or the Direction."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL233" edc:nzwidth="0x20" edc:access="-------n-------nnnnnnnnnnnnnnnnn" edc:por="00000000000000001000000001000000" edc:mclr="00000000000000001000000001000000" edc:impl="0x101FFFF" edc:_addr="0x4008126C">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="PU_PD" edc:nzwidth="0x2" edc:desc="These bits are used to enable an internal pull-up or pull-down resistor.">
              <edc:SFRFieldSemantic edc:cname="NONE" edc:desc="None. Pin tristates when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="UP" edc:desc="Pull Up Enabled" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="DOWN" edc:desc="Pull Down Enabled" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="REPEATER" edc:desc="Repeater mode. Pin is kept at previous voltage level when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="PWR_GATING" edc:nzwidth="0x2" edc:desc="The GPIO pin will be tristated when the selected power well is off."/>
            <edc:SFRFieldDef edc:cname="INTR_DET" edc:nzwidth="0x3" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="EDGE_EN" edc:nzwidth="0x1" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="OUT_BUFF_TYPE" edc:nzwidth="0x1" edc:desc="0 = Push-Pull, 1 = Open Drain"/>
            <edc:SFRFieldDef edc:cname="GPIO_DIR" edc:nzwidth="0x1" edc:desc="Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output"/>
            <edc:SFRFieldDef edc:cname="GPIO_OUT_SEL" edc:nzwidth="0x1" edc:desc="GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register."/>
            <edc:SFRFieldDef edc:cname="POL" edc:nzwidth="0x1" edc:desc="1=Inverted; 0=Non-inverted"/>
            <edc:SFRFieldDef edc:cname="MUX_CTRL" edc:nzwidth="0x3" edc:desc="00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3.">
              <edc:SFRFieldSemantic edc:cname="GPIO" edc:desc="GPIO function selected" edc:when="(field &amp; 0x7) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="FUNC1" edc:desc="Signal function 1 selected" edc:when="(field &amp; 0x7) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="FUNC2" edc:desc="Signal function 2 selected" edc:when="(field &amp; 0x7) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="FUNC3" edc:desc="Signal function 3 selected" edc:when="(field &amp; 0x7) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="INP_DIS" edc:nzwidth="0x1" edc:desc="GPIO input disable"/>
            <edc:SFRFieldDef edc:cname="ALT_GPIO_DATA" edc:nzwidth="0x1" edc:desc="GPIO Alternate Data Register."/>
            <edc:AdjustPoint edc:offset="0x7"/>
            <edc:SFRFieldDef edc:cname="GPIO_INP" edc:nzwidth="0x1" edc:desc="GPIO input from pin, independent of the Mux selection for the pin or the Direction."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL234" edc:nzwidth="0x20" edc:access="-------n-------nnnnnnnnnnnnnnnnn" edc:por="00000000000000001000000001000000" edc:mclr="00000000000000001000000001000000" edc:impl="0x101FFFF" edc:_addr="0x40081270">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="PU_PD" edc:nzwidth="0x2" edc:desc="These bits are used to enable an internal pull-up or pull-down resistor.">
              <edc:SFRFieldSemantic edc:cname="NONE" edc:desc="None. Pin tristates when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="UP" edc:desc="Pull Up Enabled" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="DOWN" edc:desc="Pull Down Enabled" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="REPEATER" edc:desc="Repeater mode. Pin is kept at previous voltage level when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="PWR_GATING" edc:nzwidth="0x2" edc:desc="The GPIO pin will be tristated when the selected power well is off."/>
            <edc:SFRFieldDef edc:cname="INTR_DET" edc:nzwidth="0x3" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="EDGE_EN" edc:nzwidth="0x1" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="OUT_BUFF_TYPE" edc:nzwidth="0x1" edc:desc="0 = Push-Pull, 1 = Open Drain"/>
            <edc:SFRFieldDef edc:cname="GPIO_DIR" edc:nzwidth="0x1" edc:desc="Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output"/>
            <edc:SFRFieldDef edc:cname="GPIO_OUT_SEL" edc:nzwidth="0x1" edc:desc="GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register."/>
            <edc:SFRFieldDef edc:cname="POL" edc:nzwidth="0x1" edc:desc="1=Inverted; 0=Non-inverted"/>
            <edc:SFRFieldDef edc:cname="MUX_CTRL" edc:nzwidth="0x3" edc:desc="00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3.">
              <edc:SFRFieldSemantic edc:cname="GPIO" edc:desc="GPIO function selected" edc:when="(field &amp; 0x7) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="FUNC1" edc:desc="Signal function 1 selected" edc:when="(field &amp; 0x7) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="FUNC2" edc:desc="Signal function 2 selected" edc:when="(field &amp; 0x7) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="FUNC3" edc:desc="Signal function 3 selected" edc:when="(field &amp; 0x7) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="INP_DIS" edc:nzwidth="0x1" edc:desc="GPIO input disable"/>
            <edc:SFRFieldDef edc:cname="ALT_GPIO_DATA" edc:nzwidth="0x1" edc:desc="GPIO Alternate Data Register."/>
            <edc:AdjustPoint edc:offset="0x7"/>
            <edc:SFRFieldDef edc:cname="GPIO_INP" edc:nzwidth="0x1" edc:desc="GPIO input from pin, independent of the Mux selection for the pin or the Direction."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL235" edc:nzwidth="0x20" edc:access="-------n-------nnnnnnnnnnnnnnnnn" edc:por="00000000000000001000000001000000" edc:mclr="00000000000000001000000001000000" edc:impl="0x101FFFF" edc:_addr="0x40081274">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="PU_PD" edc:nzwidth="0x2" edc:desc="These bits are used to enable an internal pull-up or pull-down resistor.">
              <edc:SFRFieldSemantic edc:cname="NONE" edc:desc="None. Pin tristates when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="UP" edc:desc="Pull Up Enabled" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="DOWN" edc:desc="Pull Down Enabled" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="REPEATER" edc:desc="Repeater mode. Pin is kept at previous voltage level when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="PWR_GATING" edc:nzwidth="0x2" edc:desc="The GPIO pin will be tristated when the selected power well is off."/>
            <edc:SFRFieldDef edc:cname="INTR_DET" edc:nzwidth="0x3" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="EDGE_EN" edc:nzwidth="0x1" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="OUT_BUFF_TYPE" edc:nzwidth="0x1" edc:desc="0 = Push-Pull, 1 = Open Drain"/>
            <edc:SFRFieldDef edc:cname="GPIO_DIR" edc:nzwidth="0x1" edc:desc="Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output"/>
            <edc:SFRFieldDef edc:cname="GPIO_OUT_SEL" edc:nzwidth="0x1" edc:desc="GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register."/>
            <edc:SFRFieldDef edc:cname="POL" edc:nzwidth="0x1" edc:desc="1=Inverted; 0=Non-inverted"/>
            <edc:SFRFieldDef edc:cname="MUX_CTRL" edc:nzwidth="0x3" edc:desc="00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3.">
              <edc:SFRFieldSemantic edc:cname="GPIO" edc:desc="GPIO function selected" edc:when="(field &amp; 0x7) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="FUNC1" edc:desc="Signal function 1 selected" edc:when="(field &amp; 0x7) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="FUNC2" edc:desc="Signal function 2 selected" edc:when="(field &amp; 0x7) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="FUNC3" edc:desc="Signal function 3 selected" edc:when="(field &amp; 0x7) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="INP_DIS" edc:nzwidth="0x1" edc:desc="GPIO input disable"/>
            <edc:SFRFieldDef edc:cname="ALT_GPIO_DATA" edc:nzwidth="0x1" edc:desc="GPIO Alternate Data Register."/>
            <edc:AdjustPoint edc:offset="0x7"/>
            <edc:SFRFieldDef edc:cname="GPIO_INP" edc:nzwidth="0x1" edc:desc="GPIO input from pin, independent of the Mux selection for the pin or the Direction."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL236" edc:nzwidth="0x20" edc:access="-------n-------nnnnnnnnnnnnnnnnn" edc:por="00000000000000001000000001000000" edc:mclr="00000000000000001000000001000000" edc:impl="0x101FFFF" edc:_addr="0x40081278">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="PU_PD" edc:nzwidth="0x2" edc:desc="These bits are used to enable an internal pull-up or pull-down resistor.">
              <edc:SFRFieldSemantic edc:cname="NONE" edc:desc="None. Pin tristates when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="UP" edc:desc="Pull Up Enabled" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="DOWN" edc:desc="Pull Down Enabled" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="REPEATER" edc:desc="Repeater mode. Pin is kept at previous voltage level when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="PWR_GATING" edc:nzwidth="0x2" edc:desc="The GPIO pin will be tristated when the selected power well is off."/>
            <edc:SFRFieldDef edc:cname="INTR_DET" edc:nzwidth="0x3" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="EDGE_EN" edc:nzwidth="0x1" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="OUT_BUFF_TYPE" edc:nzwidth="0x1" edc:desc="0 = Push-Pull, 1 = Open Drain"/>
            <edc:SFRFieldDef edc:cname="GPIO_DIR" edc:nzwidth="0x1" edc:desc="Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output"/>
            <edc:SFRFieldDef edc:cname="GPIO_OUT_SEL" edc:nzwidth="0x1" edc:desc="GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register."/>
            <edc:SFRFieldDef edc:cname="POL" edc:nzwidth="0x1" edc:desc="1=Inverted; 0=Non-inverted"/>
            <edc:SFRFieldDef edc:cname="MUX_CTRL" edc:nzwidth="0x3" edc:desc="00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3.">
              <edc:SFRFieldSemantic edc:cname="GPIO" edc:desc="GPIO function selected" edc:when="(field &amp; 0x7) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="FUNC1" edc:desc="Signal function 1 selected" edc:when="(field &amp; 0x7) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="FUNC2" edc:desc="Signal function 2 selected" edc:when="(field &amp; 0x7) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="FUNC3" edc:desc="Signal function 3 selected" edc:when="(field &amp; 0x7) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="INP_DIS" edc:nzwidth="0x1" edc:desc="GPIO input disable"/>
            <edc:SFRFieldDef edc:cname="ALT_GPIO_DATA" edc:nzwidth="0x1" edc:desc="GPIO Alternate Data Register."/>
            <edc:AdjustPoint edc:offset="0x7"/>
            <edc:SFRFieldDef edc:cname="GPIO_INP" edc:nzwidth="0x1" edc:desc="GPIO input from pin, independent of the Mux selection for the pin or the Direction."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL237" edc:nzwidth="0x20" edc:access="-------n-------nnnnnnnnnnnnnnnnn" edc:por="00000000000000001000000001000000" edc:mclr="00000000000000001000000001000000" edc:impl="0x101FFFF" edc:_addr="0x4008127C">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="PU_PD" edc:nzwidth="0x2" edc:desc="These bits are used to enable an internal pull-up or pull-down resistor.">
              <edc:SFRFieldSemantic edc:cname="NONE" edc:desc="None. Pin tristates when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="UP" edc:desc="Pull Up Enabled" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="DOWN" edc:desc="Pull Down Enabled" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="REPEATER" edc:desc="Repeater mode. Pin is kept at previous voltage level when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="PWR_GATING" edc:nzwidth="0x2" edc:desc="The GPIO pin will be tristated when the selected power well is off."/>
            <edc:SFRFieldDef edc:cname="INTR_DET" edc:nzwidth="0x3" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="EDGE_EN" edc:nzwidth="0x1" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="OUT_BUFF_TYPE" edc:nzwidth="0x1" edc:desc="0 = Push-Pull, 1 = Open Drain"/>
            <edc:SFRFieldDef edc:cname="GPIO_DIR" edc:nzwidth="0x1" edc:desc="Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output"/>
            <edc:SFRFieldDef edc:cname="GPIO_OUT_SEL" edc:nzwidth="0x1" edc:desc="GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register."/>
            <edc:SFRFieldDef edc:cname="POL" edc:nzwidth="0x1" edc:desc="1=Inverted; 0=Non-inverted"/>
            <edc:SFRFieldDef edc:cname="MUX_CTRL" edc:nzwidth="0x3" edc:desc="00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3.">
              <edc:SFRFieldSemantic edc:cname="GPIO" edc:desc="GPIO function selected" edc:when="(field &amp; 0x7) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="FUNC1" edc:desc="Signal function 1 selected" edc:when="(field &amp; 0x7) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="FUNC2" edc:desc="Signal function 2 selected" edc:when="(field &amp; 0x7) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="FUNC3" edc:desc="Signal function 3 selected" edc:when="(field &amp; 0x7) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="INP_DIS" edc:nzwidth="0x1" edc:desc="GPIO input disable"/>
            <edc:SFRFieldDef edc:cname="ALT_GPIO_DATA" edc:nzwidth="0x1" edc:desc="GPIO Alternate Data Register."/>
            <edc:AdjustPoint edc:offset="0x7"/>
            <edc:SFRFieldDef edc:cname="GPIO_INP" edc:nzwidth="0x1" edc:desc="GPIO input from pin, independent of the Mux selection for the pin or the Direction."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL240" edc:nzwidth="0x20" edc:access="-------n-------nnnnnnnnnnnnnnnnn" edc:por="00000000000000001000000001000000" edc:mclr="00000000000000001000000001000000" edc:impl="0x101FFFF" edc:_addr="0x40081280">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="PU_PD" edc:nzwidth="0x2" edc:desc="These bits are used to enable an internal pull-up or pull-down resistor.">
              <edc:SFRFieldSemantic edc:cname="NONE" edc:desc="None. Pin tristates when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="UP" edc:desc="Pull Up Enabled" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="DOWN" edc:desc="Pull Down Enabled" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="REPEATER" edc:desc="Repeater mode. Pin is kept at previous voltage level when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="PWR_GATING" edc:nzwidth="0x2" edc:desc="The GPIO pin will be tristated when the selected power well is off."/>
            <edc:SFRFieldDef edc:cname="INTR_DET" edc:nzwidth="0x3" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="EDGE_EN" edc:nzwidth="0x1" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="OUT_BUFF_TYPE" edc:nzwidth="0x1" edc:desc="0 = Push-Pull, 1 = Open Drain"/>
            <edc:SFRFieldDef edc:cname="GPIO_DIR" edc:nzwidth="0x1" edc:desc="Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output"/>
            <edc:SFRFieldDef edc:cname="GPIO_OUT_SEL" edc:nzwidth="0x1" edc:desc="GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register."/>
            <edc:SFRFieldDef edc:cname="POL" edc:nzwidth="0x1" edc:desc="1=Inverted; 0=Non-inverted"/>
            <edc:SFRFieldDef edc:cname="MUX_CTRL" edc:nzwidth="0x3" edc:desc="00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3.">
              <edc:SFRFieldSemantic edc:cname="GPIO" edc:desc="GPIO function selected" edc:when="(field &amp; 0x7) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="FUNC1" edc:desc="Signal function 1 selected" edc:when="(field &amp; 0x7) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="FUNC2" edc:desc="Signal function 2 selected" edc:when="(field &amp; 0x7) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="FUNC3" edc:desc="Signal function 3 selected" edc:when="(field &amp; 0x7) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="INP_DIS" edc:nzwidth="0x1" edc:desc="GPIO input disable"/>
            <edc:SFRFieldDef edc:cname="ALT_GPIO_DATA" edc:nzwidth="0x1" edc:desc="GPIO Alternate Data Register."/>
            <edc:AdjustPoint edc:offset="0x7"/>
            <edc:SFRFieldDef edc:cname="GPIO_INP" edc:nzwidth="0x1" edc:desc="GPIO input from pin, independent of the Mux selection for the pin or the Direction."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL241" edc:nzwidth="0x20" edc:access="-------n-------nnnnnnnnnnnnnnnnn" edc:por="00000000000000001000000001000000" edc:mclr="00000000000000001000000001000000" edc:impl="0x101FFFF" edc:_addr="0x40081284">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="PU_PD" edc:nzwidth="0x2" edc:desc="These bits are used to enable an internal pull-up or pull-down resistor.">
              <edc:SFRFieldSemantic edc:cname="NONE" edc:desc="None. Pin tristates when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="UP" edc:desc="Pull Up Enabled" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="DOWN" edc:desc="Pull Down Enabled" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="REPEATER" edc:desc="Repeater mode. Pin is kept at previous voltage level when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="PWR_GATING" edc:nzwidth="0x2" edc:desc="The GPIO pin will be tristated when the selected power well is off."/>
            <edc:SFRFieldDef edc:cname="INTR_DET" edc:nzwidth="0x3" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="EDGE_EN" edc:nzwidth="0x1" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="OUT_BUFF_TYPE" edc:nzwidth="0x1" edc:desc="0 = Push-Pull, 1 = Open Drain"/>
            <edc:SFRFieldDef edc:cname="GPIO_DIR" edc:nzwidth="0x1" edc:desc="Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output"/>
            <edc:SFRFieldDef edc:cname="GPIO_OUT_SEL" edc:nzwidth="0x1" edc:desc="GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register."/>
            <edc:SFRFieldDef edc:cname="POL" edc:nzwidth="0x1" edc:desc="1=Inverted; 0=Non-inverted"/>
            <edc:SFRFieldDef edc:cname="MUX_CTRL" edc:nzwidth="0x3" edc:desc="00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3.">
              <edc:SFRFieldSemantic edc:cname="GPIO" edc:desc="GPIO function selected" edc:when="(field &amp; 0x7) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="FUNC1" edc:desc="Signal function 1 selected" edc:when="(field &amp; 0x7) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="FUNC2" edc:desc="Signal function 2 selected" edc:when="(field &amp; 0x7) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="FUNC3" edc:desc="Signal function 3 selected" edc:when="(field &amp; 0x7) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="INP_DIS" edc:nzwidth="0x1" edc:desc="GPIO input disable"/>
            <edc:SFRFieldDef edc:cname="ALT_GPIO_DATA" edc:nzwidth="0x1" edc:desc="GPIO Alternate Data Register."/>
            <edc:AdjustPoint edc:offset="0x7"/>
            <edc:SFRFieldDef edc:cname="GPIO_INP" edc:nzwidth="0x1" edc:desc="GPIO input from pin, independent of the Mux selection for the pin or the Direction."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL242" edc:nzwidth="0x20" edc:access="-------n-------nnnnnnnnnnnnnnnnn" edc:por="00000000000000001000000001000000" edc:mclr="00000000000000001000000001000000" edc:impl="0x101FFFF" edc:_addr="0x40081288">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="PU_PD" edc:nzwidth="0x2" edc:desc="These bits are used to enable an internal pull-up or pull-down resistor.">
              <edc:SFRFieldSemantic edc:cname="NONE" edc:desc="None. Pin tristates when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="UP" edc:desc="Pull Up Enabled" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="DOWN" edc:desc="Pull Down Enabled" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="REPEATER" edc:desc="Repeater mode. Pin is kept at previous voltage level when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="PWR_GATING" edc:nzwidth="0x2" edc:desc="The GPIO pin will be tristated when the selected power well is off."/>
            <edc:SFRFieldDef edc:cname="INTR_DET" edc:nzwidth="0x3" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="EDGE_EN" edc:nzwidth="0x1" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="OUT_BUFF_TYPE" edc:nzwidth="0x1" edc:desc="0 = Push-Pull, 1 = Open Drain"/>
            <edc:SFRFieldDef edc:cname="GPIO_DIR" edc:nzwidth="0x1" edc:desc="Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output"/>
            <edc:SFRFieldDef edc:cname="GPIO_OUT_SEL" edc:nzwidth="0x1" edc:desc="GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register."/>
            <edc:SFRFieldDef edc:cname="POL" edc:nzwidth="0x1" edc:desc="1=Inverted; 0=Non-inverted"/>
            <edc:SFRFieldDef edc:cname="MUX_CTRL" edc:nzwidth="0x3" edc:desc="00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3.">
              <edc:SFRFieldSemantic edc:cname="GPIO" edc:desc="GPIO function selected" edc:when="(field &amp; 0x7) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="FUNC1" edc:desc="Signal function 1 selected" edc:when="(field &amp; 0x7) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="FUNC2" edc:desc="Signal function 2 selected" edc:when="(field &amp; 0x7) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="FUNC3" edc:desc="Signal function 3 selected" edc:when="(field &amp; 0x7) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="INP_DIS" edc:nzwidth="0x1" edc:desc="GPIO input disable"/>
            <edc:SFRFieldDef edc:cname="ALT_GPIO_DATA" edc:nzwidth="0x1" edc:desc="GPIO Alternate Data Register."/>
            <edc:AdjustPoint edc:offset="0x7"/>
            <edc:SFRFieldDef edc:cname="GPIO_INP" edc:nzwidth="0x1" edc:desc="GPIO input from pin, independent of the Mux selection for the pin or the Direction."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL243" edc:nzwidth="0x20" edc:access="-------n-------nnnnnnnnnnnnnnnnn" edc:por="00000000000000001000000001000000" edc:mclr="00000000000000001000000001000000" edc:impl="0x101FFFF" edc:_addr="0x4008128C">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="PU_PD" edc:nzwidth="0x2" edc:desc="These bits are used to enable an internal pull-up or pull-down resistor.">
              <edc:SFRFieldSemantic edc:cname="NONE" edc:desc="None. Pin tristates when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="UP" edc:desc="Pull Up Enabled" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="DOWN" edc:desc="Pull Down Enabled" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="REPEATER" edc:desc="Repeater mode. Pin is kept at previous voltage level when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="PWR_GATING" edc:nzwidth="0x2" edc:desc="The GPIO pin will be tristated when the selected power well is off."/>
            <edc:SFRFieldDef edc:cname="INTR_DET" edc:nzwidth="0x3" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="EDGE_EN" edc:nzwidth="0x1" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="OUT_BUFF_TYPE" edc:nzwidth="0x1" edc:desc="0 = Push-Pull, 1 = Open Drain"/>
            <edc:SFRFieldDef edc:cname="GPIO_DIR" edc:nzwidth="0x1" edc:desc="Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output"/>
            <edc:SFRFieldDef edc:cname="GPIO_OUT_SEL" edc:nzwidth="0x1" edc:desc="GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register."/>
            <edc:SFRFieldDef edc:cname="POL" edc:nzwidth="0x1" edc:desc="1=Inverted; 0=Non-inverted"/>
            <edc:SFRFieldDef edc:cname="MUX_CTRL" edc:nzwidth="0x3" edc:desc="00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3.">
              <edc:SFRFieldSemantic edc:cname="GPIO" edc:desc="GPIO function selected" edc:when="(field &amp; 0x7) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="FUNC1" edc:desc="Signal function 1 selected" edc:when="(field &amp; 0x7) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="FUNC2" edc:desc="Signal function 2 selected" edc:when="(field &amp; 0x7) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="FUNC3" edc:desc="Signal function 3 selected" edc:when="(field &amp; 0x7) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="INP_DIS" edc:nzwidth="0x1" edc:desc="GPIO input disable"/>
            <edc:SFRFieldDef edc:cname="ALT_GPIO_DATA" edc:nzwidth="0x1" edc:desc="GPIO Alternate Data Register."/>
            <edc:AdjustPoint edc:offset="0x7"/>
            <edc:SFRFieldDef edc:cname="GPIO_INP" edc:nzwidth="0x1" edc:desc="GPIO input from pin, independent of the Mux selection for the pin or the Direction."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL244" edc:nzwidth="0x20" edc:access="-------n-------nnnnnnnnnnnnnnnnn" edc:por="00000000000000001000000001000000" edc:mclr="00000000000000001000000001000000" edc:impl="0x101FFFF" edc:_addr="0x40081290">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="PU_PD" edc:nzwidth="0x2" edc:desc="These bits are used to enable an internal pull-up or pull-down resistor.">
              <edc:SFRFieldSemantic edc:cname="NONE" edc:desc="None. Pin tristates when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="UP" edc:desc="Pull Up Enabled" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="DOWN" edc:desc="Pull Down Enabled" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="REPEATER" edc:desc="Repeater mode. Pin is kept at previous voltage level when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="PWR_GATING" edc:nzwidth="0x2" edc:desc="The GPIO pin will be tristated when the selected power well is off."/>
            <edc:SFRFieldDef edc:cname="INTR_DET" edc:nzwidth="0x3" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="EDGE_EN" edc:nzwidth="0x1" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="OUT_BUFF_TYPE" edc:nzwidth="0x1" edc:desc="0 = Push-Pull, 1 = Open Drain"/>
            <edc:SFRFieldDef edc:cname="GPIO_DIR" edc:nzwidth="0x1" edc:desc="Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output"/>
            <edc:SFRFieldDef edc:cname="GPIO_OUT_SEL" edc:nzwidth="0x1" edc:desc="GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register."/>
            <edc:SFRFieldDef edc:cname="POL" edc:nzwidth="0x1" edc:desc="1=Inverted; 0=Non-inverted"/>
            <edc:SFRFieldDef edc:cname="MUX_CTRL" edc:nzwidth="0x3" edc:desc="00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3.">
              <edc:SFRFieldSemantic edc:cname="GPIO" edc:desc="GPIO function selected" edc:when="(field &amp; 0x7) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="FUNC1" edc:desc="Signal function 1 selected" edc:when="(field &amp; 0x7) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="FUNC2" edc:desc="Signal function 2 selected" edc:when="(field &amp; 0x7) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="FUNC3" edc:desc="Signal function 3 selected" edc:when="(field &amp; 0x7) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="INP_DIS" edc:nzwidth="0x1" edc:desc="GPIO input disable"/>
            <edc:SFRFieldDef edc:cname="ALT_GPIO_DATA" edc:nzwidth="0x1" edc:desc="GPIO Alternate Data Register."/>
            <edc:AdjustPoint edc:offset="0x7"/>
            <edc:SFRFieldDef edc:cname="GPIO_INP" edc:nzwidth="0x1" edc:desc="GPIO input from pin, independent of the Mux selection for the pin or the Direction."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL245" edc:nzwidth="0x20" edc:access="-------n-------nnnnnnnnnnnnnnnnn" edc:por="00000000000000001000000001000000" edc:mclr="00000000000000001000000001000000" edc:impl="0x101FFFF" edc:_addr="0x40081294">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="PU_PD" edc:nzwidth="0x2" edc:desc="These bits are used to enable an internal pull-up or pull-down resistor.">
              <edc:SFRFieldSemantic edc:cname="NONE" edc:desc="None. Pin tristates when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="UP" edc:desc="Pull Up Enabled" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="DOWN" edc:desc="Pull Down Enabled" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="REPEATER" edc:desc="Repeater mode. Pin is kept at previous voltage level when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="PWR_GATING" edc:nzwidth="0x2" edc:desc="The GPIO pin will be tristated when the selected power well is off."/>
            <edc:SFRFieldDef edc:cname="INTR_DET" edc:nzwidth="0x3" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="EDGE_EN" edc:nzwidth="0x1" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="OUT_BUFF_TYPE" edc:nzwidth="0x1" edc:desc="0 = Push-Pull, 1 = Open Drain"/>
            <edc:SFRFieldDef edc:cname="GPIO_DIR" edc:nzwidth="0x1" edc:desc="Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output"/>
            <edc:SFRFieldDef edc:cname="GPIO_OUT_SEL" edc:nzwidth="0x1" edc:desc="GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register."/>
            <edc:SFRFieldDef edc:cname="POL" edc:nzwidth="0x1" edc:desc="1=Inverted; 0=Non-inverted"/>
            <edc:SFRFieldDef edc:cname="MUX_CTRL" edc:nzwidth="0x3" edc:desc="00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3.">
              <edc:SFRFieldSemantic edc:cname="GPIO" edc:desc="GPIO function selected" edc:when="(field &amp; 0x7) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="FUNC1" edc:desc="Signal function 1 selected" edc:when="(field &amp; 0x7) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="FUNC2" edc:desc="Signal function 2 selected" edc:when="(field &amp; 0x7) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="FUNC3" edc:desc="Signal function 3 selected" edc:when="(field &amp; 0x7) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="INP_DIS" edc:nzwidth="0x1" edc:desc="GPIO input disable"/>
            <edc:SFRFieldDef edc:cname="ALT_GPIO_DATA" edc:nzwidth="0x1" edc:desc="GPIO Alternate Data Register."/>
            <edc:AdjustPoint edc:offset="0x7"/>
            <edc:SFRFieldDef edc:cname="GPIO_INP" edc:nzwidth="0x1" edc:desc="GPIO input from pin, independent of the Mux selection for the pin or the Direction."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL246" edc:nzwidth="0x20" edc:access="-------n-------nnnnnnnnnnnnnnnnn" edc:por="00000000000000001000000001000000" edc:mclr="00000000000000001000000001000000" edc:impl="0x101FFFF" edc:_addr="0x40081298">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="PU_PD" edc:nzwidth="0x2" edc:desc="These bits are used to enable an internal pull-up or pull-down resistor.">
              <edc:SFRFieldSemantic edc:cname="NONE" edc:desc="None. Pin tristates when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="UP" edc:desc="Pull Up Enabled" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="DOWN" edc:desc="Pull Down Enabled" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="REPEATER" edc:desc="Repeater mode. Pin is kept at previous voltage level when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="PWR_GATING" edc:nzwidth="0x2" edc:desc="The GPIO pin will be tristated when the selected power well is off."/>
            <edc:SFRFieldDef edc:cname="INTR_DET" edc:nzwidth="0x3" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="EDGE_EN" edc:nzwidth="0x1" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="OUT_BUFF_TYPE" edc:nzwidth="0x1" edc:desc="0 = Push-Pull, 1 = Open Drain"/>
            <edc:SFRFieldDef edc:cname="GPIO_DIR" edc:nzwidth="0x1" edc:desc="Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output"/>
            <edc:SFRFieldDef edc:cname="GPIO_OUT_SEL" edc:nzwidth="0x1" edc:desc="GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register."/>
            <edc:SFRFieldDef edc:cname="POL" edc:nzwidth="0x1" edc:desc="1=Inverted; 0=Non-inverted"/>
            <edc:SFRFieldDef edc:cname="MUX_CTRL" edc:nzwidth="0x3" edc:desc="00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3.">
              <edc:SFRFieldSemantic edc:cname="GPIO" edc:desc="GPIO function selected" edc:when="(field &amp; 0x7) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="FUNC1" edc:desc="Signal function 1 selected" edc:when="(field &amp; 0x7) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="FUNC2" edc:desc="Signal function 2 selected" edc:when="(field &amp; 0x7) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="FUNC3" edc:desc="Signal function 3 selected" edc:when="(field &amp; 0x7) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="INP_DIS" edc:nzwidth="0x1" edc:desc="GPIO input disable"/>
            <edc:SFRFieldDef edc:cname="ALT_GPIO_DATA" edc:nzwidth="0x1" edc:desc="GPIO Alternate Data Register."/>
            <edc:AdjustPoint edc:offset="0x7"/>
            <edc:SFRFieldDef edc:cname="GPIO_INP" edc:nzwidth="0x1" edc:desc="GPIO input from pin, independent of the Mux selection for the pin or the Direction."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL247" edc:nzwidth="0x20" edc:access="-------n-------nnnnnnnnnnnnnnnnn" edc:por="00000000000000001000000001000000" edc:mclr="00000000000000001000000001000000" edc:impl="0x101FFFF" edc:_addr="0x4008129C">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="PU_PD" edc:nzwidth="0x2" edc:desc="These bits are used to enable an internal pull-up or pull-down resistor.">
              <edc:SFRFieldSemantic edc:cname="NONE" edc:desc="None. Pin tristates when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="UP" edc:desc="Pull Up Enabled" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="DOWN" edc:desc="Pull Down Enabled" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="REPEATER" edc:desc="Repeater mode. Pin is kept at previous voltage level when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="PWR_GATING" edc:nzwidth="0x2" edc:desc="The GPIO pin will be tristated when the selected power well is off."/>
            <edc:SFRFieldDef edc:cname="INTR_DET" edc:nzwidth="0x3" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="EDGE_EN" edc:nzwidth="0x1" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="OUT_BUFF_TYPE" edc:nzwidth="0x1" edc:desc="0 = Push-Pull, 1 = Open Drain"/>
            <edc:SFRFieldDef edc:cname="GPIO_DIR" edc:nzwidth="0x1" edc:desc="Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output"/>
            <edc:SFRFieldDef edc:cname="GPIO_OUT_SEL" edc:nzwidth="0x1" edc:desc="GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register."/>
            <edc:SFRFieldDef edc:cname="POL" edc:nzwidth="0x1" edc:desc="1=Inverted; 0=Non-inverted"/>
            <edc:SFRFieldDef edc:cname="MUX_CTRL" edc:nzwidth="0x3" edc:desc="00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3.">
              <edc:SFRFieldSemantic edc:cname="GPIO" edc:desc="GPIO function selected" edc:when="(field &amp; 0x7) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="FUNC1" edc:desc="Signal function 1 selected" edc:when="(field &amp; 0x7) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="FUNC2" edc:desc="Signal function 2 selected" edc:when="(field &amp; 0x7) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="FUNC3" edc:desc="Signal function 3 selected" edc:when="(field &amp; 0x7) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="INP_DIS" edc:nzwidth="0x1" edc:desc="GPIO input disable"/>
            <edc:SFRFieldDef edc:cname="ALT_GPIO_DATA" edc:nzwidth="0x1" edc:desc="GPIO Alternate Data Register."/>
            <edc:AdjustPoint edc:offset="0x7"/>
            <edc:SFRFieldDef edc:cname="GPIO_INP" edc:nzwidth="0x1" edc:desc="GPIO input from pin, independent of the Mux selection for the pin or the Direction."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL250" edc:nzwidth="0x20" edc:access="-------n-------nnnnnnnnnnnnnnnnn" edc:por="00000000000000001000000001000000" edc:mclr="00000000000000001000000001000000" edc:impl="0x101FFFF" edc:_addr="0x400812A0">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="PU_PD" edc:nzwidth="0x2" edc:desc="These bits are used to enable an internal pull-up or pull-down resistor.">
              <edc:SFRFieldSemantic edc:cname="NONE" edc:desc="None. Pin tristates when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="UP" edc:desc="Pull Up Enabled" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="DOWN" edc:desc="Pull Down Enabled" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="REPEATER" edc:desc="Repeater mode. Pin is kept at previous voltage level when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="PWR_GATING" edc:nzwidth="0x2" edc:desc="The GPIO pin will be tristated when the selected power well is off."/>
            <edc:SFRFieldDef edc:cname="INTR_DET" edc:nzwidth="0x3" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="EDGE_EN" edc:nzwidth="0x1" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="OUT_BUFF_TYPE" edc:nzwidth="0x1" edc:desc="0 = Push-Pull, 1 = Open Drain"/>
            <edc:SFRFieldDef edc:cname="GPIO_DIR" edc:nzwidth="0x1" edc:desc="Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output"/>
            <edc:SFRFieldDef edc:cname="GPIO_OUT_SEL" edc:nzwidth="0x1" edc:desc="GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register."/>
            <edc:SFRFieldDef edc:cname="POL" edc:nzwidth="0x1" edc:desc="1=Inverted; 0=Non-inverted"/>
            <edc:SFRFieldDef edc:cname="MUX_CTRL" edc:nzwidth="0x3" edc:desc="00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3.">
              <edc:SFRFieldSemantic edc:cname="GPIO" edc:desc="GPIO function selected" edc:when="(field &amp; 0x7) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="FUNC1" edc:desc="Signal function 1 selected" edc:when="(field &amp; 0x7) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="FUNC2" edc:desc="Signal function 2 selected" edc:when="(field &amp; 0x7) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="FUNC3" edc:desc="Signal function 3 selected" edc:when="(field &amp; 0x7) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="INP_DIS" edc:nzwidth="0x1" edc:desc="GPIO input disable"/>
            <edc:SFRFieldDef edc:cname="ALT_GPIO_DATA" edc:nzwidth="0x1" edc:desc="GPIO Alternate Data Register."/>
            <edc:AdjustPoint edc:offset="0x7"/>
            <edc:SFRFieldDef edc:cname="GPIO_INP" edc:nzwidth="0x1" edc:desc="GPIO input from pin, independent of the Mux selection for the pin or the Direction."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL251" edc:nzwidth="0x20" edc:access="-------n-------nnnnnnnnnnnnnnnnn" edc:por="00000000000000001000000001000000" edc:mclr="00000000000000001000000001000000" edc:impl="0x101FFFF" edc:_addr="0x400812A4">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="PU_PD" edc:nzwidth="0x2" edc:desc="These bits are used to enable an internal pull-up or pull-down resistor.">
              <edc:SFRFieldSemantic edc:cname="NONE" edc:desc="None. Pin tristates when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="UP" edc:desc="Pull Up Enabled" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="DOWN" edc:desc="Pull Down Enabled" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="REPEATER" edc:desc="Repeater mode. Pin is kept at previous voltage level when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="PWR_GATING" edc:nzwidth="0x2" edc:desc="The GPIO pin will be tristated when the selected power well is off."/>
            <edc:SFRFieldDef edc:cname="INTR_DET" edc:nzwidth="0x3" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="EDGE_EN" edc:nzwidth="0x1" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="OUT_BUFF_TYPE" edc:nzwidth="0x1" edc:desc="0 = Push-Pull, 1 = Open Drain"/>
            <edc:SFRFieldDef edc:cname="GPIO_DIR" edc:nzwidth="0x1" edc:desc="Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output"/>
            <edc:SFRFieldDef edc:cname="GPIO_OUT_SEL" edc:nzwidth="0x1" edc:desc="GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register."/>
            <edc:SFRFieldDef edc:cname="POL" edc:nzwidth="0x1" edc:desc="1=Inverted; 0=Non-inverted"/>
            <edc:SFRFieldDef edc:cname="MUX_CTRL" edc:nzwidth="0x3" edc:desc="00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3.">
              <edc:SFRFieldSemantic edc:cname="GPIO" edc:desc="GPIO function selected" edc:when="(field &amp; 0x7) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="FUNC1" edc:desc="Signal function 1 selected" edc:when="(field &amp; 0x7) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="FUNC2" edc:desc="Signal function 2 selected" edc:when="(field &amp; 0x7) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="FUNC3" edc:desc="Signal function 3 selected" edc:when="(field &amp; 0x7) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="INP_DIS" edc:nzwidth="0x1" edc:desc="GPIO input disable"/>
            <edc:SFRFieldDef edc:cname="ALT_GPIO_DATA" edc:nzwidth="0x1" edc:desc="GPIO Alternate Data Register."/>
            <edc:AdjustPoint edc:offset="0x7"/>
            <edc:SFRFieldDef edc:cname="GPIO_INP" edc:nzwidth="0x1" edc:desc="GPIO input from pin, independent of the Mux selection for the pin or the Direction."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL252" edc:nzwidth="0x20" edc:access="-------n-------nnnnnnnnnnnnnnnnn" edc:por="00000000000000001000000001000000" edc:mclr="00000000000000001000000001000000" edc:impl="0x101FFFF" edc:_addr="0x400812A8">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="PU_PD" edc:nzwidth="0x2" edc:desc="These bits are used to enable an internal pull-up or pull-down resistor.">
              <edc:SFRFieldSemantic edc:cname="NONE" edc:desc="None. Pin tristates when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="UP" edc:desc="Pull Up Enabled" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="DOWN" edc:desc="Pull Down Enabled" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="REPEATER" edc:desc="Repeater mode. Pin is kept at previous voltage level when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="PWR_GATING" edc:nzwidth="0x2" edc:desc="The GPIO pin will be tristated when the selected power well is off."/>
            <edc:SFRFieldDef edc:cname="INTR_DET" edc:nzwidth="0x3" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="EDGE_EN" edc:nzwidth="0x1" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="OUT_BUFF_TYPE" edc:nzwidth="0x1" edc:desc="0 = Push-Pull, 1 = Open Drain"/>
            <edc:SFRFieldDef edc:cname="GPIO_DIR" edc:nzwidth="0x1" edc:desc="Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output"/>
            <edc:SFRFieldDef edc:cname="GPIO_OUT_SEL" edc:nzwidth="0x1" edc:desc="GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register."/>
            <edc:SFRFieldDef edc:cname="POL" edc:nzwidth="0x1" edc:desc="1=Inverted; 0=Non-inverted"/>
            <edc:SFRFieldDef edc:cname="MUX_CTRL" edc:nzwidth="0x3" edc:desc="00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3.">
              <edc:SFRFieldSemantic edc:cname="GPIO" edc:desc="GPIO function selected" edc:when="(field &amp; 0x7) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="FUNC1" edc:desc="Signal function 1 selected" edc:when="(field &amp; 0x7) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="FUNC2" edc:desc="Signal function 2 selected" edc:when="(field &amp; 0x7) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="FUNC3" edc:desc="Signal function 3 selected" edc:when="(field &amp; 0x7) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="INP_DIS" edc:nzwidth="0x1" edc:desc="GPIO input disable"/>
            <edc:SFRFieldDef edc:cname="ALT_GPIO_DATA" edc:nzwidth="0x1" edc:desc="GPIO Alternate Data Register."/>
            <edc:AdjustPoint edc:offset="0x7"/>
            <edc:SFRFieldDef edc:cname="GPIO_INP" edc:nzwidth="0x1" edc:desc="GPIO input from pin, independent of the Mux selection for the pin or the Direction."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL253" edc:nzwidth="0x20" edc:access="-------n-------nnnnnnnnnnnnnnnnn" edc:por="00000000000000001000000001000000" edc:mclr="00000000000000001000000001000000" edc:impl="0x101FFFF" edc:_addr="0x400812AC">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="PU_PD" edc:nzwidth="0x2" edc:desc="These bits are used to enable an internal pull-up or pull-down resistor.">
              <edc:SFRFieldSemantic edc:cname="NONE" edc:desc="None. Pin tristates when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="UP" edc:desc="Pull Up Enabled" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="DOWN" edc:desc="Pull Down Enabled" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="REPEATER" edc:desc="Repeater mode. Pin is kept at previous voltage level when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="PWR_GATING" edc:nzwidth="0x2" edc:desc="The GPIO pin will be tristated when the selected power well is off."/>
            <edc:SFRFieldDef edc:cname="INTR_DET" edc:nzwidth="0x3" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="EDGE_EN" edc:nzwidth="0x1" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="OUT_BUFF_TYPE" edc:nzwidth="0x1" edc:desc="0 = Push-Pull, 1 = Open Drain"/>
            <edc:SFRFieldDef edc:cname="GPIO_DIR" edc:nzwidth="0x1" edc:desc="Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output"/>
            <edc:SFRFieldDef edc:cname="GPIO_OUT_SEL" edc:nzwidth="0x1" edc:desc="GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register."/>
            <edc:SFRFieldDef edc:cname="POL" edc:nzwidth="0x1" edc:desc="1=Inverted; 0=Non-inverted"/>
            <edc:SFRFieldDef edc:cname="MUX_CTRL" edc:nzwidth="0x3" edc:desc="00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3.">
              <edc:SFRFieldSemantic edc:cname="GPIO" edc:desc="GPIO function selected" edc:when="(field &amp; 0x7) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="FUNC1" edc:desc="Signal function 1 selected" edc:when="(field &amp; 0x7) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="FUNC2" edc:desc="Signal function 2 selected" edc:when="(field &amp; 0x7) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="FUNC3" edc:desc="Signal function 3 selected" edc:when="(field &amp; 0x7) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="INP_DIS" edc:nzwidth="0x1" edc:desc="GPIO input disable"/>
            <edc:SFRFieldDef edc:cname="ALT_GPIO_DATA" edc:nzwidth="0x1" edc:desc="GPIO Alternate Data Register."/>
            <edc:AdjustPoint edc:offset="0x7"/>
            <edc:SFRFieldDef edc:cname="GPIO_INP" edc:nzwidth="0x1" edc:desc="GPIO input from pin, independent of the Mux selection for the pin or the Direction."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL254" edc:nzwidth="0x20" edc:access="-------n-------nnnnnnnnnnnnnnnnn" edc:por="00000000000000001000000001000000" edc:mclr="00000000000000001000000001000000" edc:impl="0x101FFFF" edc:_addr="0x400812B0">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="PU_PD" edc:nzwidth="0x2" edc:desc="These bits are used to enable an internal pull-up or pull-down resistor.">
              <edc:SFRFieldSemantic edc:cname="NONE" edc:desc="None. Pin tristates when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="UP" edc:desc="Pull Up Enabled" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="DOWN" edc:desc="Pull Down Enabled" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="REPEATER" edc:desc="Repeater mode. Pin is kept at previous voltage level when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="PWR_GATING" edc:nzwidth="0x2" edc:desc="The GPIO pin will be tristated when the selected power well is off."/>
            <edc:SFRFieldDef edc:cname="INTR_DET" edc:nzwidth="0x3" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="EDGE_EN" edc:nzwidth="0x1" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="OUT_BUFF_TYPE" edc:nzwidth="0x1" edc:desc="0 = Push-Pull, 1 = Open Drain"/>
            <edc:SFRFieldDef edc:cname="GPIO_DIR" edc:nzwidth="0x1" edc:desc="Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output"/>
            <edc:SFRFieldDef edc:cname="GPIO_OUT_SEL" edc:nzwidth="0x1" edc:desc="GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register."/>
            <edc:SFRFieldDef edc:cname="POL" edc:nzwidth="0x1" edc:desc="1=Inverted; 0=Non-inverted"/>
            <edc:SFRFieldDef edc:cname="MUX_CTRL" edc:nzwidth="0x3" edc:desc="00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3.">
              <edc:SFRFieldSemantic edc:cname="GPIO" edc:desc="GPIO function selected" edc:when="(field &amp; 0x7) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="FUNC1" edc:desc="Signal function 1 selected" edc:when="(field &amp; 0x7) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="FUNC2" edc:desc="Signal function 2 selected" edc:when="(field &amp; 0x7) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="FUNC3" edc:desc="Signal function 3 selected" edc:when="(field &amp; 0x7) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="INP_DIS" edc:nzwidth="0x1" edc:desc="GPIO input disable"/>
            <edc:SFRFieldDef edc:cname="ALT_GPIO_DATA" edc:nzwidth="0x1" edc:desc="GPIO Alternate Data Register."/>
            <edc:AdjustPoint edc:offset="0x7"/>
            <edc:SFRFieldDef edc:cname="GPIO_INP" edc:nzwidth="0x1" edc:desc="GPIO input from pin, independent of the Mux selection for the pin or the Direction."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL255" edc:nzwidth="0x20" edc:access="-------n-------nnnnnnnnnnnnnnnnn" edc:por="00000000000000001000000001000000" edc:mclr="00000000000000001000000001000000" edc:impl="0x101FFFF" edc:_addr="0x400812B4">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="PU_PD" edc:nzwidth="0x2" edc:desc="These bits are used to enable an internal pull-up or pull-down resistor.">
              <edc:SFRFieldSemantic edc:cname="NONE" edc:desc="None. Pin tristates when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="UP" edc:desc="Pull Up Enabled" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="DOWN" edc:desc="Pull Down Enabled" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="REPEATER" edc:desc="Repeater mode. Pin is kept at previous voltage level when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="PWR_GATING" edc:nzwidth="0x2" edc:desc="The GPIO pin will be tristated when the selected power well is off."/>
            <edc:SFRFieldDef edc:cname="INTR_DET" edc:nzwidth="0x3" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="EDGE_EN" edc:nzwidth="0x1" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="OUT_BUFF_TYPE" edc:nzwidth="0x1" edc:desc="0 = Push-Pull, 1 = Open Drain"/>
            <edc:SFRFieldDef edc:cname="GPIO_DIR" edc:nzwidth="0x1" edc:desc="Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output"/>
            <edc:SFRFieldDef edc:cname="GPIO_OUT_SEL" edc:nzwidth="0x1" edc:desc="GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register."/>
            <edc:SFRFieldDef edc:cname="POL" edc:nzwidth="0x1" edc:desc="1=Inverted; 0=Non-inverted"/>
            <edc:SFRFieldDef edc:cname="MUX_CTRL" edc:nzwidth="0x3" edc:desc="00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3.">
              <edc:SFRFieldSemantic edc:cname="GPIO" edc:desc="GPIO function selected" edc:when="(field &amp; 0x7) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="FUNC1" edc:desc="Signal function 1 selected" edc:when="(field &amp; 0x7) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="FUNC2" edc:desc="Signal function 2 selected" edc:when="(field &amp; 0x7) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="FUNC3" edc:desc="Signal function 3 selected" edc:when="(field &amp; 0x7) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="INP_DIS" edc:nzwidth="0x1" edc:desc="GPIO input disable"/>
            <edc:SFRFieldDef edc:cname="ALT_GPIO_DATA" edc:nzwidth="0x1" edc:desc="GPIO Alternate Data Register."/>
            <edc:AdjustPoint edc:offset="0x7"/>
            <edc:SFRFieldDef edc:cname="GPIO_INP" edc:nzwidth="0x1" edc:desc="GPIO input from pin, independent of the Mux selection for the pin or the Direction."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL256" edc:nzwidth="0x20" edc:access="-------n-------nnnnnnnnnnnnnnnnn" edc:por="00000000000000001000000001000000" edc:mclr="00000000000000001000000001000000" edc:impl="0x101FFFF" edc:_addr="0x400812B8">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="PU_PD" edc:nzwidth="0x2" edc:desc="These bits are used to enable an internal pull-up or pull-down resistor.">
              <edc:SFRFieldSemantic edc:cname="NONE" edc:desc="None. Pin tristates when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="UP" edc:desc="Pull Up Enabled" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="DOWN" edc:desc="Pull Down Enabled" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="REPEATER" edc:desc="Repeater mode. Pin is kept at previous voltage level when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="PWR_GATING" edc:nzwidth="0x2" edc:desc="The GPIO pin will be tristated when the selected power well is off."/>
            <edc:SFRFieldDef edc:cname="INTR_DET" edc:nzwidth="0x3" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="EDGE_EN" edc:nzwidth="0x1" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="OUT_BUFF_TYPE" edc:nzwidth="0x1" edc:desc="0 = Push-Pull, 1 = Open Drain"/>
            <edc:SFRFieldDef edc:cname="GPIO_DIR" edc:nzwidth="0x1" edc:desc="Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output"/>
            <edc:SFRFieldDef edc:cname="GPIO_OUT_SEL" edc:nzwidth="0x1" edc:desc="GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register."/>
            <edc:SFRFieldDef edc:cname="POL" edc:nzwidth="0x1" edc:desc="1=Inverted; 0=Non-inverted"/>
            <edc:SFRFieldDef edc:cname="MUX_CTRL" edc:nzwidth="0x3" edc:desc="00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3.">
              <edc:SFRFieldSemantic edc:cname="GPIO" edc:desc="GPIO function selected" edc:when="(field &amp; 0x7) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="FUNC1" edc:desc="Signal function 1 selected" edc:when="(field &amp; 0x7) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="FUNC2" edc:desc="Signal function 2 selected" edc:when="(field &amp; 0x7) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="FUNC3" edc:desc="Signal function 3 selected" edc:when="(field &amp; 0x7) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="INP_DIS" edc:nzwidth="0x1" edc:desc="GPIO input disable"/>
            <edc:SFRFieldDef edc:cname="ALT_GPIO_DATA" edc:nzwidth="0x1" edc:desc="GPIO Alternate Data Register."/>
            <edc:AdjustPoint edc:offset="0x7"/>
            <edc:SFRFieldDef edc:cname="GPIO_INP" edc:nzwidth="0x1" edc:desc="GPIO input from pin, independent of the Mux selection for the pin or the Direction."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL257" edc:nzwidth="0x20" edc:access="-------n-------nnnnnnnnnnnnnnnnn" edc:por="00000000000000001000000001000000" edc:mclr="00000000000000001000000001000000" edc:impl="0x101FFFF" edc:_addr="0x400812BC">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="PU_PD" edc:nzwidth="0x2" edc:desc="These bits are used to enable an internal pull-up or pull-down resistor.">
              <edc:SFRFieldSemantic edc:cname="NONE" edc:desc="None. Pin tristates when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="UP" edc:desc="Pull Up Enabled" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="DOWN" edc:desc="Pull Down Enabled" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="REPEATER" edc:desc="Repeater mode. Pin is kept at previous voltage level when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="PWR_GATING" edc:nzwidth="0x2" edc:desc="The GPIO pin will be tristated when the selected power well is off."/>
            <edc:SFRFieldDef edc:cname="INTR_DET" edc:nzwidth="0x3" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="EDGE_EN" edc:nzwidth="0x1" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="OUT_BUFF_TYPE" edc:nzwidth="0x1" edc:desc="0 = Push-Pull, 1 = Open Drain"/>
            <edc:SFRFieldDef edc:cname="GPIO_DIR" edc:nzwidth="0x1" edc:desc="Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output"/>
            <edc:SFRFieldDef edc:cname="GPIO_OUT_SEL" edc:nzwidth="0x1" edc:desc="GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register."/>
            <edc:SFRFieldDef edc:cname="POL" edc:nzwidth="0x1" edc:desc="1=Inverted; 0=Non-inverted"/>
            <edc:SFRFieldDef edc:cname="MUX_CTRL" edc:nzwidth="0x3" edc:desc="00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3.">
              <edc:SFRFieldSemantic edc:cname="GPIO" edc:desc="GPIO function selected" edc:when="(field &amp; 0x7) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="FUNC1" edc:desc="Signal function 1 selected" edc:when="(field &amp; 0x7) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="FUNC2" edc:desc="Signal function 2 selected" edc:when="(field &amp; 0x7) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="FUNC3" edc:desc="Signal function 3 selected" edc:when="(field &amp; 0x7) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="INP_DIS" edc:nzwidth="0x1" edc:desc="GPIO input disable"/>
            <edc:SFRFieldDef edc:cname="ALT_GPIO_DATA" edc:nzwidth="0x1" edc:desc="GPIO Alternate Data Register."/>
            <edc:AdjustPoint edc:offset="0x7"/>
            <edc:SFRFieldDef edc:cname="GPIO_INP" edc:nzwidth="0x1" edc:desc="GPIO input from pin, independent of the Mux selection for the pin or the Direction."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL260" edc:nzwidth="0x20" edc:access="-------n-------nnnnnnnnnnnnnnnnn" edc:por="00000000000000001000000001000000" edc:mclr="00000000000000001000000001000000" edc:impl="0x101FFFF" edc:_addr="0x400812C0">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="PU_PD" edc:nzwidth="0x2" edc:desc="These bits are used to enable an internal pull-up or pull-down resistor.">
              <edc:SFRFieldSemantic edc:cname="NONE" edc:desc="None. Pin tristates when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="UP" edc:desc="Pull Up Enabled" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="DOWN" edc:desc="Pull Down Enabled" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="REPEATER" edc:desc="Repeater mode. Pin is kept at previous voltage level when no active driver is present on the pin." edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="PWR_GATING" edc:nzwidth="0x2" edc:desc="The GPIO pin will be tristated when the selected power well is off."/>
            <edc:SFRFieldDef edc:cname="INTR_DET" edc:nzwidth="0x3" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="EDGE_EN" edc:nzwidth="0x1" edc:desc="Determines the interrupt capability of the GPIO input."/>
            <edc:SFRFieldDef edc:cname="OUT_BUFF_TYPE" edc:nzwidth="0x1" edc:desc="0 = Push-Pull, 1 = Open Drain"/>
            <edc:SFRFieldDef edc:cname="GPIO_DIR" edc:nzwidth="0x1" edc:desc="Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output"/>
            <edc:SFRFieldDef edc:cname="GPIO_OUT_SEL" edc:nzwidth="0x1" edc:desc="GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register."/>
            <edc:SFRFieldDef edc:cname="POL" edc:nzwidth="0x1" edc:desc="1=Inverted; 0=Non-inverted"/>
            <edc:SFRFieldDef edc:cname="MUX_CTRL" edc:nzwidth="0x3" edc:desc="00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3.">
              <edc:SFRFieldSemantic edc:cname="GPIO" edc:desc="GPIO function selected" edc:when="(field &amp; 0x7) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="FUNC1" edc:desc="Signal function 1 selected" edc:when="(field &amp; 0x7) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="FUNC2" edc:desc="Signal function 2 selected" edc:when="(field &amp; 0x7) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="FUNC3" edc:desc="Signal function 3 selected" edc:when="(field &amp; 0x7) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="INP_DIS" edc:nzwidth="0x1" edc:desc="GPIO input disable"/>
            <edc:SFRFieldDef edc:cname="ALT_GPIO_DATA" edc:nzwidth="0x1" edc:desc="GPIO Alternate Data Register."/>
            <edc:AdjustPoint edc:offset="0x7"/>
            <edc:SFRFieldDef edc:cname="GPIO_INP" edc:nzwidth="0x1" edc:desc="GPIO input from pin, independent of the Mux selection for the pin or the Direction."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:AdjustPoint edc:offset="0x3C" edc:_addr="0x400812C4"/>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="PARIN0" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x40081300"/>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="PARIN1" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x40081304"/>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="PARIN2" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x40081308"/>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="PARIN3" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x4008130C"/>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="PARIN4" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x40081310"/>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="PARIN5" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x40081314"/>
      <edc:AdjustPoint edc:offset="0x68" edc:_addr="0x40081318"/>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="PAROUT0" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x40081380"/>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="PAROUT1" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x40081384"/>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="PAROUT2" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x40081388"/>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="PAROUT3" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x4008138C"/>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="PAROUT4" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x40081390"/>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="PAROUT5" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x40081394"/>
      <edc:AdjustPoint edc:offset="0x168" edc:_addr="0x40081398"/>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL2P00" edc:nzwidth="0x20" edc:access="--------------------------nn---n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x31" edc:_addr="0x40081500">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="SLEW_CTRL" edc:nzwidth="0x1" edc:desc="Selects slew rate on the pin. 1=fast 0=slow"/>
            <edc:AdjustPoint edc:offset="0x3"/>
            <edc:SFRFieldDef edc:cname="DRIV_STREN" edc:nzwidth="0x2" edc:desc="Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA">
              <edc:SFRFieldSemantic edc:cname="LEVEL0" edc:desc="For PIO12 = 2mA, PIO24 = 4mA" edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL1" edc:desc="For PIO12 = 4mA, PIO24 = 8mA" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL2" edc:desc="For PIO12 = 8mA, PIO24 = 16mA" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL3" edc:desc="For PIO12 = 12mA, PIO24 = 24mA" edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL2P01" edc:nzwidth="0x20" edc:access="--------------------------nn---n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x31" edc:_addr="0x40081504">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="SLEW_CTRL" edc:nzwidth="0x1" edc:desc="Selects slew rate on the pin. 1=fast 0=slow"/>
            <edc:AdjustPoint edc:offset="0x3"/>
            <edc:SFRFieldDef edc:cname="DRIV_STREN" edc:nzwidth="0x2" edc:desc="Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA">
              <edc:SFRFieldSemantic edc:cname="LEVEL0" edc:desc="For PIO12 = 2mA, PIO24 = 4mA" edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL1" edc:desc="For PIO12 = 4mA, PIO24 = 8mA" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL2" edc:desc="For PIO12 = 8mA, PIO24 = 16mA" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL3" edc:desc="For PIO12 = 12mA, PIO24 = 24mA" edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL2P02" edc:nzwidth="0x20" edc:access="--------------------------nn---n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x31" edc:_addr="0x40081508">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="SLEW_CTRL" edc:nzwidth="0x1" edc:desc="Selects slew rate on the pin. 1=fast 0=slow"/>
            <edc:AdjustPoint edc:offset="0x3"/>
            <edc:SFRFieldDef edc:cname="DRIV_STREN" edc:nzwidth="0x2" edc:desc="Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA">
              <edc:SFRFieldSemantic edc:cname="LEVEL0" edc:desc="For PIO12 = 2mA, PIO24 = 4mA" edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL1" edc:desc="For PIO12 = 4mA, PIO24 = 8mA" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL2" edc:desc="For PIO12 = 8mA, PIO24 = 16mA" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL3" edc:desc="For PIO12 = 12mA, PIO24 = 24mA" edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL2P03" edc:nzwidth="0x20" edc:access="--------------------------nn---n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x31" edc:_addr="0x4008150C">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="SLEW_CTRL" edc:nzwidth="0x1" edc:desc="Selects slew rate on the pin. 1=fast 0=slow"/>
            <edc:AdjustPoint edc:offset="0x3"/>
            <edc:SFRFieldDef edc:cname="DRIV_STREN" edc:nzwidth="0x2" edc:desc="Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA">
              <edc:SFRFieldSemantic edc:cname="LEVEL0" edc:desc="For PIO12 = 2mA, PIO24 = 4mA" edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL1" edc:desc="For PIO12 = 4mA, PIO24 = 8mA" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL2" edc:desc="For PIO12 = 8mA, PIO24 = 16mA" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL3" edc:desc="For PIO12 = 12mA, PIO24 = 24mA" edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL2P04" edc:nzwidth="0x20" edc:access="--------------------------nn---n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x31" edc:_addr="0x40081510">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="SLEW_CTRL" edc:nzwidth="0x1" edc:desc="Selects slew rate on the pin. 1=fast 0=slow"/>
            <edc:AdjustPoint edc:offset="0x3"/>
            <edc:SFRFieldDef edc:cname="DRIV_STREN" edc:nzwidth="0x2" edc:desc="Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA">
              <edc:SFRFieldSemantic edc:cname="LEVEL0" edc:desc="For PIO12 = 2mA, PIO24 = 4mA" edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL1" edc:desc="For PIO12 = 4mA, PIO24 = 8mA" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL2" edc:desc="For PIO12 = 8mA, PIO24 = 16mA" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL3" edc:desc="For PIO12 = 12mA, PIO24 = 24mA" edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL2P05" edc:nzwidth="0x20" edc:access="--------------------------nn---n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x31" edc:_addr="0x40081514">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="SLEW_CTRL" edc:nzwidth="0x1" edc:desc="Selects slew rate on the pin. 1=fast 0=slow"/>
            <edc:AdjustPoint edc:offset="0x3"/>
            <edc:SFRFieldDef edc:cname="DRIV_STREN" edc:nzwidth="0x2" edc:desc="Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA">
              <edc:SFRFieldSemantic edc:cname="LEVEL0" edc:desc="For PIO12 = 2mA, PIO24 = 4mA" edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL1" edc:desc="For PIO12 = 4mA, PIO24 = 8mA" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL2" edc:desc="For PIO12 = 8mA, PIO24 = 16mA" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL3" edc:desc="For PIO12 = 12mA, PIO24 = 24mA" edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL2P06" edc:nzwidth="0x20" edc:access="--------------------------nn---n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x31" edc:_addr="0x40081518">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="SLEW_CTRL" edc:nzwidth="0x1" edc:desc="Selects slew rate on the pin. 1=fast 0=slow"/>
            <edc:AdjustPoint edc:offset="0x3"/>
            <edc:SFRFieldDef edc:cname="DRIV_STREN" edc:nzwidth="0x2" edc:desc="Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA">
              <edc:SFRFieldSemantic edc:cname="LEVEL0" edc:desc="For PIO12 = 2mA, PIO24 = 4mA" edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL1" edc:desc="For PIO12 = 4mA, PIO24 = 8mA" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL2" edc:desc="For PIO12 = 8mA, PIO24 = 16mA" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL3" edc:desc="For PIO12 = 12mA, PIO24 = 24mA" edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL2P07" edc:nzwidth="0x20" edc:access="--------------------------nn---n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x31" edc:_addr="0x4008151C">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="SLEW_CTRL" edc:nzwidth="0x1" edc:desc="Selects slew rate on the pin. 1=fast 0=slow"/>
            <edc:AdjustPoint edc:offset="0x3"/>
            <edc:SFRFieldDef edc:cname="DRIV_STREN" edc:nzwidth="0x2" edc:desc="Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA">
              <edc:SFRFieldSemantic edc:cname="LEVEL0" edc:desc="For PIO12 = 2mA, PIO24 = 4mA" edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL1" edc:desc="For PIO12 = 4mA, PIO24 = 8mA" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL2" edc:desc="For PIO12 = 8mA, PIO24 = 16mA" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL3" edc:desc="For PIO12 = 12mA, PIO24 = 24mA" edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL2P10" edc:nzwidth="0x20" edc:access="--------------------------nn---n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x31" edc:_addr="0x40081520">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="SLEW_CTRL" edc:nzwidth="0x1" edc:desc="Selects slew rate on the pin. 1=fast 0=slow"/>
            <edc:AdjustPoint edc:offset="0x3"/>
            <edc:SFRFieldDef edc:cname="DRIV_STREN" edc:nzwidth="0x2" edc:desc="Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA">
              <edc:SFRFieldSemantic edc:cname="LEVEL0" edc:desc="For PIO12 = 2mA, PIO24 = 4mA" edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL1" edc:desc="For PIO12 = 4mA, PIO24 = 8mA" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL2" edc:desc="For PIO12 = 8mA, PIO24 = 16mA" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL3" edc:desc="For PIO12 = 12mA, PIO24 = 24mA" edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL2P11" edc:nzwidth="0x20" edc:access="--------------------------nn---n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x31" edc:_addr="0x40081524">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="SLEW_CTRL" edc:nzwidth="0x1" edc:desc="Selects slew rate on the pin. 1=fast 0=slow"/>
            <edc:AdjustPoint edc:offset="0x3"/>
            <edc:SFRFieldDef edc:cname="DRIV_STREN" edc:nzwidth="0x2" edc:desc="Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA">
              <edc:SFRFieldSemantic edc:cname="LEVEL0" edc:desc="For PIO12 = 2mA, PIO24 = 4mA" edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL1" edc:desc="For PIO12 = 4mA, PIO24 = 8mA" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL2" edc:desc="For PIO12 = 8mA, PIO24 = 16mA" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL3" edc:desc="For PIO12 = 12mA, PIO24 = 24mA" edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL2P12" edc:nzwidth="0x20" edc:access="--------------------------nn---n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x31" edc:_addr="0x40081528">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="SLEW_CTRL" edc:nzwidth="0x1" edc:desc="Selects slew rate on the pin. 1=fast 0=slow"/>
            <edc:AdjustPoint edc:offset="0x3"/>
            <edc:SFRFieldDef edc:cname="DRIV_STREN" edc:nzwidth="0x2" edc:desc="Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA">
              <edc:SFRFieldSemantic edc:cname="LEVEL0" edc:desc="For PIO12 = 2mA, PIO24 = 4mA" edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL1" edc:desc="For PIO12 = 4mA, PIO24 = 8mA" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL2" edc:desc="For PIO12 = 8mA, PIO24 = 16mA" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL3" edc:desc="For PIO12 = 12mA, PIO24 = 24mA" edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL2P13" edc:nzwidth="0x20" edc:access="--------------------------nn---n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x31" edc:_addr="0x4008152C">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="SLEW_CTRL" edc:nzwidth="0x1" edc:desc="Selects slew rate on the pin. 1=fast 0=slow"/>
            <edc:AdjustPoint edc:offset="0x3"/>
            <edc:SFRFieldDef edc:cname="DRIV_STREN" edc:nzwidth="0x2" edc:desc="Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA">
              <edc:SFRFieldSemantic edc:cname="LEVEL0" edc:desc="For PIO12 = 2mA, PIO24 = 4mA" edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL1" edc:desc="For PIO12 = 4mA, PIO24 = 8mA" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL2" edc:desc="For PIO12 = 8mA, PIO24 = 16mA" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL3" edc:desc="For PIO12 = 12mA, PIO24 = 24mA" edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL2P14" edc:nzwidth="0x20" edc:access="--------------------------nn---n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x31" edc:_addr="0x40081530">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="SLEW_CTRL" edc:nzwidth="0x1" edc:desc="Selects slew rate on the pin. 1=fast 0=slow"/>
            <edc:AdjustPoint edc:offset="0x3"/>
            <edc:SFRFieldDef edc:cname="DRIV_STREN" edc:nzwidth="0x2" edc:desc="Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA">
              <edc:SFRFieldSemantic edc:cname="LEVEL0" edc:desc="For PIO12 = 2mA, PIO24 = 4mA" edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL1" edc:desc="For PIO12 = 4mA, PIO24 = 8mA" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL2" edc:desc="For PIO12 = 8mA, PIO24 = 16mA" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL3" edc:desc="For PIO12 = 12mA, PIO24 = 24mA" edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL2P15" edc:nzwidth="0x20" edc:access="--------------------------nn---n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x31" edc:_addr="0x40081534">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="SLEW_CTRL" edc:nzwidth="0x1" edc:desc="Selects slew rate on the pin. 1=fast 0=slow"/>
            <edc:AdjustPoint edc:offset="0x3"/>
            <edc:SFRFieldDef edc:cname="DRIV_STREN" edc:nzwidth="0x2" edc:desc="Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA">
              <edc:SFRFieldSemantic edc:cname="LEVEL0" edc:desc="For PIO12 = 2mA, PIO24 = 4mA" edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL1" edc:desc="For PIO12 = 4mA, PIO24 = 8mA" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL2" edc:desc="For PIO12 = 8mA, PIO24 = 16mA" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL3" edc:desc="For PIO12 = 12mA, PIO24 = 24mA" edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL2P16" edc:nzwidth="0x20" edc:access="--------------------------nn---n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x31" edc:_addr="0x40081538">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="SLEW_CTRL" edc:nzwidth="0x1" edc:desc="Selects slew rate on the pin. 1=fast 0=slow"/>
            <edc:AdjustPoint edc:offset="0x3"/>
            <edc:SFRFieldDef edc:cname="DRIV_STREN" edc:nzwidth="0x2" edc:desc="Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA">
              <edc:SFRFieldSemantic edc:cname="LEVEL0" edc:desc="For PIO12 = 2mA, PIO24 = 4mA" edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL1" edc:desc="For PIO12 = 4mA, PIO24 = 8mA" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL2" edc:desc="For PIO12 = 8mA, PIO24 = 16mA" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL3" edc:desc="For PIO12 = 12mA, PIO24 = 24mA" edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL2P17" edc:nzwidth="0x20" edc:access="--------------------------nn---n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x31" edc:_addr="0x4008153C">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="SLEW_CTRL" edc:nzwidth="0x1" edc:desc="Selects slew rate on the pin. 1=fast 0=slow"/>
            <edc:AdjustPoint edc:offset="0x3"/>
            <edc:SFRFieldDef edc:cname="DRIV_STREN" edc:nzwidth="0x2" edc:desc="Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA">
              <edc:SFRFieldSemantic edc:cname="LEVEL0" edc:desc="For PIO12 = 2mA, PIO24 = 4mA" edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL1" edc:desc="For PIO12 = 4mA, PIO24 = 8mA" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL2" edc:desc="For PIO12 = 8mA, PIO24 = 16mA" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL3" edc:desc="For PIO12 = 12mA, PIO24 = 24mA" edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL2P20" edc:nzwidth="0x20" edc:access="--------------------------nn---n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x31" edc:_addr="0x40081540">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="SLEW_CTRL" edc:nzwidth="0x1" edc:desc="Selects slew rate on the pin. 1=fast 0=slow"/>
            <edc:AdjustPoint edc:offset="0x3"/>
            <edc:SFRFieldDef edc:cname="DRIV_STREN" edc:nzwidth="0x2" edc:desc="Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA">
              <edc:SFRFieldSemantic edc:cname="LEVEL0" edc:desc="For PIO12 = 2mA, PIO24 = 4mA" edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL1" edc:desc="For PIO12 = 4mA, PIO24 = 8mA" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL2" edc:desc="For PIO12 = 8mA, PIO24 = 16mA" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL3" edc:desc="For PIO12 = 12mA, PIO24 = 24mA" edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL2P21" edc:nzwidth="0x20" edc:access="--------------------------nn---n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x31" edc:_addr="0x40081544">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="SLEW_CTRL" edc:nzwidth="0x1" edc:desc="Selects slew rate on the pin. 1=fast 0=slow"/>
            <edc:AdjustPoint edc:offset="0x3"/>
            <edc:SFRFieldDef edc:cname="DRIV_STREN" edc:nzwidth="0x2" edc:desc="Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA">
              <edc:SFRFieldSemantic edc:cname="LEVEL0" edc:desc="For PIO12 = 2mA, PIO24 = 4mA" edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL1" edc:desc="For PIO12 = 4mA, PIO24 = 8mA" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL2" edc:desc="For PIO12 = 8mA, PIO24 = 16mA" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL3" edc:desc="For PIO12 = 12mA, PIO24 = 24mA" edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL2P22" edc:nzwidth="0x20" edc:access="--------------------------nn---n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x31" edc:_addr="0x40081548">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="SLEW_CTRL" edc:nzwidth="0x1" edc:desc="Selects slew rate on the pin. 1=fast 0=slow"/>
            <edc:AdjustPoint edc:offset="0x3"/>
            <edc:SFRFieldDef edc:cname="DRIV_STREN" edc:nzwidth="0x2" edc:desc="Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA">
              <edc:SFRFieldSemantic edc:cname="LEVEL0" edc:desc="For PIO12 = 2mA, PIO24 = 4mA" edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL1" edc:desc="For PIO12 = 4mA, PIO24 = 8mA" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL2" edc:desc="For PIO12 = 8mA, PIO24 = 16mA" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL3" edc:desc="For PIO12 = 12mA, PIO24 = 24mA" edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL2P23" edc:nzwidth="0x20" edc:access="--------------------------nn---n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x31" edc:_addr="0x4008154C">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="SLEW_CTRL" edc:nzwidth="0x1" edc:desc="Selects slew rate on the pin. 1=fast 0=slow"/>
            <edc:AdjustPoint edc:offset="0x3"/>
            <edc:SFRFieldDef edc:cname="DRIV_STREN" edc:nzwidth="0x2" edc:desc="Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA">
              <edc:SFRFieldSemantic edc:cname="LEVEL0" edc:desc="For PIO12 = 2mA, PIO24 = 4mA" edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL1" edc:desc="For PIO12 = 4mA, PIO24 = 8mA" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL2" edc:desc="For PIO12 = 8mA, PIO24 = 16mA" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL3" edc:desc="For PIO12 = 12mA, PIO24 = 24mA" edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL2P24" edc:nzwidth="0x20" edc:access="--------------------------nn---n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x31" edc:_addr="0x40081550">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="SLEW_CTRL" edc:nzwidth="0x1" edc:desc="Selects slew rate on the pin. 1=fast 0=slow"/>
            <edc:AdjustPoint edc:offset="0x3"/>
            <edc:SFRFieldDef edc:cname="DRIV_STREN" edc:nzwidth="0x2" edc:desc="Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA">
              <edc:SFRFieldSemantic edc:cname="LEVEL0" edc:desc="For PIO12 = 2mA, PIO24 = 4mA" edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL1" edc:desc="For PIO12 = 4mA, PIO24 = 8mA" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL2" edc:desc="For PIO12 = 8mA, PIO24 = 16mA" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL3" edc:desc="For PIO12 = 12mA, PIO24 = 24mA" edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL2P25" edc:nzwidth="0x20" edc:access="--------------------------nn---n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x31" edc:_addr="0x40081554">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="SLEW_CTRL" edc:nzwidth="0x1" edc:desc="Selects slew rate on the pin. 1=fast 0=slow"/>
            <edc:AdjustPoint edc:offset="0x3"/>
            <edc:SFRFieldDef edc:cname="DRIV_STREN" edc:nzwidth="0x2" edc:desc="Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA">
              <edc:SFRFieldSemantic edc:cname="LEVEL0" edc:desc="For PIO12 = 2mA, PIO24 = 4mA" edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL1" edc:desc="For PIO12 = 4mA, PIO24 = 8mA" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL2" edc:desc="For PIO12 = 8mA, PIO24 = 16mA" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL3" edc:desc="For PIO12 = 12mA, PIO24 = 24mA" edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL2P26" edc:nzwidth="0x20" edc:access="--------------------------nn---n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x31" edc:_addr="0x40081558">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="SLEW_CTRL" edc:nzwidth="0x1" edc:desc="Selects slew rate on the pin. 1=fast 0=slow"/>
            <edc:AdjustPoint edc:offset="0x3"/>
            <edc:SFRFieldDef edc:cname="DRIV_STREN" edc:nzwidth="0x2" edc:desc="Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA">
              <edc:SFRFieldSemantic edc:cname="LEVEL0" edc:desc="For PIO12 = 2mA, PIO24 = 4mA" edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL1" edc:desc="For PIO12 = 4mA, PIO24 = 8mA" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL2" edc:desc="For PIO12 = 8mA, PIO24 = 16mA" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL3" edc:desc="For PIO12 = 12mA, PIO24 = 24mA" edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL2P27" edc:nzwidth="0x20" edc:access="--------------------------nn---n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x31" edc:_addr="0x4008155C">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="SLEW_CTRL" edc:nzwidth="0x1" edc:desc="Selects slew rate on the pin. 1=fast 0=slow"/>
            <edc:AdjustPoint edc:offset="0x3"/>
            <edc:SFRFieldDef edc:cname="DRIV_STREN" edc:nzwidth="0x2" edc:desc="Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA">
              <edc:SFRFieldSemantic edc:cname="LEVEL0" edc:desc="For PIO12 = 2mA, PIO24 = 4mA" edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL1" edc:desc="For PIO12 = 4mA, PIO24 = 8mA" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL2" edc:desc="For PIO12 = 8mA, PIO24 = 16mA" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL3" edc:desc="For PIO12 = 12mA, PIO24 = 24mA" edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL2P30" edc:nzwidth="0x20" edc:access="--------------------------nn---n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x31" edc:_addr="0x40081560">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="SLEW_CTRL" edc:nzwidth="0x1" edc:desc="Selects slew rate on the pin. 1=fast 0=slow"/>
            <edc:AdjustPoint edc:offset="0x3"/>
            <edc:SFRFieldDef edc:cname="DRIV_STREN" edc:nzwidth="0x2" edc:desc="Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA">
              <edc:SFRFieldSemantic edc:cname="LEVEL0" edc:desc="For PIO12 = 2mA, PIO24 = 4mA" edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL1" edc:desc="For PIO12 = 4mA, PIO24 = 8mA" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL2" edc:desc="For PIO12 = 8mA, PIO24 = 16mA" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL3" edc:desc="For PIO12 = 12mA, PIO24 = 24mA" edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL2P31" edc:nzwidth="0x20" edc:access="--------------------------nn---n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x31" edc:_addr="0x40081564">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="SLEW_CTRL" edc:nzwidth="0x1" edc:desc="Selects slew rate on the pin. 1=fast 0=slow"/>
            <edc:AdjustPoint edc:offset="0x3"/>
            <edc:SFRFieldDef edc:cname="DRIV_STREN" edc:nzwidth="0x2" edc:desc="Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA">
              <edc:SFRFieldSemantic edc:cname="LEVEL0" edc:desc="For PIO12 = 2mA, PIO24 = 4mA" edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL1" edc:desc="For PIO12 = 4mA, PIO24 = 8mA" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL2" edc:desc="For PIO12 = 8mA, PIO24 = 16mA" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL3" edc:desc="For PIO12 = 12mA, PIO24 = 24mA" edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL2P32" edc:nzwidth="0x20" edc:access="--------------------------nn---n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x31" edc:_addr="0x40081568">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="SLEW_CTRL" edc:nzwidth="0x1" edc:desc="Selects slew rate on the pin. 1=fast 0=slow"/>
            <edc:AdjustPoint edc:offset="0x3"/>
            <edc:SFRFieldDef edc:cname="DRIV_STREN" edc:nzwidth="0x2" edc:desc="Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA">
              <edc:SFRFieldSemantic edc:cname="LEVEL0" edc:desc="For PIO12 = 2mA, PIO24 = 4mA" edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL1" edc:desc="For PIO12 = 4mA, PIO24 = 8mA" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL2" edc:desc="For PIO12 = 8mA, PIO24 = 16mA" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL3" edc:desc="For PIO12 = 12mA, PIO24 = 24mA" edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL2P33" edc:nzwidth="0x20" edc:access="--------------------------nn---n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x31" edc:_addr="0x4008156C">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="SLEW_CTRL" edc:nzwidth="0x1" edc:desc="Selects slew rate on the pin. 1=fast 0=slow"/>
            <edc:AdjustPoint edc:offset="0x3"/>
            <edc:SFRFieldDef edc:cname="DRIV_STREN" edc:nzwidth="0x2" edc:desc="Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA">
              <edc:SFRFieldSemantic edc:cname="LEVEL0" edc:desc="For PIO12 = 2mA, PIO24 = 4mA" edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL1" edc:desc="For PIO12 = 4mA, PIO24 = 8mA" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL2" edc:desc="For PIO12 = 8mA, PIO24 = 16mA" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL3" edc:desc="For PIO12 = 12mA, PIO24 = 24mA" edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL2P34" edc:nzwidth="0x20" edc:access="--------------------------nn---n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x31" edc:_addr="0x40081570">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="SLEW_CTRL" edc:nzwidth="0x1" edc:desc="Selects slew rate on the pin. 1=fast 0=slow"/>
            <edc:AdjustPoint edc:offset="0x3"/>
            <edc:SFRFieldDef edc:cname="DRIV_STREN" edc:nzwidth="0x2" edc:desc="Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA">
              <edc:SFRFieldSemantic edc:cname="LEVEL0" edc:desc="For PIO12 = 2mA, PIO24 = 4mA" edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL1" edc:desc="For PIO12 = 4mA, PIO24 = 8mA" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL2" edc:desc="For PIO12 = 8mA, PIO24 = 16mA" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL3" edc:desc="For PIO12 = 12mA, PIO24 = 24mA" edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL2P35" edc:nzwidth="0x20" edc:access="--------------------------nn---n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x31" edc:_addr="0x40081574">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="SLEW_CTRL" edc:nzwidth="0x1" edc:desc="Selects slew rate on the pin. 1=fast 0=slow"/>
            <edc:AdjustPoint edc:offset="0x3"/>
            <edc:SFRFieldDef edc:cname="DRIV_STREN" edc:nzwidth="0x2" edc:desc="Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA">
              <edc:SFRFieldSemantic edc:cname="LEVEL0" edc:desc="For PIO12 = 2mA, PIO24 = 4mA" edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL1" edc:desc="For PIO12 = 4mA, PIO24 = 8mA" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL2" edc:desc="For PIO12 = 8mA, PIO24 = 16mA" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL3" edc:desc="For PIO12 = 12mA, PIO24 = 24mA" edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL2P36" edc:nzwidth="0x20" edc:access="--------------------------nn---n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x31" edc:_addr="0x40081578">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="SLEW_CTRL" edc:nzwidth="0x1" edc:desc="Selects slew rate on the pin. 1=fast 0=slow"/>
            <edc:AdjustPoint edc:offset="0x3"/>
            <edc:SFRFieldDef edc:cname="DRIV_STREN" edc:nzwidth="0x2" edc:desc="Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA">
              <edc:SFRFieldSemantic edc:cname="LEVEL0" edc:desc="For PIO12 = 2mA, PIO24 = 4mA" edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL1" edc:desc="For PIO12 = 4mA, PIO24 = 8mA" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL2" edc:desc="For PIO12 = 8mA, PIO24 = 16mA" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL3" edc:desc="For PIO12 = 12mA, PIO24 = 24mA" edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL2P37" edc:nzwidth="0x20" edc:access="--------------------------nn---n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x31" edc:_addr="0x4008157C">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="SLEW_CTRL" edc:nzwidth="0x1" edc:desc="Selects slew rate on the pin. 1=fast 0=slow"/>
            <edc:AdjustPoint edc:offset="0x3"/>
            <edc:SFRFieldDef edc:cname="DRIV_STREN" edc:nzwidth="0x2" edc:desc="Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA">
              <edc:SFRFieldSemantic edc:cname="LEVEL0" edc:desc="For PIO12 = 2mA, PIO24 = 4mA" edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL1" edc:desc="For PIO12 = 4mA, PIO24 = 8mA" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL2" edc:desc="For PIO12 = 8mA, PIO24 = 16mA" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL3" edc:desc="For PIO12 = 12mA, PIO24 = 24mA" edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL2P40" edc:nzwidth="0x20" edc:access="--------------------------nn---n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x31" edc:_addr="0x40081580">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="SLEW_CTRL" edc:nzwidth="0x1" edc:desc="Selects slew rate on the pin. 1=fast 0=slow"/>
            <edc:AdjustPoint edc:offset="0x3"/>
            <edc:SFRFieldDef edc:cname="DRIV_STREN" edc:nzwidth="0x2" edc:desc="Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA">
              <edc:SFRFieldSemantic edc:cname="LEVEL0" edc:desc="For PIO12 = 2mA, PIO24 = 4mA" edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL1" edc:desc="For PIO12 = 4mA, PIO24 = 8mA" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL2" edc:desc="For PIO12 = 8mA, PIO24 = 16mA" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL3" edc:desc="For PIO12 = 12mA, PIO24 = 24mA" edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL2P41" edc:nzwidth="0x20" edc:access="--------------------------nn---n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x31" edc:_addr="0x40081584">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="SLEW_CTRL" edc:nzwidth="0x1" edc:desc="Selects slew rate on the pin. 1=fast 0=slow"/>
            <edc:AdjustPoint edc:offset="0x3"/>
            <edc:SFRFieldDef edc:cname="DRIV_STREN" edc:nzwidth="0x2" edc:desc="Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA">
              <edc:SFRFieldSemantic edc:cname="LEVEL0" edc:desc="For PIO12 = 2mA, PIO24 = 4mA" edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL1" edc:desc="For PIO12 = 4mA, PIO24 = 8mA" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL2" edc:desc="For PIO12 = 8mA, PIO24 = 16mA" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL3" edc:desc="For PIO12 = 12mA, PIO24 = 24mA" edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL2P42" edc:nzwidth="0x20" edc:access="--------------------------nn---n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x31" edc:_addr="0x40081588">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="SLEW_CTRL" edc:nzwidth="0x1" edc:desc="Selects slew rate on the pin. 1=fast 0=slow"/>
            <edc:AdjustPoint edc:offset="0x3"/>
            <edc:SFRFieldDef edc:cname="DRIV_STREN" edc:nzwidth="0x2" edc:desc="Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA">
              <edc:SFRFieldSemantic edc:cname="LEVEL0" edc:desc="For PIO12 = 2mA, PIO24 = 4mA" edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL1" edc:desc="For PIO12 = 4mA, PIO24 = 8mA" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL2" edc:desc="For PIO12 = 8mA, PIO24 = 16mA" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL3" edc:desc="For PIO12 = 12mA, PIO24 = 24mA" edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL2P43" edc:nzwidth="0x20" edc:access="--------------------------nn---n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x31" edc:_addr="0x4008158C">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="SLEW_CTRL" edc:nzwidth="0x1" edc:desc="Selects slew rate on the pin. 1=fast 0=slow"/>
            <edc:AdjustPoint edc:offset="0x3"/>
            <edc:SFRFieldDef edc:cname="DRIV_STREN" edc:nzwidth="0x2" edc:desc="Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA">
              <edc:SFRFieldSemantic edc:cname="LEVEL0" edc:desc="For PIO12 = 2mA, PIO24 = 4mA" edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL1" edc:desc="For PIO12 = 4mA, PIO24 = 8mA" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL2" edc:desc="For PIO12 = 8mA, PIO24 = 16mA" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL3" edc:desc="For PIO12 = 12mA, PIO24 = 24mA" edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL2P44" edc:nzwidth="0x20" edc:access="--------------------------nn---n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x31" edc:_addr="0x40081590">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="SLEW_CTRL" edc:nzwidth="0x1" edc:desc="Selects slew rate on the pin. 1=fast 0=slow"/>
            <edc:AdjustPoint edc:offset="0x3"/>
            <edc:SFRFieldDef edc:cname="DRIV_STREN" edc:nzwidth="0x2" edc:desc="Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA">
              <edc:SFRFieldSemantic edc:cname="LEVEL0" edc:desc="For PIO12 = 2mA, PIO24 = 4mA" edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL1" edc:desc="For PIO12 = 4mA, PIO24 = 8mA" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL2" edc:desc="For PIO12 = 8mA, PIO24 = 16mA" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL3" edc:desc="For PIO12 = 12mA, PIO24 = 24mA" edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL2P45" edc:nzwidth="0x20" edc:access="--------------------------nn---n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x31" edc:_addr="0x40081594">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="SLEW_CTRL" edc:nzwidth="0x1" edc:desc="Selects slew rate on the pin. 1=fast 0=slow"/>
            <edc:AdjustPoint edc:offset="0x3"/>
            <edc:SFRFieldDef edc:cname="DRIV_STREN" edc:nzwidth="0x2" edc:desc="Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA">
              <edc:SFRFieldSemantic edc:cname="LEVEL0" edc:desc="For PIO12 = 2mA, PIO24 = 4mA" edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL1" edc:desc="For PIO12 = 4mA, PIO24 = 8mA" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL2" edc:desc="For PIO12 = 8mA, PIO24 = 16mA" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL3" edc:desc="For PIO12 = 12mA, PIO24 = 24mA" edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL2P46" edc:nzwidth="0x20" edc:access="--------------------------nn---n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x31" edc:_addr="0x40081598">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="SLEW_CTRL" edc:nzwidth="0x1" edc:desc="Selects slew rate on the pin. 1=fast 0=slow"/>
            <edc:AdjustPoint edc:offset="0x3"/>
            <edc:SFRFieldDef edc:cname="DRIV_STREN" edc:nzwidth="0x2" edc:desc="Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA">
              <edc:SFRFieldSemantic edc:cname="LEVEL0" edc:desc="For PIO12 = 2mA, PIO24 = 4mA" edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL1" edc:desc="For PIO12 = 4mA, PIO24 = 8mA" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL2" edc:desc="For PIO12 = 8mA, PIO24 = 16mA" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL3" edc:desc="For PIO12 = 12mA, PIO24 = 24mA" edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL2P47" edc:nzwidth="0x20" edc:access="--------------------------nn---n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x31" edc:_addr="0x4008159C">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="SLEW_CTRL" edc:nzwidth="0x1" edc:desc="Selects slew rate on the pin. 1=fast 0=slow"/>
            <edc:AdjustPoint edc:offset="0x3"/>
            <edc:SFRFieldDef edc:cname="DRIV_STREN" edc:nzwidth="0x2" edc:desc="Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA">
              <edc:SFRFieldSemantic edc:cname="LEVEL0" edc:desc="For PIO12 = 2mA, PIO24 = 4mA" edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL1" edc:desc="For PIO12 = 4mA, PIO24 = 8mA" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL2" edc:desc="For PIO12 = 8mA, PIO24 = 16mA" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL3" edc:desc="For PIO12 = 12mA, PIO24 = 24mA" edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL2P50" edc:nzwidth="0x20" edc:access="--------------------------nn---n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x31" edc:_addr="0x400815A0">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="SLEW_CTRL" edc:nzwidth="0x1" edc:desc="Selects slew rate on the pin. 1=fast 0=slow"/>
            <edc:AdjustPoint edc:offset="0x3"/>
            <edc:SFRFieldDef edc:cname="DRIV_STREN" edc:nzwidth="0x2" edc:desc="Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA">
              <edc:SFRFieldSemantic edc:cname="LEVEL0" edc:desc="For PIO12 = 2mA, PIO24 = 4mA" edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL1" edc:desc="For PIO12 = 4mA, PIO24 = 8mA" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL2" edc:desc="For PIO12 = 8mA, PIO24 = 16mA" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL3" edc:desc="For PIO12 = 12mA, PIO24 = 24mA" edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL2P51" edc:nzwidth="0x20" edc:access="--------------------------nn---n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x31" edc:_addr="0x400815A4">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="SLEW_CTRL" edc:nzwidth="0x1" edc:desc="Selects slew rate on the pin. 1=fast 0=slow"/>
            <edc:AdjustPoint edc:offset="0x3"/>
            <edc:SFRFieldDef edc:cname="DRIV_STREN" edc:nzwidth="0x2" edc:desc="Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA">
              <edc:SFRFieldSemantic edc:cname="LEVEL0" edc:desc="For PIO12 = 2mA, PIO24 = 4mA" edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL1" edc:desc="For PIO12 = 4mA, PIO24 = 8mA" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL2" edc:desc="For PIO12 = 8mA, PIO24 = 16mA" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL3" edc:desc="For PIO12 = 12mA, PIO24 = 24mA" edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL2P52" edc:nzwidth="0x20" edc:access="--------------------------nn---n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x31" edc:_addr="0x400815A8">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="SLEW_CTRL" edc:nzwidth="0x1" edc:desc="Selects slew rate on the pin. 1=fast 0=slow"/>
            <edc:AdjustPoint edc:offset="0x3"/>
            <edc:SFRFieldDef edc:cname="DRIV_STREN" edc:nzwidth="0x2" edc:desc="Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA">
              <edc:SFRFieldSemantic edc:cname="LEVEL0" edc:desc="For PIO12 = 2mA, PIO24 = 4mA" edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL1" edc:desc="For PIO12 = 4mA, PIO24 = 8mA" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL2" edc:desc="For PIO12 = 8mA, PIO24 = 16mA" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL3" edc:desc="For PIO12 = 12mA, PIO24 = 24mA" edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL2P53" edc:nzwidth="0x20" edc:access="--------------------------nn---n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x31" edc:_addr="0x400815AC">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="SLEW_CTRL" edc:nzwidth="0x1" edc:desc="Selects slew rate on the pin. 1=fast 0=slow"/>
            <edc:AdjustPoint edc:offset="0x3"/>
            <edc:SFRFieldDef edc:cname="DRIV_STREN" edc:nzwidth="0x2" edc:desc="Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA">
              <edc:SFRFieldSemantic edc:cname="LEVEL0" edc:desc="For PIO12 = 2mA, PIO24 = 4mA" edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL1" edc:desc="For PIO12 = 4mA, PIO24 = 8mA" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL2" edc:desc="For PIO12 = 8mA, PIO24 = 16mA" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL3" edc:desc="For PIO12 = 12mA, PIO24 = 24mA" edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL2P54" edc:nzwidth="0x20" edc:access="--------------------------nn---n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x31" edc:_addr="0x400815B0">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="SLEW_CTRL" edc:nzwidth="0x1" edc:desc="Selects slew rate on the pin. 1=fast 0=slow"/>
            <edc:AdjustPoint edc:offset="0x3"/>
            <edc:SFRFieldDef edc:cname="DRIV_STREN" edc:nzwidth="0x2" edc:desc="Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA">
              <edc:SFRFieldSemantic edc:cname="LEVEL0" edc:desc="For PIO12 = 2mA, PIO24 = 4mA" edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL1" edc:desc="For PIO12 = 4mA, PIO24 = 8mA" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL2" edc:desc="For PIO12 = 8mA, PIO24 = 16mA" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL3" edc:desc="For PIO12 = 12mA, PIO24 = 24mA" edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL2P55" edc:nzwidth="0x20" edc:access="--------------------------nn---n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x31" edc:_addr="0x400815B4">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="SLEW_CTRL" edc:nzwidth="0x1" edc:desc="Selects slew rate on the pin. 1=fast 0=slow"/>
            <edc:AdjustPoint edc:offset="0x3"/>
            <edc:SFRFieldDef edc:cname="DRIV_STREN" edc:nzwidth="0x2" edc:desc="Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA">
              <edc:SFRFieldSemantic edc:cname="LEVEL0" edc:desc="For PIO12 = 2mA, PIO24 = 4mA" edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL1" edc:desc="For PIO12 = 4mA, PIO24 = 8mA" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL2" edc:desc="For PIO12 = 8mA, PIO24 = 16mA" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL3" edc:desc="For PIO12 = 12mA, PIO24 = 24mA" edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL2P56" edc:nzwidth="0x20" edc:access="--------------------------nn---n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x31" edc:_addr="0x400815B8">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="SLEW_CTRL" edc:nzwidth="0x1" edc:desc="Selects slew rate on the pin. 1=fast 0=slow"/>
            <edc:AdjustPoint edc:offset="0x3"/>
            <edc:SFRFieldDef edc:cname="DRIV_STREN" edc:nzwidth="0x2" edc:desc="Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA">
              <edc:SFRFieldSemantic edc:cname="LEVEL0" edc:desc="For PIO12 = 2mA, PIO24 = 4mA" edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL1" edc:desc="For PIO12 = 4mA, PIO24 = 8mA" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL2" edc:desc="For PIO12 = 8mA, PIO24 = 16mA" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL3" edc:desc="For PIO12 = 12mA, PIO24 = 24mA" edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL2P57" edc:nzwidth="0x20" edc:access="--------------------------nn---n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x31" edc:_addr="0x400815BC">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="SLEW_CTRL" edc:nzwidth="0x1" edc:desc="Selects slew rate on the pin. 1=fast 0=slow"/>
            <edc:AdjustPoint edc:offset="0x3"/>
            <edc:SFRFieldDef edc:cname="DRIV_STREN" edc:nzwidth="0x2" edc:desc="Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA">
              <edc:SFRFieldSemantic edc:cname="LEVEL0" edc:desc="For PIO12 = 2mA, PIO24 = 4mA" edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL1" edc:desc="For PIO12 = 4mA, PIO24 = 8mA" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL2" edc:desc="For PIO12 = 8mA, PIO24 = 16mA" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL3" edc:desc="For PIO12 = 12mA, PIO24 = 24mA" edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL2P60" edc:nzwidth="0x20" edc:access="--------------------------nn---n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x31" edc:_addr="0x400815C0">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="SLEW_CTRL" edc:nzwidth="0x1" edc:desc="Selects slew rate on the pin. 1=fast 0=slow"/>
            <edc:AdjustPoint edc:offset="0x3"/>
            <edc:SFRFieldDef edc:cname="DRIV_STREN" edc:nzwidth="0x2" edc:desc="Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA">
              <edc:SFRFieldSemantic edc:cname="LEVEL0" edc:desc="For PIO12 = 2mA, PIO24 = 4mA" edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL1" edc:desc="For PIO12 = 4mA, PIO24 = 8mA" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL2" edc:desc="For PIO12 = 8mA, PIO24 = 16mA" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL3" edc:desc="For PIO12 = 12mA, PIO24 = 24mA" edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL2P61" edc:nzwidth="0x20" edc:access="--------------------------nn---n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x31" edc:_addr="0x400815C4">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="SLEW_CTRL" edc:nzwidth="0x1" edc:desc="Selects slew rate on the pin. 1=fast 0=slow"/>
            <edc:AdjustPoint edc:offset="0x3"/>
            <edc:SFRFieldDef edc:cname="DRIV_STREN" edc:nzwidth="0x2" edc:desc="Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA">
              <edc:SFRFieldSemantic edc:cname="LEVEL0" edc:desc="For PIO12 = 2mA, PIO24 = 4mA" edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL1" edc:desc="For PIO12 = 4mA, PIO24 = 8mA" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL2" edc:desc="For PIO12 = 8mA, PIO24 = 16mA" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL3" edc:desc="For PIO12 = 12mA, PIO24 = 24mA" edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL2P62" edc:nzwidth="0x20" edc:access="--------------------------nn---n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x31" edc:_addr="0x400815C8">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="SLEW_CTRL" edc:nzwidth="0x1" edc:desc="Selects slew rate on the pin. 1=fast 0=slow"/>
            <edc:AdjustPoint edc:offset="0x3"/>
            <edc:SFRFieldDef edc:cname="DRIV_STREN" edc:nzwidth="0x2" edc:desc="Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA">
              <edc:SFRFieldSemantic edc:cname="LEVEL0" edc:desc="For PIO12 = 2mA, PIO24 = 4mA" edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL1" edc:desc="For PIO12 = 4mA, PIO24 = 8mA" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL2" edc:desc="For PIO12 = 8mA, PIO24 = 16mA" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL3" edc:desc="For PIO12 = 12mA, PIO24 = 24mA" edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL2P63" edc:nzwidth="0x20" edc:access="--------------------------nn---n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x31" edc:_addr="0x400815CC">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="SLEW_CTRL" edc:nzwidth="0x1" edc:desc="Selects slew rate on the pin. 1=fast 0=slow"/>
            <edc:AdjustPoint edc:offset="0x3"/>
            <edc:SFRFieldDef edc:cname="DRIV_STREN" edc:nzwidth="0x2" edc:desc="Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA">
              <edc:SFRFieldSemantic edc:cname="LEVEL0" edc:desc="For PIO12 = 2mA, PIO24 = 4mA" edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL1" edc:desc="For PIO12 = 4mA, PIO24 = 8mA" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL2" edc:desc="For PIO12 = 8mA, PIO24 = 16mA" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL3" edc:desc="For PIO12 = 12mA, PIO24 = 24mA" edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL2P64" edc:nzwidth="0x20" edc:access="--------------------------nn---n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x31" edc:_addr="0x400815D0">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="SLEW_CTRL" edc:nzwidth="0x1" edc:desc="Selects slew rate on the pin. 1=fast 0=slow"/>
            <edc:AdjustPoint edc:offset="0x3"/>
            <edc:SFRFieldDef edc:cname="DRIV_STREN" edc:nzwidth="0x2" edc:desc="Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA">
              <edc:SFRFieldSemantic edc:cname="LEVEL0" edc:desc="For PIO12 = 2mA, PIO24 = 4mA" edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL1" edc:desc="For PIO12 = 4mA, PIO24 = 8mA" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL2" edc:desc="For PIO12 = 8mA, PIO24 = 16mA" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL3" edc:desc="For PIO12 = 12mA, PIO24 = 24mA" edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL2P65" edc:nzwidth="0x20" edc:access="--------------------------nn---n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x31" edc:_addr="0x400815D4">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="SLEW_CTRL" edc:nzwidth="0x1" edc:desc="Selects slew rate on the pin. 1=fast 0=slow"/>
            <edc:AdjustPoint edc:offset="0x3"/>
            <edc:SFRFieldDef edc:cname="DRIV_STREN" edc:nzwidth="0x2" edc:desc="Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA">
              <edc:SFRFieldSemantic edc:cname="LEVEL0" edc:desc="For PIO12 = 2mA, PIO24 = 4mA" edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL1" edc:desc="For PIO12 = 4mA, PIO24 = 8mA" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL2" edc:desc="For PIO12 = 8mA, PIO24 = 16mA" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL3" edc:desc="For PIO12 = 12mA, PIO24 = 24mA" edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL2P66" edc:nzwidth="0x20" edc:access="--------------------------nn---n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x31" edc:_addr="0x400815D8">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="SLEW_CTRL" edc:nzwidth="0x1" edc:desc="Selects slew rate on the pin. 1=fast 0=slow"/>
            <edc:AdjustPoint edc:offset="0x3"/>
            <edc:SFRFieldDef edc:cname="DRIV_STREN" edc:nzwidth="0x2" edc:desc="Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA">
              <edc:SFRFieldSemantic edc:cname="LEVEL0" edc:desc="For PIO12 = 2mA, PIO24 = 4mA" edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL1" edc:desc="For PIO12 = 4mA, PIO24 = 8mA" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL2" edc:desc="For PIO12 = 8mA, PIO24 = 16mA" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL3" edc:desc="For PIO12 = 12mA, PIO24 = 24mA" edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL2P67" edc:nzwidth="0x20" edc:access="--------------------------nn---n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x31" edc:_addr="0x400815DC">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="SLEW_CTRL" edc:nzwidth="0x1" edc:desc="Selects slew rate on the pin. 1=fast 0=slow"/>
            <edc:AdjustPoint edc:offset="0x3"/>
            <edc:SFRFieldDef edc:cname="DRIV_STREN" edc:nzwidth="0x2" edc:desc="Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA">
              <edc:SFRFieldSemantic edc:cname="LEVEL0" edc:desc="For PIO12 = 2mA, PIO24 = 4mA" edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL1" edc:desc="For PIO12 = 4mA, PIO24 = 8mA" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL2" edc:desc="For PIO12 = 8mA, PIO24 = 16mA" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL3" edc:desc="For PIO12 = 12mA, PIO24 = 24mA" edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL2P70" edc:nzwidth="0x20" edc:access="--------------------------nn---n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x31" edc:_addr="0x400815E0">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="SLEW_CTRL" edc:nzwidth="0x1" edc:desc="Selects slew rate on the pin. 1=fast 0=slow"/>
            <edc:AdjustPoint edc:offset="0x3"/>
            <edc:SFRFieldDef edc:cname="DRIV_STREN" edc:nzwidth="0x2" edc:desc="Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA">
              <edc:SFRFieldSemantic edc:cname="LEVEL0" edc:desc="For PIO12 = 2mA, PIO24 = 4mA" edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL1" edc:desc="For PIO12 = 4mA, PIO24 = 8mA" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL2" edc:desc="For PIO12 = 8mA, PIO24 = 16mA" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL3" edc:desc="For PIO12 = 12mA, PIO24 = 24mA" edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL2P71" edc:nzwidth="0x20" edc:access="--------------------------nn---n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x31" edc:_addr="0x400815E4">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="SLEW_CTRL" edc:nzwidth="0x1" edc:desc="Selects slew rate on the pin. 1=fast 0=slow"/>
            <edc:AdjustPoint edc:offset="0x3"/>
            <edc:SFRFieldDef edc:cname="DRIV_STREN" edc:nzwidth="0x2" edc:desc="Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA">
              <edc:SFRFieldSemantic edc:cname="LEVEL0" edc:desc="For PIO12 = 2mA, PIO24 = 4mA" edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL1" edc:desc="For PIO12 = 4mA, PIO24 = 8mA" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL2" edc:desc="For PIO12 = 8mA, PIO24 = 16mA" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL3" edc:desc="For PIO12 = 12mA, PIO24 = 24mA" edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL2P72" edc:nzwidth="0x20" edc:access="--------------------------nn---n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x31" edc:_addr="0x400815E8">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="SLEW_CTRL" edc:nzwidth="0x1" edc:desc="Selects slew rate on the pin. 1=fast 0=slow"/>
            <edc:AdjustPoint edc:offset="0x3"/>
            <edc:SFRFieldDef edc:cname="DRIV_STREN" edc:nzwidth="0x2" edc:desc="Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA">
              <edc:SFRFieldSemantic edc:cname="LEVEL0" edc:desc="For PIO12 = 2mA, PIO24 = 4mA" edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL1" edc:desc="For PIO12 = 4mA, PIO24 = 8mA" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL2" edc:desc="For PIO12 = 8mA, PIO24 = 16mA" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL3" edc:desc="For PIO12 = 12mA, PIO24 = 24mA" edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL2P73" edc:nzwidth="0x20" edc:access="--------------------------nn---n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x31" edc:_addr="0x400815EC">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="SLEW_CTRL" edc:nzwidth="0x1" edc:desc="Selects slew rate on the pin. 1=fast 0=slow"/>
            <edc:AdjustPoint edc:offset="0x3"/>
            <edc:SFRFieldDef edc:cname="DRIV_STREN" edc:nzwidth="0x2" edc:desc="Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA">
              <edc:SFRFieldSemantic edc:cname="LEVEL0" edc:desc="For PIO12 = 2mA, PIO24 = 4mA" edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL1" edc:desc="For PIO12 = 4mA, PIO24 = 8mA" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL2" edc:desc="For PIO12 = 8mA, PIO24 = 16mA" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL3" edc:desc="For PIO12 = 12mA, PIO24 = 24mA" edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL2P74" edc:nzwidth="0x20" edc:access="--------------------------nn---n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x31" edc:_addr="0x400815F0">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="SLEW_CTRL" edc:nzwidth="0x1" edc:desc="Selects slew rate on the pin. 1=fast 0=slow"/>
            <edc:AdjustPoint edc:offset="0x3"/>
            <edc:SFRFieldDef edc:cname="DRIV_STREN" edc:nzwidth="0x2" edc:desc="Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA">
              <edc:SFRFieldSemantic edc:cname="LEVEL0" edc:desc="For PIO12 = 2mA, PIO24 = 4mA" edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL1" edc:desc="For PIO12 = 4mA, PIO24 = 8mA" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL2" edc:desc="For PIO12 = 8mA, PIO24 = 16mA" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL3" edc:desc="For PIO12 = 12mA, PIO24 = 24mA" edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL2P75" edc:nzwidth="0x20" edc:access="--------------------------nn---n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x31" edc:_addr="0x400815F4">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="SLEW_CTRL" edc:nzwidth="0x1" edc:desc="Selects slew rate on the pin. 1=fast 0=slow"/>
            <edc:AdjustPoint edc:offset="0x3"/>
            <edc:SFRFieldDef edc:cname="DRIV_STREN" edc:nzwidth="0x2" edc:desc="Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA">
              <edc:SFRFieldSemantic edc:cname="LEVEL0" edc:desc="For PIO12 = 2mA, PIO24 = 4mA" edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL1" edc:desc="For PIO12 = 4mA, PIO24 = 8mA" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL2" edc:desc="For PIO12 = 8mA, PIO24 = 16mA" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL3" edc:desc="For PIO12 = 12mA, PIO24 = 24mA" edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL2P76" edc:nzwidth="0x20" edc:access="--------------------------nn---n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x31" edc:_addr="0x400815F8">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="SLEW_CTRL" edc:nzwidth="0x1" edc:desc="Selects slew rate on the pin. 1=fast 0=slow"/>
            <edc:AdjustPoint edc:offset="0x3"/>
            <edc:SFRFieldDef edc:cname="DRIV_STREN" edc:nzwidth="0x2" edc:desc="Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA">
              <edc:SFRFieldSemantic edc:cname="LEVEL0" edc:desc="For PIO12 = 2mA, PIO24 = 4mA" edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL1" edc:desc="For PIO12 = 4mA, PIO24 = 8mA" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL2" edc:desc="For PIO12 = 8mA, PIO24 = 16mA" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL3" edc:desc="For PIO12 = 12mA, PIO24 = 24mA" edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL2P77" edc:nzwidth="0x20" edc:access="--------------------------nn---n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x31" edc:_addr="0x400815FC">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="SLEW_CTRL" edc:nzwidth="0x1" edc:desc="Selects slew rate on the pin. 1=fast 0=slow"/>
            <edc:AdjustPoint edc:offset="0x3"/>
            <edc:SFRFieldDef edc:cname="DRIV_STREN" edc:nzwidth="0x2" edc:desc="Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA">
              <edc:SFRFieldSemantic edc:cname="LEVEL0" edc:desc="For PIO12 = 2mA, PIO24 = 4mA" edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL1" edc:desc="For PIO12 = 4mA, PIO24 = 8mA" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL2" edc:desc="For PIO12 = 8mA, PIO24 = 16mA" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL3" edc:desc="For PIO12 = 12mA, PIO24 = 24mA" edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL2P100" edc:nzwidth="0x20" edc:access="--------------------------nn---n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x31" edc:_addr="0x40081600">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="SLEW_CTRL" edc:nzwidth="0x1" edc:desc="Selects slew rate on the pin. 1=fast 0=slow"/>
            <edc:AdjustPoint edc:offset="0x3"/>
            <edc:SFRFieldDef edc:cname="DRIV_STREN" edc:nzwidth="0x2" edc:desc="Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA">
              <edc:SFRFieldSemantic edc:cname="LEVEL0" edc:desc="For PIO12 = 2mA, PIO24 = 4mA" edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL1" edc:desc="For PIO12 = 4mA, PIO24 = 8mA" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL2" edc:desc="For PIO12 = 8mA, PIO24 = 16mA" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL3" edc:desc="For PIO12 = 12mA, PIO24 = 24mA" edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL2P101" edc:nzwidth="0x20" edc:access="--------------------------nn---n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x31" edc:_addr="0x40081604">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="SLEW_CTRL" edc:nzwidth="0x1" edc:desc="Selects slew rate on the pin. 1=fast 0=slow"/>
            <edc:AdjustPoint edc:offset="0x3"/>
            <edc:SFRFieldDef edc:cname="DRIV_STREN" edc:nzwidth="0x2" edc:desc="Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA">
              <edc:SFRFieldSemantic edc:cname="LEVEL0" edc:desc="For PIO12 = 2mA, PIO24 = 4mA" edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL1" edc:desc="For PIO12 = 4mA, PIO24 = 8mA" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL2" edc:desc="For PIO12 = 8mA, PIO24 = 16mA" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL3" edc:desc="For PIO12 = 12mA, PIO24 = 24mA" edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL2P102" edc:nzwidth="0x20" edc:access="--------------------------nn---n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x31" edc:_addr="0x40081608">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="SLEW_CTRL" edc:nzwidth="0x1" edc:desc="Selects slew rate on the pin. 1=fast 0=slow"/>
            <edc:AdjustPoint edc:offset="0x3"/>
            <edc:SFRFieldDef edc:cname="DRIV_STREN" edc:nzwidth="0x2" edc:desc="Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA">
              <edc:SFRFieldSemantic edc:cname="LEVEL0" edc:desc="For PIO12 = 2mA, PIO24 = 4mA" edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL1" edc:desc="For PIO12 = 4mA, PIO24 = 8mA" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL2" edc:desc="For PIO12 = 8mA, PIO24 = 16mA" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL3" edc:desc="For PIO12 = 12mA, PIO24 = 24mA" edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL2P103" edc:nzwidth="0x20" edc:access="--------------------------nn---n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x31" edc:_addr="0x4008160C">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="SLEW_CTRL" edc:nzwidth="0x1" edc:desc="Selects slew rate on the pin. 1=fast 0=slow"/>
            <edc:AdjustPoint edc:offset="0x3"/>
            <edc:SFRFieldDef edc:cname="DRIV_STREN" edc:nzwidth="0x2" edc:desc="Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA">
              <edc:SFRFieldSemantic edc:cname="LEVEL0" edc:desc="For PIO12 = 2mA, PIO24 = 4mA" edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL1" edc:desc="For PIO12 = 4mA, PIO24 = 8mA" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL2" edc:desc="For PIO12 = 8mA, PIO24 = 16mA" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL3" edc:desc="For PIO12 = 12mA, PIO24 = 24mA" edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL2P104" edc:nzwidth="0x20" edc:access="--------------------------nn---n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x31" edc:_addr="0x40081610">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="SLEW_CTRL" edc:nzwidth="0x1" edc:desc="Selects slew rate on the pin. 1=fast 0=slow"/>
            <edc:AdjustPoint edc:offset="0x3"/>
            <edc:SFRFieldDef edc:cname="DRIV_STREN" edc:nzwidth="0x2" edc:desc="Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA">
              <edc:SFRFieldSemantic edc:cname="LEVEL0" edc:desc="For PIO12 = 2mA, PIO24 = 4mA" edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL1" edc:desc="For PIO12 = 4mA, PIO24 = 8mA" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL2" edc:desc="For PIO12 = 8mA, PIO24 = 16mA" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL3" edc:desc="For PIO12 = 12mA, PIO24 = 24mA" edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL2P105" edc:nzwidth="0x20" edc:access="--------------------------nn---n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x31" edc:_addr="0x40081614">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="SLEW_CTRL" edc:nzwidth="0x1" edc:desc="Selects slew rate on the pin. 1=fast 0=slow"/>
            <edc:AdjustPoint edc:offset="0x3"/>
            <edc:SFRFieldDef edc:cname="DRIV_STREN" edc:nzwidth="0x2" edc:desc="Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA">
              <edc:SFRFieldSemantic edc:cname="LEVEL0" edc:desc="For PIO12 = 2mA, PIO24 = 4mA" edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL1" edc:desc="For PIO12 = 4mA, PIO24 = 8mA" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL2" edc:desc="For PIO12 = 8mA, PIO24 = 16mA" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL3" edc:desc="For PIO12 = 12mA, PIO24 = 24mA" edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL2P106" edc:nzwidth="0x20" edc:access="--------------------------nn---n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x31" edc:_addr="0x40081618">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="SLEW_CTRL" edc:nzwidth="0x1" edc:desc="Selects slew rate on the pin. 1=fast 0=slow"/>
            <edc:AdjustPoint edc:offset="0x3"/>
            <edc:SFRFieldDef edc:cname="DRIV_STREN" edc:nzwidth="0x2" edc:desc="Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA">
              <edc:SFRFieldSemantic edc:cname="LEVEL0" edc:desc="For PIO12 = 2mA, PIO24 = 4mA" edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL1" edc:desc="For PIO12 = 4mA, PIO24 = 8mA" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL2" edc:desc="For PIO12 = 8mA, PIO24 = 16mA" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL3" edc:desc="For PIO12 = 12mA, PIO24 = 24mA" edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL2P107" edc:nzwidth="0x20" edc:access="--------------------------nn---n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x31" edc:_addr="0x4008161C">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="SLEW_CTRL" edc:nzwidth="0x1" edc:desc="Selects slew rate on the pin. 1=fast 0=slow"/>
            <edc:AdjustPoint edc:offset="0x3"/>
            <edc:SFRFieldDef edc:cname="DRIV_STREN" edc:nzwidth="0x2" edc:desc="Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA">
              <edc:SFRFieldSemantic edc:cname="LEVEL0" edc:desc="For PIO12 = 2mA, PIO24 = 4mA" edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL1" edc:desc="For PIO12 = 4mA, PIO24 = 8mA" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL2" edc:desc="For PIO12 = 8mA, PIO24 = 16mA" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL3" edc:desc="For PIO12 = 12mA, PIO24 = 24mA" edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL2P110" edc:nzwidth="0x20" edc:access="--------------------------nn---n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x31" edc:_addr="0x40081620">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="SLEW_CTRL" edc:nzwidth="0x1" edc:desc="Selects slew rate on the pin. 1=fast 0=slow"/>
            <edc:AdjustPoint edc:offset="0x3"/>
            <edc:SFRFieldDef edc:cname="DRIV_STREN" edc:nzwidth="0x2" edc:desc="Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA">
              <edc:SFRFieldSemantic edc:cname="LEVEL0" edc:desc="For PIO12 = 2mA, PIO24 = 4mA" edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL1" edc:desc="For PIO12 = 4mA, PIO24 = 8mA" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL2" edc:desc="For PIO12 = 8mA, PIO24 = 16mA" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL3" edc:desc="For PIO12 = 12mA, PIO24 = 24mA" edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL2P111" edc:nzwidth="0x20" edc:access="--------------------------nn---n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x31" edc:_addr="0x40081624">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="SLEW_CTRL" edc:nzwidth="0x1" edc:desc="Selects slew rate on the pin. 1=fast 0=slow"/>
            <edc:AdjustPoint edc:offset="0x3"/>
            <edc:SFRFieldDef edc:cname="DRIV_STREN" edc:nzwidth="0x2" edc:desc="Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA">
              <edc:SFRFieldSemantic edc:cname="LEVEL0" edc:desc="For PIO12 = 2mA, PIO24 = 4mA" edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL1" edc:desc="For PIO12 = 4mA, PIO24 = 8mA" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL2" edc:desc="For PIO12 = 8mA, PIO24 = 16mA" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL3" edc:desc="For PIO12 = 12mA, PIO24 = 24mA" edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL2P112" edc:nzwidth="0x20" edc:access="--------------------------nn---n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x31" edc:_addr="0x40081628">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="SLEW_CTRL" edc:nzwidth="0x1" edc:desc="Selects slew rate on the pin. 1=fast 0=slow"/>
            <edc:AdjustPoint edc:offset="0x3"/>
            <edc:SFRFieldDef edc:cname="DRIV_STREN" edc:nzwidth="0x2" edc:desc="Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA">
              <edc:SFRFieldSemantic edc:cname="LEVEL0" edc:desc="For PIO12 = 2mA, PIO24 = 4mA" edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL1" edc:desc="For PIO12 = 4mA, PIO24 = 8mA" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL2" edc:desc="For PIO12 = 8mA, PIO24 = 16mA" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL3" edc:desc="For PIO12 = 12mA, PIO24 = 24mA" edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL2P113" edc:nzwidth="0x20" edc:access="--------------------------nn---n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x31" edc:_addr="0x4008162C">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="SLEW_CTRL" edc:nzwidth="0x1" edc:desc="Selects slew rate on the pin. 1=fast 0=slow"/>
            <edc:AdjustPoint edc:offset="0x3"/>
            <edc:SFRFieldDef edc:cname="DRIV_STREN" edc:nzwidth="0x2" edc:desc="Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA">
              <edc:SFRFieldSemantic edc:cname="LEVEL0" edc:desc="For PIO12 = 2mA, PIO24 = 4mA" edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL1" edc:desc="For PIO12 = 4mA, PIO24 = 8mA" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL2" edc:desc="For PIO12 = 8mA, PIO24 = 16mA" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL3" edc:desc="For PIO12 = 12mA, PIO24 = 24mA" edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL2P114" edc:nzwidth="0x20" edc:access="--------------------------nn---n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x31" edc:_addr="0x40081630">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="SLEW_CTRL" edc:nzwidth="0x1" edc:desc="Selects slew rate on the pin. 1=fast 0=slow"/>
            <edc:AdjustPoint edc:offset="0x3"/>
            <edc:SFRFieldDef edc:cname="DRIV_STREN" edc:nzwidth="0x2" edc:desc="Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA">
              <edc:SFRFieldSemantic edc:cname="LEVEL0" edc:desc="For PIO12 = 2mA, PIO24 = 4mA" edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL1" edc:desc="For PIO12 = 4mA, PIO24 = 8mA" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL2" edc:desc="For PIO12 = 8mA, PIO24 = 16mA" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL3" edc:desc="For PIO12 = 12mA, PIO24 = 24mA" edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL2P115" edc:nzwidth="0x20" edc:access="--------------------------nn---n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x31" edc:_addr="0x40081634">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="SLEW_CTRL" edc:nzwidth="0x1" edc:desc="Selects slew rate on the pin. 1=fast 0=slow"/>
            <edc:AdjustPoint edc:offset="0x3"/>
            <edc:SFRFieldDef edc:cname="DRIV_STREN" edc:nzwidth="0x2" edc:desc="Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA">
              <edc:SFRFieldSemantic edc:cname="LEVEL0" edc:desc="For PIO12 = 2mA, PIO24 = 4mA" edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL1" edc:desc="For PIO12 = 4mA, PIO24 = 8mA" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL2" edc:desc="For PIO12 = 8mA, PIO24 = 16mA" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL3" edc:desc="For PIO12 = 12mA, PIO24 = 24mA" edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL2P116" edc:nzwidth="0x20" edc:access="--------------------------nn---n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x31" edc:_addr="0x40081638">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="SLEW_CTRL" edc:nzwidth="0x1" edc:desc="Selects slew rate on the pin. 1=fast 0=slow"/>
            <edc:AdjustPoint edc:offset="0x3"/>
            <edc:SFRFieldDef edc:cname="DRIV_STREN" edc:nzwidth="0x2" edc:desc="Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA">
              <edc:SFRFieldSemantic edc:cname="LEVEL0" edc:desc="For PIO12 = 2mA, PIO24 = 4mA" edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL1" edc:desc="For PIO12 = 4mA, PIO24 = 8mA" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL2" edc:desc="For PIO12 = 8mA, PIO24 = 16mA" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL3" edc:desc="For PIO12 = 12mA, PIO24 = 24mA" edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL2P117" edc:nzwidth="0x20" edc:access="--------------------------nn---n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x31" edc:_addr="0x4008163C">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="SLEW_CTRL" edc:nzwidth="0x1" edc:desc="Selects slew rate on the pin. 1=fast 0=slow"/>
            <edc:AdjustPoint edc:offset="0x3"/>
            <edc:SFRFieldDef edc:cname="DRIV_STREN" edc:nzwidth="0x2" edc:desc="Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA">
              <edc:SFRFieldSemantic edc:cname="LEVEL0" edc:desc="For PIO12 = 2mA, PIO24 = 4mA" edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL1" edc:desc="For PIO12 = 4mA, PIO24 = 8mA" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL2" edc:desc="For PIO12 = 8mA, PIO24 = 16mA" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL3" edc:desc="For PIO12 = 12mA, PIO24 = 24mA" edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL2P120" edc:nzwidth="0x20" edc:access="--------------------------nn---n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x31" edc:_addr="0x40081640">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="SLEW_CTRL" edc:nzwidth="0x1" edc:desc="Selects slew rate on the pin. 1=fast 0=slow"/>
            <edc:AdjustPoint edc:offset="0x3"/>
            <edc:SFRFieldDef edc:cname="DRIV_STREN" edc:nzwidth="0x2" edc:desc="Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA">
              <edc:SFRFieldSemantic edc:cname="LEVEL0" edc:desc="For PIO12 = 2mA, PIO24 = 4mA" edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL1" edc:desc="For PIO12 = 4mA, PIO24 = 8mA" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL2" edc:desc="For PIO12 = 8mA, PIO24 = 16mA" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL3" edc:desc="For PIO12 = 12mA, PIO24 = 24mA" edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL2P121" edc:nzwidth="0x20" edc:access="--------------------------nn---n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x31" edc:_addr="0x40081644">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="SLEW_CTRL" edc:nzwidth="0x1" edc:desc="Selects slew rate on the pin. 1=fast 0=slow"/>
            <edc:AdjustPoint edc:offset="0x3"/>
            <edc:SFRFieldDef edc:cname="DRIV_STREN" edc:nzwidth="0x2" edc:desc="Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA">
              <edc:SFRFieldSemantic edc:cname="LEVEL0" edc:desc="For PIO12 = 2mA, PIO24 = 4mA" edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL1" edc:desc="For PIO12 = 4mA, PIO24 = 8mA" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL2" edc:desc="For PIO12 = 8mA, PIO24 = 16mA" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL3" edc:desc="For PIO12 = 12mA, PIO24 = 24mA" edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL2P122" edc:nzwidth="0x20" edc:access="--------------------------nn---n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x31" edc:_addr="0x40081648">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="SLEW_CTRL" edc:nzwidth="0x1" edc:desc="Selects slew rate on the pin. 1=fast 0=slow"/>
            <edc:AdjustPoint edc:offset="0x3"/>
            <edc:SFRFieldDef edc:cname="DRIV_STREN" edc:nzwidth="0x2" edc:desc="Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA">
              <edc:SFRFieldSemantic edc:cname="LEVEL0" edc:desc="For PIO12 = 2mA, PIO24 = 4mA" edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL1" edc:desc="For PIO12 = 4mA, PIO24 = 8mA" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL2" edc:desc="For PIO12 = 8mA, PIO24 = 16mA" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL3" edc:desc="For PIO12 = 12mA, PIO24 = 24mA" edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL2P123" edc:nzwidth="0x20" edc:access="--------------------------nn---n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x31" edc:_addr="0x4008164C">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="SLEW_CTRL" edc:nzwidth="0x1" edc:desc="Selects slew rate on the pin. 1=fast 0=slow"/>
            <edc:AdjustPoint edc:offset="0x3"/>
            <edc:SFRFieldDef edc:cname="DRIV_STREN" edc:nzwidth="0x2" edc:desc="Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA">
              <edc:SFRFieldSemantic edc:cname="LEVEL0" edc:desc="For PIO12 = 2mA, PIO24 = 4mA" edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL1" edc:desc="For PIO12 = 4mA, PIO24 = 8mA" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL2" edc:desc="For PIO12 = 8mA, PIO24 = 16mA" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL3" edc:desc="For PIO12 = 12mA, PIO24 = 24mA" edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL2P124" edc:nzwidth="0x20" edc:access="--------------------------nn---n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x31" edc:_addr="0x40081650">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="SLEW_CTRL" edc:nzwidth="0x1" edc:desc="Selects slew rate on the pin. 1=fast 0=slow"/>
            <edc:AdjustPoint edc:offset="0x3"/>
            <edc:SFRFieldDef edc:cname="DRIV_STREN" edc:nzwidth="0x2" edc:desc="Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA">
              <edc:SFRFieldSemantic edc:cname="LEVEL0" edc:desc="For PIO12 = 2mA, PIO24 = 4mA" edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL1" edc:desc="For PIO12 = 4mA, PIO24 = 8mA" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL2" edc:desc="For PIO12 = 8mA, PIO24 = 16mA" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL3" edc:desc="For PIO12 = 12mA, PIO24 = 24mA" edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL2P125" edc:nzwidth="0x20" edc:access="--------------------------nn---n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x31" edc:_addr="0x40081654">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="SLEW_CTRL" edc:nzwidth="0x1" edc:desc="Selects slew rate on the pin. 1=fast 0=slow"/>
            <edc:AdjustPoint edc:offset="0x3"/>
            <edc:SFRFieldDef edc:cname="DRIV_STREN" edc:nzwidth="0x2" edc:desc="Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA">
              <edc:SFRFieldSemantic edc:cname="LEVEL0" edc:desc="For PIO12 = 2mA, PIO24 = 4mA" edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL1" edc:desc="For PIO12 = 4mA, PIO24 = 8mA" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL2" edc:desc="For PIO12 = 8mA, PIO24 = 16mA" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL3" edc:desc="For PIO12 = 12mA, PIO24 = 24mA" edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL2P126" edc:nzwidth="0x20" edc:access="--------------------------nn---n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x31" edc:_addr="0x40081658">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="SLEW_CTRL" edc:nzwidth="0x1" edc:desc="Selects slew rate on the pin. 1=fast 0=slow"/>
            <edc:AdjustPoint edc:offset="0x3"/>
            <edc:SFRFieldDef edc:cname="DRIV_STREN" edc:nzwidth="0x2" edc:desc="Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA">
              <edc:SFRFieldSemantic edc:cname="LEVEL0" edc:desc="For PIO12 = 2mA, PIO24 = 4mA" edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL1" edc:desc="For PIO12 = 4mA, PIO24 = 8mA" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL2" edc:desc="For PIO12 = 8mA, PIO24 = 16mA" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL3" edc:desc="For PIO12 = 12mA, PIO24 = 24mA" edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL2P127" edc:nzwidth="0x20" edc:access="--------------------------nn---n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x31" edc:_addr="0x4008165C">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="SLEW_CTRL" edc:nzwidth="0x1" edc:desc="Selects slew rate on the pin. 1=fast 0=slow"/>
            <edc:AdjustPoint edc:offset="0x3"/>
            <edc:SFRFieldDef edc:cname="DRIV_STREN" edc:nzwidth="0x2" edc:desc="Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA">
              <edc:SFRFieldSemantic edc:cname="LEVEL0" edc:desc="For PIO12 = 2mA, PIO24 = 4mA" edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL1" edc:desc="For PIO12 = 4mA, PIO24 = 8mA" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL2" edc:desc="For PIO12 = 8mA, PIO24 = 16mA" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL3" edc:desc="For PIO12 = 12mA, PIO24 = 24mA" edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL2P130" edc:nzwidth="0x20" edc:access="--------------------------nn---n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x31" edc:_addr="0x40081660">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="SLEW_CTRL" edc:nzwidth="0x1" edc:desc="Selects slew rate on the pin. 1=fast 0=slow"/>
            <edc:AdjustPoint edc:offset="0x3"/>
            <edc:SFRFieldDef edc:cname="DRIV_STREN" edc:nzwidth="0x2" edc:desc="Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA">
              <edc:SFRFieldSemantic edc:cname="LEVEL0" edc:desc="For PIO12 = 2mA, PIO24 = 4mA" edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL1" edc:desc="For PIO12 = 4mA, PIO24 = 8mA" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL2" edc:desc="For PIO12 = 8mA, PIO24 = 16mA" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL3" edc:desc="For PIO12 = 12mA, PIO24 = 24mA" edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL2P131" edc:nzwidth="0x20" edc:access="--------------------------nn---n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x31" edc:_addr="0x40081664">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="SLEW_CTRL" edc:nzwidth="0x1" edc:desc="Selects slew rate on the pin. 1=fast 0=slow"/>
            <edc:AdjustPoint edc:offset="0x3"/>
            <edc:SFRFieldDef edc:cname="DRIV_STREN" edc:nzwidth="0x2" edc:desc="Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA">
              <edc:SFRFieldSemantic edc:cname="LEVEL0" edc:desc="For PIO12 = 2mA, PIO24 = 4mA" edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL1" edc:desc="For PIO12 = 4mA, PIO24 = 8mA" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL2" edc:desc="For PIO12 = 8mA, PIO24 = 16mA" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL3" edc:desc="For PIO12 = 12mA, PIO24 = 24mA" edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL2P132" edc:nzwidth="0x20" edc:access="--------------------------nn---n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x31" edc:_addr="0x40081668">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="SLEW_CTRL" edc:nzwidth="0x1" edc:desc="Selects slew rate on the pin. 1=fast 0=slow"/>
            <edc:AdjustPoint edc:offset="0x3"/>
            <edc:SFRFieldDef edc:cname="DRIV_STREN" edc:nzwidth="0x2" edc:desc="Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA">
              <edc:SFRFieldSemantic edc:cname="LEVEL0" edc:desc="For PIO12 = 2mA, PIO24 = 4mA" edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL1" edc:desc="For PIO12 = 4mA, PIO24 = 8mA" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL2" edc:desc="For PIO12 = 8mA, PIO24 = 16mA" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL3" edc:desc="For PIO12 = 12mA, PIO24 = 24mA" edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL2P133" edc:nzwidth="0x20" edc:access="--------------------------nn---n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x31" edc:_addr="0x4008166C">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="SLEW_CTRL" edc:nzwidth="0x1" edc:desc="Selects slew rate on the pin. 1=fast 0=slow"/>
            <edc:AdjustPoint edc:offset="0x3"/>
            <edc:SFRFieldDef edc:cname="DRIV_STREN" edc:nzwidth="0x2" edc:desc="Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA">
              <edc:SFRFieldSemantic edc:cname="LEVEL0" edc:desc="For PIO12 = 2mA, PIO24 = 4mA" edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL1" edc:desc="For PIO12 = 4mA, PIO24 = 8mA" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL2" edc:desc="For PIO12 = 8mA, PIO24 = 16mA" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL3" edc:desc="For PIO12 = 12mA, PIO24 = 24mA" edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL2P134" edc:nzwidth="0x20" edc:access="--------------------------nn---n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x31" edc:_addr="0x40081670">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="SLEW_CTRL" edc:nzwidth="0x1" edc:desc="Selects slew rate on the pin. 1=fast 0=slow"/>
            <edc:AdjustPoint edc:offset="0x3"/>
            <edc:SFRFieldDef edc:cname="DRIV_STREN" edc:nzwidth="0x2" edc:desc="Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA">
              <edc:SFRFieldSemantic edc:cname="LEVEL0" edc:desc="For PIO12 = 2mA, PIO24 = 4mA" edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL1" edc:desc="For PIO12 = 4mA, PIO24 = 8mA" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL2" edc:desc="For PIO12 = 8mA, PIO24 = 16mA" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL3" edc:desc="For PIO12 = 12mA, PIO24 = 24mA" edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL2P135" edc:nzwidth="0x20" edc:access="--------------------------nn---n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x31" edc:_addr="0x40081674">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="SLEW_CTRL" edc:nzwidth="0x1" edc:desc="Selects slew rate on the pin. 1=fast 0=slow"/>
            <edc:AdjustPoint edc:offset="0x3"/>
            <edc:SFRFieldDef edc:cname="DRIV_STREN" edc:nzwidth="0x2" edc:desc="Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA">
              <edc:SFRFieldSemantic edc:cname="LEVEL0" edc:desc="For PIO12 = 2mA, PIO24 = 4mA" edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL1" edc:desc="For PIO12 = 4mA, PIO24 = 8mA" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL2" edc:desc="For PIO12 = 8mA, PIO24 = 16mA" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL3" edc:desc="For PIO12 = 12mA, PIO24 = 24mA" edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL2P136" edc:nzwidth="0x20" edc:access="--------------------------nn---n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x31" edc:_addr="0x40081678">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="SLEW_CTRL" edc:nzwidth="0x1" edc:desc="Selects slew rate on the pin. 1=fast 0=slow"/>
            <edc:AdjustPoint edc:offset="0x3"/>
            <edc:SFRFieldDef edc:cname="DRIV_STREN" edc:nzwidth="0x2" edc:desc="Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA">
              <edc:SFRFieldSemantic edc:cname="LEVEL0" edc:desc="For PIO12 = 2mA, PIO24 = 4mA" edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL1" edc:desc="For PIO12 = 4mA, PIO24 = 8mA" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL2" edc:desc="For PIO12 = 8mA, PIO24 = 16mA" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL3" edc:desc="For PIO12 = 12mA, PIO24 = 24mA" edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL2P137" edc:nzwidth="0x20" edc:access="--------------------------nn---n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x31" edc:_addr="0x4008167C">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="SLEW_CTRL" edc:nzwidth="0x1" edc:desc="Selects slew rate on the pin. 1=fast 0=slow"/>
            <edc:AdjustPoint edc:offset="0x3"/>
            <edc:SFRFieldDef edc:cname="DRIV_STREN" edc:nzwidth="0x2" edc:desc="Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA">
              <edc:SFRFieldSemantic edc:cname="LEVEL0" edc:desc="For PIO12 = 2mA, PIO24 = 4mA" edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL1" edc:desc="For PIO12 = 4mA, PIO24 = 8mA" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL2" edc:desc="For PIO12 = 8mA, PIO24 = 16mA" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL3" edc:desc="For PIO12 = 12mA, PIO24 = 24mA" edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL2P140" edc:nzwidth="0x20" edc:access="--------------------------nn---n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x31" edc:_addr="0x40081680">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="SLEW_CTRL" edc:nzwidth="0x1" edc:desc="Selects slew rate on the pin. 1=fast 0=slow"/>
            <edc:AdjustPoint edc:offset="0x3"/>
            <edc:SFRFieldDef edc:cname="DRIV_STREN" edc:nzwidth="0x2" edc:desc="Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA">
              <edc:SFRFieldSemantic edc:cname="LEVEL0" edc:desc="For PIO12 = 2mA, PIO24 = 4mA" edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL1" edc:desc="For PIO12 = 4mA, PIO24 = 8mA" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL2" edc:desc="For PIO12 = 8mA, PIO24 = 16mA" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL3" edc:desc="For PIO12 = 12mA, PIO24 = 24mA" edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL2P141" edc:nzwidth="0x20" edc:access="--------------------------nn---n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x31" edc:_addr="0x40081684">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="SLEW_CTRL" edc:nzwidth="0x1" edc:desc="Selects slew rate on the pin. 1=fast 0=slow"/>
            <edc:AdjustPoint edc:offset="0x3"/>
            <edc:SFRFieldDef edc:cname="DRIV_STREN" edc:nzwidth="0x2" edc:desc="Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA">
              <edc:SFRFieldSemantic edc:cname="LEVEL0" edc:desc="For PIO12 = 2mA, PIO24 = 4mA" edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL1" edc:desc="For PIO12 = 4mA, PIO24 = 8mA" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL2" edc:desc="For PIO12 = 8mA, PIO24 = 16mA" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL3" edc:desc="For PIO12 = 12mA, PIO24 = 24mA" edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL2P142" edc:nzwidth="0x20" edc:access="--------------------------nn---n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x31" edc:_addr="0x40081688">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="SLEW_CTRL" edc:nzwidth="0x1" edc:desc="Selects slew rate on the pin. 1=fast 0=slow"/>
            <edc:AdjustPoint edc:offset="0x3"/>
            <edc:SFRFieldDef edc:cname="DRIV_STREN" edc:nzwidth="0x2" edc:desc="Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA">
              <edc:SFRFieldSemantic edc:cname="LEVEL0" edc:desc="For PIO12 = 2mA, PIO24 = 4mA" edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL1" edc:desc="For PIO12 = 4mA, PIO24 = 8mA" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL2" edc:desc="For PIO12 = 8mA, PIO24 = 16mA" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL3" edc:desc="For PIO12 = 12mA, PIO24 = 24mA" edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL2P143" edc:nzwidth="0x20" edc:access="--------------------------nn---n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x31" edc:_addr="0x4008168C">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="SLEW_CTRL" edc:nzwidth="0x1" edc:desc="Selects slew rate on the pin. 1=fast 0=slow"/>
            <edc:AdjustPoint edc:offset="0x3"/>
            <edc:SFRFieldDef edc:cname="DRIV_STREN" edc:nzwidth="0x2" edc:desc="Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA">
              <edc:SFRFieldSemantic edc:cname="LEVEL0" edc:desc="For PIO12 = 2mA, PIO24 = 4mA" edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL1" edc:desc="For PIO12 = 4mA, PIO24 = 8mA" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL2" edc:desc="For PIO12 = 8mA, PIO24 = 16mA" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL3" edc:desc="For PIO12 = 12mA, PIO24 = 24mA" edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL2P144" edc:nzwidth="0x20" edc:access="--------------------------nn---n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x31" edc:_addr="0x40081690">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="SLEW_CTRL" edc:nzwidth="0x1" edc:desc="Selects slew rate on the pin. 1=fast 0=slow"/>
            <edc:AdjustPoint edc:offset="0x3"/>
            <edc:SFRFieldDef edc:cname="DRIV_STREN" edc:nzwidth="0x2" edc:desc="Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA">
              <edc:SFRFieldSemantic edc:cname="LEVEL0" edc:desc="For PIO12 = 2mA, PIO24 = 4mA" edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL1" edc:desc="For PIO12 = 4mA, PIO24 = 8mA" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL2" edc:desc="For PIO12 = 8mA, PIO24 = 16mA" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL3" edc:desc="For PIO12 = 12mA, PIO24 = 24mA" edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL2P145" edc:nzwidth="0x20" edc:access="--------------------------nn---n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x31" edc:_addr="0x40081694">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="SLEW_CTRL" edc:nzwidth="0x1" edc:desc="Selects slew rate on the pin. 1=fast 0=slow"/>
            <edc:AdjustPoint edc:offset="0x3"/>
            <edc:SFRFieldDef edc:cname="DRIV_STREN" edc:nzwidth="0x2" edc:desc="Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA">
              <edc:SFRFieldSemantic edc:cname="LEVEL0" edc:desc="For PIO12 = 2mA, PIO24 = 4mA" edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL1" edc:desc="For PIO12 = 4mA, PIO24 = 8mA" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL2" edc:desc="For PIO12 = 8mA, PIO24 = 16mA" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL3" edc:desc="For PIO12 = 12mA, PIO24 = 24mA" edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL2P146" edc:nzwidth="0x20" edc:access="--------------------------nn---n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x31" edc:_addr="0x40081698">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="SLEW_CTRL" edc:nzwidth="0x1" edc:desc="Selects slew rate on the pin. 1=fast 0=slow"/>
            <edc:AdjustPoint edc:offset="0x3"/>
            <edc:SFRFieldDef edc:cname="DRIV_STREN" edc:nzwidth="0x2" edc:desc="Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA">
              <edc:SFRFieldSemantic edc:cname="LEVEL0" edc:desc="For PIO12 = 2mA, PIO24 = 4mA" edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL1" edc:desc="For PIO12 = 4mA, PIO24 = 8mA" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL2" edc:desc="For PIO12 = 8mA, PIO24 = 16mA" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL3" edc:desc="For PIO12 = 12mA, PIO24 = 24mA" edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL2P147" edc:nzwidth="0x20" edc:access="--------------------------nn---n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x31" edc:_addr="0x4008169C">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="SLEW_CTRL" edc:nzwidth="0x1" edc:desc="Selects slew rate on the pin. 1=fast 0=slow"/>
            <edc:AdjustPoint edc:offset="0x3"/>
            <edc:SFRFieldDef edc:cname="DRIV_STREN" edc:nzwidth="0x2" edc:desc="Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA">
              <edc:SFRFieldSemantic edc:cname="LEVEL0" edc:desc="For PIO12 = 2mA, PIO24 = 4mA" edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL1" edc:desc="For PIO12 = 4mA, PIO24 = 8mA" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL2" edc:desc="For PIO12 = 8mA, PIO24 = 16mA" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL3" edc:desc="For PIO12 = 12mA, PIO24 = 24mA" edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL2P150" edc:nzwidth="0x20" edc:access="--------------------------nn---n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x31" edc:_addr="0x400816A0">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="SLEW_CTRL" edc:nzwidth="0x1" edc:desc="Selects slew rate on the pin. 1=fast 0=slow"/>
            <edc:AdjustPoint edc:offset="0x3"/>
            <edc:SFRFieldDef edc:cname="DRIV_STREN" edc:nzwidth="0x2" edc:desc="Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA">
              <edc:SFRFieldSemantic edc:cname="LEVEL0" edc:desc="For PIO12 = 2mA, PIO24 = 4mA" edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL1" edc:desc="For PIO12 = 4mA, PIO24 = 8mA" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL2" edc:desc="For PIO12 = 8mA, PIO24 = 16mA" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL3" edc:desc="For PIO12 = 12mA, PIO24 = 24mA" edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL2P151" edc:nzwidth="0x20" edc:access="--------------------------nn---n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x31" edc:_addr="0x400816A4">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="SLEW_CTRL" edc:nzwidth="0x1" edc:desc="Selects slew rate on the pin. 1=fast 0=slow"/>
            <edc:AdjustPoint edc:offset="0x3"/>
            <edc:SFRFieldDef edc:cname="DRIV_STREN" edc:nzwidth="0x2" edc:desc="Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA">
              <edc:SFRFieldSemantic edc:cname="LEVEL0" edc:desc="For PIO12 = 2mA, PIO24 = 4mA" edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL1" edc:desc="For PIO12 = 4mA, PIO24 = 8mA" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL2" edc:desc="For PIO12 = 8mA, PIO24 = 16mA" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL3" edc:desc="For PIO12 = 12mA, PIO24 = 24mA" edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL2P152" edc:nzwidth="0x20" edc:access="--------------------------nn---n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x31" edc:_addr="0x400816A8">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="SLEW_CTRL" edc:nzwidth="0x1" edc:desc="Selects slew rate on the pin. 1=fast 0=slow"/>
            <edc:AdjustPoint edc:offset="0x3"/>
            <edc:SFRFieldDef edc:cname="DRIV_STREN" edc:nzwidth="0x2" edc:desc="Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA">
              <edc:SFRFieldSemantic edc:cname="LEVEL0" edc:desc="For PIO12 = 2mA, PIO24 = 4mA" edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL1" edc:desc="For PIO12 = 4mA, PIO24 = 8mA" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL2" edc:desc="For PIO12 = 8mA, PIO24 = 16mA" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL3" edc:desc="For PIO12 = 12mA, PIO24 = 24mA" edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL2P153" edc:nzwidth="0x20" edc:access="--------------------------nn---n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x31" edc:_addr="0x400816AC">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="SLEW_CTRL" edc:nzwidth="0x1" edc:desc="Selects slew rate on the pin. 1=fast 0=slow"/>
            <edc:AdjustPoint edc:offset="0x3"/>
            <edc:SFRFieldDef edc:cname="DRIV_STREN" edc:nzwidth="0x2" edc:desc="Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA">
              <edc:SFRFieldSemantic edc:cname="LEVEL0" edc:desc="For PIO12 = 2mA, PIO24 = 4mA" edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL1" edc:desc="For PIO12 = 4mA, PIO24 = 8mA" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL2" edc:desc="For PIO12 = 8mA, PIO24 = 16mA" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL3" edc:desc="For PIO12 = 12mA, PIO24 = 24mA" edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL2P154" edc:nzwidth="0x20" edc:access="--------------------------nn---n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x31" edc:_addr="0x400816B0">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="SLEW_CTRL" edc:nzwidth="0x1" edc:desc="Selects slew rate on the pin. 1=fast 0=slow"/>
            <edc:AdjustPoint edc:offset="0x3"/>
            <edc:SFRFieldDef edc:cname="DRIV_STREN" edc:nzwidth="0x2" edc:desc="Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA">
              <edc:SFRFieldSemantic edc:cname="LEVEL0" edc:desc="For PIO12 = 2mA, PIO24 = 4mA" edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL1" edc:desc="For PIO12 = 4mA, PIO24 = 8mA" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL2" edc:desc="For PIO12 = 8mA, PIO24 = 16mA" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL3" edc:desc="For PIO12 = 12mA, PIO24 = 24mA" edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL2P155" edc:nzwidth="0x20" edc:access="--------------------------nn---n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x31" edc:_addr="0x400816B4">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="SLEW_CTRL" edc:nzwidth="0x1" edc:desc="Selects slew rate on the pin. 1=fast 0=slow"/>
            <edc:AdjustPoint edc:offset="0x3"/>
            <edc:SFRFieldDef edc:cname="DRIV_STREN" edc:nzwidth="0x2" edc:desc="Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA">
              <edc:SFRFieldSemantic edc:cname="LEVEL0" edc:desc="For PIO12 = 2mA, PIO24 = 4mA" edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL1" edc:desc="For PIO12 = 4mA, PIO24 = 8mA" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL2" edc:desc="For PIO12 = 8mA, PIO24 = 16mA" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL3" edc:desc="For PIO12 = 12mA, PIO24 = 24mA" edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL2P156" edc:nzwidth="0x20" edc:access="--------------------------nn---n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x31" edc:_addr="0x400816B8">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="SLEW_CTRL" edc:nzwidth="0x1" edc:desc="Selects slew rate on the pin. 1=fast 0=slow"/>
            <edc:AdjustPoint edc:offset="0x3"/>
            <edc:SFRFieldDef edc:cname="DRIV_STREN" edc:nzwidth="0x2" edc:desc="Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA">
              <edc:SFRFieldSemantic edc:cname="LEVEL0" edc:desc="For PIO12 = 2mA, PIO24 = 4mA" edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL1" edc:desc="For PIO12 = 4mA, PIO24 = 8mA" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL2" edc:desc="For PIO12 = 8mA, PIO24 = 16mA" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL3" edc:desc="For PIO12 = 12mA, PIO24 = 24mA" edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL2P157" edc:nzwidth="0x20" edc:access="--------------------------nn---n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x31" edc:_addr="0x400816BC">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="SLEW_CTRL" edc:nzwidth="0x1" edc:desc="Selects slew rate on the pin. 1=fast 0=slow"/>
            <edc:AdjustPoint edc:offset="0x3"/>
            <edc:SFRFieldDef edc:cname="DRIV_STREN" edc:nzwidth="0x2" edc:desc="Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA">
              <edc:SFRFieldSemantic edc:cname="LEVEL0" edc:desc="For PIO12 = 2mA, PIO24 = 4mA" edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL1" edc:desc="For PIO12 = 4mA, PIO24 = 8mA" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL2" edc:desc="For PIO12 = 8mA, PIO24 = 16mA" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL3" edc:desc="For PIO12 = 12mA, PIO24 = 24mA" edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL2P160" edc:nzwidth="0x20" edc:access="--------------------------nn---n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x31" edc:_addr="0x400816C0">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="SLEW_CTRL" edc:nzwidth="0x1" edc:desc="Selects slew rate on the pin. 1=fast 0=slow"/>
            <edc:AdjustPoint edc:offset="0x3"/>
            <edc:SFRFieldDef edc:cname="DRIV_STREN" edc:nzwidth="0x2" edc:desc="Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA">
              <edc:SFRFieldSemantic edc:cname="LEVEL0" edc:desc="For PIO12 = 2mA, PIO24 = 4mA" edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL1" edc:desc="For PIO12 = 4mA, PIO24 = 8mA" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL2" edc:desc="For PIO12 = 8mA, PIO24 = 16mA" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL3" edc:desc="For PIO12 = 12mA, PIO24 = 24mA" edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL2P161" edc:nzwidth="0x20" edc:access="--------------------------nn---n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x31" edc:_addr="0x400816C4">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="SLEW_CTRL" edc:nzwidth="0x1" edc:desc="Selects slew rate on the pin. 1=fast 0=slow"/>
            <edc:AdjustPoint edc:offset="0x3"/>
            <edc:SFRFieldDef edc:cname="DRIV_STREN" edc:nzwidth="0x2" edc:desc="Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA">
              <edc:SFRFieldSemantic edc:cname="LEVEL0" edc:desc="For PIO12 = 2mA, PIO24 = 4mA" edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL1" edc:desc="For PIO12 = 4mA, PIO24 = 8mA" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL2" edc:desc="For PIO12 = 8mA, PIO24 = 16mA" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL3" edc:desc="For PIO12 = 12mA, PIO24 = 24mA" edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL2P162" edc:nzwidth="0x20" edc:access="--------------------------nn---n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x31" edc:_addr="0x400816C8">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="SLEW_CTRL" edc:nzwidth="0x1" edc:desc="Selects slew rate on the pin. 1=fast 0=slow"/>
            <edc:AdjustPoint edc:offset="0x3"/>
            <edc:SFRFieldDef edc:cname="DRIV_STREN" edc:nzwidth="0x2" edc:desc="Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA">
              <edc:SFRFieldSemantic edc:cname="LEVEL0" edc:desc="For PIO12 = 2mA, PIO24 = 4mA" edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL1" edc:desc="For PIO12 = 4mA, PIO24 = 8mA" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL2" edc:desc="For PIO12 = 8mA, PIO24 = 16mA" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL3" edc:desc="For PIO12 = 12mA, PIO24 = 24mA" edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL2P163" edc:nzwidth="0x20" edc:access="--------------------------nn---n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x31" edc:_addr="0x400816CC">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="SLEW_CTRL" edc:nzwidth="0x1" edc:desc="Selects slew rate on the pin. 1=fast 0=slow"/>
            <edc:AdjustPoint edc:offset="0x3"/>
            <edc:SFRFieldDef edc:cname="DRIV_STREN" edc:nzwidth="0x2" edc:desc="Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA">
              <edc:SFRFieldSemantic edc:cname="LEVEL0" edc:desc="For PIO12 = 2mA, PIO24 = 4mA" edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL1" edc:desc="For PIO12 = 4mA, PIO24 = 8mA" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL2" edc:desc="For PIO12 = 8mA, PIO24 = 16mA" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL3" edc:desc="For PIO12 = 12mA, PIO24 = 24mA" edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL2P164" edc:nzwidth="0x20" edc:access="--------------------------nn---n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x31" edc:_addr="0x400816D0">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="SLEW_CTRL" edc:nzwidth="0x1" edc:desc="Selects slew rate on the pin. 1=fast 0=slow"/>
            <edc:AdjustPoint edc:offset="0x3"/>
            <edc:SFRFieldDef edc:cname="DRIV_STREN" edc:nzwidth="0x2" edc:desc="Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA">
              <edc:SFRFieldSemantic edc:cname="LEVEL0" edc:desc="For PIO12 = 2mA, PIO24 = 4mA" edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL1" edc:desc="For PIO12 = 4mA, PIO24 = 8mA" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL2" edc:desc="For PIO12 = 8mA, PIO24 = 16mA" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL3" edc:desc="For PIO12 = 12mA, PIO24 = 24mA" edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL2P165" edc:nzwidth="0x20" edc:access="--------------------------nn---n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x31" edc:_addr="0x400816D4">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="SLEW_CTRL" edc:nzwidth="0x1" edc:desc="Selects slew rate on the pin. 1=fast 0=slow"/>
            <edc:AdjustPoint edc:offset="0x3"/>
            <edc:SFRFieldDef edc:cname="DRIV_STREN" edc:nzwidth="0x2" edc:desc="Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA">
              <edc:SFRFieldSemantic edc:cname="LEVEL0" edc:desc="For PIO12 = 2mA, PIO24 = 4mA" edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL1" edc:desc="For PIO12 = 4mA, PIO24 = 8mA" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL2" edc:desc="For PIO12 = 8mA, PIO24 = 16mA" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL3" edc:desc="For PIO12 = 12mA, PIO24 = 24mA" edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL2P166" edc:nzwidth="0x20" edc:access="--------------------------nn---n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x31" edc:_addr="0x400816D8">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="SLEW_CTRL" edc:nzwidth="0x1" edc:desc="Selects slew rate on the pin. 1=fast 0=slow"/>
            <edc:AdjustPoint edc:offset="0x3"/>
            <edc:SFRFieldDef edc:cname="DRIV_STREN" edc:nzwidth="0x2" edc:desc="Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA">
              <edc:SFRFieldSemantic edc:cname="LEVEL0" edc:desc="For PIO12 = 2mA, PIO24 = 4mA" edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL1" edc:desc="For PIO12 = 4mA, PIO24 = 8mA" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL2" edc:desc="For PIO12 = 8mA, PIO24 = 16mA" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL3" edc:desc="For PIO12 = 12mA, PIO24 = 24mA" edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL2P167" edc:nzwidth="0x20" edc:access="--------------------------nn---n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x31" edc:_addr="0x400816DC">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="SLEW_CTRL" edc:nzwidth="0x1" edc:desc="Selects slew rate on the pin. 1=fast 0=slow"/>
            <edc:AdjustPoint edc:offset="0x3"/>
            <edc:SFRFieldDef edc:cname="DRIV_STREN" edc:nzwidth="0x2" edc:desc="Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA">
              <edc:SFRFieldSemantic edc:cname="LEVEL0" edc:desc="For PIO12 = 2mA, PIO24 = 4mA" edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL1" edc:desc="For PIO12 = 4mA, PIO24 = 8mA" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL2" edc:desc="For PIO12 = 8mA, PIO24 = 16mA" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL3" edc:desc="For PIO12 = 12mA, PIO24 = 24mA" edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL2P170" edc:nzwidth="0x20" edc:access="--------------------------nn---n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x31" edc:_addr="0x400816E0">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="SLEW_CTRL" edc:nzwidth="0x1" edc:desc="Selects slew rate on the pin. 1=fast 0=slow"/>
            <edc:AdjustPoint edc:offset="0x3"/>
            <edc:SFRFieldDef edc:cname="DRIV_STREN" edc:nzwidth="0x2" edc:desc="Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA">
              <edc:SFRFieldSemantic edc:cname="LEVEL0" edc:desc="For PIO12 = 2mA, PIO24 = 4mA" edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL1" edc:desc="For PIO12 = 4mA, PIO24 = 8mA" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL2" edc:desc="For PIO12 = 8mA, PIO24 = 16mA" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL3" edc:desc="For PIO12 = 12mA, PIO24 = 24mA" edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL2P171" edc:nzwidth="0x20" edc:access="--------------------------nn---n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x31" edc:_addr="0x400816E4">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="SLEW_CTRL" edc:nzwidth="0x1" edc:desc="Selects slew rate on the pin. 1=fast 0=slow"/>
            <edc:AdjustPoint edc:offset="0x3"/>
            <edc:SFRFieldDef edc:cname="DRIV_STREN" edc:nzwidth="0x2" edc:desc="Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA">
              <edc:SFRFieldSemantic edc:cname="LEVEL0" edc:desc="For PIO12 = 2mA, PIO24 = 4mA" edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL1" edc:desc="For PIO12 = 4mA, PIO24 = 8mA" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL2" edc:desc="For PIO12 = 8mA, PIO24 = 16mA" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL3" edc:desc="For PIO12 = 12mA, PIO24 = 24mA" edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL2P172" edc:nzwidth="0x20" edc:access="--------------------------nn---n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x31" edc:_addr="0x400816E8">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="SLEW_CTRL" edc:nzwidth="0x1" edc:desc="Selects slew rate on the pin. 1=fast 0=slow"/>
            <edc:AdjustPoint edc:offset="0x3"/>
            <edc:SFRFieldDef edc:cname="DRIV_STREN" edc:nzwidth="0x2" edc:desc="Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA">
              <edc:SFRFieldSemantic edc:cname="LEVEL0" edc:desc="For PIO12 = 2mA, PIO24 = 4mA" edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL1" edc:desc="For PIO12 = 4mA, PIO24 = 8mA" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL2" edc:desc="For PIO12 = 8mA, PIO24 = 16mA" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL3" edc:desc="For PIO12 = 12mA, PIO24 = 24mA" edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL2P173" edc:nzwidth="0x20" edc:access="--------------------------nn---n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x31" edc:_addr="0x400816EC">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="SLEW_CTRL" edc:nzwidth="0x1" edc:desc="Selects slew rate on the pin. 1=fast 0=slow"/>
            <edc:AdjustPoint edc:offset="0x3"/>
            <edc:SFRFieldDef edc:cname="DRIV_STREN" edc:nzwidth="0x2" edc:desc="Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA">
              <edc:SFRFieldSemantic edc:cname="LEVEL0" edc:desc="For PIO12 = 2mA, PIO24 = 4mA" edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL1" edc:desc="For PIO12 = 4mA, PIO24 = 8mA" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL2" edc:desc="For PIO12 = 8mA, PIO24 = 16mA" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL3" edc:desc="For PIO12 = 12mA, PIO24 = 24mA" edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL2P174" edc:nzwidth="0x20" edc:access="--------------------------nn---n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x31" edc:_addr="0x400816F0">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="SLEW_CTRL" edc:nzwidth="0x1" edc:desc="Selects slew rate on the pin. 1=fast 0=slow"/>
            <edc:AdjustPoint edc:offset="0x3"/>
            <edc:SFRFieldDef edc:cname="DRIV_STREN" edc:nzwidth="0x2" edc:desc="Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA">
              <edc:SFRFieldSemantic edc:cname="LEVEL0" edc:desc="For PIO12 = 2mA, PIO24 = 4mA" edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL1" edc:desc="For PIO12 = 4mA, PIO24 = 8mA" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL2" edc:desc="For PIO12 = 8mA, PIO24 = 16mA" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL3" edc:desc="For PIO12 = 12mA, PIO24 = 24mA" edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL2P175" edc:nzwidth="0x20" edc:access="--------------------------nn---n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x31" edc:_addr="0x400816F4">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="SLEW_CTRL" edc:nzwidth="0x1" edc:desc="Selects slew rate on the pin. 1=fast 0=slow"/>
            <edc:AdjustPoint edc:offset="0x3"/>
            <edc:SFRFieldDef edc:cname="DRIV_STREN" edc:nzwidth="0x2" edc:desc="Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA">
              <edc:SFRFieldSemantic edc:cname="LEVEL0" edc:desc="For PIO12 = 2mA, PIO24 = 4mA" edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL1" edc:desc="For PIO12 = 4mA, PIO24 = 8mA" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL2" edc:desc="For PIO12 = 8mA, PIO24 = 16mA" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL3" edc:desc="For PIO12 = 12mA, PIO24 = 24mA" edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL2P176" edc:nzwidth="0x20" edc:access="--------------------------nn---n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x31" edc:_addr="0x400816F8">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="SLEW_CTRL" edc:nzwidth="0x1" edc:desc="Selects slew rate on the pin. 1=fast 0=slow"/>
            <edc:AdjustPoint edc:offset="0x3"/>
            <edc:SFRFieldDef edc:cname="DRIV_STREN" edc:nzwidth="0x2" edc:desc="Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA">
              <edc:SFRFieldSemantic edc:cname="LEVEL0" edc:desc="For PIO12 = 2mA, PIO24 = 4mA" edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL1" edc:desc="For PIO12 = 4mA, PIO24 = 8mA" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL2" edc:desc="For PIO12 = 8mA, PIO24 = 16mA" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL3" edc:desc="For PIO12 = 12mA, PIO24 = 24mA" edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL2P177" edc:nzwidth="0x20" edc:access="--------------------------nn---n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x31" edc:_addr="0x400816FC">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="SLEW_CTRL" edc:nzwidth="0x1" edc:desc="Selects slew rate on the pin. 1=fast 0=slow"/>
            <edc:AdjustPoint edc:offset="0x3"/>
            <edc:SFRFieldDef edc:cname="DRIV_STREN" edc:nzwidth="0x2" edc:desc="Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA">
              <edc:SFRFieldSemantic edc:cname="LEVEL0" edc:desc="For PIO12 = 2mA, PIO24 = 4mA" edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL1" edc:desc="For PIO12 = 4mA, PIO24 = 8mA" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL2" edc:desc="For PIO12 = 8mA, PIO24 = 16mA" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL3" edc:desc="For PIO12 = 12mA, PIO24 = 24mA" edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL2P200" edc:nzwidth="0x20" edc:access="--------------------------nn---n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x31" edc:_addr="0x40081700">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="SLEW_CTRL" edc:nzwidth="0x1" edc:desc="Selects slew rate on the pin. 1=fast 0=slow"/>
            <edc:AdjustPoint edc:offset="0x3"/>
            <edc:SFRFieldDef edc:cname="DRIV_STREN" edc:nzwidth="0x2" edc:desc="Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA">
              <edc:SFRFieldSemantic edc:cname="LEVEL0" edc:desc="For PIO12 = 2mA, PIO24 = 4mA" edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL1" edc:desc="For PIO12 = 4mA, PIO24 = 8mA" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL2" edc:desc="For PIO12 = 8mA, PIO24 = 16mA" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL3" edc:desc="For PIO12 = 12mA, PIO24 = 24mA" edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL2P201" edc:nzwidth="0x20" edc:access="--------------------------nn---n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x31" edc:_addr="0x40081704">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="SLEW_CTRL" edc:nzwidth="0x1" edc:desc="Selects slew rate on the pin. 1=fast 0=slow"/>
            <edc:AdjustPoint edc:offset="0x3"/>
            <edc:SFRFieldDef edc:cname="DRIV_STREN" edc:nzwidth="0x2" edc:desc="Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA">
              <edc:SFRFieldSemantic edc:cname="LEVEL0" edc:desc="For PIO12 = 2mA, PIO24 = 4mA" edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL1" edc:desc="For PIO12 = 4mA, PIO24 = 8mA" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL2" edc:desc="For PIO12 = 8mA, PIO24 = 16mA" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL3" edc:desc="For PIO12 = 12mA, PIO24 = 24mA" edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL2P202" edc:nzwidth="0x20" edc:access="--------------------------nn---n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x31" edc:_addr="0x40081708">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="SLEW_CTRL" edc:nzwidth="0x1" edc:desc="Selects slew rate on the pin. 1=fast 0=slow"/>
            <edc:AdjustPoint edc:offset="0x3"/>
            <edc:SFRFieldDef edc:cname="DRIV_STREN" edc:nzwidth="0x2" edc:desc="Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA">
              <edc:SFRFieldSemantic edc:cname="LEVEL0" edc:desc="For PIO12 = 2mA, PIO24 = 4mA" edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL1" edc:desc="For PIO12 = 4mA, PIO24 = 8mA" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL2" edc:desc="For PIO12 = 8mA, PIO24 = 16mA" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL3" edc:desc="For PIO12 = 12mA, PIO24 = 24mA" edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL2P203" edc:nzwidth="0x20" edc:access="--------------------------nn---n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x31" edc:_addr="0x4008170C">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="SLEW_CTRL" edc:nzwidth="0x1" edc:desc="Selects slew rate on the pin. 1=fast 0=slow"/>
            <edc:AdjustPoint edc:offset="0x3"/>
            <edc:SFRFieldDef edc:cname="DRIV_STREN" edc:nzwidth="0x2" edc:desc="Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA">
              <edc:SFRFieldSemantic edc:cname="LEVEL0" edc:desc="For PIO12 = 2mA, PIO24 = 4mA" edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL1" edc:desc="For PIO12 = 4mA, PIO24 = 8mA" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL2" edc:desc="For PIO12 = 8mA, PIO24 = 16mA" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL3" edc:desc="For PIO12 = 12mA, PIO24 = 24mA" edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL2P204" edc:nzwidth="0x20" edc:access="--------------------------nn---n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x31" edc:_addr="0x40081710">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="SLEW_CTRL" edc:nzwidth="0x1" edc:desc="Selects slew rate on the pin. 1=fast 0=slow"/>
            <edc:AdjustPoint edc:offset="0x3"/>
            <edc:SFRFieldDef edc:cname="DRIV_STREN" edc:nzwidth="0x2" edc:desc="Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA">
              <edc:SFRFieldSemantic edc:cname="LEVEL0" edc:desc="For PIO12 = 2mA, PIO24 = 4mA" edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL1" edc:desc="For PIO12 = 4mA, PIO24 = 8mA" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL2" edc:desc="For PIO12 = 8mA, PIO24 = 16mA" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL3" edc:desc="For PIO12 = 12mA, PIO24 = 24mA" edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL2P205" edc:nzwidth="0x20" edc:access="--------------------------nn---n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x31" edc:_addr="0x40081714">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="SLEW_CTRL" edc:nzwidth="0x1" edc:desc="Selects slew rate on the pin. 1=fast 0=slow"/>
            <edc:AdjustPoint edc:offset="0x3"/>
            <edc:SFRFieldDef edc:cname="DRIV_STREN" edc:nzwidth="0x2" edc:desc="Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA">
              <edc:SFRFieldSemantic edc:cname="LEVEL0" edc:desc="For PIO12 = 2mA, PIO24 = 4mA" edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL1" edc:desc="For PIO12 = 4mA, PIO24 = 8mA" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL2" edc:desc="For PIO12 = 8mA, PIO24 = 16mA" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL3" edc:desc="For PIO12 = 12mA, PIO24 = 24mA" edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL2P206" edc:nzwidth="0x20" edc:access="--------------------------nn---n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x31" edc:_addr="0x40081718">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="SLEW_CTRL" edc:nzwidth="0x1" edc:desc="Selects slew rate on the pin. 1=fast 0=slow"/>
            <edc:AdjustPoint edc:offset="0x3"/>
            <edc:SFRFieldDef edc:cname="DRIV_STREN" edc:nzwidth="0x2" edc:desc="Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA">
              <edc:SFRFieldSemantic edc:cname="LEVEL0" edc:desc="For PIO12 = 2mA, PIO24 = 4mA" edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL1" edc:desc="For PIO12 = 4mA, PIO24 = 8mA" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL2" edc:desc="For PIO12 = 8mA, PIO24 = 16mA" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL3" edc:desc="For PIO12 = 12mA, PIO24 = 24mA" edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL2P207" edc:nzwidth="0x20" edc:access="--------------------------nn---n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x31" edc:_addr="0x4008171C">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="SLEW_CTRL" edc:nzwidth="0x1" edc:desc="Selects slew rate on the pin. 1=fast 0=slow"/>
            <edc:AdjustPoint edc:offset="0x3"/>
            <edc:SFRFieldDef edc:cname="DRIV_STREN" edc:nzwidth="0x2" edc:desc="Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA">
              <edc:SFRFieldSemantic edc:cname="LEVEL0" edc:desc="For PIO12 = 2mA, PIO24 = 4mA" edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL1" edc:desc="For PIO12 = 4mA, PIO24 = 8mA" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL2" edc:desc="For PIO12 = 8mA, PIO24 = 16mA" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL3" edc:desc="For PIO12 = 12mA, PIO24 = 24mA" edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL2P210" edc:nzwidth="0x20" edc:access="--------------------------nn---n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x31" edc:_addr="0x40081720">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="SLEW_CTRL" edc:nzwidth="0x1" edc:desc="Selects slew rate on the pin. 1=fast 0=slow"/>
            <edc:AdjustPoint edc:offset="0x3"/>
            <edc:SFRFieldDef edc:cname="DRIV_STREN" edc:nzwidth="0x2" edc:desc="Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA">
              <edc:SFRFieldSemantic edc:cname="LEVEL0" edc:desc="For PIO12 = 2mA, PIO24 = 4mA" edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL1" edc:desc="For PIO12 = 4mA, PIO24 = 8mA" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL2" edc:desc="For PIO12 = 8mA, PIO24 = 16mA" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL3" edc:desc="For PIO12 = 12mA, PIO24 = 24mA" edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL2P211" edc:nzwidth="0x20" edc:access="--------------------------nn---n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x31" edc:_addr="0x40081724">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="SLEW_CTRL" edc:nzwidth="0x1" edc:desc="Selects slew rate on the pin. 1=fast 0=slow"/>
            <edc:AdjustPoint edc:offset="0x3"/>
            <edc:SFRFieldDef edc:cname="DRIV_STREN" edc:nzwidth="0x2" edc:desc="Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA">
              <edc:SFRFieldSemantic edc:cname="LEVEL0" edc:desc="For PIO12 = 2mA, PIO24 = 4mA" edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL1" edc:desc="For PIO12 = 4mA, PIO24 = 8mA" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL2" edc:desc="For PIO12 = 8mA, PIO24 = 16mA" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL3" edc:desc="For PIO12 = 12mA, PIO24 = 24mA" edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL2P212" edc:nzwidth="0x20" edc:access="--------------------------nn---n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x31" edc:_addr="0x40081728">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="SLEW_CTRL" edc:nzwidth="0x1" edc:desc="Selects slew rate on the pin. 1=fast 0=slow"/>
            <edc:AdjustPoint edc:offset="0x3"/>
            <edc:SFRFieldDef edc:cname="DRIV_STREN" edc:nzwidth="0x2" edc:desc="Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA">
              <edc:SFRFieldSemantic edc:cname="LEVEL0" edc:desc="For PIO12 = 2mA, PIO24 = 4mA" edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL1" edc:desc="For PIO12 = 4mA, PIO24 = 8mA" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL2" edc:desc="For PIO12 = 8mA, PIO24 = 16mA" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL3" edc:desc="For PIO12 = 12mA, PIO24 = 24mA" edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL2P213" edc:nzwidth="0x20" edc:access="--------------------------nn---n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x31" edc:_addr="0x4008172C">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="SLEW_CTRL" edc:nzwidth="0x1" edc:desc="Selects slew rate on the pin. 1=fast 0=slow"/>
            <edc:AdjustPoint edc:offset="0x3"/>
            <edc:SFRFieldDef edc:cname="DRIV_STREN" edc:nzwidth="0x2" edc:desc="Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA">
              <edc:SFRFieldSemantic edc:cname="LEVEL0" edc:desc="For PIO12 = 2mA, PIO24 = 4mA" edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL1" edc:desc="For PIO12 = 4mA, PIO24 = 8mA" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL2" edc:desc="For PIO12 = 8mA, PIO24 = 16mA" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL3" edc:desc="For PIO12 = 12mA, PIO24 = 24mA" edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL2P214" edc:nzwidth="0x20" edc:access="--------------------------nn---n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x31" edc:_addr="0x40081730">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="SLEW_CTRL" edc:nzwidth="0x1" edc:desc="Selects slew rate on the pin. 1=fast 0=slow"/>
            <edc:AdjustPoint edc:offset="0x3"/>
            <edc:SFRFieldDef edc:cname="DRIV_STREN" edc:nzwidth="0x2" edc:desc="Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA">
              <edc:SFRFieldSemantic edc:cname="LEVEL0" edc:desc="For PIO12 = 2mA, PIO24 = 4mA" edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL1" edc:desc="For PIO12 = 4mA, PIO24 = 8mA" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL2" edc:desc="For PIO12 = 8mA, PIO24 = 16mA" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL3" edc:desc="For PIO12 = 12mA, PIO24 = 24mA" edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL2P215" edc:nzwidth="0x20" edc:access="--------------------------nn---n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x31" edc:_addr="0x40081734">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="SLEW_CTRL" edc:nzwidth="0x1" edc:desc="Selects slew rate on the pin. 1=fast 0=slow"/>
            <edc:AdjustPoint edc:offset="0x3"/>
            <edc:SFRFieldDef edc:cname="DRIV_STREN" edc:nzwidth="0x2" edc:desc="Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA">
              <edc:SFRFieldSemantic edc:cname="LEVEL0" edc:desc="For PIO12 = 2mA, PIO24 = 4mA" edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL1" edc:desc="For PIO12 = 4mA, PIO24 = 8mA" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL2" edc:desc="For PIO12 = 8mA, PIO24 = 16mA" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL3" edc:desc="For PIO12 = 12mA, PIO24 = 24mA" edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL2P216" edc:nzwidth="0x20" edc:access="--------------------------nn---n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x31" edc:_addr="0x40081738">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="SLEW_CTRL" edc:nzwidth="0x1" edc:desc="Selects slew rate on the pin. 1=fast 0=slow"/>
            <edc:AdjustPoint edc:offset="0x3"/>
            <edc:SFRFieldDef edc:cname="DRIV_STREN" edc:nzwidth="0x2" edc:desc="Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA">
              <edc:SFRFieldSemantic edc:cname="LEVEL0" edc:desc="For PIO12 = 2mA, PIO24 = 4mA" edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL1" edc:desc="For PIO12 = 4mA, PIO24 = 8mA" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL2" edc:desc="For PIO12 = 8mA, PIO24 = 16mA" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL3" edc:desc="For PIO12 = 12mA, PIO24 = 24mA" edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL2P217" edc:nzwidth="0x20" edc:access="--------------------------nn---n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x31" edc:_addr="0x4008173C">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="SLEW_CTRL" edc:nzwidth="0x1" edc:desc="Selects slew rate on the pin. 1=fast 0=slow"/>
            <edc:AdjustPoint edc:offset="0x3"/>
            <edc:SFRFieldDef edc:cname="DRIV_STREN" edc:nzwidth="0x2" edc:desc="Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA">
              <edc:SFRFieldSemantic edc:cname="LEVEL0" edc:desc="For PIO12 = 2mA, PIO24 = 4mA" edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL1" edc:desc="For PIO12 = 4mA, PIO24 = 8mA" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL2" edc:desc="For PIO12 = 8mA, PIO24 = 16mA" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL3" edc:desc="For PIO12 = 12mA, PIO24 = 24mA" edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL2P220" edc:nzwidth="0x20" edc:access="--------------------------nn---n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x31" edc:_addr="0x40081740">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="SLEW_CTRL" edc:nzwidth="0x1" edc:desc="Selects slew rate on the pin. 1=fast 0=slow"/>
            <edc:AdjustPoint edc:offset="0x3"/>
            <edc:SFRFieldDef edc:cname="DRIV_STREN" edc:nzwidth="0x2" edc:desc="Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA">
              <edc:SFRFieldSemantic edc:cname="LEVEL0" edc:desc="For PIO12 = 2mA, PIO24 = 4mA" edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL1" edc:desc="For PIO12 = 4mA, PIO24 = 8mA" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL2" edc:desc="For PIO12 = 8mA, PIO24 = 16mA" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL3" edc:desc="For PIO12 = 12mA, PIO24 = 24mA" edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL2P221" edc:nzwidth="0x20" edc:access="--------------------------nn---n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x31" edc:_addr="0x40081744">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="SLEW_CTRL" edc:nzwidth="0x1" edc:desc="Selects slew rate on the pin. 1=fast 0=slow"/>
            <edc:AdjustPoint edc:offset="0x3"/>
            <edc:SFRFieldDef edc:cname="DRIV_STREN" edc:nzwidth="0x2" edc:desc="Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA">
              <edc:SFRFieldSemantic edc:cname="LEVEL0" edc:desc="For PIO12 = 2mA, PIO24 = 4mA" edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL1" edc:desc="For PIO12 = 4mA, PIO24 = 8mA" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL2" edc:desc="For PIO12 = 8mA, PIO24 = 16mA" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL3" edc:desc="For PIO12 = 12mA, PIO24 = 24mA" edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL2P222" edc:nzwidth="0x20" edc:access="--------------------------nn---n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x31" edc:_addr="0x40081748">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="SLEW_CTRL" edc:nzwidth="0x1" edc:desc="Selects slew rate on the pin. 1=fast 0=slow"/>
            <edc:AdjustPoint edc:offset="0x3"/>
            <edc:SFRFieldDef edc:cname="DRIV_STREN" edc:nzwidth="0x2" edc:desc="Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA">
              <edc:SFRFieldSemantic edc:cname="LEVEL0" edc:desc="For PIO12 = 2mA, PIO24 = 4mA" edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL1" edc:desc="For PIO12 = 4mA, PIO24 = 8mA" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL2" edc:desc="For PIO12 = 8mA, PIO24 = 16mA" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL3" edc:desc="For PIO12 = 12mA, PIO24 = 24mA" edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL2P223" edc:nzwidth="0x20" edc:access="--------------------------nn---n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x31" edc:_addr="0x4008174C">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="SLEW_CTRL" edc:nzwidth="0x1" edc:desc="Selects slew rate on the pin. 1=fast 0=slow"/>
            <edc:AdjustPoint edc:offset="0x3"/>
            <edc:SFRFieldDef edc:cname="DRIV_STREN" edc:nzwidth="0x2" edc:desc="Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA">
              <edc:SFRFieldSemantic edc:cname="LEVEL0" edc:desc="For PIO12 = 2mA, PIO24 = 4mA" edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL1" edc:desc="For PIO12 = 4mA, PIO24 = 8mA" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL2" edc:desc="For PIO12 = 8mA, PIO24 = 16mA" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL3" edc:desc="For PIO12 = 12mA, PIO24 = 24mA" edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL2P224" edc:nzwidth="0x20" edc:access="--------------------------nn---n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x31" edc:_addr="0x40081750">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="SLEW_CTRL" edc:nzwidth="0x1" edc:desc="Selects slew rate on the pin. 1=fast 0=slow"/>
            <edc:AdjustPoint edc:offset="0x3"/>
            <edc:SFRFieldDef edc:cname="DRIV_STREN" edc:nzwidth="0x2" edc:desc="Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA">
              <edc:SFRFieldSemantic edc:cname="LEVEL0" edc:desc="For PIO12 = 2mA, PIO24 = 4mA" edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL1" edc:desc="For PIO12 = 4mA, PIO24 = 8mA" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL2" edc:desc="For PIO12 = 8mA, PIO24 = 16mA" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL3" edc:desc="For PIO12 = 12mA, PIO24 = 24mA" edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL2P225" edc:nzwidth="0x20" edc:access="--------------------------nn---n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x31" edc:_addr="0x40081754">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="SLEW_CTRL" edc:nzwidth="0x1" edc:desc="Selects slew rate on the pin. 1=fast 0=slow"/>
            <edc:AdjustPoint edc:offset="0x3"/>
            <edc:SFRFieldDef edc:cname="DRIV_STREN" edc:nzwidth="0x2" edc:desc="Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA">
              <edc:SFRFieldSemantic edc:cname="LEVEL0" edc:desc="For PIO12 = 2mA, PIO24 = 4mA" edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL1" edc:desc="For PIO12 = 4mA, PIO24 = 8mA" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL2" edc:desc="For PIO12 = 8mA, PIO24 = 16mA" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL3" edc:desc="For PIO12 = 12mA, PIO24 = 24mA" edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL2P226" edc:nzwidth="0x20" edc:access="--------------------------nn---n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x31" edc:_addr="0x40081758">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="SLEW_CTRL" edc:nzwidth="0x1" edc:desc="Selects slew rate on the pin. 1=fast 0=slow"/>
            <edc:AdjustPoint edc:offset="0x3"/>
            <edc:SFRFieldDef edc:cname="DRIV_STREN" edc:nzwidth="0x2" edc:desc="Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA">
              <edc:SFRFieldSemantic edc:cname="LEVEL0" edc:desc="For PIO12 = 2mA, PIO24 = 4mA" edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL1" edc:desc="For PIO12 = 4mA, PIO24 = 8mA" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL2" edc:desc="For PIO12 = 8mA, PIO24 = 16mA" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL3" edc:desc="For PIO12 = 12mA, PIO24 = 24mA" edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL2P227" edc:nzwidth="0x20" edc:access="--------------------------nn---n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x31" edc:_addr="0x4008175C">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="SLEW_CTRL" edc:nzwidth="0x1" edc:desc="Selects slew rate on the pin. 1=fast 0=slow"/>
            <edc:AdjustPoint edc:offset="0x3"/>
            <edc:SFRFieldDef edc:cname="DRIV_STREN" edc:nzwidth="0x2" edc:desc="Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA">
              <edc:SFRFieldSemantic edc:cname="LEVEL0" edc:desc="For PIO12 = 2mA, PIO24 = 4mA" edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL1" edc:desc="For PIO12 = 4mA, PIO24 = 8mA" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL2" edc:desc="For PIO12 = 8mA, PIO24 = 16mA" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL3" edc:desc="For PIO12 = 12mA, PIO24 = 24mA" edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL2P230" edc:nzwidth="0x20" edc:access="--------------------------nn---n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x31" edc:_addr="0x40081760">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="SLEW_CTRL" edc:nzwidth="0x1" edc:desc="Selects slew rate on the pin. 1=fast 0=slow"/>
            <edc:AdjustPoint edc:offset="0x3"/>
            <edc:SFRFieldDef edc:cname="DRIV_STREN" edc:nzwidth="0x2" edc:desc="Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA">
              <edc:SFRFieldSemantic edc:cname="LEVEL0" edc:desc="For PIO12 = 2mA, PIO24 = 4mA" edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL1" edc:desc="For PIO12 = 4mA, PIO24 = 8mA" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL2" edc:desc="For PIO12 = 8mA, PIO24 = 16mA" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL3" edc:desc="For PIO12 = 12mA, PIO24 = 24mA" edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL2P231" edc:nzwidth="0x20" edc:access="--------------------------nn---n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x31" edc:_addr="0x40081764">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="SLEW_CTRL" edc:nzwidth="0x1" edc:desc="Selects slew rate on the pin. 1=fast 0=slow"/>
            <edc:AdjustPoint edc:offset="0x3"/>
            <edc:SFRFieldDef edc:cname="DRIV_STREN" edc:nzwidth="0x2" edc:desc="Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA">
              <edc:SFRFieldSemantic edc:cname="LEVEL0" edc:desc="For PIO12 = 2mA, PIO24 = 4mA" edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL1" edc:desc="For PIO12 = 4mA, PIO24 = 8mA" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL2" edc:desc="For PIO12 = 8mA, PIO24 = 16mA" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL3" edc:desc="For PIO12 = 12mA, PIO24 = 24mA" edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL2P232" edc:nzwidth="0x20" edc:access="--------------------------nn---n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x31" edc:_addr="0x40081768">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="SLEW_CTRL" edc:nzwidth="0x1" edc:desc="Selects slew rate on the pin. 1=fast 0=slow"/>
            <edc:AdjustPoint edc:offset="0x3"/>
            <edc:SFRFieldDef edc:cname="DRIV_STREN" edc:nzwidth="0x2" edc:desc="Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA">
              <edc:SFRFieldSemantic edc:cname="LEVEL0" edc:desc="For PIO12 = 2mA, PIO24 = 4mA" edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL1" edc:desc="For PIO12 = 4mA, PIO24 = 8mA" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL2" edc:desc="For PIO12 = 8mA, PIO24 = 16mA" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL3" edc:desc="For PIO12 = 12mA, PIO24 = 24mA" edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL2P233" edc:nzwidth="0x20" edc:access="--------------------------nn---n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x31" edc:_addr="0x4008176C">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="SLEW_CTRL" edc:nzwidth="0x1" edc:desc="Selects slew rate on the pin. 1=fast 0=slow"/>
            <edc:AdjustPoint edc:offset="0x3"/>
            <edc:SFRFieldDef edc:cname="DRIV_STREN" edc:nzwidth="0x2" edc:desc="Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA">
              <edc:SFRFieldSemantic edc:cname="LEVEL0" edc:desc="For PIO12 = 2mA, PIO24 = 4mA" edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL1" edc:desc="For PIO12 = 4mA, PIO24 = 8mA" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL2" edc:desc="For PIO12 = 8mA, PIO24 = 16mA" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL3" edc:desc="For PIO12 = 12mA, PIO24 = 24mA" edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL2P234" edc:nzwidth="0x20" edc:access="--------------------------nn---n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x31" edc:_addr="0x40081770">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="SLEW_CTRL" edc:nzwidth="0x1" edc:desc="Selects slew rate on the pin. 1=fast 0=slow"/>
            <edc:AdjustPoint edc:offset="0x3"/>
            <edc:SFRFieldDef edc:cname="DRIV_STREN" edc:nzwidth="0x2" edc:desc="Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA">
              <edc:SFRFieldSemantic edc:cname="LEVEL0" edc:desc="For PIO12 = 2mA, PIO24 = 4mA" edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL1" edc:desc="For PIO12 = 4mA, PIO24 = 8mA" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL2" edc:desc="For PIO12 = 8mA, PIO24 = 16mA" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL3" edc:desc="For PIO12 = 12mA, PIO24 = 24mA" edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL2P235" edc:nzwidth="0x20" edc:access="--------------------------nn---n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x31" edc:_addr="0x40081774">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="SLEW_CTRL" edc:nzwidth="0x1" edc:desc="Selects slew rate on the pin. 1=fast 0=slow"/>
            <edc:AdjustPoint edc:offset="0x3"/>
            <edc:SFRFieldDef edc:cname="DRIV_STREN" edc:nzwidth="0x2" edc:desc="Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA">
              <edc:SFRFieldSemantic edc:cname="LEVEL0" edc:desc="For PIO12 = 2mA, PIO24 = 4mA" edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL1" edc:desc="For PIO12 = 4mA, PIO24 = 8mA" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL2" edc:desc="For PIO12 = 8mA, PIO24 = 16mA" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL3" edc:desc="For PIO12 = 12mA, PIO24 = 24mA" edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL2P236" edc:nzwidth="0x20" edc:access="--------------------------nn---n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x31" edc:_addr="0x40081778">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="SLEW_CTRL" edc:nzwidth="0x1" edc:desc="Selects slew rate on the pin. 1=fast 0=slow"/>
            <edc:AdjustPoint edc:offset="0x3"/>
            <edc:SFRFieldDef edc:cname="DRIV_STREN" edc:nzwidth="0x2" edc:desc="Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA">
              <edc:SFRFieldSemantic edc:cname="LEVEL0" edc:desc="For PIO12 = 2mA, PIO24 = 4mA" edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL1" edc:desc="For PIO12 = 4mA, PIO24 = 8mA" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL2" edc:desc="For PIO12 = 8mA, PIO24 = 16mA" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL3" edc:desc="For PIO12 = 12mA, PIO24 = 24mA" edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL2P237" edc:nzwidth="0x20" edc:access="--------------------------nn---n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x31" edc:_addr="0x4008177C">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="SLEW_CTRL" edc:nzwidth="0x1" edc:desc="Selects slew rate on the pin. 1=fast 0=slow"/>
            <edc:AdjustPoint edc:offset="0x3"/>
            <edc:SFRFieldDef edc:cname="DRIV_STREN" edc:nzwidth="0x2" edc:desc="Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA">
              <edc:SFRFieldSemantic edc:cname="LEVEL0" edc:desc="For PIO12 = 2mA, PIO24 = 4mA" edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL1" edc:desc="For PIO12 = 4mA, PIO24 = 8mA" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL2" edc:desc="For PIO12 = 8mA, PIO24 = 16mA" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL3" edc:desc="For PIO12 = 12mA, PIO24 = 24mA" edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL2P240" edc:nzwidth="0x20" edc:access="--------------------------nn---n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x31" edc:_addr="0x40081780">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="SLEW_CTRL" edc:nzwidth="0x1" edc:desc="Selects slew rate on the pin. 1=fast 0=slow"/>
            <edc:AdjustPoint edc:offset="0x3"/>
            <edc:SFRFieldDef edc:cname="DRIV_STREN" edc:nzwidth="0x2" edc:desc="Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA">
              <edc:SFRFieldSemantic edc:cname="LEVEL0" edc:desc="For PIO12 = 2mA, PIO24 = 4mA" edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL1" edc:desc="For PIO12 = 4mA, PIO24 = 8mA" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL2" edc:desc="For PIO12 = 8mA, PIO24 = 16mA" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL3" edc:desc="For PIO12 = 12mA, PIO24 = 24mA" edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL2P241" edc:nzwidth="0x20" edc:access="--------------------------nn---n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x31" edc:_addr="0x40081784">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="SLEW_CTRL" edc:nzwidth="0x1" edc:desc="Selects slew rate on the pin. 1=fast 0=slow"/>
            <edc:AdjustPoint edc:offset="0x3"/>
            <edc:SFRFieldDef edc:cname="DRIV_STREN" edc:nzwidth="0x2" edc:desc="Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA">
              <edc:SFRFieldSemantic edc:cname="LEVEL0" edc:desc="For PIO12 = 2mA, PIO24 = 4mA" edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL1" edc:desc="For PIO12 = 4mA, PIO24 = 8mA" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL2" edc:desc="For PIO12 = 8mA, PIO24 = 16mA" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL3" edc:desc="For PIO12 = 12mA, PIO24 = 24mA" edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL2P242" edc:nzwidth="0x20" edc:access="--------------------------nn---n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x31" edc:_addr="0x40081788">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="SLEW_CTRL" edc:nzwidth="0x1" edc:desc="Selects slew rate on the pin. 1=fast 0=slow"/>
            <edc:AdjustPoint edc:offset="0x3"/>
            <edc:SFRFieldDef edc:cname="DRIV_STREN" edc:nzwidth="0x2" edc:desc="Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA">
              <edc:SFRFieldSemantic edc:cname="LEVEL0" edc:desc="For PIO12 = 2mA, PIO24 = 4mA" edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL1" edc:desc="For PIO12 = 4mA, PIO24 = 8mA" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL2" edc:desc="For PIO12 = 8mA, PIO24 = 16mA" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL3" edc:desc="For PIO12 = 12mA, PIO24 = 24mA" edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL2P243" edc:nzwidth="0x20" edc:access="--------------------------nn---n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x31" edc:_addr="0x4008178C">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="SLEW_CTRL" edc:nzwidth="0x1" edc:desc="Selects slew rate on the pin. 1=fast 0=slow"/>
            <edc:AdjustPoint edc:offset="0x3"/>
            <edc:SFRFieldDef edc:cname="DRIV_STREN" edc:nzwidth="0x2" edc:desc="Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA">
              <edc:SFRFieldSemantic edc:cname="LEVEL0" edc:desc="For PIO12 = 2mA, PIO24 = 4mA" edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL1" edc:desc="For PIO12 = 4mA, PIO24 = 8mA" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL2" edc:desc="For PIO12 = 8mA, PIO24 = 16mA" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL3" edc:desc="For PIO12 = 12mA, PIO24 = 24mA" edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL2P244" edc:nzwidth="0x20" edc:access="--------------------------nn---n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x31" edc:_addr="0x40081790">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="SLEW_CTRL" edc:nzwidth="0x1" edc:desc="Selects slew rate on the pin. 1=fast 0=slow"/>
            <edc:AdjustPoint edc:offset="0x3"/>
            <edc:SFRFieldDef edc:cname="DRIV_STREN" edc:nzwidth="0x2" edc:desc="Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA">
              <edc:SFRFieldSemantic edc:cname="LEVEL0" edc:desc="For PIO12 = 2mA, PIO24 = 4mA" edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL1" edc:desc="For PIO12 = 4mA, PIO24 = 8mA" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL2" edc:desc="For PIO12 = 8mA, PIO24 = 16mA" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL3" edc:desc="For PIO12 = 12mA, PIO24 = 24mA" edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL2P245" edc:nzwidth="0x20" edc:access="--------------------------nn---n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x31" edc:_addr="0x40081794">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="SLEW_CTRL" edc:nzwidth="0x1" edc:desc="Selects slew rate on the pin. 1=fast 0=slow"/>
            <edc:AdjustPoint edc:offset="0x3"/>
            <edc:SFRFieldDef edc:cname="DRIV_STREN" edc:nzwidth="0x2" edc:desc="Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA">
              <edc:SFRFieldSemantic edc:cname="LEVEL0" edc:desc="For PIO12 = 2mA, PIO24 = 4mA" edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL1" edc:desc="For PIO12 = 4mA, PIO24 = 8mA" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL2" edc:desc="For PIO12 = 8mA, PIO24 = 16mA" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL3" edc:desc="For PIO12 = 12mA, PIO24 = 24mA" edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL2P246" edc:nzwidth="0x20" edc:access="--------------------------nn---n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x31" edc:_addr="0x40081798">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="SLEW_CTRL" edc:nzwidth="0x1" edc:desc="Selects slew rate on the pin. 1=fast 0=slow"/>
            <edc:AdjustPoint edc:offset="0x3"/>
            <edc:SFRFieldDef edc:cname="DRIV_STREN" edc:nzwidth="0x2" edc:desc="Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA">
              <edc:SFRFieldSemantic edc:cname="LEVEL0" edc:desc="For PIO12 = 2mA, PIO24 = 4mA" edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL1" edc:desc="For PIO12 = 4mA, PIO24 = 8mA" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL2" edc:desc="For PIO12 = 8mA, PIO24 = 16mA" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL3" edc:desc="For PIO12 = 12mA, PIO24 = 24mA" edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL2P247" edc:nzwidth="0x20" edc:access="--------------------------nn---n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x31" edc:_addr="0x4008179C">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="SLEW_CTRL" edc:nzwidth="0x1" edc:desc="Selects slew rate on the pin. 1=fast 0=slow"/>
            <edc:AdjustPoint edc:offset="0x3"/>
            <edc:SFRFieldDef edc:cname="DRIV_STREN" edc:nzwidth="0x2" edc:desc="Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA">
              <edc:SFRFieldSemantic edc:cname="LEVEL0" edc:desc="For PIO12 = 2mA, PIO24 = 4mA" edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL1" edc:desc="For PIO12 = 4mA, PIO24 = 8mA" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL2" edc:desc="For PIO12 = 8mA, PIO24 = 16mA" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL3" edc:desc="For PIO12 = 12mA, PIO24 = 24mA" edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL2P250" edc:nzwidth="0x20" edc:access="--------------------------nn---n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x31" edc:_addr="0x400817A0">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="SLEW_CTRL" edc:nzwidth="0x1" edc:desc="Selects slew rate on the pin. 1=fast 0=slow"/>
            <edc:AdjustPoint edc:offset="0x3"/>
            <edc:SFRFieldDef edc:cname="DRIV_STREN" edc:nzwidth="0x2" edc:desc="Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA">
              <edc:SFRFieldSemantic edc:cname="LEVEL0" edc:desc="For PIO12 = 2mA, PIO24 = 4mA" edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL1" edc:desc="For PIO12 = 4mA, PIO24 = 8mA" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL2" edc:desc="For PIO12 = 8mA, PIO24 = 16mA" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL3" edc:desc="For PIO12 = 12mA, PIO24 = 24mA" edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL2P251" edc:nzwidth="0x20" edc:access="--------------------------nn---n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x31" edc:_addr="0x400817A4">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="SLEW_CTRL" edc:nzwidth="0x1" edc:desc="Selects slew rate on the pin. 1=fast 0=slow"/>
            <edc:AdjustPoint edc:offset="0x3"/>
            <edc:SFRFieldDef edc:cname="DRIV_STREN" edc:nzwidth="0x2" edc:desc="Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA">
              <edc:SFRFieldSemantic edc:cname="LEVEL0" edc:desc="For PIO12 = 2mA, PIO24 = 4mA" edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL1" edc:desc="For PIO12 = 4mA, PIO24 = 8mA" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL2" edc:desc="For PIO12 = 8mA, PIO24 = 16mA" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL3" edc:desc="For PIO12 = 12mA, PIO24 = 24mA" edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL2P252" edc:nzwidth="0x20" edc:access="--------------------------nn---n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x31" edc:_addr="0x400817A8">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="SLEW_CTRL" edc:nzwidth="0x1" edc:desc="Selects slew rate on the pin. 1=fast 0=slow"/>
            <edc:AdjustPoint edc:offset="0x3"/>
            <edc:SFRFieldDef edc:cname="DRIV_STREN" edc:nzwidth="0x2" edc:desc="Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA">
              <edc:SFRFieldSemantic edc:cname="LEVEL0" edc:desc="For PIO12 = 2mA, PIO24 = 4mA" edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL1" edc:desc="For PIO12 = 4mA, PIO24 = 8mA" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL2" edc:desc="For PIO12 = 8mA, PIO24 = 16mA" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL3" edc:desc="For PIO12 = 12mA, PIO24 = 24mA" edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL2P253" edc:nzwidth="0x20" edc:access="--------------------------nn---n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x31" edc:_addr="0x400817AC">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="SLEW_CTRL" edc:nzwidth="0x1" edc:desc="Selects slew rate on the pin. 1=fast 0=slow"/>
            <edc:AdjustPoint edc:offset="0x3"/>
            <edc:SFRFieldDef edc:cname="DRIV_STREN" edc:nzwidth="0x2" edc:desc="Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA">
              <edc:SFRFieldSemantic edc:cname="LEVEL0" edc:desc="For PIO12 = 2mA, PIO24 = 4mA" edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL1" edc:desc="For PIO12 = 4mA, PIO24 = 8mA" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL2" edc:desc="For PIO12 = 8mA, PIO24 = 16mA" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL3" edc:desc="For PIO12 = 12mA, PIO24 = 24mA" edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL2P254" edc:nzwidth="0x20" edc:access="--------------------------nn---n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x31" edc:_addr="0x400817B0">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="SLEW_CTRL" edc:nzwidth="0x1" edc:desc="Selects slew rate on the pin. 1=fast 0=slow"/>
            <edc:AdjustPoint edc:offset="0x3"/>
            <edc:SFRFieldDef edc:cname="DRIV_STREN" edc:nzwidth="0x2" edc:desc="Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA">
              <edc:SFRFieldSemantic edc:cname="LEVEL0" edc:desc="For PIO12 = 2mA, PIO24 = 4mA" edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL1" edc:desc="For PIO12 = 4mA, PIO24 = 8mA" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL2" edc:desc="For PIO12 = 8mA, PIO24 = 16mA" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL3" edc:desc="For PIO12 = 12mA, PIO24 = 24mA" edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL2P255" edc:nzwidth="0x20" edc:access="--------------------------nn---n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x31" edc:_addr="0x400817B4">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="SLEW_CTRL" edc:nzwidth="0x1" edc:desc="Selects slew rate on the pin. 1=fast 0=slow"/>
            <edc:AdjustPoint edc:offset="0x3"/>
            <edc:SFRFieldDef edc:cname="DRIV_STREN" edc:nzwidth="0x2" edc:desc="Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA">
              <edc:SFRFieldSemantic edc:cname="LEVEL0" edc:desc="For PIO12 = 2mA, PIO24 = 4mA" edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL1" edc:desc="For PIO12 = 4mA, PIO24 = 8mA" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL2" edc:desc="For PIO12 = 8mA, PIO24 = 16mA" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL3" edc:desc="For PIO12 = 12mA, PIO24 = 24mA" edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL2P256" edc:nzwidth="0x20" edc:access="--------------------------nn---n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x31" edc:_addr="0x400817B8">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="SLEW_CTRL" edc:nzwidth="0x1" edc:desc="Selects slew rate on the pin. 1=fast 0=slow"/>
            <edc:AdjustPoint edc:offset="0x3"/>
            <edc:SFRFieldDef edc:cname="DRIV_STREN" edc:nzwidth="0x2" edc:desc="Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA">
              <edc:SFRFieldSemantic edc:cname="LEVEL0" edc:desc="For PIO12 = 2mA, PIO24 = 4mA" edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL1" edc:desc="For PIO12 = 4mA, PIO24 = 8mA" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL2" edc:desc="For PIO12 = 8mA, PIO24 = 16mA" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL3" edc:desc="For PIO12 = 12mA, PIO24 = 24mA" edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL2P257" edc:nzwidth="0x20" edc:access="--------------------------nn---n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x31" edc:_addr="0x400817BC">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="SLEW_CTRL" edc:nzwidth="0x1" edc:desc="Selects slew rate on the pin. 1=fast 0=slow"/>
            <edc:AdjustPoint edc:offset="0x3"/>
            <edc:SFRFieldDef edc:cname="DRIV_STREN" edc:nzwidth="0x2" edc:desc="Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA">
              <edc:SFRFieldSemantic edc:cname="LEVEL0" edc:desc="For PIO12 = 2mA, PIO24 = 4mA" edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL1" edc:desc="For PIO12 = 4mA, PIO24 = 8mA" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL2" edc:desc="For PIO12 = 8mA, PIO24 = 16mA" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL3" edc:desc="For PIO12 = 12mA, PIO24 = 24mA" edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="GPIO" edc:cname="CTRL2P260" edc:nzwidth="0x20" edc:access="--------------------------nn---n" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x31" edc:_addr="0x400817C0">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="GPIO">
            <edc:SFRFieldDef edc:cname="SLEW_CTRL" edc:nzwidth="0x1" edc:desc="Selects slew rate on the pin. 1=fast 0=slow"/>
            <edc:AdjustPoint edc:offset="0x3"/>
            <edc:SFRFieldDef edc:cname="DRIV_STREN" edc:nzwidth="0x2" edc:desc="Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA">
              <edc:SFRFieldSemantic edc:cname="LEVEL0" edc:desc="For PIO12 = 2mA, PIO24 = 4mA" edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL1" edc:desc="For PIO12 = 4mA, PIO24 = 8mA" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL2" edc:desc="For PIO12 = 8mA, PIO24 = 16mA" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="LEVEL3" edc:desc="For PIO12 = 12mA, PIO24 = 24mA" edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:AdjustPoint edc:offset="0x880" edc:_addr="0x400817C4"/>
      <edc:SFRDef ltx:memberofperipheral="OTP" edc:cname="WR_LOCK0" edc:nzwidth="0x8" edc:access="nnnnnnnn" edc:por="00000000" edc:mclr="00000000" edc:_addr="0x40082044">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="OTP">
            <edc:SFRFieldDef edc:cname="WL0" edc:nzwidth="0x8" edc:desc="When any of the bits are set, the corresponding 32byte range in the OTP is not writable."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="OTP" edc:cname="WR_LOCK1" edc:nzwidth="0x8" edc:access="nnnnnnnn" edc:por="00000000" edc:mclr="00000000" edc:_addr="0x40082045">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="OTP">
            <edc:SFRFieldDef edc:cname="WL1" edc:nzwidth="0x8" edc:desc="When any of the bits are set, the corresponding 32byte range in the OTP is not writable."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="OTP" edc:cname="WR_LOCK2" edc:nzwidth="0x8" edc:access="nnnnnnnn" edc:por="00000000" edc:mclr="00000000" edc:_addr="0x40082046">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="OTP">
            <edc:SFRFieldDef edc:cname="WL2" edc:nzwidth="0x8" edc:desc="When any of the bits are set, the corresponding 32byte range in the OTP is not writable."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="OTP" edc:cname="WR_LOCK3" edc:nzwidth="0x8" edc:access="nnnnnnnn" edc:por="00000000" edc:mclr="00000000" edc:_addr="0x40082047">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="OTP">
            <edc:SFRFieldDef edc:cname="WL3" edc:nzwidth="0x8" edc:desc="When any of the bits are set, the corresponding 32byte range in the OTP is not writable."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="OTP" edc:cname="RD_LOCK0" edc:nzwidth="0x8" edc:access="nnnnnnnn" edc:por="00000000" edc:mclr="00000000" edc:_addr="0x40082048">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="OTP">
            <edc:SFRFieldDef edc:cname="RL0" edc:nzwidth="0x8" edc:desc="When any of the bits are set, the corresponding 32byte range in the OTP is not readable."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="OTP" edc:cname="RD_LOCK1" edc:nzwidth="0x8" edc:access="nnnnnnnn" edc:por="00000000" edc:mclr="00000000" edc:_addr="0x40082049">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="OTP">
            <edc:SFRFieldDef edc:cname="RL1" edc:nzwidth="0x8" edc:desc="When any of the bits are set, the corresponding 32byte range in the OTP is not readable."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="OTP" edc:cname="RD_LOCK2" edc:nzwidth="0x8" edc:access="nnnnnnnn" edc:por="00000000" edc:mclr="00000000" edc:_addr="0x4008204A">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="OTP">
            <edc:SFRFieldDef edc:cname="RL2" edc:nzwidth="0x8" edc:desc="When any of the bits are set, the corresponding 32byte range in the OTP is not readable."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="OTP" edc:cname="RD_LOCK3" edc:nzwidth="0x8" edc:access="nnnnnnnn" edc:por="00000000" edc:mclr="00000000" edc:_addr="0x4008204B">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="OTP">
            <edc:SFRFieldDef edc:cname="RL3" edc:nzwidth="0x8" edc:desc="When any of the bits are set, the corresponding 32byte range in the OTP is not readable."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="OTP" edc:cname="WR_FINE_LCK" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x4008204C">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="OTP">
            <edc:SFRFieldDef edc:cname="WR_FINE_LCK" edc:nzwidth="0x20" edc:desc="Each bit locks write to a byte in the OTP range starting byte 320 to 351 0=Not Locked 1=Locked."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="OTP" edc:cname="RD_FINE_LCK" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0x40082050">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="OTP">
            <edc:SFRFieldDef edc:cname="RD_FINE_LCK" edc:nzwidth="0x20" edc:desc="Each bit locks read to a byte in the OTP range starting byte 320 to 351 0=Not Locked 1=Locked."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
    </edc:SFRDataSector>
    <edc:SFRDataSector edc:regionid="HOST_DEVICE_REGISTERS" edc:beginaddr="0x400F0000" edc:endaddr="0x400FFF28" edc:rw="rw">
      <edc:AdjustPoint edc:offset="0xFF07" edc:_addr="0x400F0000"/>
      <edc:SFRDef ltx:memberofperipheral="GCR" edc:cname="LDN" edc:nzwidth="0x8" edc:access="nnnnnnnn" edc:por="00000000" edc:mclr="00000000" edc:_addr="0x400FFF07"/>
      <edc:AdjustPoint edc:offset="0x14" edc:_addr="0x400FFF08"/>
      <edc:SFRDef ltx:memberofperipheral="GCR" edc:cname="DEV_REV" edc:nzwidth="0x8" edc:access="rrrrrrrr" edc:por="10100000" edc:mclr="10100000" edc:_addr="0x400FFF1C"/>
      <edc:SFRDef ltx:memberofperipheral="GCR" edc:cname="DEV_SUBID" edc:nzwidth="0x8" edc:access="rrrrrrrr" edc:por="01010010" edc:mclr="01010010" edc:_addr="0x400FFF1D"/>
      <edc:SFRDef ltx:memberofperipheral="GCR" edc:cname="DEV_ID" edc:nzwidth="0x10" edc:access="rrrrrrrrrrrrrrrr" edc:por="0000000000100100" edc:mclr="0000000000100100" edc:_addr="0x400FFF1E"/>
      <edc:SFRDef ltx:memberofperipheral="GCR" edc:cname="LEG_DEV_ID" edc:nzwidth="0x8" edc:access="rrrrrrrr" edc:por="11111110" edc:mclr="11111110" edc:_addr="0x400FFF20"/>
      <edc:SFRDef ltx:memberofperipheral="GCR" edc:cname="LEG_DEV_REV" edc:nzwidth="0x8" edc:access="rrrrrrrr" edc:por="10100000" edc:mclr="10100000" edc:_addr="0x400FFF21"/>
      <edc:AdjustPoint edc:offset="0x2" edc:_addr="0x400FFF22"/>
      <edc:SFRDef ltx:memberofperipheral="GCR" edc:cname="OTP_ID" edc:nzwidth="0x8" edc:access="rrrrrrrr" edc:por="00000000" edc:mclr="00000000" edc:_addr="0x400FFF24"/>
      <edc:SFRDef ltx:memberofperipheral="GCR" edc:cname="VLD_ID" edc:nzwidth="0x8" edc:access="rrrrrrrr" edc:por="00000000" edc:mclr="00000000" edc:_addr="0x400FFF25"/>
      <edc:SFRDef ltx:memberofperipheral="GCR" edc:cname="BR_REV_ID" edc:nzwidth="0x8" edc:access="rrrrrrrr" edc:por="00000000" edc:mclr="00000000" edc:_addr="0x400FFF26"/>
    </edc:SFRDataSector>
    <edc:GPRDataSector edc:regionid="CRYPTO_RAM" edc:beginaddr="0x40100000" edc:endaddr="0x40106000" edc:rw="r"/>
    <edc:SFRDataSector edc:regionid="SCS" edc:beginaddr="0xE000E000" edc:endaddr="0xE000EF48" edc:rw="rw">
      <edc:AdjustPoint edc:offset="0x4" edc:_addr="0xE000E000"/>
      <edc:SFRDef edc:nzwidth="0x20" edc:cname="ICTR" edc:impl="0xF" edc:access="----------------------------rrrr" edc:por="xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx" edc:mclr="xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx" edc:desc="Interrupt Controller Type Register" edc:_addr="0xE000E004">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0">
            <edc:SFRFieldDef edc:nzwidth="0x4" edc:cname="INTLINESNUM" edc:desc="Number of interrupt lines supported by NVIC in granularities of 32."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SystemControl" edc:cname="ACTLR" edc:nzwidth="0x20" edc:access="----------------------nn-----nnn" edc:impl="0x307" edc:_addr="0xE000E008">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SystemControl">
            <edc:SFRFieldDef edc:cname="DISMCYCINT" edc:nzwidth="0x1" edc:desc="Disable interruption of LDM/STM instructions"/>
            <edc:SFRFieldDef edc:cname="DISDEFWBUF" edc:nzwidth="0x1" edc:desc="Disable wruite buffer use during default memory map accesses"/>
            <edc:SFRFieldDef edc:cname="DISFOLD" edc:nzwidth="0x1" edc:desc="Disable IT folding"/>
            <edc:AdjustPoint edc:offset="0x5"/>
            <edc:SFRFieldDef edc:cname="DISFPCA" edc:nzwidth="0x1" edc:desc="Disable automatic update of CONTROL.FPCA"/>
            <edc:SFRFieldDef edc:cname="DISOOFP" edc:nzwidth="0x1" edc:desc="Disable out-of-order FP instructions"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:AdjustPoint edc:offset="0x4" edc:_addr="0xE000E00C"/>
      <edc:SFRDef ltx:memberofperipheral="SysTick" edc:cname="CSR" edc:nzwidth="0x20" edc:access="---------------n-------------nnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x10007" edc:_addr="0xE000E010">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SysTick">
            <edc:SFRFieldDef edc:cname="ENABLE" edc:nzwidth="0x1" edc:desc="SysTick Counter Enable">
              <edc:SFRFieldSemantic edc:cname="VALUE_0" edc:desc="Counter disabled" edc:when="(field &amp; 0x1) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="VALUE_1" edc:desc="Counter enabled" edc:when="(field &amp; 0x1) == 0x01"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="TICKINT" edc:nzwidth="0x1" edc:desc="SysTick Exception Request Enable">
              <edc:SFRFieldSemantic edc:cname="VALUE_0" edc:desc="Counting down to 0 does not assert the SysTick exception request" edc:when="(field &amp; 0x1) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="VALUE_1" edc:desc="Counting down to 0 asserts the SysTick exception request" edc:when="(field &amp; 0x1) == 0x01"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="CLKSOURCE" edc:nzwidth="0x1" edc:desc="Clock Source 0=external, 1=processor">
              <edc:SFRFieldSemantic edc:cname="VALUE_0" edc:desc="External clock" edc:when="(field &amp; 0x1) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="VALUE_1" edc:desc="Processor clock" edc:when="(field &amp; 0x1) == 0x01"/>
            </edc:SFRFieldDef>
            <edc:AdjustPoint edc:offset="0xD"/>
            <edc:SFRFieldDef edc:cname="COUNTFLAG" edc:nzwidth="0x1" edc:desc="Timer counted to 0 since last read of register"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SysTick" edc:cname="RVR" edc:nzwidth="0x20" edc:access="--------nnnnnnnnnnnnnnnnnnnnnnnn" edc:impl="0xFFFFFF" edc:_addr="0xE000E014">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SysTick">
            <edc:SFRFieldDef edc:cname="RELOAD" edc:nzwidth="0x18" edc:desc="Value to load into the SysTick Current Value Register when the counter reaches 0"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SysTick" edc:cname="CVR" edc:nzwidth="0x20" edc:access="--------nnnnnnnnnnnnnnnnnnnnnnnn" edc:impl="0xFFFFFF" edc:_addr="0xE000E018">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SysTick">
            <edc:SFRFieldDef edc:cname="CURRENT" edc:nzwidth="0x18" edc:desc="Current value at the time the register is accessed"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SysTick" edc:cname="CALIB" edc:nzwidth="0x20" edc:access="rr------rrrrrrrrrrrrrrrrrrrrrrrr" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0xC0FFFFFF" edc:_addr="0xE000E01C">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SysTick">
            <edc:SFRFieldDef edc:cname="TENMS" edc:nzwidth="0x18" edc:desc="Reload value to use for 10ms timing"/>
            <edc:AdjustPoint edc:offset="0x6"/>
            <edc:SFRFieldDef edc:cname="SKEW" edc:nzwidth="0x1" edc:desc="TENMS is rounded from non-integer ratio">
              <edc:SFRFieldSemantic edc:cname="VALUE_0" edc:desc="10ms calibration value is exact" edc:when="(field &amp; 0x1) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="VALUE_1" edc:desc="10ms calibration value is inexact, because of the clock frequency" edc:when="(field &amp; 0x1) == 0x01"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="NOREF" edc:nzwidth="0x1" edc:desc="No Separate Reference Clock">
              <edc:SFRFieldSemantic edc:cname="VALUE_0" edc:desc="The reference clock is provided" edc:when="(field &amp; 0x1) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="VALUE_1" edc:desc="The reference clock is not provided" edc:when="(field &amp; 0x1) == 0x01"/>
            </edc:SFRFieldDef>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:AdjustPoint edc:offset="0xE0" edc:_addr="0xE000E020"/>
      <edc:SFRDef ltx:memberofperipheral="NVIC" edc:cname="ISER0" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0xE000E100">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="NVIC">
            <edc:SFRFieldDef edc:cname="SETENA" edc:nzwidth="0x20" edc:desc="Interrupt set enable bits"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:AdjustPoint edc:offset="0x7C" edc:_addr="0xE000E104"/>
      <edc:SFRDef ltx:memberofperipheral="NVIC" edc:cname="ICER0" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0xE000E180">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="NVIC">
            <edc:SFRFieldDef edc:cname="CLRENA" edc:nzwidth="0x20" edc:desc="Interrupt clear-enable bits"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:AdjustPoint edc:offset="0x7C" edc:_addr="0xE000E184"/>
      <edc:SFRDef ltx:memberofperipheral="NVIC" edc:cname="ISPR0" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0xE000E200">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="NVIC">
            <edc:SFRFieldDef edc:cname="SETPEND" edc:nzwidth="0x20" edc:desc="Interrupt set-pending bits"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:AdjustPoint edc:offset="0x7C" edc:_addr="0xE000E204"/>
      <edc:SFRDef ltx:memberofperipheral="NVIC" edc:cname="ICPR0" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0xE000E280">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="NVIC">
            <edc:SFRFieldDef edc:cname="CLRPEND" edc:nzwidth="0x20" edc:desc="Interrupt clear-pending bits"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:AdjustPoint edc:offset="0x7C" edc:_addr="0xE000E284"/>
      <edc:SFRDef ltx:memberofperipheral="NVIC" edc:cname="IABR0" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:_addr="0xE000E300">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="NVIC">
            <edc:SFRFieldDef edc:cname="ACTIVE" edc:nzwidth="0x20" edc:desc="Interrupt active bits"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:AdjustPoint edc:offset="0xFC" edc:_addr="0xE000E304"/>
      <edc:SFRDef ltx:memberofperipheral="NVIC" edc:cname="IP0" edc:nzwidth="0x8" edc:access="-----nnn" edc:por="00000000" edc:mclr="00000000" edc:impl="0x7" edc:_addr="0xE000E400">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="NVIC">
            <edc:SFRFieldDef edc:cname="PRI0" edc:nzwidth="0x3" edc:desc="Priority of interrupt n"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="NVIC" edc:cname="IP1" edc:nzwidth="0x8" edc:access="-----nnn" edc:por="00000000" edc:mclr="00000000" edc:impl="0x7" edc:_addr="0xE000E401">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="NVIC">
            <edc:SFRFieldDef edc:cname="PRI0" edc:nzwidth="0x3" edc:desc="Priority of interrupt n"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="NVIC" edc:cname="IP2" edc:nzwidth="0x8" edc:access="-----nnn" edc:por="00000000" edc:mclr="00000000" edc:impl="0x7" edc:_addr="0xE000E402">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="NVIC">
            <edc:SFRFieldDef edc:cname="PRI0" edc:nzwidth="0x3" edc:desc="Priority of interrupt n"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="NVIC" edc:cname="IP3" edc:nzwidth="0x8" edc:access="-----nnn" edc:por="00000000" edc:mclr="00000000" edc:impl="0x7" edc:_addr="0xE000E403">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="NVIC">
            <edc:SFRFieldDef edc:cname="PRI0" edc:nzwidth="0x3" edc:desc="Priority of interrupt n"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="NVIC" edc:cname="IP4" edc:nzwidth="0x8" edc:access="-----nnn" edc:por="00000000" edc:mclr="00000000" edc:impl="0x7" edc:_addr="0xE000E404">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="NVIC">
            <edc:SFRFieldDef edc:cname="PRI0" edc:nzwidth="0x3" edc:desc="Priority of interrupt n"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="NVIC" edc:cname="IP5" edc:nzwidth="0x8" edc:access="-----nnn" edc:por="00000000" edc:mclr="00000000" edc:impl="0x7" edc:_addr="0xE000E405">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="NVIC">
            <edc:SFRFieldDef edc:cname="PRI0" edc:nzwidth="0x3" edc:desc="Priority of interrupt n"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="NVIC" edc:cname="IP6" edc:nzwidth="0x8" edc:access="-----nnn" edc:por="00000000" edc:mclr="00000000" edc:impl="0x7" edc:_addr="0xE000E406">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="NVIC">
            <edc:SFRFieldDef edc:cname="PRI0" edc:nzwidth="0x3" edc:desc="Priority of interrupt n"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="NVIC" edc:cname="IP7" edc:nzwidth="0x8" edc:access="-----nnn" edc:por="00000000" edc:mclr="00000000" edc:impl="0x7" edc:_addr="0xE000E407">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="NVIC">
            <edc:SFRFieldDef edc:cname="PRI0" edc:nzwidth="0x3" edc:desc="Priority of interrupt n"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:AdjustPoint edc:offset="0x8F8" edc:_addr="0xE000E408"/>
      <edc:SFRDef ltx:memberofperipheral="SystemControl" edc:cname="CPUID" edc:nzwidth="0x20" edc:access="rrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrr" edc:por="01000001000011111100001001000001" edc:mclr="01000001000011111100001001000001" edc:_addr="0xE000ED00">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SystemControl">
            <edc:SFRFieldDef edc:cname="REVISION" edc:nzwidth="0x4" edc:desc="Processor revision number"/>
            <edc:SFRFieldDef edc:cname="PARTNO" edc:nzwidth="0xC" edc:desc="Process Part Number, 0xC24=Cortex-M4"/>
            <edc:SFRFieldDef edc:cname="CONSTANT" edc:nzwidth="0x4" edc:desc="Constant"/>
            <edc:SFRFieldDef edc:cname="VARIANT" edc:nzwidth="0x4" edc:desc="Variant number"/>
            <edc:SFRFieldDef edc:cname="IMPLEMENTER" edc:nzwidth="0x8" edc:desc="Implementer code, 0x41=ARM"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SystemControl" edc:cname="ICSR" edc:nzwidth="0x20" edc:access="n--nnnn-nn----nnnnnnn--nnnnnnnnn" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x9EC3F9FF" edc:_addr="0xE000ED04">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SystemControl">
            <edc:SFRFieldDef edc:cname="VECTACTIVE" edc:nzwidth="0x9" edc:desc="Active exception number"/>
            <edc:AdjustPoint edc:offset="0x2"/>
            <edc:SFRFieldDef edc:cname="RETTOBASE" edc:nzwidth="0x1" edc:desc="No preempted active exceptions to execute"/>
            <edc:SFRFieldDef edc:cname="VECTPENDING" edc:nzwidth="0x6" edc:desc="Exception number of the highest priority pending enabled exception"/>
            <edc:AdjustPoint edc:offset="0x4"/>
            <edc:SFRFieldDef edc:cname="ISRPENDING" edc:nzwidth="0x1" edc:desc="Interrupt pending flag"/>
            <edc:SFRFieldDef edc:cname="ISRPREEMPT" edc:nzwidth="0x1" edc:desc="Debug only"/>
            <edc:AdjustPoint edc:offset="0x1"/>
            <edc:SFRFieldDef edc:cname="PENDSTCLR" edc:nzwidth="0x1" edc:desc="SysTick clear-pending bit">
              <edc:SFRFieldSemantic edc:cname="VALUE_0" edc:desc="No effect" edc:when="(field &amp; 0x1) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="VALUE_1" edc:desc="Removes the pending state from the SysTick exception" edc:when="(field &amp; 0x1) == 0x01"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="PENDSTSET" edc:nzwidth="0x1" edc:desc="SysTick set-pending bit">
              <edc:SFRFieldSemantic edc:cname="VALUE_0" edc:desc="Write: no effect; read: SysTick exception is not pending" edc:when="(field &amp; 0x1) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="VALUE_1" edc:desc="Write: changes SysTick exception state to pending; read: SysTick exception is pending" edc:when="(field &amp; 0x1) == 0x01"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="PENDSVCLR" edc:nzwidth="0x1" edc:desc="PendSV clear-pending bit">
              <edc:SFRFieldSemantic edc:cname="VALUE_0" edc:desc="No effect" edc:when="(field &amp; 0x1) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="VALUE_1" edc:desc="Removes the pending state from the PendSV exception" edc:when="(field &amp; 0x1) == 0x01"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="PENDSVSET" edc:nzwidth="0x1" edc:desc="PendSV set-pending bit">
              <edc:SFRFieldSemantic edc:cname="VALUE_0" edc:desc="Write: no effect; read: PendSV exception is not pending" edc:when="(field &amp; 0x1) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="VALUE_1" edc:desc="Write: changes PendSV exception state to pending; read: PendSV exception is pending" edc:when="(field &amp; 0x1) == 0x01"/>
            </edc:SFRFieldDef>
            <edc:AdjustPoint edc:offset="0x2"/>
            <edc:SFRFieldDef edc:cname="NMIPENDSET" edc:nzwidth="0x1" edc:desc="NMI set-pending bit">
              <edc:SFRFieldSemantic edc:cname="VALUE_0" edc:desc="Write: no effect; read: NMI exception is not pending" edc:when="(field &amp; 0x1) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="VALUE_1" edc:desc="Write: changes NMI exception state to pending; read: NMI exception is pending" edc:when="(field &amp; 0x1) == 0x01"/>
            </edc:SFRFieldDef>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:AdjustPoint edc:offset="0x4" edc:_addr="0xE000ED08"/>
      <edc:SFRDef ltx:memberofperipheral="SystemControl" edc:cname="AIRCR" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnn----nnn-----nnn" edc:por="11111010000001010000000000000000" edc:mclr="11111010000001010000000000000000" edc:impl="0xFFFF8707" edc:_addr="0xE000ED0C">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SystemControl">
            <edc:SFRFieldDef edc:cname="VECTRESET" edc:nzwidth="0x1" edc:desc="Must write 0"/>
            <edc:SFRFieldDef edc:cname="VECTCLRACTIVE" edc:nzwidth="0x1" edc:desc="Must write 0"/>
            <edc:SFRFieldDef edc:cname="SYSRESETREQ" edc:nzwidth="0x1" edc:desc="System Reset Request">
              <edc:SFRFieldSemantic edc:cname="VALUE_0" edc:desc="No system reset request" edc:when="(field &amp; 0x1) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="VALUE_1" edc:desc="Asserts a signal to the outer system that requests a reset" edc:when="(field &amp; 0x1) == 0x01"/>
            </edc:SFRFieldDef>
            <edc:AdjustPoint edc:offset="0x5"/>
            <edc:SFRFieldDef edc:cname="PRIGROUP" edc:nzwidth="0x3" edc:desc="Interrupt priority grouping"/>
            <edc:AdjustPoint edc:offset="0x4"/>
            <edc:SFRFieldDef edc:cname="ENDIANNESS" edc:nzwidth="0x1" edc:desc="Data endianness, 0=little, 1=big">
              <edc:SFRFieldSemantic edc:cname="VALUE_0" edc:desc="Little-endian" edc:when="(field &amp; 0x1) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="VALUE_1" edc:desc="Big-endian" edc:when="(field &amp; 0x1) == 0x01"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="VECTKEY" edc:nzwidth="0x10" edc:desc="Register key"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SystemControl" edc:cname="SCR" edc:nzwidth="0x20" edc:access="---------------------------n-nn-" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x16" edc:_addr="0xE000ED10">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SystemControl">
            <edc:AdjustPoint edc:offset="0x1"/>
            <edc:SFRFieldDef edc:cname="SLEEPONEXIT" edc:nzwidth="0x1" edc:desc="Sleep-on-exit on handler return">
              <edc:SFRFieldSemantic edc:cname="VALUE_0" edc:desc="Do not sleep when returning to Thread mode" edc:when="(field &amp; 0x1) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="VALUE_1" edc:desc="Enter sleep, or deep sleep, on return from an ISR" edc:when="(field &amp; 0x1) == 0x01"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="SLEEPDEEP" edc:nzwidth="0x1" edc:desc="Deep Sleep used as low power mode">
              <edc:SFRFieldSemantic edc:cname="VALUE_0" edc:desc="Sleep" edc:when="(field &amp; 0x1) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="VALUE_1" edc:desc="Deep sleep" edc:when="(field &amp; 0x1) == 0x01"/>
            </edc:SFRFieldDef>
            <edc:AdjustPoint edc:offset="0x1"/>
            <edc:SFRFieldDef edc:cname="SEVONPEND" edc:nzwidth="0x1" edc:desc="Send Event on Pending bit">
              <edc:SFRFieldSemantic edc:cname="VALUE_0" edc:desc="Only enabled interrupts or events can wakeup the processor, disabled interrupts are excluded" edc:when="(field &amp; 0x1) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="VALUE_1" edc:desc="Enabled events and all interrupts, including disabled interrupts, can wakeup the processor" edc:when="(field &amp; 0x1) == 0x01"/>
            </edc:SFRFieldDef>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SystemControl" edc:cname="CCR" edc:nzwidth="0x20" edc:access="----------------------nn---nn-nn" edc:por="00000000000000000000001000000000" edc:mclr="00000000000000000000001000000000" edc:impl="0x31B" edc:_addr="0xE000ED14">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SystemControl">
            <edc:SFRFieldDef edc:cname="NONBASETHRDENA" edc:nzwidth="0x1" edc:desc="Indicates how processor enters Thread mode"/>
            <edc:SFRFieldDef edc:cname="USERSETMPEND" edc:nzwidth="0x1" edc:desc="Enables unprivileged software access to STIR register"/>
            <edc:AdjustPoint edc:offset="0x1"/>
            <edc:SFRFieldDef edc:cname="UNALIGN_TRP" edc:nzwidth="0x1" edc:desc="Enables unaligned access traps">
              <edc:SFRFieldSemantic edc:cname="VALUE_0" edc:desc="Do not trap unaligned halfword and word accesses" edc:when="(field &amp; 0x1) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="VALUE_1" edc:desc="Trap unaligned halfword and word accesses" edc:when="(field &amp; 0x1) == 0x01"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="DIV_0_TRP" edc:nzwidth="0x1" edc:desc="Enables divide by 0 trap"/>
            <edc:AdjustPoint edc:offset="0x3"/>
            <edc:SFRFieldDef edc:cname="BFHFNMIGN" edc:nzwidth="0x1" edc:desc="Ignore LDM/STM BusFault for -1/-2 priority handlers"/>
            <edc:SFRFieldDef edc:cname="STKALIGN" edc:nzwidth="0x1" edc:desc="Indicates stack alignment on exception entry">
              <edc:SFRFieldSemantic edc:cname="VALUE_0" edc:desc="4-byte aligned" edc:when="(field &amp; 0x1) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="VALUE_1" edc:desc="8-byte aligned" edc:when="(field &amp; 0x1) == 0x01"/>
            </edc:SFRFieldDef>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SystemControl" edc:cname="SHPR1" edc:nzwidth="0x20" edc:access="--------nnnnnnnnnnnnnnnnnnnnnnnn" edc:impl="0xFFFFFF" edc:_addr="0xE000ED18">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SystemControl">
            <edc:SFRFieldDef edc:cname="PRI_4" edc:nzwidth="0x8" edc:desc="Priority of system handler 4, MemManage"/>
            <edc:SFRFieldDef edc:cname="PRI_5" edc:nzwidth="0x8" edc:desc="Priority of system handler 5, BusFault"/>
            <edc:SFRFieldDef edc:cname="PRI_6" edc:nzwidth="0x8" edc:desc="Priority of system handler 6, UsageFault"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SystemControl" edc:cname="SHPR2" edc:nzwidth="0x20" edc:access="nnnnnnnn------------------------" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0xFF000000" edc:_addr="0xE000ED1C">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SystemControl">
            <edc:AdjustPoint edc:offset="0x18"/>
            <edc:SFRFieldDef edc:cname="PRI_11" edc:nzwidth="0x8" edc:desc="Priority of system handler 11, SVCall"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SystemControl" edc:cname="SHPR3" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnn----------------" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0xFFFF0000" edc:_addr="0xE000ED20">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SystemControl">
            <edc:AdjustPoint edc:offset="0x10"/>
            <edc:SFRFieldDef edc:cname="PRI_14" edc:nzwidth="0x8" edc:desc="Priority of system handler 14, PendSV"/>
            <edc:SFRFieldDef edc:cname="PRI_15" edc:nzwidth="0x8" edc:desc="Priority of system handler 15, SysTick exception"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SystemControl" edc:cname="SHCSR" edc:nzwidth="0x20" edc:access="-------------nnnnnnnnn-nn---n-nn" edc:impl="0x7FD8B" edc:_addr="0xE000ED24">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SystemControl">
            <edc:SFRFieldDef edc:cname="MEMFAULTACT" edc:nzwidth="0x1" edc:desc="MemManage exception active bit"/>
            <edc:SFRFieldDef edc:cname="BUSFAULTACT" edc:nzwidth="0x1" edc:desc="BusFault exception active bit"/>
            <edc:AdjustPoint edc:offset="0x1"/>
            <edc:SFRFieldDef edc:cname="USGFAULTACT" edc:nzwidth="0x1" edc:desc="UsageFault exception active bit"/>
            <edc:AdjustPoint edc:offset="0x3"/>
            <edc:SFRFieldDef edc:cname="SVCALLACT" edc:nzwidth="0x1" edc:desc="SVCall active bit"/>
            <edc:SFRFieldDef edc:cname="MONITORACT" edc:nzwidth="0x1" edc:desc="DebugMonitor exception active bit"/>
            <edc:AdjustPoint edc:offset="0x1"/>
            <edc:SFRFieldDef edc:cname="PENDSVACT" edc:nzwidth="0x1" edc:desc="PendSV exception active bit"/>
            <edc:SFRFieldDef edc:cname="SYSTICKACT" edc:nzwidth="0x1" edc:desc="SysTick exception active bit"/>
            <edc:SFRFieldDef edc:cname="USGFAULTPENDED" edc:nzwidth="0x1" edc:desc="UsageFault exception pending bit"/>
            <edc:SFRFieldDef edc:cname="MEMFAULTPENDED" edc:nzwidth="0x1" edc:desc="MemManage exception pending bit"/>
            <edc:SFRFieldDef edc:cname="BUSFAULTPENDED" edc:nzwidth="0x1" edc:desc="BusFault exception pending bit"/>
            <edc:SFRFieldDef edc:cname="SVCALLPENDED" edc:nzwidth="0x1" edc:desc="SVCall pending bit"/>
            <edc:SFRFieldDef edc:cname="MEMFAULTENA" edc:nzwidth="0x1" edc:desc="MemManage enable bit"/>
            <edc:SFRFieldDef edc:cname="BUSFAULTENA" edc:nzwidth="0x1" edc:desc="BusFault enable bit"/>
            <edc:SFRFieldDef edc:cname="USGFAULTENA" edc:nzwidth="0x1" edc:desc="UsageFault enable bit"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SystemControl" edc:cname="CFSR" edc:nzwidth="0x20" edc:access="------nn----nnnnn-nnnnnnn-nnn-nn" edc:impl="0x30FBFBB" edc:_addr="0xE000ED28">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SystemControl">
            <edc:SFRFieldDef edc:cname="IACCVIOL" edc:nzwidth="0x1" edc:desc="Instruction access violation"/>
            <edc:SFRFieldDef edc:cname="DACCVIOL" edc:nzwidth="0x1" edc:desc="Data access violation"/>
            <edc:AdjustPoint edc:offset="0x1"/>
            <edc:SFRFieldDef edc:cname="MUNSTKERR" edc:nzwidth="0x1" edc:desc="MemManage Fault on unstacking for exception return"/>
            <edc:SFRFieldDef edc:cname="MSTKERR" edc:nzwidth="0x1" edc:desc="MemManage Fault on stacking for exception entry"/>
            <edc:SFRFieldDef edc:cname="MLSPERR" edc:nzwidth="0x1" edc:desc="MemManager Fault occured during FP lazy state preservation"/>
            <edc:AdjustPoint edc:offset="0x1"/>
            <edc:SFRFieldDef edc:cname="MMARVALID" edc:nzwidth="0x1" edc:desc="MemManage Fault Address Register valid"/>
            <edc:SFRFieldDef edc:cname="IBUSERR" edc:nzwidth="0x1" edc:desc="Instruction bus error"/>
            <edc:SFRFieldDef edc:cname="PRECISERR" edc:nzwidth="0x1" edc:desc="Precise data bus error"/>
            <edc:SFRFieldDef edc:cname="IMPRECISERR" edc:nzwidth="0x1" edc:desc="Imprecise data bus error"/>
            <edc:SFRFieldDef edc:cname="UNSTKERR" edc:nzwidth="0x1" edc:desc="BusFault on unstacking for exception return"/>
            <edc:SFRFieldDef edc:cname="STKERR" edc:nzwidth="0x1" edc:desc="BusFault on stacking for exception entry"/>
            <edc:SFRFieldDef edc:cname="LSPERR" edc:nzwidth="0x1" edc:desc="BusFault occured during FP lazy state preservation"/>
            <edc:AdjustPoint edc:offset="0x1"/>
            <edc:SFRFieldDef edc:cname="BFARVALID" edc:nzwidth="0x1" edc:desc="BusFault Address Register valid"/>
            <edc:SFRFieldDef edc:cname="UNDEFINSTR" edc:nzwidth="0x1" edc:desc="Undefined instruction UsageFault"/>
            <edc:SFRFieldDef edc:cname="INVSTATE" edc:nzwidth="0x1" edc:desc="Invalid state UsageFault"/>
            <edc:SFRFieldDef edc:cname="INVPC" edc:nzwidth="0x1" edc:desc="Invalid PC load UsageFault"/>
            <edc:SFRFieldDef edc:cname="NOCP" edc:nzwidth="0x1" edc:desc="No coprocessor UsageFault"/>
            <edc:AdjustPoint edc:offset="0x4"/>
            <edc:SFRFieldDef edc:cname="UNALIGNED" edc:nzwidth="0x1" edc:desc="Unaligned access UsageFault"/>
            <edc:SFRFieldDef edc:cname="DIVBYZERO" edc:nzwidth="0x1" edc:desc="Divide by zero UsageFault"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SystemControl" edc:cname="HFSR" edc:nzwidth="0x20" edc:access="nn----------------------------n-" edc:impl="0xC0000002" edc:_addr="0xE000ED2C">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SystemControl">
            <edc:AdjustPoint edc:offset="0x1"/>
            <edc:SFRFieldDef edc:cname="VECTTBL" edc:nzwidth="0x1" edc:desc="BusFault on a Vector Table read during exception processing"/>
            <edc:AdjustPoint edc:offset="0x1C"/>
            <edc:SFRFieldDef edc:cname="FORCED" edc:nzwidth="0x1" edc:desc="Forced Hard Fault"/>
            <edc:SFRFieldDef edc:cname="DEBUGEVT" edc:nzwidth="0x1" edc:desc="Debug: always write 0"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SystemControl" edc:cname="DFSR" edc:nzwidth="0x20" edc:access="---------------------------nnnnn" edc:impl="0x1F" edc:_addr="0xE000ED30">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SystemControl">
            <edc:SFRFieldDef edc:cname="HALTED" edc:nzwidth="0x1"/>
            <edc:SFRFieldDef edc:cname="BKPT" edc:nzwidth="0x1"/>
            <edc:SFRFieldDef edc:cname="DWTTRAP" edc:nzwidth="0x1"/>
            <edc:SFRFieldDef edc:cname="VCATCH" edc:nzwidth="0x1"/>
            <edc:SFRFieldDef edc:cname="EXTERNAL" edc:nzwidth="0x1"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SystemControl" edc:cname="MMFAR" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:_addr="0xE000ED34">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SystemControl">
            <edc:SFRFieldDef edc:cname="ADDRESS" edc:nzwidth="0x20" edc:desc="Address that generated the MemManage fault"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SystemControl" edc:cname="BFAR" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:_addr="0xE000ED38">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SystemControl">
            <edc:SFRFieldDef edc:cname="ADDRESS" edc:nzwidth="0x20" edc:desc="Address that generated the BusFault"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SystemControl" edc:cname="AFSR" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:_addr="0xE000ED3C">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SystemControl">
            <edc:SFRFieldDef edc:cname="IMPDEF" edc:nzwidth="0x20" edc:desc="AUXFAULT input signals"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="SystemControl" edc:cname="PFR0" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:_addr="0xE000ED40"/>
      <edc:SFRDef ltx:memberofperipheral="SystemControl" edc:cname="PFR1" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn" edc:_addr="0xE000ED44"/>
      <edc:SFRDef ltx:memberofperipheral="SystemControl" edc:cname="DFR" edc:nzwidth="0x20" edc:access="rrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrr" edc:_addr="0xE000ED48"/>
      <edc:SFRDef ltx:memberofperipheral="SystemControl" edc:cname="ADR" edc:nzwidth="0x20" edc:access="rrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrr" edc:_addr="0xE000ED4C"/>
      <edc:SFRDef ltx:memberofperipheral="SystemControl" edc:cname="MMFR0" edc:nzwidth="0x20" edc:access="rrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrr" edc:_addr="0xE000ED50"/>
      <edc:SFRDef ltx:memberofperipheral="SystemControl" edc:cname="MMFR1" edc:nzwidth="0x20" edc:access="rrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrr" edc:_addr="0xE000ED54"/>
      <edc:SFRDef ltx:memberofperipheral="SystemControl" edc:cname="MMFR2" edc:nzwidth="0x20" edc:access="rrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrr" edc:_addr="0xE000ED58"/>
      <edc:SFRDef ltx:memberofperipheral="SystemControl" edc:cname="MMFR3" edc:nzwidth="0x20" edc:access="rrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrr" edc:_addr="0xE000ED5C"/>
      <edc:SFRDef ltx:memberofperipheral="SystemControl" edc:cname="ISAR0" edc:nzwidth="0x20" edc:access="rrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrr" edc:_addr="0xE000ED60"/>
      <edc:SFRDef ltx:memberofperipheral="SystemControl" edc:cname="ISAR1" edc:nzwidth="0x20" edc:access="rrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrr" edc:_addr="0xE000ED64"/>
      <edc:SFRDef ltx:memberofperipheral="SystemControl" edc:cname="ISAR2" edc:nzwidth="0x20" edc:access="rrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrr" edc:_addr="0xE000ED68"/>
      <edc:SFRDef ltx:memberofperipheral="SystemControl" edc:cname="ISAR3" edc:nzwidth="0x20" edc:access="rrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrr" edc:_addr="0xE000ED6C"/>
      <edc:SFRDef ltx:memberofperipheral="SystemControl" edc:cname="ISAR4" edc:nzwidth="0x20" edc:access="rrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrr" edc:_addr="0xE000ED70"/>
      <edc:AdjustPoint edc:offset="0x14" edc:_addr="0xE000ED74"/>
      <edc:SFRDef ltx:memberofperipheral="SystemControl" edc:cname="CPACR" edc:nzwidth="0x20" edc:access="--------nnnn--------------------" edc:impl="0xF00000" edc:_addr="0xE000ED88">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="SystemControl">
            <edc:AdjustPoint edc:offset="0x14"/>
            <edc:SFRFieldDef edc:cname="CP10" edc:nzwidth="0x2" edc:desc="Access privileges for coprocessor 10">
              <edc:SFRFieldSemantic edc:cname="DENIED" edc:desc="Access denied" edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="PRIV" edc:desc="Privileged access only" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="FULL" edc:desc="Full access" edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="CP11" edc:nzwidth="0x2" edc:desc="Access privileges for coprocessor 11">
              <edc:SFRFieldSemantic edc:cname="DENIED" edc:desc="Access denied" edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="PRIV" edc:desc="Privileged access only" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="FULL" edc:desc="Full access" edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:AdjustPoint edc:offset="0x174" edc:_addr="0xE000ED8C"/>
      <edc:SFRDef ltx:memberofperipheral="NVIC" edc:cname="STIR" edc:nzwidth="0x20" edc:access="-----------------------wwwwwwwww" edc:impl="0x1FF" edc:_addr="0xE000EF00">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="NVIC">
            <edc:SFRFieldDef edc:cname="INTID" edc:nzwidth="0x9" edc:desc="Interrupt ID to trigger"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:AdjustPoint edc:offset="0x30" edc:_addr="0xE000EF04"/>
      <edc:SFRDef ltx:memberofperipheral="FPU" edc:cname="FPCCR" edc:nzwidth="0x20" edc:access="nn---------------------n-nnnn-nn" edc:por="11000000000000000000000000000000" edc:mclr="11000000000000000000000000000000" edc:impl="0xC000017B" edc:_addr="0xE000EF34">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="FPU">
            <edc:SFRFieldDef edc:cname="LSPACT" edc:nzwidth="0x1"/>
            <edc:SFRFieldDef edc:cname="USER" edc:nzwidth="0x1"/>
            <edc:AdjustPoint edc:offset="0x1"/>
            <edc:SFRFieldDef edc:cname="THREAD" edc:nzwidth="0x1"/>
            <edc:SFRFieldDef edc:cname="HFRDY" edc:nzwidth="0x1"/>
            <edc:SFRFieldDef edc:cname="MMRDY" edc:nzwidth="0x1"/>
            <edc:SFRFieldDef edc:cname="BFRDY" edc:nzwidth="0x1"/>
            <edc:AdjustPoint edc:offset="0x1"/>
            <edc:SFRFieldDef edc:cname="MONRDY" edc:nzwidth="0x1"/>
            <edc:AdjustPoint edc:offset="0x15"/>
            <edc:SFRFieldDef edc:cname="LSPEN" edc:nzwidth="0x1"/>
            <edc:SFRFieldDef edc:cname="ASPEN" edc:nzwidth="0x1"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="FPU" edc:cname="FPCAR" edc:nzwidth="0x20" edc:access="nnnnnnnnnnnnnnnnnnnnnnnnnnnnn---" edc:impl="0xFFFFFFF8" edc:_addr="0xE000EF38">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="FPU">
            <edc:AdjustPoint edc:offset="0x3"/>
            <edc:SFRFieldDef edc:cname="ADDRESS" edc:nzwidth="0x1D" edc:desc="Address for FP registers in exception stack frame"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="FPU" edc:cname="FPDSCR" edc:nzwidth="0x20" edc:access="-----nnnnn----------------------" edc:por="00000000000000000000000000000000" edc:mclr="00000000000000000000000000000000" edc:impl="0x7C00000" edc:_addr="0xE000EF3C">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="FPU">
            <edc:AdjustPoint edc:offset="0x16"/>
            <edc:SFRFieldDef edc:cname="RMODE" edc:nzwidth="0x2" edc:desc="Default value for FPSCR.RMODE">
              <edc:SFRFieldSemantic edc:cname="RN" edc:desc="Round to Nearest" edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="RP" edc:desc="Round towards Positive Infinity" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="RM" edc:desc="Round towards Negative Infinity" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="RZ" edc:desc="Round towards Zero" edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="FZ" edc:nzwidth="0x1" edc:desc="Default value for FPSCR.FZ"/>
            <edc:SFRFieldDef edc:cname="DN" edc:nzwidth="0x1" edc:desc="Default value for FPSCR.DN"/>
            <edc:SFRFieldDef edc:cname="AHP" edc:nzwidth="0x1" edc:desc="Default value for FPSCR.AHP"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="FPU" edc:cname="MVFR0" edc:nzwidth="0x20" edc:access="rrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrr" edc:_addr="0xE000EF40">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="FPU">
            <edc:SFRFieldDef edc:cname="A_SIMD_registers" edc:nzwidth="0x4"/>
            <edc:SFRFieldDef edc:cname="Single_precision" edc:nzwidth="0x4"/>
            <edc:SFRFieldDef edc:cname="Double_precision" edc:nzwidth="0x4"/>
            <edc:SFRFieldDef edc:cname="FP_excep_trapping" edc:nzwidth="0x4"/>
            <edc:SFRFieldDef edc:cname="Divide" edc:nzwidth="0x4"/>
            <edc:SFRFieldDef edc:cname="Square_root" edc:nzwidth="0x4"/>
            <edc:SFRFieldDef edc:cname="Short_vectors" edc:nzwidth="0x4"/>
            <edc:SFRFieldDef edc:cname="FP_rounding_modes" edc:nzwidth="0x4"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="FPU" edc:cname="MVFR1" edc:nzwidth="0x20" edc:access="rrrrrrrr----------------rrrrrrrr" edc:impl="0xFF0000FF" edc:_addr="0xE000EF44">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="FPU">
            <edc:SFRFieldDef edc:cname="FtZ_mode" edc:nzwidth="0x4"/>
            <edc:SFRFieldDef edc:cname="D_NaN_mode" edc:nzwidth="0x4"/>
            <edc:AdjustPoint edc:offset="0x10"/>
            <edc:SFRFieldDef edc:cname="FP_HPFP" edc:nzwidth="0x4"/>
            <edc:SFRFieldDef edc:cname="FP_fused_MAC" edc:nzwidth="0x4"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
    </edc:SFRDataSector>
    <edc:ExternalSector edc:regionid="EXTERNAL_FLASH" edc:beginaddr="0x50000000" edc:endaddr="0x58000000" edc:isexecutable="true" edc:rw="rw" edc:type="flash"/>
    <edc:DeviceIDSector edc:regionid="devid" edc:beginaddr="0x400FFF1E" edc:endaddr="0x400FFF22" edc:value="0x245200" edc:mask="0xFFFFFF00"/>
    <edc:RegisterMap edc:id="UART0/DATA">
      <edc:MuxedSFRDef edc:nzwidth="0x8" edc:addr="0x4000C400">
        <edc:SelectSFR>
          <edc:SFRDef ltx:memberofperipheral="UART0" edc:cname="RX_DAT" edc:nzwidth="0x8" edc:access="rrrrrrrr" edc:por="00000000" edc:mclr="00000000"/>
        </edc:SelectSFR>
        <edc:SelectSFR>
          <edc:SFRDef ltx:memberofperipheral="UART0" edc:cname="TX_DAT" edc:nzwidth="0x8" edc:access="wwwwwwww" edc:por="00000000" edc:mclr="00000000"/>
        </edc:SelectSFR>
      </edc:MuxedSFRDef>
      <edc:SFRDef ltx:memberofperipheral="UART0" edc:cname="IEN" edc:nzwidth="0x8" edc:access="----nnnn" edc:por="00000000" edc:mclr="00000000" edc:impl="0xF" edc:addr="0x4000C401">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="UART0">
            <edc:SFRFieldDef edc:cname="ERDAI" edc:nzwidth="0x1" edc:desc="ERDAI This bit enables the Received Data Available Interrupt (and timeout interrupts in the FIFO mode) when set to logic '1'."/>
            <edc:SFRFieldDef edc:cname="ETHREI" edc:nzwidth="0x1" edc:desc="ETHREI This bit enables the Transmitter Holding Register Empty Interrupt when set to logic '1'."/>
            <edc:SFRFieldDef edc:cname="ELSI" edc:nzwidth="0x1" edc:desc="ELSI This bit enables the Received Line Status Interrupt when set to logic '1'."/>
            <edc:SFRFieldDef edc:cname="EMSI" edc:nzwidth="0x1" edc:desc="EMSI  This bit enables the MODEM Status Interrupt when set to logic '1'."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:MuxedSFRDef edc:nzwidth="0x8" edc:addr="0x4000C402">
        <edc:SelectSFR>
          <edc:SFRDef ltx:memberofperipheral="UART0" edc:cname="FIFO_CR" edc:nzwidth="0x8" edc:access="ww--wwww" edc:por="00000000" edc:mclr="00000000" edc:impl="0xCF">
            <edc:SFRModeList>
              <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="UART0">
                <edc:SFRFieldDef edc:cname="EXRF" edc:nzwidth="0x1" edc:desc="EXRF Enable XMIT and RECV FIFO."/>
                <edc:SFRFieldDef edc:cname="CLR_RECV_FIFO" edc:nzwidth="0x1" edc:desc="CLEAR_RECV_FIFO  Setting this bit to a logic '1' clears all bytes in the RCVR FIFO and resets its counter logic to '0'."/>
                <edc:SFRFieldDef edc:cname="CLR_XMIT_FIFO" edc:nzwidth="0x1" edc:desc="CLEAR_XMIT_FIFO  Setting this bit to a logic '1' clears all bytes in the XMIT FIFO and resets its counter logic to '0' . The shift register is not cleared. This bit is self-clearing."/>
                <edc:SFRFieldDef edc:cname="DMA_MODE_SEL" edc:nzwidth="0x1" edc:desc="DMA_MODE_SELECT  Writing to this bit has no effect on the operation of the UART. The RXRDY and TXRDY pins are not available on this chip."/>
                <edc:AdjustPoint edc:offset="0x2"/>
                <edc:SFRFieldDef edc:cname="RECV_FIFO_TRIG_LVL" edc:nzwidth="0x2" edc:desc="RECV_FIFO_TRIGGER_LEVEL These bits are used to set the trigger level for the RCVR FIFO interrupt."/>
              </edc:SFRMode>
            </edc:SFRModeList>
          </edc:SFRDef>
        </edc:SelectSFR>
        <edc:SelectSFR>
          <edc:SFRDef ltx:memberofperipheral="UART0" edc:cname="INT_ID" edc:nzwidth="0x8" edc:access="rr--rrrr" edc:por="00000000" edc:mclr="00000000" edc:impl="0xCF">
            <edc:SFRModeList>
              <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="UART0">
                <edc:SFRFieldDef edc:cname="IPEND" edc:nzwidth="0x1" edc:desc="IPEND  This bit can be used in either a hardwired prioritized or polled environment to indicate whether an interrupt is pending."/>
                <edc:SFRFieldDef edc:cname="INTID" edc:nzwidth="0x3" edc:desc="INTID  These bits identify the highest priority interrupt pending"/>
                <edc:AdjustPoint edc:offset="0x2"/>
                <edc:SFRFieldDef edc:cname="FIFO_EN" edc:nzwidth="0x2" edc:desc="These two bits are set when the FIFO CONTROL Register bit 0 equals 1."/>
              </edc:SFRMode>
            </edc:SFRModeList>
          </edc:SFRDef>
        </edc:SelectSFR>
      </edc:MuxedSFRDef>
      <edc:SFRDef ltx:memberofperipheral="UART0" edc:cname="LCR" edc:nzwidth="0x8" edc:access="nnnnnnnn" edc:por="00000000" edc:mclr="00000000" edc:addr="0x4000C403">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="UART0">
            <edc:SFRFieldDef edc:cname="WORD_LEN" edc:nzwidth="0x2" edc:desc="WORD_LENGTH These two bits specify the number of bits in each transmitted or received serial character.">
              <edc:SFRFieldSemantic edc:cname="5_BIT" edc:desc="5 Bits" edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="6_BIT" edc:desc="6 Bits" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="7_BIT" edc:desc="7 Bits" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="8_BIT" edc:desc="8 Bits" edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="STOP_BITS" edc:nzwidth="0x1" edc:desc="STOP_BITS  This bit specifies the number of stop bits in each transmitted or received serial character.">
              <edc:SFRFieldSemantic edc:cname="ONE_STOP_BIT" edc:desc="1 Stop bit" edc:when="(field &amp; 0x1) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="ONE_FIVE_TWO_STOP_BITS" edc:desc="1.5 or 2 Stop bits" edc:when="(field &amp; 0x1) == 0x01"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="EN_PAR" edc:nzwidth="0x1" edc:desc="ENABLE_PARITY  Parity Enable bit."/>
            <edc:SFRFieldDef edc:cname="PAR_SEL" edc:nzwidth="0x1" edc:desc="PARITY_SELECT Even Parity Select bit.">
              <edc:SFRFieldSemantic edc:cname="ODD" edc:desc="Odd Parity" edc:when="(field &amp; 0x1) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="EVEN" edc:desc="Even Parity" edc:when="(field &amp; 0x1) == 0x01"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="STICK_PAR" edc:nzwidth="0x1" edc:desc="STICK_PARITY  Stick Parity bit."/>
            <edc:SFRFieldDef edc:cname="BRK_CTRL" edc:nzwidth="0x1" edc:desc="BREAK_CONTROL Set Break Control bit"/>
            <edc:SFRFieldDef edc:cname="DLAB" edc:nzwidth="0x1" edc:desc="DLAB Divisor Latch Access Bit (DLAB)."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="UART0" edc:cname="MCR" edc:nzwidth="0x8" edc:access="---nnnnn" edc:por="00000000" edc:mclr="00000000" edc:impl="0x1F" edc:addr="0x4000C404">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="UART0">
            <edc:SFRFieldDef edc:cname="DTR" edc:nzwidth="0x1" edc:desc="DTR  This bit controls the Data Terminal Ready (nDTR) output."/>
            <edc:SFRFieldDef edc:cname="RTS" edc:nzwidth="0x1" edc:desc="RTS  This bit controls the Request To Send (nRTS) output."/>
            <edc:SFRFieldDef edc:cname="OUT1" edc:nzwidth="0x1" edc:desc="OUT1 This bit controls the Output 1 (OUT1) bit."/>
            <edc:SFRFieldDef edc:cname="OUT2" edc:nzwidth="0x1" edc:desc="OUT2  This bit is used to enable an UART interrupt."/>
            <edc:SFRFieldDef edc:cname="LOOPBACK" edc:nzwidth="0x1" edc:desc="LOOPBACK  This bit provides the loopback feature for diagnostic testing of the Serial Port."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="UART0" edc:cname="LSR" edc:nzwidth="0x8" edc:access="rrrrrrrr" edc:por="00000000" edc:mclr="00000000" edc:addr="0x4000C405">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="UART0">
            <edc:SFRFieldDef edc:cname="DATA_READY" edc:nzwidth="0x1" edc:desc="DATA_READY  Data Ready. It is set to a logic '1' whenever a complete incoming character has been received and transferred into the Receiver Buffer Register or the FIFO"/>
            <edc:SFRFieldDef edc:cname="OVERRUN" edc:nzwidth="0x1" edc:desc="OVERRUN  Overrun Error."/>
            <edc:SFRFieldDef edc:cname="PE" edc:nzwidth="0x1" edc:desc="PARITY ERROR  Parity Error."/>
            <edc:SFRFieldDef edc:cname="FRAME_ERR" edc:nzwidth="0x1" edc:desc="FRAME_ERROR Framing Error."/>
            <edc:SFRFieldDef edc:cname="BRK_INTR" edc:nzwidth="0x1" edc:desc="BREAK_INTERRUPT   Break Interrupt."/>
            <edc:SFRFieldDef edc:cname="TRANS_EMPTY" edc:nzwidth="0x1" edc:desc="TRANSMIT_EMPTY  Transmitter Holding Register Empty Bit 5 indicates that the Serial Port is ready to accept a new character for transmission."/>
            <edc:SFRFieldDef edc:cname="TRANS_ERR" edc:nzwidth="0x1" edc:desc="Transmitter Empty. Bit 6 is set to a logic '1' whenever the Transmitter Holding Register (THR) and Transmitter Shift Register (TSR) are both empty."/>
            <edc:SFRFieldDef edc:cname="FIFO_ERR" edc:nzwidth="0x1" edc:desc="FIFO_ERROR"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="UART0" edc:cname="MSR" edc:nzwidth="0x8" edc:access="rrrrrrrr" edc:por="00000000" edc:mclr="00000000" edc:addr="0x4000C406">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="UART0">
            <edc:SFRFieldDef edc:cname="CTS" edc:nzwidth="0x1" edc:desc="CTS  Delta Clear To Send (DCTS)."/>
            <edc:SFRFieldDef edc:cname="DSR" edc:nzwidth="0x1" edc:desc="DSR  Delta Data Set Ready (DDSR)."/>
            <edc:SFRFieldDef edc:cname="RI" edc:nzwidth="0x1" edc:desc="RI  Trailing Edge of Ring Indicator (TERI)."/>
            <edc:SFRFieldDef edc:cname="DCD" edc:nzwidth="0x1" edc:desc="DCD  Delta Data Carrier Detect (DDCD)."/>
            <edc:SFRFieldDef edc:cname="nCTS" edc:nzwidth="0x1" edc:desc="nCTS  This bit is the complement of the Clear To Send (nCTS) input."/>
            <edc:SFRFieldDef edc:cname="nDSR" edc:nzwidth="0x1" edc:desc="This bit is the complement of the Data Set Ready (nDSR) input."/>
            <edc:SFRFieldDef edc:cname="nRI" edc:nzwidth="0x1" edc:desc="nRI This bit is the complement of the Ring Indicator (nRI) input."/>
            <edc:SFRFieldDef edc:cname="nDCD" edc:nzwidth="0x1" edc:desc="nDCD   This bit is the complement of the Data Carrier Detect (nDCD) input."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="UART0" edc:cname="SCR" edc:nzwidth="0x8" edc:access="nnnnnnnn" edc:por="00000000" edc:mclr="00000000" edc:addr="0x4000C407"/>
      <edc:SFRDef ltx:memberofperipheral="UART0" edc:cname="ACTIVATE" edc:nzwidth="0x8" edc:access="nnnnnnnn" edc:por="00000000" edc:mclr="00000000" edc:addr="0x4000C730"/>
      <edc:SFRDef ltx:memberofperipheral="UART0" edc:cname="CFG_SEL" edc:nzwidth="0x8" edc:access="-----nnn" edc:por="00000000" edc:mclr="00000000" edc:impl="0x7" edc:addr="0x4000C7F0">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="UART0">
            <edc:SFRFieldDef edc:cname="CLK_SRC" edc:nzwidth="0x1" edc:desc="CLK_SRC  1=The UART Baud Clock is derived from an external clock source, 0=The UART Baud Clock is derived from one of the two internal clock sources">
              <edc:SFRFieldSemantic edc:cname="INTERNAL" edc:desc="Baud Clock is derived from one of the two internal clock sources" edc:when="(field &amp; 0x1) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="EXTERNAL" edc:desc="Baud Clock is derived from an external clock source" edc:when="(field &amp; 0x1) == 0x01"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="PWR" edc:nzwidth="0x1" edc:desc="POWER  1=The RESET reset signal is derived from nSIO_RESET, 0=The RESET reset signal is derived from VCC1_RESET"/>
            <edc:SFRFieldDef edc:cname="POLAR" edc:nzwidth="0x1" edc:desc="POLARITY  1=The UART_TX and UART_RX pins functions are inverted, 0=The UART_TX and UART_RX pins functions are not inverted"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
    </edc:RegisterMap>
    <edc:RegisterMap edc:id="UART0/DLAB">
      <edc:SFRDef ltx:memberofperipheral="UART0" edc:cname="BAUDRT_LSB" edc:nzwidth="0x8" edc:access="nnnnnnnn" edc:por="00000000" edc:mclr="00000000" edc:addr="0x4000C400"/>
      <edc:SFRDef ltx:memberofperipheral="UART0" edc:cname="BAUDRT_MSB" edc:nzwidth="0x8" edc:access="nnnnnnnn" edc:por="00000000" edc:mclr="00000000" edc:addr="0x4000C401">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="UART0">
            <edc:SFRFieldDef edc:cname="BAUDRT_DIV_MSB" edc:nzwidth="0x7" edc:desc="Baud Rate divisor (MSB)."/>
            <edc:SFRFieldDef edc:cname="BAUD_CLK_SEL" edc:nzwidth="0x1" edc:desc="Baud Clock Selection">
              <edc:SFRFieldSemantic edc:cname="1843200_Hz" edc:desc="Baud clock is derived from the 1.8432MHz Clk" edc:when="(field &amp; 0x1) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="48000000_HZ" edc:desc="baud clock is derived from the 48MHz Clk" edc:when="(field &amp; 0x1) == 0x01"/>
            </edc:SFRFieldDef>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:MuxedSFRDef edc:nzwidth="0x8" edc:addr="0x4000C402">
        <edc:SelectSFR>
          <edc:SFRDef ltx:memberofperipheral="UART0" edc:cname="FIFO_CR" edc:nzwidth="0x8" edc:access="ww--wwww" edc:por="00000000" edc:mclr="00000000" edc:impl="0xCF">
            <edc:SFRModeList>
              <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="UART0">
                <edc:SFRFieldDef edc:cname="EXRF" edc:nzwidth="0x1" edc:desc="EXRF Enable XMIT and RECV FIFO."/>
                <edc:SFRFieldDef edc:cname="CLR_RECV_FIFO" edc:nzwidth="0x1" edc:desc="CLEAR_RECV_FIFO  Setting this bit to a logic '1' clears all bytes in the RCVR FIFO and resets its counter logic to '0'."/>
                <edc:SFRFieldDef edc:cname="CLR_XMIT_FIFO" edc:nzwidth="0x1" edc:desc="CLEAR_XMIT_FIFO  Setting this bit to a logic '1' clears all bytes in the XMIT FIFO and resets its counter logic to '0' . The shift register is not cleared. This bit is self-clearing."/>
                <edc:SFRFieldDef edc:cname="DMA_MODE_SEL" edc:nzwidth="0x1" edc:desc="DMA_MODE_SELECT  Writing to this bit has no effect on the operation of the UART. The RXRDY and TXRDY pins are not available on this chip."/>
                <edc:AdjustPoint edc:offset="0x2"/>
                <edc:SFRFieldDef edc:cname="RECV_FIFO_TRIG_LVL" edc:nzwidth="0x2" edc:desc="RECV_FIFO_TRIGGER_LEVEL These bits are used to set the trigger level for the RCVR FIFO interrupt."/>
              </edc:SFRMode>
            </edc:SFRModeList>
          </edc:SFRDef>
        </edc:SelectSFR>
        <edc:SelectSFR>
          <edc:SFRDef ltx:memberofperipheral="UART0" edc:cname="INT_ID" edc:nzwidth="0x8" edc:access="rr--rrrr" edc:por="00000000" edc:mclr="00000000" edc:impl="0xCF">
            <edc:SFRModeList>
              <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="UART0">
                <edc:SFRFieldDef edc:cname="IPEND" edc:nzwidth="0x1" edc:desc="IPEND  This bit can be used in either a hardwired prioritized or polled environment to indicate whether an interrupt is pending."/>
                <edc:SFRFieldDef edc:cname="INTID" edc:nzwidth="0x3" edc:desc="INTID  These bits identify the highest priority interrupt pending"/>
                <edc:AdjustPoint edc:offset="0x2"/>
                <edc:SFRFieldDef edc:cname="FIFO_EN" edc:nzwidth="0x2" edc:desc="These two bits are set when the FIFO CONTROL Register bit 0 equals 1."/>
              </edc:SFRMode>
            </edc:SFRModeList>
          </edc:SFRDef>
        </edc:SelectSFR>
      </edc:MuxedSFRDef>
      <edc:SFRDef ltx:memberofperipheral="UART0" edc:cname="LCR" edc:nzwidth="0x8" edc:access="nnnnnnnn" edc:por="00000000" edc:mclr="00000000" edc:addr="0x4000C403">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="UART0">
            <edc:SFRFieldDef edc:cname="WORD_LEN" edc:nzwidth="0x2" edc:desc="WORD_LENGTH These two bits specify the number of bits in each transmitted or received serial character.">
              <edc:SFRFieldSemantic edc:cname="5_BIT" edc:desc="5 Bits" edc:when="(field &amp; 0x3) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="6_BIT" edc:desc="6 Bits" edc:when="(field &amp; 0x3) == 0x01"/>
              <edc:SFRFieldSemantic edc:cname="7_BIT" edc:desc="7 Bits" edc:when="(field &amp; 0x3) == 0x02"/>
              <edc:SFRFieldSemantic edc:cname="8_BIT" edc:desc="8 Bits" edc:when="(field &amp; 0x3) == 0x03"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="STOP_BITS" edc:nzwidth="0x1" edc:desc="STOP_BITS  This bit specifies the number of stop bits in each transmitted or received serial character.">
              <edc:SFRFieldSemantic edc:cname="ONE_STOP_BIT" edc:desc="1 Stop bit" edc:when="(field &amp; 0x1) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="ONE_FIVE_TWO_STOP_BITS" edc:desc="1.5 or 2 Stop bits" edc:when="(field &amp; 0x1) == 0x01"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="EN_PAR" edc:nzwidth="0x1" edc:desc="ENABLE_PARITY  Parity Enable bit."/>
            <edc:SFRFieldDef edc:cname="PAR_SEL" edc:nzwidth="0x1" edc:desc="PARITY_SELECT Even Parity Select bit.">
              <edc:SFRFieldSemantic edc:cname="ODD" edc:desc="Odd Parity" edc:when="(field &amp; 0x1) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="EVEN" edc:desc="Even Parity" edc:when="(field &amp; 0x1) == 0x01"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="STICK_PAR" edc:nzwidth="0x1" edc:desc="STICK_PARITY  Stick Parity bit."/>
            <edc:SFRFieldDef edc:cname="BRK_CTRL" edc:nzwidth="0x1" edc:desc="BREAK_CONTROL Set Break Control bit"/>
            <edc:SFRFieldDef edc:cname="DLAB" edc:nzwidth="0x1" edc:desc="DLAB Divisor Latch Access Bit (DLAB)."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="UART0" edc:cname="MCR" edc:nzwidth="0x8" edc:access="---nnnnn" edc:por="00000000" edc:mclr="00000000" edc:impl="0x1F" edc:addr="0x4000C404">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="UART0">
            <edc:SFRFieldDef edc:cname="DTR" edc:nzwidth="0x1" edc:desc="DTR  This bit controls the Data Terminal Ready (nDTR) output."/>
            <edc:SFRFieldDef edc:cname="RTS" edc:nzwidth="0x1" edc:desc="RTS  This bit controls the Request To Send (nRTS) output."/>
            <edc:SFRFieldDef edc:cname="OUT1" edc:nzwidth="0x1" edc:desc="OUT1 This bit controls the Output 1 (OUT1) bit."/>
            <edc:SFRFieldDef edc:cname="OUT2" edc:nzwidth="0x1" edc:desc="OUT2  This bit is used to enable an UART interrupt."/>
            <edc:SFRFieldDef edc:cname="LOOPBACK" edc:nzwidth="0x1" edc:desc="LOOPBACK  This bit provides the loopback feature for diagnostic testing of the Serial Port."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="UART0" edc:cname="LSR" edc:nzwidth="0x8" edc:access="rrrrrrrr" edc:por="00000000" edc:mclr="00000000" edc:addr="0x4000C405">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="UART0">
            <edc:SFRFieldDef edc:cname="DATA_READY" edc:nzwidth="0x1" edc:desc="DATA_READY  Data Ready. It is set to a logic '1' whenever a complete incoming character has been received and transferred into the Receiver Buffer Register or the FIFO"/>
            <edc:SFRFieldDef edc:cname="OVERRUN" edc:nzwidth="0x1" edc:desc="OVERRUN  Overrun Error."/>
            <edc:SFRFieldDef edc:cname="PE" edc:nzwidth="0x1" edc:desc="PARITY ERROR  Parity Error."/>
            <edc:SFRFieldDef edc:cname="FRAME_ERR" edc:nzwidth="0x1" edc:desc="FRAME_ERROR Framing Error."/>
            <edc:SFRFieldDef edc:cname="BRK_INTR" edc:nzwidth="0x1" edc:desc="BREAK_INTERRUPT   Break Interrupt."/>
            <edc:SFRFieldDef edc:cname="TRANS_EMPTY" edc:nzwidth="0x1" edc:desc="TRANSMIT_EMPTY  Transmitter Holding Register Empty Bit 5 indicates that the Serial Port is ready to accept a new character for transmission."/>
            <edc:SFRFieldDef edc:cname="TRANS_ERR" edc:nzwidth="0x1" edc:desc="Transmitter Empty. Bit 6 is set to a logic '1' whenever the Transmitter Holding Register (THR) and Transmitter Shift Register (TSR) are both empty."/>
            <edc:SFRFieldDef edc:cname="FIFO_ERR" edc:nzwidth="0x1" edc:desc="FIFO_ERROR"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="UART0" edc:cname="MSR" edc:nzwidth="0x8" edc:access="rrrrrrrr" edc:por="00000000" edc:mclr="00000000" edc:addr="0x4000C406">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="UART0">
            <edc:SFRFieldDef edc:cname="CTS" edc:nzwidth="0x1" edc:desc="CTS  Delta Clear To Send (DCTS)."/>
            <edc:SFRFieldDef edc:cname="DSR" edc:nzwidth="0x1" edc:desc="DSR  Delta Data Set Ready (DDSR)."/>
            <edc:SFRFieldDef edc:cname="RI" edc:nzwidth="0x1" edc:desc="RI  Trailing Edge of Ring Indicator (TERI)."/>
            <edc:SFRFieldDef edc:cname="DCD" edc:nzwidth="0x1" edc:desc="DCD  Delta Data Carrier Detect (DDCD)."/>
            <edc:SFRFieldDef edc:cname="nCTS" edc:nzwidth="0x1" edc:desc="nCTS  This bit is the complement of the Clear To Send (nCTS) input."/>
            <edc:SFRFieldDef edc:cname="nDSR" edc:nzwidth="0x1" edc:desc="This bit is the complement of the Data Set Ready (nDSR) input."/>
            <edc:SFRFieldDef edc:cname="nRI" edc:nzwidth="0x1" edc:desc="nRI This bit is the complement of the Ring Indicator (nRI) input."/>
            <edc:SFRFieldDef edc:cname="nDCD" edc:nzwidth="0x1" edc:desc="nDCD   This bit is the complement of the Data Carrier Detect (nDCD) input."/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
      <edc:SFRDef ltx:memberofperipheral="UART0" edc:cname="SCR" edc:nzwidth="0x8" edc:access="nnnnnnnn" edc:por="00000000" edc:mclr="00000000" edc:addr="0x4000C407"/>
      <edc:SFRDef ltx:memberofperipheral="UART0" edc:cname="ACTIVATE" edc:nzwidth="0x8" edc:access="nnnnnnnn" edc:por="00000000" edc:mclr="00000000" edc:addr="0x4000C730"/>
      <edc:SFRDef ltx:memberofperipheral="UART0" edc:cname="CFG_SEL" edc:nzwidth="0x8" edc:access="-----nnn" edc:por="00000000" edc:mclr="00000000" edc:impl="0x7" edc:addr="0x4000C7F0">
        <edc:SFRModeList>
          <edc:SFRMode edc:id="DS.0" ltx:memberofperipheral="UART0">
            <edc:SFRFieldDef edc:cname="CLK_SRC" edc:nzwidth="0x1" edc:desc="CLK_SRC  1=The UART Baud Clock is derived from an external clock source, 0=The UART Baud Clock is derived from one of the two internal clock sources">
              <edc:SFRFieldSemantic edc:cname="INTERNAL" edc:desc="Baud Clock is derived from one of the two internal clock sources" edc:when="(field &amp; 0x1) == 0x00"/>
              <edc:SFRFieldSemantic edc:cname="EXTERNAL" edc:desc="Baud Clock is derived from an external clock source" edc:when="(field &amp; 0x1) == 0x01"/>
            </edc:SFRFieldDef>
            <edc:SFRFieldDef edc:cname="PWR" edc:nzwidth="0x1" edc:desc="POWER  1=The RESET reset signal is derived from nSIO_RESET, 0=The RESET reset signal is derived from VCC1_RESET"/>
            <edc:SFRFieldDef edc:cname="POLAR" edc:nzwidth="0x1" edc:desc="POLARITY  1=The UART_TX and UART_RX pins functions are inverted, 0=The UART_TX and UART_RX pins functions are not inverted"/>
          </edc:SFRMode>
        </edc:SFRModeList>
      </edc:SFRDef>
    </edc:RegisterMap>
    <edc:EmulatorSector edc:beginaddr="0xE0001000" edc:endaddr="0xE000F000" edc:regionid="emulation"/>
  </edc:PhysicalSpace>
  <edc:PinList edc:ppsflavor="atmel">
    <edc:Pin>
      <edc:VirtualPin edc:name="GPIO000" edc:ppsfunction="default" ltx:memberofperipheral="GPIO"/>
      <edc:VirtualPin edc:name="SPI0_KILL" edc:ppsfunction="B" ltx:memberofperipheral="SPI_MON0"/>
      <edc:VirtualPin edc:name="SPI0_RESET_n" edc:ppsfunction="C" ltx:memberofperipheral="SPI_MON0"/>
    </edc:Pin>
    <edc:Pin>
      <edc:VirtualPin edc:name="GPIO002" edc:ppsfunction="default" ltx:memberofperipheral="GPIO"/>
      <edc:VirtualPin edc:name="QSPI0_CS1_n" edc:ppsfunction="B" ltx:memberofperipheral="QMSPI0"/>
      <edc:VirtualPin edc:name="SPIMON_QSPI0_CS1_n" edc:ppsfunction="C" ltx:memberofperipheral="SPI_MON0"/>
    </edc:Pin>
    <edc:Pin>
      <edc:VirtualPin edc:name="GPIO003" edc:ppsfunction="default" ltx:memberofperipheral="GPIO"/>
      <edc:VirtualPin edc:name="SDA0" edc:ppsfunction="B" ltx:memberofperipheral="SMB0"/>
      <edc:VirtualPin edc:name="SDA0" edc:ppsfunction="B" ltx:memberofperipheral="SMB1"/>
      <edc:VirtualPin edc:name="SDA0" edc:ppsfunction="B" ltx:memberofperipheral="SMB2"/>
      <edc:VirtualPin edc:name="SDA0" edc:ppsfunction="B" ltx:memberofperipheral="SMB3"/>
      <edc:VirtualPin edc:name="SDA0" edc:ppsfunction="B" ltx:memberofperipheral="SMB4"/>
    </edc:Pin>
    <edc:Pin>
      <edc:VirtualPin edc:name="GPIO004" edc:ppsfunction="default" ltx:memberofperipheral="GPIO"/>
      <edc:VirtualPin edc:name="SCL0" edc:ppsfunction="B" ltx:memberofperipheral="SMB0"/>
      <edc:VirtualPin edc:name="SCL0" edc:ppsfunction="B" ltx:memberofperipheral="SMB1"/>
      <edc:VirtualPin edc:name="SCL0" edc:ppsfunction="B" ltx:memberofperipheral="SMB2"/>
      <edc:VirtualPin edc:name="SCL0" edc:ppsfunction="B" ltx:memberofperipheral="SMB3"/>
      <edc:VirtualPin edc:name="SCL0" edc:ppsfunction="B" ltx:memberofperipheral="SMB4"/>
    </edc:Pin>
    <edc:Pin>
      <edc:VirtualPin edc:name="GPIO012" edc:ppsfunction="default" ltx:memberofperipheral="GPIO"/>
    </edc:Pin>
    <edc:Pin>
      <edc:VirtualPin edc:name="GPIO013" edc:ppsfunction="default" ltx:memberofperipheral="GPIO"/>
      <edc:VirtualPin edc:name="SP1_ALT_IO3" edc:ppsfunction="B" ltx:memberofperipheral="SPI_MON1"/>
    </edc:Pin>
    <edc:Pin>
      <edc:VirtualPin edc:name="GPIO015" edc:ppsfunction="default" ltx:memberofperipheral="GPIO"/>
      <edc:VirtualPin edc:name="ICT10" edc:ppsfunction="C" ltx:memberofperipheral="CCT"/>
    </edc:Pin>
    <edc:Pin>
      <edc:VirtualPin edc:name="GPIO016" edc:ppsfunction="default" ltx:memberofperipheral="GPIO"/>
      <edc:VirtualPin edc:name="QSPI0_IO3" edc:ppsfunction="B" ltx:memberofperipheral="QMSPI0"/>
      <edc:VirtualPin edc:name="QSPI0_IO3_CLAMP" edc:ppsfunction="C" ltx:memberofperipheral="SPI_MON0"/>
    </edc:Pin>
    <edc:Pin>
      <edc:VirtualPin edc:name="GPIO020" edc:ppsfunction="default" ltx:memberofperipheral="GPIO"/>
      <edc:VirtualPin edc:name="QSPI0_IN_CS0_n" edc:ppsfunction="B" ltx:memberofperipheral="QMSPI0"/>
    </edc:Pin>
    <edc:Pin>
      <edc:VirtualPin edc:name="GPIO021" edc:ppsfunction="default" ltx:memberofperipheral="GPIO"/>
      <edc:VirtualPin edc:name="QSPI0_IN_CS1_n" edc:ppsfunction="B" ltx:memberofperipheral="QMSPI0"/>
    </edc:Pin>
    <edc:Pin>
      <edc:VirtualPin edc:name="GPIO022" edc:ppsfunction="default" ltx:memberofperipheral="GPIO"/>
      <edc:VirtualPin edc:name="QSPI0_IN_IO1" edc:ppsfunction="B" ltx:memberofperipheral="QMSPI0"/>
      <edc:VirtualPin edc:name="QSPI0_IN_IO1" edc:ppsfunction="B" ltx:memberofperipheral="SPT0"/>
    </edc:Pin>
    <edc:Pin>
      <edc:VirtualPin edc:name="GPIO023" edc:ppsfunction="default" ltx:memberofperipheral="GPIO"/>
      <edc:VirtualPin edc:name="QSPI0_IN_IO0" edc:ppsfunction="B" ltx:memberofperipheral="QMSPI0"/>
      <edc:VirtualPin edc:name="QSPI0_IN_IO0" edc:ppsfunction="B" ltx:memberofperipheral="SPT0"/>
    </edc:Pin>
    <edc:Pin>
      <edc:VirtualPin edc:name="GPIO024" edc:ppsfunction="default" ltx:memberofperipheral="GPIO"/>
      <edc:VirtualPin edc:name="SPI1PER_CS_n" edc:ppsfunction="B" ltx:memberofperipheral="SPT1"/>
      <edc:VirtualPin edc:name="SPI1PER_CS_n" edc:ppsfunction="B" ltx:memberofperipheral="SPI_MON1"/>
    </edc:Pin>
    <edc:Pin>
      <edc:VirtualPin edc:name="GPIO026" edc:ppsfunction="default" ltx:memberofperipheral="GPIO"/>
      <edc:VirtualPin edc:name="SP0_AP_INTR" edc:ppsfunction="B" ltx:memberofperipheral="SPI_MON0"/>
    </edc:Pin>
    <edc:Pin>
      <edc:VirtualPin edc:name="GPIO027" edc:ppsfunction="default" ltx:memberofperipheral="GPIO"/>
      <edc:VirtualPin edc:name="ALT_TFDP_CLK" edc:ppsfunction="B" ltx:memberofperipheral="TFDP"/>
    </edc:Pin>
    <edc:Pin>
      <edc:VirtualPin edc:name="GPIO030" edc:ppsfunction="default" ltx:memberofperipheral="GPIO"/>
      <edc:VirtualPin edc:name="SDA10" edc:ppsfunction="B" ltx:memberofperipheral="SMB0"/>
      <edc:VirtualPin edc:name="SDA10" edc:ppsfunction="B" ltx:memberofperipheral="SMB1"/>
      <edc:VirtualPin edc:name="SDA10" edc:ppsfunction="B" ltx:memberofperipheral="SMB2"/>
      <edc:VirtualPin edc:name="SDA10" edc:ppsfunction="B" ltx:memberofperipheral="SMB3"/>
      <edc:VirtualPin edc:name="SDA10" edc:ppsfunction="B" ltx:memberofperipheral="SMB4"/>
    </edc:Pin>
    <edc:Pin>
      <edc:VirtualPin edc:name="GPIO031" edc:ppsfunction="default" ltx:memberofperipheral="GPIO"/>
      <edc:VirtualPin edc:name="SP1_ALT_IO0" edc:ppsfunction="B" ltx:memberofperipheral="SPI_MON1"/>
    </edc:Pin>
    <edc:Pin>
      <edc:VirtualPin edc:name="GPIO032" edc:ppsfunction="default" ltx:memberofperipheral="GPIO"/>
      <edc:VirtualPin edc:name="QSPI1_IN_IO1" edc:ppsfunction="B" ltx:memberofperipheral="QMSPI1"/>
      <edc:VirtualPin edc:name="QSPI1_IN_IO1" edc:ppsfunction="B" ltx:memberofperipheral="SPT1"/>
    </edc:Pin>
    <edc:Pin>
      <edc:VirtualPin edc:name="GPIO033" edc:ppsfunction="default" ltx:memberofperipheral="GPIO"/>
    </edc:Pin>
    <edc:Pin>
      <edc:VirtualPin edc:name="GPIO034" edc:ppsfunction="default" ltx:memberofperipheral="GPIO"/>
      <edc:VirtualPin edc:name="SP1_AP_INTR" edc:ppsfunction="B" ltx:memberofperipheral="SPT1"/>
      <edc:VirtualPin edc:name="SP1_AP_INTR" edc:ppsfunction="B" ltx:memberofperipheral="SPI_MON1"/>
    </edc:Pin>
    <edc:Pin>
      <edc:VirtualPin edc:name="GPIO045" edc:ppsfunction="default" ltx:memberofperipheral="GPIO"/>
      <edc:VirtualPin edc:name="QSPI1_IN_CS1_n" edc:ppsfunction="B" ltx:memberofperipheral="QMSPI1"/>
    </edc:Pin>
    <edc:Pin>
      <edc:VirtualPin edc:name="GPIO046" edc:ppsfunction="default" ltx:memberofperipheral="GPIO"/>
      <edc:VirtualPin edc:name="SP1_ALT_CS_n" edc:ppsfunction="B" ltx:memberofperipheral="SPI_MON1"/>
    </edc:Pin>
    <edc:Pin>
      <edc:VirtualPin edc:name="GPIO047" edc:ppsfunction="default" ltx:memberofperipheral="GPIO"/>
      <edc:VirtualPin edc:name="SP1_ALT_IO1" edc:ppsfunction="B" ltx:memberofperipheral="SPI_MON1"/>
    </edc:Pin>
    <edc:Pin>
      <edc:VirtualPin edc:name="GPIO050" edc:ppsfunction="default" ltx:memberofperipheral="GPIO"/>
      <edc:VirtualPin edc:name="ICT0" edc:ppsfunction="B" ltx:memberofperipheral="CCT"/>
    </edc:Pin>
    <edc:Pin>
      <edc:VirtualPin edc:name="GPIO053" edc:ppsfunction="default" ltx:memberofperipheral="GPIO"/>
      <edc:VirtualPin edc:name="PWM0" edc:ppsfunction="B" ltx:memberofperipheral="PWM0"/>
      <edc:VirtualPin edc:name="SP0_AP_INTR" edc:ppsfunction="B" ltx:memberofperipheral="SPT0"/>
    </edc:Pin>
    <edc:Pin>
      <edc:VirtualPin edc:name="GPIO055" edc:ppsfunction="default" ltx:memberofperipheral="GPIO"/>
      <edc:VirtualPin edc:name="QSPI0_CS0_n" edc:ppsfunction="B" ltx:memberofperipheral="QMSPI0"/>
      <edc:VirtualPin edc:name="SPIMON_QSPI0_CS0_n" edc:ppsfunction="C" ltx:memberofperipheral="SPI_MON0"/>
    </edc:Pin>
    <edc:Pin>
      <edc:VirtualPin edc:name="GPIO056" edc:ppsfunction="default" ltx:memberofperipheral="GPIO"/>
      <edc:VirtualPin edc:name="QSPI0_CLK" edc:ppsfunction="B" ltx:memberofperipheral="QMSPI0"/>
      <edc:VirtualPin edc:name="QSPI0_CLK_CLAMP" edc:ppsfunction="C" ltx:memberofperipheral="SPI_MON0"/>
    </edc:Pin>
    <edc:Pin>
      <edc:VirtualPin edc:name="GPIO057" edc:ppsfunction="default" ltx:memberofperipheral="GPIO"/>
      <edc:VirtualPin edc:name="VCC_PWRGD" edc:ppsfunction="B" ltx:memberofperipheral="PCR"/>
    </edc:Pin>
    <edc:Pin>
      <edc:VirtualPin edc:name="GPIO063" edc:ppsfunction="default" ltx:memberofperipheral="GPIO"/>
      <edc:VirtualPin edc:name="SP1_ALT_CLK" edc:ppsfunction="B" ltx:memberofperipheral="SPI_MON1"/>
    </edc:Pin>
    <edc:Pin>
      <edc:VirtualPin edc:name="GPIO070" edc:ppsfunction="default" ltx:memberofperipheral="GPIO"/>
      <edc:VirtualPin edc:name="QSPI1_IN_IO0" edc:ppsfunction="B" ltx:memberofperipheral="QMSPI1"/>
      <edc:VirtualPin edc:name="QSPI1_IN_IO0" edc:ppsfunction="B" ltx:memberofperipheral="SPT1"/>
    </edc:Pin>
    <edc:Pin>
      <edc:VirtualPin edc:name="GPIO071" edc:ppsfunction="default" ltx:memberofperipheral="GPIO"/>
      <edc:VirtualPin edc:name="QSPI1_IN_CS0_n" edc:ppsfunction="B" ltx:memberofperipheral="QMSPI1"/>
    </edc:Pin>
    <edc:Pin>
      <edc:VirtualPin edc:name="GPIO104" edc:ppsfunction="default" ltx:memberofperipheral="GPIO"/>
      <edc:VirtualPin edc:name="UART0_TX" edc:ppsfunction="B" ltx:memberofperipheral="UART0"/>
      <edc:VirtualPin edc:name="TFDP_CLK" edc:ppsfunction="C" ltx:memberofperipheral="TFDP"/>
    </edc:Pin>
    <edc:Pin>
      <edc:VirtualPin edc:name="GPIO105" edc:ppsfunction="default" ltx:memberofperipheral="GPIO"/>
      <edc:VirtualPin edc:name="UART0_RX" edc:ppsfunction="B" ltx:memberofperipheral="UART0"/>
      <edc:VirtualPin edc:name="TFDP_DATA" edc:ppsfunction="C" ltx:memberofperipheral="TFDP"/>
    </edc:Pin>
    <edc:Pin>
      <edc:VirtualPin edc:name="GPIO106" edc:ppsfunction="default" ltx:memberofperipheral="GPIO"/>
      <edc:VirtualPin edc:name="AP0_RESET_n" edc:ppsfunction="B" ltx:memberofperipheral="SPI_MON0"/>
    </edc:Pin>
    <edc:Pin>
      <edc:VirtualPin edc:name="GPIO107" edc:ppsfunction="default" ltx:memberofperipheral="GPIO"/>
      <edc:VirtualPin edc:name="SCL10" edc:ppsfunction="B" ltx:memberofperipheral="SMB0"/>
      <edc:VirtualPin edc:name="SCL10" edc:ppsfunction="B" ltx:memberofperipheral="SMB1"/>
      <edc:VirtualPin edc:name="SCL10" edc:ppsfunction="B" ltx:memberofperipheral="SMB2"/>
      <edc:VirtualPin edc:name="SCL10" edc:ppsfunction="B" ltx:memberofperipheral="SMB3"/>
      <edc:VirtualPin edc:name="SCL10" edc:ppsfunction="B" ltx:memberofperipheral="SMB4"/>
      <edc:VirtualPin edc:name="ALT_VIOL_0" edc:ppsfunction="C" ltx:memberofperipheral="SPI_MON0"/>
    </edc:Pin>
    <edc:Pin>
      <edc:VirtualPin edc:name="GPIO112" edc:ppsfunction="default" ltx:memberofperipheral="GPIO"/>
      <edc:VirtualPin edc:name="ALT_VIOL_1" edc:ppsfunction="B" ltx:memberofperipheral="SPI_MON1"/>
      <edc:VirtualPin edc:name="ALT_TFDP_DATA" edc:ppsfunction="C" ltx:memberofperipheral="TFDP"/>
    </edc:Pin>
    <edc:Pin>
      <edc:VirtualPin edc:name="GPIO113" edc:ppsfunction="default" ltx:memberofperipheral="GPIO"/>
      <edc:VirtualPin edc:name="ICT9" edc:ppsfunction="B" ltx:memberofperipheral="CCT"/>
    </edc:Pin>
    <edc:Pin>
      <edc:VirtualPin edc:name="GPIO120" edc:ppsfunction="default" ltx:memberofperipheral="GPIO"/>
      <edc:VirtualPin edc:name="QSPI1_CS1_n" edc:ppsfunction="B" ltx:memberofperipheral="QMSPI1"/>
      <edc:VirtualPin edc:name="SPIMON_QSPI1_CS1_n" edc:ppsfunction="C" ltx:memberofperipheral="SPI_MON1"/>
    </edc:Pin>
    <edc:Pin>
      <edc:VirtualPin edc:name="GPIO121" edc:ppsfunction="default" ltx:memberofperipheral="GPIO"/>
      <edc:VirtualPin edc:name="QSPI1_IO0" edc:ppsfunction="B" ltx:memberofperipheral="QMSPI1"/>
      <edc:VirtualPin edc:name="QSPI1_IO0_CLAMP" edc:ppsfunction="C" ltx:memberofperipheral="SPI_MON1"/>
    </edc:Pin>
    <edc:Pin>
      <edc:VirtualPin edc:name="GPIO122" edc:ppsfunction="default" ltx:memberofperipheral="GPIO"/>
      <edc:VirtualPin edc:name="QSPI1_IO1" edc:ppsfunction="B" ltx:memberofperipheral="QMSPI1"/>
      <edc:VirtualPin edc:name="QSPI1_IO1_CLAMP" edc:ppsfunction="C" ltx:memberofperipheral="SPI_MON1"/>
    </edc:Pin>
    <edc:Pin>
      <edc:VirtualPin edc:name="GPIO123" edc:ppsfunction="default" ltx:memberofperipheral="GPIO"/>
      <edc:VirtualPin edc:name="QSPI1_IO2" edc:ppsfunction="B" ltx:memberofperipheral="QMSPI1"/>
      <edc:VirtualPin edc:name="QSPI1_IO2_CLAMP" edc:ppsfunction="C" ltx:memberofperipheral="SPI_MON1"/>
    </edc:Pin>
    <edc:Pin>
      <edc:VirtualPin edc:name="GPIO124" edc:ppsfunction="default" ltx:memberofperipheral="GPIO"/>
      <edc:VirtualPin edc:name="QSPI1_CS0_n" edc:ppsfunction="B" ltx:memberofperipheral="QMSPI1"/>
      <edc:VirtualPin edc:name="SPIMON_QSPI1_CS0_n" edc:ppsfunction="C" ltx:memberofperipheral="SPI_MON1"/>
    </edc:Pin>
    <edc:Pin>
      <edc:VirtualPin edc:name="GPIO125" edc:ppsfunction="default" ltx:memberofperipheral="GPIO"/>
      <edc:VirtualPin edc:name="QSPI1_CLK" edc:ppsfunction="B" ltx:memberofperipheral="QMSPI1"/>
      <edc:VirtualPin edc:name="QSPI1_CLK_CLAMP" edc:ppsfunction="C" ltx:memberofperipheral="SPI_MON1"/>
    </edc:Pin>
    <edc:Pin>
      <edc:VirtualPin edc:name="GPIO126" edc:ppsfunction="default" ltx:memberofperipheral="GPIO"/>
      <edc:VirtualPin edc:name="QSPI1_IO3" edc:ppsfunction="B" ltx:memberofperipheral="QMSPI1"/>
      <edc:VirtualPin edc:name="QSPI1_IO3_CLAMP" edc:ppsfunction="C" ltx:memberofperipheral="SPI_MON1"/>
    </edc:Pin>
    <edc:Pin>
      <edc:VirtualPin edc:name="GPIO127" edc:ppsfunction="default" ltx:memberofperipheral="GPIO"/>
      <edc:VirtualPin edc:name="SP1_ALT_IO2" edc:ppsfunction="B" ltx:memberofperipheral="SPI_MON1"/>
    </edc:Pin>
    <edc:Pin>
      <edc:VirtualPin edc:name="GPIO130" edc:ppsfunction="default" ltx:memberofperipheral="GPIO"/>
      <edc:VirtualPin edc:name="CLK32KHZ_IN" edc:ppsfunction="B" ltx:memberofperipheral="PCR"/>
    </edc:Pin>
    <edc:Pin>
      <edc:VirtualPin edc:name="GPIO131" edc:ppsfunction="default" ltx:memberofperipheral="GPIO"/>
      <edc:VirtualPin edc:name="SPI0PER_CS_n" edc:ppsfunction="B" ltx:memberofperipheral="SPT0"/>
      <edc:VirtualPin edc:name="AP1_RESET_n" edc:ppsfunction="B" ltx:memberofperipheral="SPI_MON1"/>
    </edc:Pin>
    <edc:Pin>
      <edc:VirtualPin edc:name="GPIO132" edc:ppsfunction="default" ltx:memberofperipheral="GPIO"/>
      <edc:VirtualPin edc:name="SDA6" edc:ppsfunction="B" ltx:memberofperipheral="SMB0"/>
      <edc:VirtualPin edc:name="SDA6" edc:ppsfunction="B" ltx:memberofperipheral="SMB1"/>
      <edc:VirtualPin edc:name="SDA6" edc:ppsfunction="B" ltx:memberofperipheral="SMB2"/>
      <edc:VirtualPin edc:name="SDA6" edc:ppsfunction="B" ltx:memberofperipheral="SMB3"/>
      <edc:VirtualPin edc:name="SDA6" edc:ppsfunction="B" ltx:memberofperipheral="SMB4"/>
    </edc:Pin>
    <edc:Pin>
      <edc:VirtualPin edc:name="GPIO140" edc:ppsfunction="default" ltx:memberofperipheral="GPIO"/>
      <edc:VirtualPin edc:name="SCL6" edc:ppsfunction="B" ltx:memberofperipheral="SMB0"/>
      <edc:VirtualPin edc:name="SCL6" edc:ppsfunction="B" ltx:memberofperipheral="SMB1"/>
      <edc:VirtualPin edc:name="SCL6" edc:ppsfunction="B" ltx:memberofperipheral="SMB2"/>
      <edc:VirtualPin edc:name="SCL6" edc:ppsfunction="B" ltx:memberofperipheral="SMB3"/>
      <edc:VirtualPin edc:name="SCL6" edc:ppsfunction="B" ltx:memberofperipheral="SMB4"/>
    </edc:Pin>
    <edc:Pin>
      <edc:VirtualPin edc:name="GPIO143" edc:ppsfunction="default" ltx:memberofperipheral="GPIO"/>
      <edc:VirtualPin edc:name="SDA4" edc:ppsfunction="B" ltx:memberofperipheral="SMB0"/>
      <edc:VirtualPin edc:name="SDA4" edc:ppsfunction="B" ltx:memberofperipheral="SMB1"/>
      <edc:VirtualPin edc:name="SDA4" edc:ppsfunction="B" ltx:memberofperipheral="SMB2"/>
      <edc:VirtualPin edc:name="SDA4" edc:ppsfunction="B" ltx:memberofperipheral="SMB3"/>
      <edc:VirtualPin edc:name="SDA4" edc:ppsfunction="B" ltx:memberofperipheral="SMB4"/>
    </edc:Pin>
    <edc:Pin>
      <edc:VirtualPin edc:name="GPIO144" edc:ppsfunction="default" ltx:memberofperipheral="GPIO"/>
      <edc:VirtualPin edc:name="SCL4" edc:ppsfunction="B" ltx:memberofperipheral="SMB0"/>
      <edc:VirtualPin edc:name="SCL4" edc:ppsfunction="B" ltx:memberofperipheral="SMB1"/>
      <edc:VirtualPin edc:name="SCL4" edc:ppsfunction="B" ltx:memberofperipheral="SMB2"/>
      <edc:VirtualPin edc:name="SCL4" edc:ppsfunction="B" ltx:memberofperipheral="SMB3"/>
      <edc:VirtualPin edc:name="SCL4" edc:ppsfunction="B" ltx:memberofperipheral="SMB4"/>
    </edc:Pin>
    <edc:Pin>
      <edc:VirtualPin edc:name="GPIO145" edc:ppsfunction="default" ltx:memberofperipheral="GPIO"/>
      <edc:VirtualPin edc:name="SDA9" edc:ppsfunction="B" ltx:memberofperipheral="SMB0"/>
      <edc:VirtualPin edc:name="SDA9" edc:ppsfunction="B" ltx:memberofperipheral="SMB1"/>
      <edc:VirtualPin edc:name="SDA9" edc:ppsfunction="B" ltx:memberofperipheral="SMB2"/>
      <edc:VirtualPin edc:name="SDA9" edc:ppsfunction="B" ltx:memberofperipheral="SMB3"/>
      <edc:VirtualPin edc:name="SDA9" edc:ppsfunction="B" ltx:memberofperipheral="SMB4"/>
    </edc:Pin>
    <edc:Pin>
      <edc:VirtualPin edc:name="GPIO146" edc:ppsfunction="default" ltx:memberofperipheral="GPIO"/>
      <edc:VirtualPin edc:name="SCL9" edc:ppsfunction="B" ltx:memberofperipheral="SMB0"/>
      <edc:VirtualPin edc:name="SCL9" edc:ppsfunction="B" ltx:memberofperipheral="SMB1"/>
      <edc:VirtualPin edc:name="SCL9" edc:ppsfunction="B" ltx:memberofperipheral="SMB2"/>
      <edc:VirtualPin edc:name="SCL9" edc:ppsfunction="B" ltx:memberofperipheral="SMB3"/>
      <edc:VirtualPin edc:name="SCL9" edc:ppsfunction="B" ltx:memberofperipheral="SMB4"/>
    </edc:Pin>
    <edc:Pin>
      <edc:VirtualPin edc:name="GPIO147" edc:ppsfunction="default" ltx:memberofperipheral="GPIO"/>
      <edc:VirtualPin edc:name="SDA15" edc:ppsfunction="B" ltx:memberofperipheral="SMB0"/>
      <edc:VirtualPin edc:name="SDA15" edc:ppsfunction="B" ltx:memberofperipheral="SMB1"/>
      <edc:VirtualPin edc:name="SDA15" edc:ppsfunction="B" ltx:memberofperipheral="SMB2"/>
      <edc:VirtualPin edc:name="SDA15" edc:ppsfunction="B" ltx:memberofperipheral="SMB3"/>
      <edc:VirtualPin edc:name="SDA15" edc:ppsfunction="B" ltx:memberofperipheral="SMB4"/>
    </edc:Pin>
    <edc:Pin>
      <edc:VirtualPin edc:name="GPIO150" edc:ppsfunction="default" ltx:memberofperipheral="GPIO"/>
      <edc:VirtualPin edc:name="SCL15" edc:ppsfunction="B" ltx:memberofperipheral="SMB0"/>
      <edc:VirtualPin edc:name="SCL15" edc:ppsfunction="B" ltx:memberofperipheral="SMB1"/>
      <edc:VirtualPin edc:name="SCL15" edc:ppsfunction="B" ltx:memberofperipheral="SMB2"/>
      <edc:VirtualPin edc:name="SCL15" edc:ppsfunction="B" ltx:memberofperipheral="SMB3"/>
      <edc:VirtualPin edc:name="SCL15" edc:ppsfunction="B" ltx:memberofperipheral="SMB4"/>
    </edc:Pin>
    <edc:Pin>
      <edc:VirtualPin edc:name="GPIO156" edc:ppsfunction="default" ltx:memberofperipheral="GPIO"/>
      <edc:VirtualPin edc:name="LED0" edc:ppsfunction="B" ltx:memberofperipheral="LED0"/>
    </edc:Pin>
    <edc:Pin>
      <edc:VirtualPin edc:name="GPIO157" edc:ppsfunction="default" ltx:memberofperipheral="GPIO"/>
      <edc:VirtualPin edc:name="LED1" edc:ppsfunction="B" ltx:memberofperipheral="LED1"/>
    </edc:Pin>
    <edc:Pin>
      <edc:VirtualPin edc:name="GPIO163" edc:ppsfunction="default" ltx:memberofperipheral="GPIO"/>
      <edc:VirtualPin edc:name="SPI1_KILL" edc:ppsfunction="B" ltx:memberofperipheral="SPI_MON1"/>
      <edc:VirtualPin edc:name="SPI_RESET_n" edc:ppsfunction="C" ltx:memberofperipheral="SPI_MON1"/>
    </edc:Pin>
    <edc:Pin>
      <edc:VirtualPin edc:name="GPIO165" edc:ppsfunction="default" ltx:memberofperipheral="GPIO"/>
      <edc:VirtualPin edc:name="QSPI1_IN_IO2" edc:ppsfunction="B" ltx:memberofperipheral="QMSPI1"/>
      <edc:VirtualPin edc:name="QSPI1_IN_IO2" edc:ppsfunction="B" ltx:memberofperipheral="SPT1"/>
    </edc:Pin>
    <edc:Pin>
      <edc:VirtualPin edc:name="GPIO170" edc:ppsfunction="default" ltx:memberofperipheral="GPIO"/>
      <edc:VirtualPin edc:name="TFDP_CLK" edc:ppsfunction="C" ltx:memberofperipheral="TFDP"/>
    </edc:Pin>
    <edc:Pin>
      <edc:VirtualPin edc:name="GPIO171" edc:ppsfunction="default" ltx:memberofperipheral="GPIO"/>
      <edc:VirtualPin edc:name="QSPI1_IN_IO3" edc:ppsfunction="B" ltx:memberofperipheral="QMSPI1"/>
      <edc:VirtualPin edc:name="QSPI1_IN_IO3" edc:ppsfunction="B" ltx:memberofperipheral="SPT1"/>
      <edc:VirtualPin edc:name="TFDP_DATA" edc:ppsfunction="C" ltx:memberofperipheral="TFDP"/>
    </edc:Pin>
    <edc:Pin>
      <edc:VirtualPin edc:name="GPIO200" edc:ppsfunction="default" ltx:memberofperipheral="GPIO"/>
      <edc:VirtualPin edc:name="QSPI1_IN_CLK" edc:ppsfunction="B" ltx:memberofperipheral="QMSPI1"/>
      <edc:VirtualPin edc:name="QSPI1_IN_CLK" edc:ppsfunction="B" ltx:memberofperipheral="SPT1"/>
    </edc:Pin>
    <edc:Pin>
      <edc:VirtualPin edc:name="GPIO201" edc:ppsfunction="default" ltx:memberofperipheral="GPIO"/>
      <edc:VirtualPin edc:name="CLK32KHZ_OUT" edc:ppsfunction="B" ltx:memberofperipheral="PCR"/>
    </edc:Pin>
    <edc:Pin>
      <edc:VirtualPin edc:name="GPIO202" edc:ppsfunction="default" ltx:memberofperipheral="GPIO"/>
      <edc:VirtualPin edc:name="QSPI0_IN_IO2" edc:ppsfunction="B" ltx:memberofperipheral="QMSPI0"/>
      <edc:VirtualPin edc:name="QSPI0_IN_IO2" edc:ppsfunction="B" ltx:memberofperipheral="SPT0"/>
    </edc:Pin>
    <edc:Pin>
      <edc:VirtualPin edc:name="GPIO203" edc:ppsfunction="default" ltx:memberofperipheral="GPIO"/>
      <edc:VirtualPin edc:name="QSPI0_IN_IO3" edc:ppsfunction="B" ltx:memberofperipheral="QMSPI0"/>
      <edc:VirtualPin edc:name="QSPI0_IN_IO3" edc:ppsfunction="B" ltx:memberofperipheral="SPT0"/>
    </edc:Pin>
    <edc:Pin>
      <edc:VirtualPin edc:name="GPIO204" edc:ppsfunction="default" ltx:memberofperipheral="GPIO"/>
      <edc:VirtualPin edc:name="QSPI0_IN_CLK" edc:ppsfunction="B" ltx:memberofperipheral="QMSPI0"/>
      <edc:VirtualPin edc:name="QSPI0_IN_CLK" edc:ppsfunction="B" ltx:memberofperipheral="SPT0"/>
    </edc:Pin>
    <edc:Pin>
      <edc:VirtualPin edc:name="GPIO223" edc:ppsfunction="default" ltx:memberofperipheral="GPIO"/>
      <edc:VirtualPin edc:name="QSPI0_IO0" edc:ppsfunction="B" ltx:memberofperipheral="QMSPI0"/>
      <edc:VirtualPin edc:name="QSPI0_IO0_CLAMP" edc:ppsfunction="C" ltx:memberofperipheral="SPI_MON0"/>
    </edc:Pin>
    <edc:Pin>
      <edc:VirtualPin edc:name="GPIO224" edc:ppsfunction="default" ltx:memberofperipheral="GPIO"/>
      <edc:VirtualPin edc:name="QSPI0_IO1" edc:ppsfunction="B" ltx:memberofperipheral="QMSPI0"/>
      <edc:VirtualPin edc:name="QSPI0_IO1_CLAMP" edc:ppsfunction="C" ltx:memberofperipheral="SPI_MON0"/>
    </edc:Pin>
    <edc:Pin>
      <edc:VirtualPin edc:name="GPIO227" edc:ppsfunction="default" ltx:memberofperipheral="GPIO"/>
      <edc:VirtualPin edc:name="QSPI0_IO2" edc:ppsfunction="B" ltx:memberofperipheral="QMSPI0"/>
      <edc:VirtualPin edc:name="QSPI0_IO2_CLAMP" edc:ppsfunction="C" ltx:memberofperipheral="SPI_MON0"/>
    </edc:Pin>
    <edc:Pin>
      <edc:VirtualPin edc:name="GPIO250" edc:ppsfunction="default" ltx:memberofperipheral="GPIO"/>
      <edc:VirtualPin edc:name="SPI0PER_CS_n" edc:ppsfunction="B" ltx:memberofperipheral="SPI_MON0"/>
    </edc:Pin>
    <edc:Pin>
      <edc:VirtualPin edc:name="GPIO253" edc:ppsfunction="default" ltx:memberofperipheral="GPIO"/>
      <edc:VirtualPin edc:name="TST_CLK_OUT" edc:ppsfunction="B" ltx:memberofperipheral="PCR"/>
    </edc:Pin>
    <edc:Pin>
      <edc:VirtualPin edc:name="JTAG_RST_N"/>
    </edc:Pin>
    <edc:Pin>
      <edc:VirtualPin edc:name="nRESET_IN" edc:ppsfunction="A" ltx:memberofperipheral="PCR"/>
    </edc:Pin>
    <edc:Pin>
      <edc:VirtualPin edc:name="VSS_ANALOG"/>
    </edc:Pin>
    <edc:Pin>
      <edc:VirtualPin edc:name="VTR_PLL"/>
    </edc:Pin>
    <edc:Pin>
      <edc:VirtualPin edc:name="VSS"/>
    </edc:Pin>
    <edc:Pin>
      <edc:VirtualPin edc:name="VTR_REG"/>
    </edc:Pin>
    <edc:Pin>
      <edc:VirtualPin edc:name="VTR1"/>
    </edc:Pin>
    <edc:Pin>
      <edc:VirtualPin edc:name="VTR_ANALOG"/>
    </edc:Pin>
    <edc:Pin>
      <edc:VirtualPin edc:name="VR_CAP"/>
    </edc:Pin>
    <edc:Pin>
      <edc:VirtualPin edc:name="VSS"/>
    </edc:Pin>
    <edc:Pin>
      <edc:VirtualPin edc:name="VTR2"/>
    </edc:Pin>
    <edc:Pin>
      <edc:VirtualPin edc:name="VSS"/>
    </edc:Pin>
    <edc:Pin>
      <edc:VirtualPin edc:name="VSS"/>
    </edc:Pin>
  </edc:PinList>
</edc:PIC>
