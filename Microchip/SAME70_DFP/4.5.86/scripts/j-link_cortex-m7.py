# This file is autogenerated
comm_speed=8000000
comm_iface = True
reset_delay = 0
has_reset = True
show_output = False
log_level = 0

def onShowPropsDFP2(t):
    ide.addBooleanProperty(t,"arm.use_vtor" , "*|programoptions|programoptions.eraseb4program","Set PC and SP to VTOR","After reset, force PC and SP to the entries defined by the VTOR", False)
    ide.addTextProperty(t,"arm.vtor_adr" , "*|programoptions|programoptions.eraseb4program","VTOR table or numerical address", "Enter address of vector table", "exception_table")
    ide.addPropCategory(t,"diagnostics" , "*|programoptions", "Diagnostics")
    ide.addBooleanProperty(t,"script.show_output" , "*|diagnostics|*","Output diagnostic logging","Show diagnostic text in the Output window", False)
    ide.addTextProperty(t,"script.log_level" , "*|diagnostics|*","Diagnostic log level","Set diagnostic level (usually 0 1 or 3)", "1")
    ide.addTextProperty(t,"script.reset_delay" , "*|diagnostics|*","Additional delay after reset","Enter additional RST settling delay in msec", "0")
    ide.addBooleanProperty(t,"script.has_reset" , "*|diagnostics|*","Uncheck if RESET line is not wired","Normally checked. Uncheck if the target does not have RST connected to the debugger", True)

def _begin_communication_session():    
    global comm_iface, comm_speed,_stealth_runstate, erase_as_needed 
    global log_level,show_output,reset_delay, target_was_reset, has_reset
    log_level  = settings.getNumeric("script.log_level",log_level)
    show_output= settings.getBool("script.show_output",show_output)
    has_reset  = settings.getBool("script.has_reset",has_reset)
    reset_delay= settings.getNumeric("script.reset_delay",reset_delay)
    comm_iface = settings.getString("communication.interface", "swd") == "swd"
    comm_speed = settings.getNumeric("communication.frequency", comm_speed)
    _stealth_runstate = 2
    erase_as_needed = True    
    dev.Connect(comm_iface, comm_speed)
    dev.SetApiLogging(log_level)
    log.setShowOutput(show_output)
    if "RH71" in device:
        initialize_HEFC()

def _end_communication_session(): 
    pass

def _end_of_operations():
    pass

def _begin_debug_session():
    reset_target()
    
def _debug_read(mem_type, start, length, data):
    _prog_read(mem_type, start, length, data)

def _debug_write(mt, start, length, data):
    dev.Write(start, data, 0, length)

def _get_pc():
    return dev.ReadReg64(arm.PC)

def _get_reg(idx):
    return dev.ReadReg64(idx)

def _set_reg(idx,val):
    return dev.WriteReg64(idx,val)

def _mem_read(start, length, data):
    dev.Read(start, data, 0, length)

def _mem_write(start, length, data):
    dev.Write(start, data, 0, length)

def _run_target():
    dev.GoEx(1, 1)

def _halt_target():
    dev.Halt()

def _step_target():
    dev.Step()

def _set_pc(pc):
    dev.WriteReg64(arm.PC, pc)

def _reset_target():
    reset_and_halt()

def reset_and_halt():
    dev.Reset()

g_stopped = False
def _is_target_running():
    global g_stopped

    stopped = dev.IsHalted()
    if stopped != g_stopped:
        log.info("Debug: target has halted" if stopped else "Debug: target is now running")
        g_stopped = stopped
    return 0  == g_stopped

def _end_debug_session(): 
    pass

def _release_from_reset():
    log.error("Hold in reset not implemented")

def _hold_in_reset():
    log.error("Hold in reset not implemented")
    
efc_cmd_wp   = 0x5a000001
efc_cmd_ewp  = 0x5a000003
efc_cmd_ea   = 0x5a000005
efc_cmd_epa  = 0x5a000007
efc_cmd_slb  = 0x5a000008
efc_cmd_clb  = 0x5a000009
efc_cmd_glb  = 0x5a00000a
efc_cmd_sgpb = 0x5a00000B
efc_cmd_cgpb = 0x5a00000C
efc_cmd_ggpb = 0x5a00000D


if "RH71" in device:
    FLASH_START = 0x10000000
    PAGE_SIZE = 256
    PAGE_PER_LOCKBIT = 1
    GPNVM_BIT_MASK = 0x0FFFFFFF0FFFFFFF0FFFFFFF00000702L   # Bit mask for user changeable GPNVM bits
    chipid = 0x40100000  # HEFC CHIPID register
    efc_fmr  = 0x40004000  # HEFC Flash Mode Register
    efc_fcr  = 0x40004004  # HEFC Flash Command Register
    efc_fsr  = 0x40004008  # HEFC Flash Status Register
    efc_frr  = 0x4000400c  # HEFC Flash Result Register
    efc_fpmr = 0x40004040  # HEFC Flash Power Management Register
    efc_wpmr = 0x400040e4  # HEFC Write Protection Mode Register
    efc_cmd_ep = 0x5a000006  # available on SAMRH71, but not available on Canopus (SAME70, S70, V70/71)
    rstc_cr = 0x40100200
    rstc_sr = 0x40100204
    rstc_mr = 0x40100208
elif "M7" in architecture:
    FLASH_START = 0x0400000
    PAGE_SIZE = 512
    PAGE_PER_LOCKBIT = 32
    GPNVM_BIT_MASK = 0x183 # Bit mask for user changeable GPNVM bits
    chipid = 0x400e0940  # EEFC CHIPID register
    efc_fmr  = 0x400e0c00  # EEFC Flash Mode Register
    efc_fcr  = 0x400e0c04  # EEFC Flash Command Register
    efc_fsr  = 0x400e0c08  # EEFC Flash Status Register
    efc_frr  = 0x400e0c0c  # EEFC Flash Result Register
    efc_wpmr = 0x400e0ce4  # EEFC Write Protection Mode Register
    efc_cmd_ewp = 0x5a000003  # available on Canopus (SAME70, S70, V70/71), but not available on SAMRH71
    efc_cmd_ewpl = 0x5a000004  # available on Canopus (SAME70, S70, V70/71), but not available on SAMRH71
    rstc_cr = 0x400e1800
    rstc_sr = 0x400e1804
    rstc_mr = 0x400e1808
else: #sam3 and sam4 devices 
    FLASH_START = 0x0400000
    PAGE_SIZE = 512
    PAGE_PER_LOCKBIT = 16
    GPNVM_BIT_MASK = 0x183 # Bit mask for user changeable GPNVM bits
    chipid = 0x400e0740  # EEFC CHIPID register
    efc_fmr  = 0x400e0a00  # EEFC Flash Mode Register
    efc_fcr  = 0x400e0a04  # EEFC Flash Command Register
    efc_fsr  = 0x400e0a08  # EEFC Flash Status Register
    efc_frr  = 0x400e0a0c  # EEFC Flash Result Register
    rstc_cr = 0x400e1400
    rstc_sr = 0x400e1404
    rstc_mr = 0x400e1408

def log_efc_fsr_error(fsr):
    err_string = ""
    if fsr & 0x00080000: # FSR_MECCEMSB
        err_string = "MECCEMSB"
    if fsr & 0x00040000: # FSR_UECCEMSB
        err_string += " UECCEMSB"
    if fsr & 0x00020000: # FSR_MECCELSB
        err_string += " MECCELSB"
    if fsr & 0x00010000: # FSR_UECCELSB
        err_string += " UECCELSB"
    if fsr & 0x10: # FSR_WREER
        err_string += " WREER"
    if fsr & 8: # FSR_FLERR
        err_string += " FLERR"
    if fsr & 4: # FSR_FLOCKE
        err_string += " FLOCKE"
    if fsr & 2: # FSR_FCMDE
        err_string += " FCMDE"
    if err_string == "":
        return
    err_string = "Flash controller error " + err_string 
    raise Exception(err_string)

def waitForFlashReady():
    n = 0
    max_retries = 100
    while n < max_retries:
        r = dev.Read32(efc_fsr)
        log_efc_fsr_error(r)
        if r & 1: # FSR_FRDY:
            break
        dev.Delay(100000) # 100ms
        n = n+1
    if n == max_retries:
        raise Exception("Timeout waiting for flash ready")

def bitsInByte(byteValue):
    for i in xrange(8):
        yield (byteValue >> i) & 1

def eefc_cmd(cmd):
    dev.Write32(efc_fcr, cmd)
    waitForFlashReady()

def write_config(address, length, data):
    log.info("Prog: write_config at address 0x%0X, length 0x%0X" % (address, length))
    # Converting value to indexing access, and writing one GPNVM bit at the time
    if address == 0xD0000000:
        bit_index = 0
        for val in data:
            for bit in bitsInByte(val):
                if((GPNVM_BIT_MASK >> bit_index) & 1):
                    if(bit == 1):
                        log.info("Debug: Setting GPNVM bit %d" % bit_index)
                        eefc_cmd( efc_cmd_sgpb | (bit_index << 8))
                    else:
                        log.info("Debug: Clearing GPNVM bit %d" % bit_index)
                        eefc_cmd( efc_cmd_cgpb | (bit_index << 8))
                bit_index += 1
    elif address == 0xD0000004 or "RH71" in device and address == 0xD0000010:
        bit_index = 0
        for val in data:
            for bit in bitsInByte(val):
                if (bit == 1):
                    log.info("Debug: Setting Lock bit %d" % bit_index)
                    eefc_cmd( efc_cmd_slb | (bit_index * PAGE_PER_LOCKBIT << 8))
                else:
                    log.info("Debug: Clearing Lock bit %d" % bit_index)
                    eefc_cmd( efc_cmd_clb | (bit_index * PAGE_PER_LOCKBIT << 8))
                bit_index += 1

def read_config(address, length, data):
    log.info("Prog: read_config at address 0x%0X, length 0x%0X" % (address, length))
    if address == 0xD0000000:
        eefc_cmd(efc_cmd_ggpb)
    elif address == 0xD0000004 or "RH71" in device and address == 0xD0000010:
        eefc_cmd(efc_cmd_glb)
        
    for read_index in range(data.__len__()):
        if read_index % 4 == 0:
            read_data = dev.Read32(efc_frr)
            log.info("Prog: Config bits at address 0x%0X, value: 0x%0X" % (address, read_data))
        data[read_index] = 0xFF & read_data
        read_data = read_data >> 8

def _erase():
    global erase_as_needed
    dev.Halt()
    dev.api.JLINK_EraseChip()
    erase_as_needed = False # tell prog_write not to erase rows prior to write
    dev.Delay(100000)

def _begin_programming_operation():
    pass

def _prog_write(type_of_mem, address, length, data): 
    global erase_as_needed
    if str(type_of_mem) == "Cfg":
        write_config(address, length, data)
        return
    elif str(type_of_mem) != "Pgm":
        dev.Write(address, data, 0, length)
        return

    if address == 0x41004000:
        log.error("Setting the security bit is not supported on Segger tools")
    _flash_write(address, length, data, erase_as_needed)
    erase_as_needed = True

def _flash_write(address, length, data, doerase):
    dev.Write(address, data, 0, length)

def _prog_read(type_of_mem, address, length, data):    
    if str(type_of_mem) == "Cfg":
        read_config(address, length, data)
        return
    dev.Read(address, data, 0, length)

def _end_of_operations():
    dev.Reset()

def get_sp():
    return dev.ReadReg64(arm.SP)

def set_sp(sp):
    log.info("Debug: Set sp to 0x%0x" % sp)
    dev.WriteReg64(arm.SP, sp)

# Workarounds for flash bank startup after reset problems with SAMRH71F20-EK board rev 2.0
rh71_2_0_workaround_VAR_factor = True
rh71_2_0_workaround_init_PC_SP = True
rh71_2_0_workaround_reset_30ms_delay = True

reset_delay = 30000 if "RH71" in device and rh71_2_0_workaround_reset_30ms_delay else 0

def initialize_HEFC(): # only for SAMRH71
    log.info("Prog: initialize_HEFC")

    # set up GCLK for HEFC
    dev.Write32(0x40100254, 0x00008000) # disable watchdog        wdt_mr
    dev.Write32(0x4000C020, 0x00370028) # Set internal RC 10 MHz  ckgr_mor
    dev.Write32(0x4000C10C, 0x30401432) # Set GCLK with div 5     pmc_pcr

    if rh71_2_0_workaround_VAR_factor:
        set_var_factor_and_power_toggle_flash()

    #waitForPWSReady
    n = 0
    max_retries = 100
    
    while n < max_retries:
        r = dev.Read32(efc_fpmr)
        if r & 2: # PWS_STAT
            dev.Delay(250000)  # wait 250ms after seeing PWS_STAT bit
            break
        dev.Delay(100000) # 100ms
        n = n+1
    if n == max_retries:
        raise Exception("Timeout waiting for PWS ready")

    if rh71_2_0_workaround_init_PC_SP:
        initialize_PC_SP()

def set_var_factor_and_power_toggle_flash(): # only for SAMRH71, probably only needed for rev 2.0 boards
    # reset problem for flash (for rev 2.0 of device), can read flash only every second reset
    # without this workaround
    dev.Write32(efc_fpmr, 0x00013F0F) # set var factor at 0x3F  1111
    dev.Write32(efc_fpmr, 0x00013F0E) # Power OFF flash         1110
    dev.Write32(efc_fpmr, 0x00003F0D) # Power ON flash          1101

def initialize_PC_SP(): # only for SAMRH71, probably only needed for rev 2.0 boards
    log.info("Initialize PC and SP (should be done by core, problem in SAMRH71F20-EK board rev 2.0)")
    reset_handler = dev.Read32(0x10000004)
    old_pc = get_pc()
    pc_different = old_pc != (reset_handler & 0xFFFFFFFE)

    stack_pointer = dev.Read32(0x10000000)
    old_sp = get_sp()
    sp_different = old_sp != stack_pointer

    if pc_different and reset_handler != 0xFFFFFFFF: # only if not flash is erased
        set_pc(reset_handler)
        # Correct EPSR T bit in case core didn't initialize PC and T bit correctly (if PC bit 0 is set, then set T bit)
        psr = dev.ReadReg64(16)
        if reset_handler & 1 and not psr & 0x01000000:
            log.error("PC initialization by core failed, corrected 0x%X -> 0x%X and set EPSR T bit" % (old_pc, get_pc()))
            dev.WriteReg64(16, psr | 0x01000000)
        else:
            log.error("PC initialization by core failed, corrected 0x%X -> 0x%X" % (old_pc, get_pc()))
    if sp_different and stack_pointer != 0xFFFFFFFF: # only if not flash is erased
        set_sp(stack_pointer)
        log.error("SP initialization by core failed, corrected 0x%X -> 0x%X" % (old_sp, get_sp()))

def begin_communication_session(): #mplab
    log.info("Begin comm session")
    _begin_communication_session()

def end_communication_session(): #mplab
    log.info("End comm session")
    _end_communication_session()

def begin_programming_operation(): #mplab
    log.info("Begin operations")
    _begin_programming_operation()

def read_device_id():#mplab
    log.info("Read device ID")
    return _read_device_id()

def erase(): #mplab
    log.info("Erase")
    _erase()

def prog_write(type_of_mem, address, length, data): #mplab
    log.info("Writing %08x bytes to address 0x%08x of %s memory" % (length, address, type_of_mem))
    _prog_write(type_of_mem, address, length, data)

def prog_read(type_of_mem, address, length, data): #mplab
    log.info("Reading %08x bytes from address 0x%08x of %s memory" % (length, address, type_of_mem))
    _prog_read(type_of_mem, address, length, data)

def end_of_operations():#mplab
    log.info("End of operations")
    _end_of_operations()

def begin_debug_session():  #mplab
    log.info("Debug: Init debug session")
    _begin_debug_session()

def debug_read(mt, start, length, data):  #mplab
    log.info("Debug: Reading %08x bytes at start address 0x%08x (%s)" % (length, start, mt))
    _debug_read(mt, start, length, data)

def debug_write(mt, start, length, data):  #mplab
    log.info("Debug: Writing %08x bytes at start address 0x%08x (%s)" % (length, start, mt))
    _debug_write(mt, start, length, data)

def set_pc(pc):  #mplab
    log.info("Debug: set pc to 0x%08x" % pc)
    _set_pc(pc)

def get_pc():  #mplab
    pc = _get_pc()
    log.info("Debug: get_pc PC=0x%08x" % pc)
    return pc

def run_target():#mplab
    log.info("Debug: run target")
    _run_target()

_stealth_runstate = 2
def halt_target():  #mplab
    global _stealth_runstate    
    log.info("Debug: halt target")
    _stealth_runstate = 2  # cancels stealth mode
    _halt_target()

def step_target():  #mplab
    log.info("Debug: stepping at pc 0x%08x" % get_pc())
    _step_target()

def reset_target(): #mplab
    log.info("Debug: reset")
    _reset_target()
    on_after_reset() # call autoload hook

def is_target_running():#mplab
    global _stealth_runstate
    if _stealth_runstate == 2:
        return _is_target_running()
    return _stealth_runstate != 0

def on_after_reset(): 
    if not settings.getBool("arm.use_vtor", False):
        return
    vtor_name  = settings.getString("arm.vtor_adr", "0")

    vtor = -1
    try:
        vtor = int(vtor_name,0)
    except:
        try:
            vtor=deb.GetSymbolAddress(vtor_name)
        except:
            log.error("Debug: failed to compute location of VTOR")
            return
    load_vtor(vtor) 
    pass

def load_vtor(adr):
    try:
        pc = dev.Read32(adr + 4)
        sp = dev.Read32(adr)
        set_pc(arm.PC,pc)
        dev.WriteReg64(arm.SP,sp)
        log.info("Setting pc=%08x and sp=%08x" % (pc, sp))
    except:
        log.error("Debug: failed to set PC and SP to contents of exception_table")

def on_program_done():
    on_after_reset()

def end_debug_session():  #mplab
    log.info("Debug: End debug session")
    _end_debug_session()

def verify_transfer(type_of_mem, address, data, length):  #mplab
    log.error("Not-implemented Verifying %08x bytes to address 0x%0x of %s memory" % (length, address, type_of_mem))
    return True

def blank_check():  #mplab
    log.info("Blank check")

def hold_in_reset():  #mplab
    log.info("Hold in reset")
    _hold_in_reset()

def release_from_reset():  #mplab
    log.info("Release from reset")
    _release_from_reset()
    
