# This file is autogenerated
comm_speed=2000000
erase_as_needed = True  # used in prog_write
comm_iface = True
reset_delay = 0
show_output = False
log_level = 0
use_vtor  = False
vtor_name = "0"

def begin_debug_session():  # mplab
    log.info("Debug: Init debug session")
    dev.Connect(comm_iface, comm_speed)
    reset_and_halt()
    cache_onDebugStart()

def begin_communication_session():  # mplab
    global log_level,show_output,reset_delay
    log_level    = settings.getNumeric("script.log_level",log_level)
    show_output  = settings.getBool("script.show_output",show_output)
    reset_delay = settings.getNumeric("script.reset_delay",reset_delay)

    dev.SetApiLogging(log_level)
    log.setShowOutput(show_output)

    global comm_iface, comm_speed, erase_as_needed, use_vtor,vtor_name
    comm_iface = settings.getString("communication.interface", "swd") == "swd"
    comm_speed = settings.getNumeric("communication.frequency", comm_speed)
    use_vtor   = settings.getBool("arm.use_vtor", False)
    vtor_name  = settings.getString("arm.vtor_adr", "0")
    erase_as_needed = True  # used in prog_write

def onShowPropsDFP2(t):
    ide.addBooleanProperty(t,"arm.use_vtor" , "*|programoptions|programoptions.eraseb4program","Set PC and SP to VTOR","After reset, force PC and SP to the entries defined by the VTOR", False)
    ide.addTextProperty(t,"arm.vtor_adr" , "*|programoptions|programoptions.eraseb4program","VTOR table or numerical address", "Enter address of vector table", "exception_table")
    ide.addPropCategory(t,"diagnostics" , "*|communication", "Diagnostics")
    ide.addBooleanProperty(t,"script.show_output" , "*|diagnostics|*","Output diagnostic logging","Show diagnostic text in the Output window", False)
    ide.addTextProperty(t,"script.log_level" , "*|diagnostics|*","Diagnostic log level","Set diagnostic level (usually 0 1 or 3)", "0")
    ide.addTextProperty(t,"script.reset_delay" , "*|debugoptions|*","Additional delay after reset","Enter additional RST settling delay in msec", "0")

def print_dhcsr_v(t, d):
    log.info(t + arm.getDHCSRString(d))

def print_dhcsr(text):
    try:
        d = dev.Read32(arm.DHCSR)
        print_dhcsr_v(text, d)
        return d
    except:
        log.log("DHCSR is unreadable")
        return 0

def verify_transfer(type_of_mem, address, data, length):  # mplab
    log.info("Prog: not implemented: Verifying %d bytes to address 0x%0x of %s memory" % (length, address, type_of_mem))

def blank_check():  # mplab
    log.info("Prog: Blank check")

def debug_read(mem_type, start, length, data):  # mplab
    log.info("Debug: Reading %d bytes at start address 0x%08x (%s)" % (length, start, mem_type))
    cache_onDataRead(start,length)
    dev.Read(start, data, 0, length)

def debug_write(mem_type, start, length, data):  # mplab
    log.info("Debug: Writing %d bytes at start address 0x%08x (%s)" % (length, start, mem_type))
    cache_onDataWrite(start,length)
    dev.Write(start, data, 0, length)

def get_pc():  # mplab
    try:
        pc = dev.ReadReg64(15)
    except:
        log.error("get_pc returned error")
        return 0
    log.info("get_pc PC=0x%08x" % pc)
    return pc

def run_target():  # mplab
    log.info("Debug: run target")
    dev.Write32(arm.DHCSR, 0xa05f0001)  # DBGKEY | C_DEBUGEN | C_HALT

def halt_target():  # mplab
    log.info("Debug: halt target")
    dev.Write32(arm.DHCSR, 0xa05f0003)  # DBGKEY | C_DEBUGEN | C_HALT

def step_target():  # mplab
    log.info("Debug: stepping at pc 0x%08x" % get_pc())

    dev.Write32(arm.DHCSR, 0xa05f000b)  # DBGKEY | C_DEBUGEN | C_HALT | C_MASKINTS
    dev.Write32(arm.DHCSR, 0xa05f000d)  # DBGKEY | C_DEBUGEN | C_STEP | C_MASKINTS
    dev.Write32(arm.DHCSR, 0xa05f0003)  # DBGKEY | C_DEBUGEN | C_HALT

def set_pc(pc):  # mplab
    log.info("Debug: set pc to 0x%08x" % pc)
    dev.WriteReg64(15, pc)

def print_byte_array(text, array, index, size):
    string = text
    for i in range(size):
        string += " %x" % array[i+index]
    log.info(string)

g_is_running = True
def is_target_running():  # mplab
    global g_is_running
    dhcsr = dev.Read32(arm.DHCSR)
    state = 0 == (dhcsr & 0x20000)
    if state != g_is_running:
        log.info("Debug: target is now running" if state else "Debug: target has halted")
        g_is_running = state
    if not g_is_running:
        cache_onStop()
    return g_is_running

def on_after_reset(): 
    global use_vtor,vtor_name
    if not use_vtor:
        return
    vtor = -1
    try:
        vtor = int(vtor_name,0)
    except:
        try:
            vtor=deb.GetSymbolAddress(vtor_name)
        except:
            log.error("Debug: failed to compute location of VTOR")
            return
    load_vtor(vtor) 
    pass

def load_vtor(adr):
    try:
        dev.WriteReg64(arm.PC,dev.Read32(adr + 4))
        dev.WriteReg64(arm.SP,dev.Read32(adr))
    except:
        log.error("Debug: failed to set PC and SP to vtor[0] and vtor[4], with vtor=0x%08x" % adr)


def on_program_done():
    on_after_reset()

def reset_target():  # mplab
    log.info("Debug: Reset target")
    reset_and_halt()
    on_after_reset() # call autoload hook

def end_debug_session():  # mplab
    log.info("Debug: End debug session")
    run_target()
    dev.Disconnect()

def hold_in_reset():  # mplab
    log.info("Prog: Hold in reset")
    dev.Connect(True, 100000)
    dev.Pins(0, dev.RESET, 1000)

def alt_hold_in_reset():  # mplab
    # Alternative if RESET pin is not connected to debugger
    log.info("Prog: Hold in reset , no reset line")
    dev.Connect(True, 100000)
    reset_and_halt()

def release_from_reset():  # mplab
    global reset_delay
    log.info("Prog: Release from reset")
    # toggle reset line
    dev.Connect(True, 100000)
    dev.Pins(0, dev.RESET, 1000)
    dev.Delay(reset_delay)
    dev.Pins(dev.RESET, dev.RESET, 1000)  # now float reset back
    dev.Delay(reset_delay)

def alt_release_from_reset():  # mplab
    log.info("Prog: Release from reset, no reset line")
    dev.Connect(True, 100000)
    dev.Write32(dev.AIRCR, 0x05fa0004)  # VECTKEY | SYSRESETREQ

def set_sw_bp_gen(address, erase_size, instruction, flags):  # mplab
    global erase_as_needed
    log.debug("Debug: set/reset bp at address 0x%0x, store instructions 0x%0x, flags = 0x%0x" % (address, instruction, flags))
    if address >= 0x20000000:
        erase_size = 4 

    erase_page_start = address & ~(erase_size-1)
    address_in_erase_page = address & (erase_size-1)

    data = bytearray(erase_size)
    cache_invalidateInstrCache()
    dev.Read(erase_page_start, data, 0, erase_size)
    return_value = data[address_in_erase_page] | (data[address_in_erase_page+1] << 8)

    # Insert software breakpoint instruction in the data
    data[address_in_erase_page] = instruction & 0xFF
    data[address_in_erase_page+1] = (instruction >> 8) & 0xFF

    if erase_size == 4:
        dev.Write(erase_page_start, data, 0, erase_size)
    else:
        erase_as_needed = True
        prog_write("Pgm", erase_page_start, erase_size, data)
    return return_value


# device specific functions

efc_cmd_wp   = 0x5a000001
efc_cmd_ewp  = 0x5a000003
efc_cmd_ea   = 0x5a000005
efc_cmd_epa  = 0x5a000007
efc_cmd_sgpb = 0x5a00000B
efc_cmd_cgpb = 0x5a00000C
efc_cmd_ggpb = 0x5a00000D


if "RH71" in device:
    FLASH_START = 0x10000000
    PAGE_SIZE = 256
    GPNVM_BIT_MASK = 0x2   # Bit mask for user changeable GPNVM bits
    efc_fmr  = 0x40004000  # HEFC Flash Mode Register
    efc_fcr  = 0x40004004  # HEFC Flash Command Register
    efc_fsr  = 0x40004008  # HEFC Flash Status Register
    efc_frr  = 0x4000400c  # HEFC Flash Result Register
    efc_fpmr = 0x40004040  # HEFC Flash Power Management Register
    efc_wpmr = 0x400040e4  # HEFC Write Protection Mode Register
    efc_cmd_ep = 0x5a000006  # available on SAMRH71, but not available on Canopus (SAME70, S70, V70/71)
    rstc_cr = 0x40100200
    rstc_sr = 0x40100204
    rstc_mr = 0x40100208
elif "M7" in architecture:
    FLASH_START = 0x0400000
    PAGE_SIZE = 512
    GPNVM_BIT_MASK = 0x183 # Bit mask for user changeable GPNVM bits
    efc_fmr  = 0x400e0c00  # EEFC Flash Mode Register
    efc_fcr  = 0x400e0c04  # EEFC Flash Command Register
    efc_fsr  = 0x400e0c08  # EEFC Flash Status Register
    efc_frr  = 0x400e0c0c  # EEFC Flash Result Register
    efc_wpmr = 0x400e0ce4  # EEFC Write Protection Mode Register
    efc_cmd_ewp = 0x5a000003  # available on Canopus (SAME70, S70, V70/71), but not available on SAMRH71
    efc_cmd_ewpl = 0x5a000004  # available on Canopus (SAME70, S70, V70/71), but not available on SAMRH71
    rstc_cr = 0x400e1800
    rstc_sr = 0x400e1804
    rstc_mr = 0x400e1808
else: #sam3 and sam4 devices 
    FLASH_START = 0x0400000
    PAGE_SIZE = 512
    GPNVM_BIT_MASK = 0x183 # Bit mask for user changeable GPNVM bits
    efc_fmr  = 0x400e0a00  # EEFC Flash Mode Register
    efc_fcr  = 0x400e0a04  # EEFC Flash Command Register
    efc_fsr  = 0x400e0a08  # EEFC Flash Status Register
    efc_frr  = 0x400e0a0c  # EEFC Flash Result Register
    rstc_cr = 0x400e1400
    rstc_sr = 0x400e1404
    rstc_mr = 0x400e1408

def log_efc_fsr_error(fsr):
    err_string = ""
    if fsr & 0x00080000: # FSR_MECCEMSB
        err_string = "MECCEMSB"
    if fsr & 0x00040000: # FSR_UECCEMSB
        err_string += " UECCEMSB"
    if fsr & 0x00020000: # FSR_MECCELSB
        err_string += " MECCELSB"
    if fsr & 0x00010000: # FSR_UECCELSB
        err_string += " UECCELSB"
    if fsr & 0x10: # FSR_WREER
        err_string += " WREER"
    if fsr & 8: # FSR_FLERR
        err_string += " FLERR"
    if fsr & 4: # FSR_FLOCKE
        err_string += " FLOCKE"
    if fsr & 2: # FSR_FCMDE
        err_string += " FCMDE"
    if err_string == "":
        return
    err_string = "Flash controller error " + err_string 
    raise Exception(err_string)

def waitForFlashReady():
    n = 0
    max_retries = 100
    while n < max_retries:
        r = dev.Read32(efc_fsr)
        log_efc_fsr_error(r)
        if r & 1: # FSR_FRDY:
            break
        dev.Delay(100000) # 100ms
        n = n+1
    if n == max_retries:
        raise Exception("Timeout waiting for flash ready")

def bitsInByte(byteValue):
    for i in xrange(8):
        yield (byteValue >> i) & 1

def eefc_cmd(cmd):
    dev.Write32(efc_fcr, cmd)
    waitForFlashReady()

def write_config(address, len, data):
    # Converting value to indexing access, and writing one GPNVM bit at the time
    mask = GPNVM_BIT_MASK  # Use mask to avoid writing to reserved bits
    bit_index = 0
    for val in data:
        for bit in bitsInByte(val):
            if(mask & 0x01):
                if(bit == 1):
                    log.info("Debug: Setting GPNVM bit %d" % bit_index)
                    eefc_cmd( efc_cmd_sgpb | (bit_index << 8))
                else:
                    log.info("Debug: Clearing GPNVM bit %d" % bit_index)
                    eefc_cmd( efc_cmd_cgpb | (bit_index << 8))
            mask = mask >> 1
            if not mask:
                return
            bit_index += 1

def read_config(address, length, data):
    gpnvm_address = address & 0x1F
    eefc_cmd(efc_cmd_ggpb)
    read_index = 0
    data_index = 0
    read_data = 0
    while read_index < (gpnvm_address + length):
        if read_index % 4 == 0:
            read_data = dev.Read32(efc_frr)
            log.info("Prog: GPNVM at address 0x%0X, value: 0x%0X" % (address, read_data))
        if read_index >= gpnvm_address:
            data[data_index] = 0xFF & read_data
            data_index += 1
        read_data = read_data >> 8
        read_index += 1

ccrFlags = 0
instructionCacheImplemented = False
dataCacheImplemented = False
DCISW = 0xE000EF60L
DCCISW = 0xE000EF74L
DCCMVAC = 0xE000EF68L
DCIMVAC = 0xE000EF5CL
DCCIMVAC = 0xE000EF70L
CCSIDR = 0xE000ED80L

def isCacheEnabled(cacheType):
    return 0 != (ccrFlags & (1 << cacheType));

def getDataCacheLineSize():
    ccsidr = dev.Read32(CCSIDR)
    line_len =  (ccsidr & 7) + 2
    line_len = 1 << (line_len+2)
    log.debug("data cache line size 0x%x" % line_len)
    return line_len

def invalidateCache(startAddr, size, write) :
    CCR_DC = 16
    startAddr &= 0xFFFFFFFF
    endAddr = startAddr + size
    cacheOperation = DCCIMVAC if write else DCCMVAC
    if startAddr < 0x40000000 and isCacheEnabled(CCR_DC):
        mva = startAddr
        if endAddr - startAddr <= 4:
            dev.Write32(cacheOperation, mva)
            return

    #Align startAddr to dataCacheLineSize
    if ( (startAddr & (dataCacheLineSize - 1)) != 0) :
        startAddr = (startAddr)& ~(dataCacheLineSize - 1)
    # Align endAddr to dataCacheLineSize
    if ( (endAddr & (dataCacheLineSize - 1)) != 0) :
        endAddr = (endAddr + dataCacheLineSize - 1) & ~(dataCacheLineSize - 1)
    
    log.debug("Invalidating range  0x%x to 0x%x" % (startAddr, endAddr))
    mva = startAddr
    while mva < endAddr: 
        dev.Write32(cacheOperation, mva)
        mva = mva + dataCacheLineSize

dataCacheLineSize = 1
def cache_onDebugStart():
    global dataCacheLineSize
    global instructionCacheImplemented, dataCacheImplemented
    CLIDR_ADDRESS = 0xE000ED78L
    clidrVal = dev.Read32(CLIDR_ADDRESS)
    instructionCacheImplemented = 0 != (clidrVal & 1)
    dataCacheImplemented = 0 != (clidrVal & 2)
    if (clidrVal & 0x7) == 4:
        instructionCacheImplemented = dataCacheImplemented = True;
    if dataCacheImplemented:
        dataCacheLineSize = getDataCacheLineSize()

def cache_onStop():
    global ccrFlags
    CCR = 0xE000ED14L
    ccrFlags = dev.Read32(CCR)

def cache_onDataRead(adr,size):
    if dataCacheImplemented:
        invalidateCache(adr, size, False)

def cache_onDataWrite(adr,size):
    if dataCacheImplemented:
        invalidateCache(adr, size, True)

def cache_invalidateInstrCache():
    if instructionCacheImplemented:
        CCR_IC = 17
        ICIALLU = 0xE000EF50L
        if isCacheEnabled(CCR_IC): # if instruction cache is enabled
            dev.Write32(ICIALLU, 0x0) # invalidate cache

# Flash strategy
# 0: Halt before programming/read mem operations, run afterwards
# 1: Reset and halt before programming/read mem operations, release from reset afterwards
if "RH71" in device:
    flash_strategy = 0
else:
    flash_strategy = 1


# Workarounds for flash bank startup after reset problems with SAMRH71F20-EK board rev 2.0
rh71_2_0_workaround_VAR_factor = True
rh71_2_0_workaround_init_PC_SP = True
rh71_2_0_workaround_reset_30ms_delay = True

reset_delay = 30000 if "RH71" in device and rh71_2_0_workaround_reset_30ms_delay else 0

def begin_programming_operation():
    dev.Connect(comm_iface, comm_speed)
    reset_and_halt() 

def halt_or_raise():
    halt_target()
    n = 0
    while n < 5:
        if not is_target_running():
            return
        dev.Delay(100000) # 100ms
        n = n+1
    raise Exception("Failed to halt target!")

def resetPeripheralsWithRstc():
    dev.Write32(rstc_mr, 0xa5000b00) # long(RSTC_KEY) | rstc_erstl)
    dev.Write32(rstc_cr, 0xa5000001)  # long(RSTC_KEY) | PROCRST)

    n = 0
    max_retries = 100
    while n < max_retries:
        dev.Delay(10000)  # 10ms
        r = dev.Read32(rstc_sr)
        if r & 0x00020000: # SRCMP
            continue  # Software reset in progress
        if r & 0x00010000: # NRSTL
            break
        n = n+1

    if n == max_retries:
        raise Exception("timeout in reset")

    dev.Write32(rstc_mr, 0xa5000001) # long(RSTC_KEY) | URSTEN) # Enable user reset again (URSTEN == 1)


def erase():#mplab
    global erase_as_needed
    log.info("Prog: Erase")

    try:
        eefc_cmd(efc_cmd_ea)
    except Exception, e:
        r = dev.Read32(efc_fsr)
        if r & 4 :  # lock error
            if "RH71" in device:
                for i in range(32):
                    eefc_cmd(0x5a000009 | (i*256))
                eefc_cmd(efc_cmd_ea)
            else:
                raise e

    erase_as_needed = False # tell prog_write not to erase rows prior to write


def reset_and_halt():
    log.info("Prog: Reset and halt")
    # check run state and clear S_RESET_ST so that we can use it to detect end of reset later
    halt_or_raise()

    dev.Write32(arm.DEMCR, 0x01000001) # TRCENA | VC_CORERESET) 

    if "RH71" in device:
        # SAMRH71 use SYSRESETREQ to reset core + peripherals, will loose connection so need to reconnect.
        try:
            dev.Write32(arm.AIRCR, 0x05fa0004) # VECTKEY | SYSRESETREQ)  # 1=VECTRESET 4=SYSRESETREQ
        except:
            log.info("Reset with SYSRESETREQ, lost connection, try to reconnect to the device")
        dev.Disconnect()
        dev.Connect(comm_iface, comm_speed)
    else:
        # Canopus use RSTC (PROCRST) to reset peripherals and VECTRESET to reset core.
        resetPeripheralsWithRstc()
        dev.Write32(arm.AIRCR, 0x05fa0001) # VECTKEY | VECTRESET)  # 1=VECTRESET 4=SYSRESETREQ

    n = 0
    max_retries = 100
    seenReset = False
    while n < max_retries:
        dhcsr = dev.Read32(arm.DHCSR)
        #log.info("S_RESET_ST = %s / %s at PC = %X" % ("1" if dhcsr & 0x02000000 else "0", "Halted" if dhcsr & 0x20000 else "RUNNING", get_pc()))
        if (dhcsr & 0x02000000): # wait for S_RESET_ST
            seenReset = True
        hasHalted = 0 != (dhcsr & 0x20000) # S_HALT
        if seenReset:
            if hasHalted:  # wait for S_HALT
                break
        dev.Delay(100000) # 100ms
        n = n+1
    dev.Write32(dev.DEMCR, 0x01000000) # TRCENA reset VC_CORERESET bit
    if n == max_retries:
        raise Exception("Timeout in reset")

    if "RH71" in device:
        initialize_HEFC()


def initialize_HEFC(): # only for SAMRH71
    log.info("Prog: initialize_HEFC")

    # set up GCLK for HEFC
    dev.Write32(0x40100254, 0x00008000) # disable watchdog        wdt_mr
    dev.Write32(0x4000C020, 0x00370028) # Set internal RC 10 MHz  ckgr_mor
    dev.Write32(0x4000C10C, 0x30401432) # Set GCLK with div 5     pmc_pcr

    if rh71_2_0_workaround_VAR_factor:
        set_var_factor_and_power_toggle_flash()

    #waitForPWSReady
    n = 0
    max_retries = 100
    
    while n < max_retries:
        r = dev.Read32(efc_fpmr)
        if r & 2: # PWS_STAT
            dev.Delay(250000)  # wait 250ms after seeing PWS_STAT bit
            break
        dev.Delay(100000) # 100ms
        n = n+1
    if n == max_retries:
        raise Exception("Timeout waiting for PWS ready")

    if rh71_2_0_workaround_init_PC_SP:
        initialize_PC_SP()

def set_var_factor_and_power_toggle_flash(): # only for SAMRH71, probably only needed for rev 2.0 boards
    # reset problem for flash (for rev 2.0 of device), can read flash only every second reset
    # without this workaround
    dev.Write32(efc_fpmr, 0x00013F0F) # set var factor at 0x3F  1111
    dev.Write32(efc_fpmr, 0x00013F0E) # Power OFF flash         1110
    dev.Write32(efc_fpmr, 0x00003F0D) # Power ON flash          1101

def initialize_PC_SP(): # only for SAMRH71, probably only needed for rev 2.0 boards
    log.info("Initialize PC and SP (should be done by core, problem in SAMRH71F20-EK board rev 2.0)")
    reset_handler = dev.Read32(0x10000004)
    old_pc = get_pc()
    pc_different = old_pc != (reset_handler & 0xFFFFFFFE)

    stack_pointer = dev.Read32(0x10000000)
    old_sp = get_sp()
    sp_different = old_sp != stack_pointer

    if pc_different and reset_handler != 0xFFFFFFFF: # only if not flash is erased
        set_pc(reset_handler)
        # Correct EPSR T bit in case core didn't initialize PC and T bit correctly (if PC bit 0 is set, then set T bit)
        psr = dev.ReadReg64(16)
        if reset_handler & 1 and not psr & 0x01000000:
            log.error("PC initialization by core failed, corrected 0x%X -> 0x%X and set EPSR T bit" % (old_pc, get_pc()))
            dev.WriteReg64(16, psr | 0x01000000)
        else:
            log.error("PC initialization by core failed, corrected 0x%X -> 0x%X" % (old_pc, get_pc()))
    if sp_different and stack_pointer != 0xFFFFFFFF: # only if not flash is erased
        set_sp(stack_pointer)
        log.error("SP initialization by core failed, corrected 0x%X -> 0x%X" % (old_sp, get_sp()))
    
def write_flash_page(adr, ofs, data, cmd):
    log.debug("Write flash page adr=0x%0x, ofs=0x%0x" % (adr, ofs))
    dev.Write(adr, data, ofs, PAGE_SIZE)
    if "RH71" in device:
        page_number = adr & 0x3fff00 # SAMRH71 has page_size 256
    else:
        page_number = (adr & 0x3ffe00)/2 # Canopus has page_size 512
    eefc_cmd(cmd | page_number)
    log.debug("Written page %d (0x%0x) at 0x%0x" % (page_number/256, page_number*2, adr))

def prog_write(type_of_mem, address, length, data):#mplab
    global erase_as_needed
    log.info("Prog: Writing %d bytes to address 0x%0x of %s memory" % (length, address, type_of_mem))
    if str(type_of_mem) == "Cfg":
        write_config(address, length, data)
        return  # This should never be reached...
    elif str(type_of_mem) != "Pgm":
        dev.Write(address, data, 0, length)
        return

    if "RH71" not in device: # SAMRH71 don't support wait states (ref prelim data sheet)
        # Set Flash Wait States to 7 cycles (6+1)
        dev.Write32(efc_fmr, 0x00000600)

    flash_write( address, length, data, erase_as_needed)
    erase_as_needed = True  # only the first Prg write is allowed without an erase

def flash_write(address, length, data, doerase):
    written = 0

    if "RH71" in device:
        # note that this code expects length to be a multiple of PAGE_SIZE
        while written < length:
            page_number = address & 0x3fff00 # SAMRH71 has page_size 256
            # Erase and write page (two separate commands on SAMRH71)
            if doerase:  
                eefc_cmd(efc_cmd_ep | page_number)
            write_flash_page(address,written,data,efc_cmd_wp)
            written += PAGE_SIZE
            address += PAGE_SIZE
        return

    while written < length:
        if (address & (FLASH_START-1)) < (2 * 8 * 1024):
            buffer_size = PAGE_SIZE
            cmd = efc_cmd_ewp if doerase else efc_cmd_wp
        else:
            if doerase:
                #erase 16 pages
                addr = address & 0x003FF000 #isolate page number
                eefc_cmd(efc_cmd_epa | (addr >> 1) | 0x200)
            cmd = efc_cmd_wp
            buffer_size = PAGE_SIZE * 16

        write_len = min(length - written, buffer_size)
        while write_len > 0:
            write_flash_page(address, written, data, cmd)
            written += PAGE_SIZE
            address += PAGE_SIZE
            write_len -= PAGE_SIZE

def prog_read(type_of_mem, address, length, data):#mplab
    log.info("Prog: Reading %d bytes from address 0x%0x of %s memory..." % (length, address, type_of_mem))

    if str(type_of_mem) == "Cfg":
        read_config(address, length, data)
        return
    dev.Read(address, data, 0, length)


def end_of_operations():#mplab
    log.info("Prog: End of operations")
    try:# temporarily use try-except to bypass exception of double calling this function, remove try-except when MPLABXE-4164 is resolved
        run_target()
    except:
        return
    dev.Disconnect()

def get_sp():
    return dev.ReadReg64(arm.SP)

def set_sp(sp):
    log.info("Debug: Set sp to 0x%0x" % sp)
    dev.WriteReg64(arm.SP, sp)

def set_sw_bp(address, instruction, flags):
    if (address & (FLASH_START-1)) < 16384 or "RH71" in device:
        return set_sw_bp_gen(address, PAGE_SIZE,instruction,flags)
    return set_sw_bp_gen(address, 16*PAGE_SIZE, instruction, flags)

