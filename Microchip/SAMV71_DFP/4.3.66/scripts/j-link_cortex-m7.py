# This file is autogenerated
comm_speed=8000000
printDebug = False
logLevel = 0

def begin_communication_session():
    global comm_iface, comm_speed
    comm_iface = settings.getString("communication.interface", "swd") == "swd"
    comm_speed = settings.getNumeric("communication.frequency", comm_speed)
    dev.Connect(comm_iface, comm_speed)
    dev.SetApiLogging(logLevel)
    log.setShowOutput(printDebug)

def begin_debug_session():#mplab
    log.info("Debug: Init debug session")
    reset_target()
    
def debug_read(mem_type, start, length, data):#mplab
    log.info("Debug: Reading %d bytes at start address 0x%08x (%s)" % (length, start, mem_type))
    dev.Read(start, data, 0, length)

def debug_write(mem_type, start, length, data):#mplab
    log.info("Debug: Writing %d bytes at start address 0x%08x (%s)" % (length, start, mem_type))
    dev.Write(start, data, 0, length)

def get_pc():#mplab
    return dev.ReadReg64(arm.PC)

def run_target():#mplab
    log.info("Debug: run target")
    dev.GoEx(1, 1)

def halt_target():#mplab
    log.info("Debug: halt target")
    dev.Halt()

def step_target():#mplab
    log.info("Debug: stepping at pc 0x%08x" % get_pc())
    dev.Step()

def set_pc(pc):#mplab
    log.info("Debug: set pc to 0x%08x" % pc)
    dev.WriteReg64(arm.PC, pc)

def reset_target(): # mplab
    log.info("Debug: reset")
    dev.Reset()
    on_after_reset() # call autoload hook

g_stopped = False

def is_target_running(): # mplab
    global g_stopped

    stopped = dev.IsHalted()
    if stopped != g_stopped:
        log.info("Debug: target has halted" if stopped else "Debug: target is now running")
        g_stopped = stopped
    return 0  == g_stopped

def end_debug_session():  # mplab
    log.info("Debug: End debug session")

def on_after_reset():  # hook to be overwritten in autoload.py
    try:
        vtor=deb.GetSymbolAddress("exception_table")
        load_vtor(vtor) 
    except:
        pass        
    pass

def load_vtor(adr):
    try:
        dev.WriteReg64(arm.PC,dev.Read32(adr + 4))
        dev.WriteReg64(arm.SP,dev.Read32(adr))
    except:
        log.error("Debug: failed to set PC and SP to contents of exception_table")

def on_program_done():
    on_after_reset()
efc_cmd_wp   = 0x5a000001
efc_cmd_ewp  = 0x5a000003
efc_cmd_ea   = 0x5a000005
efc_cmd_epa  = 0x5a000007
efc_cmd_sgpb = 0x5a00000B
efc_cmd_cgpb = 0x5a00000C
efc_cmd_ggpb = 0x5a00000D


if "RH71" in device:
    FLASH_START = 0x10000000
    PAGE_SIZE = 256
    GPNVM_BIT_MASK = 0x2   # Bit mask for user changeable GPNVM bits
    efc_fmr  = 0x40004000  # HEFC Flash Mode Register
    efc_fcr  = 0x40004004  # HEFC Flash Command Register
    efc_fsr  = 0x40004008  # HEFC Flash Status Register
    efc_frr  = 0x4000400c  # HEFC Flash Result Register
    efc_fpmr = 0x40004040  # HEFC Flash Power Management Register
    efc_wpmr = 0x400040e4  # HEFC Write Protection Mode Register
    efc_cmd_ep = 0x5a000006  # available on SAMRH71, but not available on Canopus (SAME70, S70, V70/71)
    rstc_cr = 0x40100200
    rstc_sr = 0x40100204
    rstc_mr = 0x40100208
elif "M7" in architecture:
    FLASH_START = 0x0400000
    PAGE_SIZE = 512
    GPNVM_BIT_MASK = 0x183 # Bit mask for user changeable GPNVM bits
    efc_fmr  = 0x400e0c00  # EEFC Flash Mode Register
    efc_fcr  = 0x400e0c04  # EEFC Flash Command Register
    efc_fsr  = 0x400e0c08  # EEFC Flash Status Register
    efc_frr  = 0x400e0c0c  # EEFC Flash Result Register
    efc_wpmr = 0x400e0ce4  # EEFC Write Protection Mode Register
    efc_cmd_ewp = 0x5a000003  # available on Canopus (SAME70, S70, V70/71), but not available on SAMRH71
    efc_cmd_ewpl = 0x5a000004  # available on Canopus (SAME70, S70, V70/71), but not available on SAMRH71
    rstc_cr = 0x400e1800
    rstc_sr = 0x400e1804
    rstc_mr = 0x400e1808
else: #sam3 and sam4 devices 
    FLASH_START = 0x0400000
    PAGE_SIZE = 512
    GPNVM_BIT_MASK = 0x183 # Bit mask for user changeable GPNVM bits
    efc_fmr  = 0x400e0a00  # EEFC Flash Mode Register
    efc_fcr  = 0x400e0a04  # EEFC Flash Command Register
    efc_fsr  = 0x400e0a08  # EEFC Flash Status Register
    efc_frr  = 0x400e0a0c  # EEFC Flash Result Register
    rstc_cr = 0x400e1400
    rstc_sr = 0x400e1404
    rstc_mr = 0x400e1408

def log_efc_fsr_error(fsr):
    err_string = ""
    if fsr & 0x00080000: # FSR_MECCEMSB
        err_string = "MECCEMSB"
    if fsr & 0x00040000: # FSR_UECCEMSB
        err_string += " UECCEMSB"
    if fsr & 0x00020000: # FSR_MECCELSB
        err_string += " MECCELSB"
    if fsr & 0x00010000: # FSR_UECCELSB
        err_string += " UECCELSB"
    if fsr & 0x10: # FSR_WREER
        err_string += " WREER"
    if fsr & 8: # FSR_FLERR
        err_string += " FLERR"
    if fsr & 4: # FSR_FLOCKE
        err_string += " FLOCKE"
    if fsr & 2: # FSR_FCMDE
        err_string += " FCMDE"
    if err_string == "":
        return
    err_string = "Flash controller error " + err_string 
    raise Exception(err_string)

def waitForFlashReady():
    n = 0
    max_retries = 100
    while n < max_retries:
        r = dev.Read32(efc_fsr)
        log_efc_fsr_error(r)
        if r & 1: # FSR_FRDY:
            break
        dev.Delay(100000) # 100ms
        n = n+1
    if n == max_retries:
        raise Exception("Timeout waiting for flash ready")

def bitsInByte(byteValue):
    for i in xrange(8):
        yield (byteValue >> i) & 1

def eefc_cmd(cmd):
    dev.Write32(efc_fcr, cmd)
    waitForFlashReady()

def write_config(address, len, data):
    # Converting value to indexing access, and writing one GPNVM bit at the time
    mask = GPNVM_BIT_MASK  # Use mask to avoid writing to reserved bits
    bit_index = 0
    for val in data:
        for bit in bitsInByte(val):
            if(mask & 0x01):
                if(bit == 1):
                    log.info("Debug: Setting GPNVM bit %d" % bit_index)
                    eefc_cmd( efc_cmd_sgpb | (bit_index << 8))
                else:
                    log.info("Debug: Clearing GPNVM bit %d" % bit_index)
                    eefc_cmd( efc_cmd_cgpb | (bit_index << 8))
            mask = mask >> 1
            if not mask:
                return
            bit_index += 1

def read_config(address, length, data):
    gpnvm_address = address & 0x1F
    eefc_cmd(efc_cmd_ggpb)
    read_index = 0
    data_index = 0
    read_data = 0
    while read_index < (gpnvm_address + length):
        if read_index % 4 == 0:
            read_data = dev.Read32(efc_frr)
            log.info("Prog: GPNVM at address 0x%0X, value: 0x%0X" % (address, read_data))
        if read_index >= gpnvm_address:
            data[data_index] = 0xFF & read_data
            data_index += 1
        read_data = read_data >> 8
        read_index += 1

def erase(): # mplab
    # looks like dev erases as it goes. No need for a whole chip erase
    log.info("Prog: Erase")
    dev.Halt()
    dev.api.JLINK_EraseChip()
    dev.Delay(100000)


def prog_write(type_of_mem, address, length, data): # mplab
    log.info("Writing %d bytes to address 0x%0x of %s memory" % (length, address, type_of_mem))
    if str(type_of_mem) == "Cfg":
        write_config(address, length, data)
        return  # This should never be reached...
    elif str(type_of_mem) != "Pgm":
        dev.Write(address, data, 0, length)
        return

    dev.Write(address, data, 0, length)

def prog_read(type_of_mem, address, length, data): # mplab
    log.info("Reading %d bytes from address 0x%0x of %s memory" % (length, address, type_of_mem))
    if str(type_of_mem) == "Cfg":
        read_config(address, length, data)
        return
    dev.Read(address, data, 0, length)


def end_of_operations(): # mplab
    log.info("Prog: End of operations")
    dev.Reset()
