# This file is autogenerated
comm_speed=2000000
erase_as_needed = True  # used in prog_write
comm_iface = True
reset_delay = 0
has_reset = True
show_output = False
log_level = 0

def _begin_debug_session():
    dev.Connect(comm_iface, comm_speed)
    reset_and_halt()
    cache_onDebugStart()

def _begin_communication_session(): 
    global log_level,show_output,reset_delay, target_was_reset, has_reset, _stealth_runstate    
    log_level    = settings.getNumeric("script.log_level",log_level)
    show_output  = settings.getBool("script.show_output",show_output)
    has_reset  = settings.getBool("script.has_reset",has_reset)
    reset_delay = settings.getNumeric("script.reset_delay",reset_delay)

    target_was_reset = False
    _stealth_runstate = 2
    dev.SetApiLogging(log_level)
    log.setShowOutput(show_output)

    global comm_iface, comm_speed, erase_as_needed
    comm_iface = settings.getString("communication.interface", "swd") == "swd"
    comm_speed = settings.getNumeric("communication.frequency", comm_speed)
    erase_as_needed = True  # used in prog_write

def _end_communication_session(): 
    _end_of_operations()

def onShowPropsDFP2(t):
    ide.addBooleanProperty(t,"arm.use_vtor" , "*|programoptions|programoptions.eraseb4program","Set PC and SP to VTOR","After reset, force PC and SP to the entries defined by the VTOR", False)
    ide.addTextProperty(t,"arm.vtor_adr" , "*|programoptions|programoptions.eraseb4program","VTOR table or numerical address", "Enter address of vector table", "exception_table")
    ide.addPropCategory(t,"diagnostics" , "*|toolpack", "Diagnostics")
    ide.addBooleanProperty(t,"script.show_output" , "*|diagnostics|*","Output diagnostic logging","Show diagnostic text in the Output window", False)
    ide.addTextProperty(t,"script.log_level" , "*|diagnostics|*","Diagnostic log level","Set diagnostic level (usually 0 1 or 3)", "1")
    ide.addTextProperty(t,"script.reset_delay" , "*|diagnostics|*","Additional delay after reset","Enter additional RST settling delay in msec", "0")
    ide.addBooleanProperty(t,"script.has_reset" , "*|diagnostics|*","Uncheck if RESET line is not wired","Normally checked. Uncheck if the target does not have RST connected to the debugger", True)

def print_dhcsr_v(t, d):
    log.info(t + arm.getDHCSRString(d))

def print_dhcsr(text):
    try:
        d = dev.Read32(arm.DHCSR)
        print_dhcsr_v(text, d)
        return d
    except:
        log.log("DHCSR is unreadable")
        return 0

def _debug_read(mt, start, length, data):
    cache_onDataRead(start,length)
    _prog_read(mt, start, length, data)

def _debug_write(mt, start, length, data):
    if str(mt) == "Pgm":
        cache_invalidateInstrCache()
        _flash_write(start, length, data, True)
        return

    cache_onDataWrite(start,length)
    dev.Write(start, data, 0, length)

def _get_pc():
    try:
        pc = dev.ReadReg64(15)
    except:
        log.error("get_pc returned error")
        return 0
    return pc

def _get_reg(idx):
    return dev.ReadReg64(idx)

def _set_reg(idx,val):
    return dev.WriteReg64(idx,val)

def _mem_read(start, length, data):
    dev.Read(start, data, 0, length)

def _mem_write(start, length, data):
    dev.Write(start, data, 0, length)

def _run_target():
    cache_onRun()
    dev.Write32(arm.DHCSR, 0xa05f0001)  # DBGKEY | C_DEBUGEN | C_HALT

def _halt_target():
    dev.Write32(arm.DHCSR, 0xa05f0003)  # DBGKEY | C_DEBUGEN | C_HALT

def _step_target():
    cache_onRun()
    dev.Write32(arm.DHCSR, 0xa05f000b)  # DBGKEY | C_DEBUGEN | C_HALT | C_MASKINTS
    dev.Write32(arm.DHCSR, 0xa05f000d)  # DBGKEY | C_DEBUGEN | C_STEP | C_MASKINTS
    dev.Write32(arm.DHCSR, 0xa05f0003)  # DBGKEY | C_DEBUGEN | C_HALT
    cache_onStop()

def _set_pc(pc):
    dev.WriteReg64(15, pc)

def print_byte_array(text, array, index, size):
    string = text
    for i in range(size):
        string += " %x" % array[i+index]
    log.info(string)

g_is_running = True
def _is_target_running():
    global g_is_running
    dhcsr = dev.Read32(arm.DHCSR)
    state = 0 == (dhcsr & 0x20000)
    if state != g_is_running:
        log.info("Debug: target is now running" if state else "Debug: target has halted")
        g_is_running = state 
    if not g_is_running:
        cache_onStop()
    return g_is_running

def on_after_reset(): 
    if not settings.getBool("arm.use_vtor", False):
        return
    vtor_name  = settings.getString("arm.vtor_adr", "0")

    vtor = -1
    try:
        vtor = int(vtor_name,0)
    except:
        try:
            vtor=deb.GetSymbolAddress(vtor_name)
        except:
            log.error("Debug: failed to compute location of VTOR")
            return
    load_vtor(vtor) 
    pass

def load_vtor(adr):
    try:
        dev.WriteReg64(arm.PC,dev.Read32(adr + 4))
        dev.WriteReg64(arm.SP,dev.Read32(adr))
    except:
        log.error("Debug: failed to set PC and SP to vtor[0] and vtor[4], with vtor=0x%08x" % adr)


def on_program_done():
    on_after_reset()

def _reset_target(): 
    reset_and_halt()

def _end_debug_session(): 
    run_target()
    dev.Disconnect()

def _hold_in_reset(): 
    global target_was_reset
    global has_reset
    if not has_reset:
        alt_hold_in_reset()
        return
    log.info("Prog: Hold in reset")
    try:
        dev.SetInterface(dev.SWD)
    except:
        dev.Connect(True, 100000)
    dev.Pins(0, dev.RESET, 1000)
    target_was_reset = True
    # do not dev.Disconnect() . The debugger needs to stay connected to actively keep the reset line low.

def alt_hold_in_reset(): 
    # Alternative if RESET pin is not connected to debugger
    log.info("Prog: Hold in reset , no reset line")
    dev.Connect(True, 100000)
    reset_and_halt()

def _release_from_reset():
    global target_was_reset,reset_delay
    global has_reset
    if target_was_reset:
        return
    if not has_reset:
        log.info("Prog: Release from reset (soft reset)")
        dev.Connect(True, 100000)
        reset_and_halt()
        run_target()
        return

    log.info("Prog: Release from reset (float reset line)")

    # toggle reset line
    try:
        dev.SetInterface(dev.SWD)
    except:
        dev.Connect(True, 100000)
    dev.Pins(0, dev.RESET, 1000)
    dev.Delay(reset_delay)
    dev.Pins(dev.RESET, dev.RESET, 1000)  # now float reset back
    dev.Delay(reset_delay)
    target_was_reset = True
    dev.Disconnect() #we are done with the part

def alt_release_from_reset():
    log.info("Prog: Release from reset, no reset line")
    dev.Connect(True, 100000)
    dev.Write32(dev.AIRCR, 0x05fa0004)  # VECTKEY | SYSRESETREQ

def set_sw_bp_gen(address, erase_size, instruction, flags):  #mplab
    global erase_as_needed
    log.debug("Debug: set/reset bp at address 0x%0x, store instructions 0x%0x, flags = 0x%0x" % (address, instruction, flags))
    if address >= 0x20000000:
        erase_size = 4 
    else:
        clear_and_report_flash_error()


    erase_page_start = address & ~(erase_size-1)
    address_in_erase_page = address & (erase_size-1)

    data = bytearray(erase_size)
    cache_invalidateInstrCache()
    dev.Read(erase_page_start, data, 0, erase_size)
    return_value = data[address_in_erase_page] | (data[address_in_erase_page+1] << 8)

    # Insert software breakpoint instruction in the data
    data[address_in_erase_page] = instruction & 0xFF
    data[address_in_erase_page+1] = (instruction >> 8) & 0xFF

    if erase_size == 4:
        dev.Write(erase_page_start, data, 0, erase_size)
    else:
        erase_as_needed = True
        prog_write("Pgm", erase_page_start, erase_size, data)
    return return_value


# device specific functions

erase_as_needed = True

L11SDAL0 = 100
L11SDAL1 = 101
L11CHIPERASE0 = 0xE0
L11CHIPERASE1 = 0xE1
L11CHIPERASE2 = 0xE2
L11CHIPERASE3 = 0xE3
L11CHIPERASE4 = 0xE4
L10CHIPERASE = 0xE3
ERASETYPE = None
ERASEKEY0 = [0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff]
ERASEKEY1 = [0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff]
ERASEKEY2 = [0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff]

dal = -1
dsuAddress = 0x41002100  # external address range to bypass security filter

def cache_onDebugStart():
    pass
def cache_onStop():
    pass
def cache_onRun():
    pass
def cache_onDataRead(adr,size):
    pass
def cache_onDataWrite(adr,size):
    pass
def cache_invalidateInstrCache():
    pass

def onloadDFP(ide):
    if ("L11" in device) or ("LS" in device) :
        ide.addCommand("Device actions|Set DAL 0", "set_dal_0")
        ide.addCommand("Device actions|Set DAL 1", "set_dal_1")
        ide.addCommand("Device actions|ChipErase_NS CE0", "chip_erase_0")
        ide.addCommand("Device actions|ChipErase_S CE1", "chip_erase_1")
        ide.addCommand("Device actions|ChipErase_ALL CE2", "chip_erase_2")
    elif "L10" in device:
        ide.addCommand("Device actions|Set DAL 0", "set_dal_0")
        ide.addCommand("Device actions|Chip Erase", "chip_erase_l10")
    elif "LE00" in device:
        ide.addCommand("Device actions|Set DAL 0", "set_dal_0")
        ide.addCommand("Device actions|Chip Erase", "chip_erase_3")
        ide.addCommand("Device actions|Chip Erase All", "chip_erase_4")

def special_action(key, cmd):
    if deb.Connected():
        r = msg.msg("Debugger is in use. Stop debugging and retry", "Busy")
        return
    deb.Connect()
    try:
        special_nvm_op(key, cmd)
    finally:
        deb.Disconnect()

def set_dal_0():
    global dal
    special_action([], L11SDAL0)
    msg.msg("DAL is now " + str(dal), "Set DAL 0")


def set_dal_1():
    global dal
    special_action([], L11SDAL1)
    msg.msg("DAL is now " + str(dal), "Set DAL 1")


def ce_with_dlg(k, t):
    global dal
    try:
        special_action(k,  t)
        msg.msg("Chip erase done. DAL is now " + str(dal), "Chip Erase")
    except Exception, e:
        log.error("Chip erase - " + str(e))
        msg.msg(str(e), "Chip Erase - Error")


def chip_erase_2():
    ce_with_dlg(ERASEKEY2,  L11CHIPERASE2)


def chip_erase_1():
    ce_with_dlg(ERASEKEY1,  L11CHIPERASE1)


def chip_erase_0():
    ce_with_dlg(ERASEKEY0,  L11CHIPERASE0)

def chip_erase_3():
    ce_with_dlg([],  L11CHIPERASE3)

def chip_erase_4():
    ce_with_dlg([],  L11CHIPERASE4)


def chip_erase_l10():
    ce_with_dlg(ERASEKEY0,  L10CHIPERASE)


nvmCtrl = 0
erase_size = 0x100
UROW = 0x00804000
BOCOR = 0x0080C000


def reset_extension():
    global reset_delay # additional delay for reset line if needed
    global has_reset
    if not has_reset:
        return

    delay=1000  # time to  wait for analog RESET/SWCLK pins to become digitally high/low
    try:
        dev.SetInterface(dev.SWD)
    except:
        dev.Connect(comm_iface, comm_speed)
    dev.Pins(0,dev.RESET,delay)  # 1 msec with reset high 
    if reset_delay > 0:
        dev.Delay(reset_delay)
    dev.Pins(dev.RESET,dev.RESET,delay) # 1 msec with floating reset 
    if reset_delay > 0:
        dev.Delay(reset_delay)
    dev.Pins(0,dev.RESET | dev.SWCLK,delay); # 1 msec with reset and clock low 
    if reset_delay > 0:
        dev.Delay(reset_delay)
    dev.Pins(dev.RESET,dev.RESET,delay); # now float reset back
    if reset_delay > 0:
        dev.Delay(reset_delay)
    dev.Delay(10000)


def reset_to_park(brext):
    global has_reset
    reset_extension()
    dev.Connect(comm_iface, comm_speed)
    if not has_reset:
        reset_and_halt()
        log.info("Programming may not work without a connected RESET line")
        return
    exit_reset_extension(brext)


def _begin_programming_operation():
    global erase_as_needed
    erase_as_needed = True
    try:
        reset_to_park(False)  # may fail if locked
    except:
        pass

def _read_device_id():
    return dev.Read32(0x41002118) # DSU-DID register


def _erase():
    global ERASEKEY, ERASETYPE
    global erase_as_needed
    global set_dal_val

    set_dal_val = 10  # reset DAL variable
    keys = settings.getString("x.erase.key", "0xffffffff,0xffffffff,0xffffffff,0xffffffff").split(",")
    ERASEKEY = [0, 0, 0, 0]
    for i in range(0, 4):
        ERASEKEY[i] = long(keys[i], 16)

    if "L10" in device:
        ERASETYPE = L10CHIPERASE
    elif "LE" in device:
        et = settings.getString("x.erase.type", "ChipEraseAll")

        if et == "ChipEraseAll":
            ERASETYPE = L11CHIPERASE4
        elif et == "ChipErase":
            ERASETYPE = L11CHIPERASE3
    else:
        et = settings.getString("x.erase.type", "ChipEraseAll")

        if et == "ChipEraseS":
            ERASETYPE = L11CHIPERASE1
        elif et == "ChipEraseNS":
            ERASETYPE = L11CHIPERASE0
        elif et == "ChipEraseAll":
            ERASETYPE = L11CHIPERASE2
        else:
            return    # do not erase

    erase_as_needed = False  # tell prog_write not to erase rows prior to write
    special_nvm_op(ERASEKEY, ERASETYPE)
    pass


prevCfgReg = 0
prevCfgReg2 = 0
OFFSET_CTRLB_2802 = 4
OFFSET_CTRLC_2802 = 8


def cfg_nvmctrl():
    global prevCfgReg, prevCfgReg2
    set_nvmctrl_baseaddr()
    prevCfgReg2 = dev.Read8(nvmCtrl+OFFSET_CTRLC_2802)
    newCfgReg2 = prevCfgReg2 & 0x00fe  # use automatic writes
    if newCfgReg2 != prevCfgReg2:
        dev.Write8(nvmCtrl+OFFSET_CTRLC_2802, newCfgReg2)

    # CTRLB size = 4
    #global prevCfgReg
    if 0 == prevCfgReg:
        prevCfgReg = dev.Read32(nvmCtrl+OFFSET_CTRLB_2802)
    wait_states = 15
    newCfgReg = (prevCfgReg & ~0x1e) | (wait_states << 1)  # wait states 15
    if newCfgReg != prevCfgReg:
        dev.Write32(nvmCtrl+OFFSET_CTRLB_2802, newCfgReg)


def restore_nvmctrl():
    dev.Write8(nvmCtrl + OFFSET_CTRLC_2802, prevCfgReg2)
    dev.Write32(nvmCtrl + OFFSET_CTRLB_2802, prevCfgReg)


def erase_row(addr):
    # write a few bytes to the page buffer to set address register
    dev.Write32(addr, 0xFFFFFFFF)
    CMD_ERASE_ROW = 0xA502  # works on all flash sections on L10
    nvm_cmd(CMD_ERASE_ROW, 20)


def nvm_cmd(command, t):
    dev.Write16(nvmCtrl + 0, command)
    while t > 0:
        if is_nvm_ready():
            return
        dev.Delay(1000)
        t = t - 1
    if t == 0:
        raise Exception("timeout executing NVM command")


def write_row(adr, ofs, data):
    page_size = 64
    written = 0

    while written < erase_size:
        dev.Write(adr, data, ofs + written, page_size)
        nvm_cmd(0xA504, 20)  # writePage
        adr += page_size
        written += page_size


set_dal_val = 10

def _prog_write(type_of_mem, address, length, data): 
    if address == 0x41004000:
        if length < 1:
            log.error("Empty DAL payload")
            return
        global set_dal_val
        set_dal_val = data[0] - 0x4B
        log.info("Will change DAL to %d" % set_dal_val)
        return
    if str(type_of_mem) != "Pgm" and  str(type_of_mem) != "Cfg" and  str(type_of_mem) != "UserID":
        dev.Write(address, data, 0, length)
        return
    global erase_as_needed        
    _flash_write(address,length,data,erase_as_needed)
    erase_as_needed = True  # only the first Prg write is allowed without an erase

def _flash_write(address, length, data,doerase):
    cfg_nvmctrl()
    # assumes flash is pre erased, so no row erase
    if address == UROW or address == BOCOR:
        if "L10" in device or "LE" in device:
            erase_row(address)
            write_row(address, 0, data)
        else:
            write_cfg_page(address, data,  0)
            if length > 0xc000-0x4000:
                write_cfg_page(BOCOR, data, 0xc000-0x4000)
    else:
        written = 0
        while written < length:
            if doerase:
                erase_row(address)
            write_row(address, written, data)
            written += erase_size
            address += erase_size
        
    restore_nvmctrl()


def _prog_read(type_of_mem, address, length, data):    
    dev.Read(address, data, 0, length)

def reset_and_halt():
    log.info("Debug: Reset target")
    reset_to_park(False)
# set a dwt breakpoint to halt on flash entry
    dev.Write32(arm.DEMCR, 0x01000000)  # enable TRCENA
    dev.Write32(0xe0001028, 0x00000412)
    dev.Write32(0xe0001020, 0x00000000)
    dev.Write32(0xe0001030, 0x00400000)
    dev.Write32(0xe0001038, 0x00000413)
    run_target()
    release_brext()
    dev.Delay(1000)
    t = 10
    while t > 0:
        try:
            if not is_target_running():
                dev.Write32(arm.DEMCR, 0x000000)  # disable TRCENA
                return
        except:
            pass  #during BOOTROM execution there may be errors reading DHCSR
        dev.Delay(100000)  # bootloader validation can take up to 0.5 sec
        t = t - 1
    if t == 0:
        log.error("Device did not halt")
    dev.Write32(arm.DEMCR, 0x000000)  # disable TRCENA


def _end_of_operations():
    global set_dal_val, erase_as_needed
    erase_as_needed = True
    if set_dal_val < 2:
        log.info("Setting DAL " + str(set_dal_val))
        special_nvm_op([], (L11SDAL0 if set_dal_val == 0 else L11SDAL1))
        set_dal_val = 10
    dev.Disconnect()


def program_row(adr, ofs, buf):
    erase_row(adr)
    write_row(adr, ofs, buf)


BCC = 0x20  # bootrom communication channel
STATUSA = 1
STATUSB = 2
CRSTEXTBIT = 2  # CRSTEXT bit in STATUSA
BREXTBIT = 0x20  # BREXT bit in STATUSA

DEBUGGER_CMD_INIT = 0x44424755  # Initiate communication to enter trap functions
DEBUGGER_CMD_EXIT = 0x444247AA  # Goto exit function


def is_nvm_ready():
    OFFSET_INTFLAG_2802 = 0x14
    intReg = dev.Read8(nvmCtrl + OFFSET_INTFLAG_2802)
    isReady = 0 != (intReg & 1)
    if not (intReg & 0xfe):  # if no ERROR bit is set
        return isReady
    # clear error bits in INTFLAG
    dev.Write8(nvmCtrl + OFFSET_INTFLAG_2802, 2 | 4 | 8 | 16)
    raise Exception("NVMctrl reports an error")

def clear_and_report_flash_error():
    try:
        is_nvm_ready()
    except:
        log.error("NVM controller is in an error state while setting a swbp. Clearing the error")

def brom_read_status():
    return dev.Read32(dsuAddress + BCC + 4)


def exit_reset_extension(brext):
    global dal
    reply = 0
    
    statusa = dev.Read8(dsuAddress + STATUSA)  # debug
    dal = 3 & dev.Read8(dsuAddress + 2)
    if 0 == (statusa & CRSTEXTBIT):
        log.error(device + " could not enter reset extension")
        return False

    dev.Write8(dsuAddress + STATUSA, CRSTEXTBIT)  # clear crstext
    #  ROM starts running after clearing reset extension
    dev.Delay(5000)
    reply = 0
    if (dev.Read8(dsuAddress+STATUSB) & 0x80):
        reply = brom_read_status()
    if reply != 0:
        log.error("User page validation failed with error code 0x%08x" % reply)
        raise Exception("Page validation")

    dev.Write32(dsuAddress + BCC, DEBUGGER_CMD_EXIT)  # exit to park mode

    # after cmdexit , BOOTROM does boot validation, which may take up to 500msec
    # after which it enters the park loop and can be halted, if bootldr verify ok
    n = 0
    r = 0
    while n < 20:
        if 0 != (dev.Read8(dsuAddress + STATUSB) & 0x80):   # if new data on BCCD1 , read it
            reply = brom_read_status()
            if reply == 0xEC000022:
                raise Exception("Chip is locked")
            if reply != 0xEC000039:
                log.error("Boot validation failed with error code 0x%02x" % (reply & 0xff))
                raise Exception("Boot validation")
            break
        dev.Delay(50000)
        n = n+1
    if n == 20:
        log.error("The Bootrom did not confirm the CPU park mode")
        raise Exception("Cannot enter park mode")
    # we can now halt the target if at DAL 2
    halt_target()
    dal = 3 & dev.Read8(dsuAddress + 2)
    if brext:
        release_brext()
    return True


def release_brext():
    dev.Write8(dsuAddress + STATUSA, BREXTBIT)


DSU_STATUSB_BCCD0 = 1 << 6
dsuAddress = 0x41002100  # external address range to bypass security filter
BCC = 0x20               # bootrom communication channel


def brom_send_key(data, timeout):
    for wrd in data:
        dev.Write32(dsuAddress + BCC, wrd)
        while timeout > 0:
            u8regval = dev.Read8(dsuAddress + STATUSB)  # read statusb
            if 0 == (u8regval & DSU_STATUSB_BCCD0):  # break if BCC was read
                break
            dev.Delay(1000)
            timeout = timeout - 1
        if timeout == 0:
            return 1
    return 0


def brom_read_status():
    return dev.Read32(dsuAddress + BCC + 4)


def special_nvm_op(key, ceMode):
    global dal
    SIG_COMM = 0xec000020
    SIG_CMD_SUCCESS = 0xec000021
    SIG_CMD_VALID = 0xec000024
    SIG_CMD_INVALID = 0xec000025
    SIG_BOOT_OK = 0xEC000039

    if (ceMode == L11SDAL0) or (ceMode == L11SDAL1):
        reset_to_park(False)
        CMD_SDAL0 = 0xA54B
        CMD_SDAL1 = 0xA54C
        set_nvmctrl_baseaddr()
        nvm_cmd(CMD_SDAL0 if (ceMode == L11SDAL0) else CMD_SDAL1, 100)
        try:
            # at DAL 0 the device will not exit to park mode
            reset_to_park(True)
        except:
            pass
        return

    reset_extension()
    dev.Connect(comm_iface, comm_speed)

    statusa = dev.Read8(dsuAddress + STATUSA)
    if 0 == (statusa & CRSTEXTBIT):
        raise Exception(device + " could not enter reset extension. Please check the reset line is connected to debugger.")

    dev.Write8(dsuAddress + STATUSA, CRSTEXTBIT)
    dev.Delay(5000)  # // wait for device validation
    errCode = 0
    if 0 != (dev.Read8(dsuAddress + STATUSB) & 0x80):
        errCode = brom_read_status()

    if errCode != 0:
        log.error(device + " failed to boot. Error code {}".format(errCode)) # log the error, but proceed with chip erase

    dev.Write32(dsuAddress + BCC, DEBUGGER_CMD_INIT)
    reply = brom_read_status()
    if (errCode == 0 and reply != SIG_COMM):
        raise Exception(device + " chip erase failed to enter command loop.") # shouldnt happen

    if (ceMode != L10CHIPERASE and (ceMode < L11CHIPERASE0 or ceMode > L11CHIPERASE4)):
        raise Exception(device + " chip erase failed (invalid mode).")

    dev.Write32(dsuAddress + BCC, 0x44424700 | ceMode)
    reply = brom_read_status()
    if reply != SIG_CMD_VALID:
        log.error(device + " chip erase failed because bootrom did not accept chip erase command")
        raise Exception(device + " chip erase failed (cmd error)")

    if ceMode != L10CHIPERASE and ceMode != L11CHIPERASE4:
        brom_send_key(key, 100)

    for j in range(0, 20):
        reply = brom_read_status()
        if reply != SIG_CMD_VALID and reply != 0:
            break
        dev.Delay(1000000)
    if reply != SIG_CMD_SUCCESS:
        log.error(device + " chip erase failed : error code 0x%X" % reply)
        reset_to_park(False)
        try:
            bocor = bytearray(16)
            dev.Read(BOCOR + 0x10, bocor, 0, 16)
            dev.Read(BOCOR + 0x20, bocor, 0, 16)
            dev.Read(BOCOR + 0x30, bocor, 0, 16)
        except:
            log.error(device + " error reading bocor")
        raise Exception(device + " chip erase failed : error code 0x%X" % reply)
    else:
        log.info(device + " chip erase done")
    reset_to_park(True)
    pass


def set_nvmctrl_baseaddr():
    global nvmCtrl, dal
    nvmCtrl = 0x41004000
    if "L10" in device or "LE" in device:
        return
    dal = 3 & dev.Read8(dsuAddress + 2)
    if dal != 1:
        nvmCtrl = 0x41005000
    return

FUSES_BOOTROM_BOOTKEY = 80      # 640/8
FUSES_BOOTROM_BOOTKEYSIZE = 32 # (896-640)/8
FUSES_BOOTROM_BOCORHASH = 224  # 1792/8

SHA_HASHSIZE_IN_BYTES       = 32
SHA_CHUNKSIZE_IN_BYTES      = 64
BNSC_GRANULARITY = 0x20   # Boot Flash Non-Secure Callable region granularity
BP_GRANULARITY = 0x100    # BOOTPROT region granularity

#define BROM_BOOTOPT_NONE					            0
#define BROM_BOOTOPT_SHA256					            1
#define BROM_BOOTOPT_SHA256BOOTKEY			            2
#define BROM_BOOTOPT_HMAC					            3
#define BROM_BOOTOPT_BOCORSHA256_BSECC608				4
#define BROM_BOOTOPT_BOCORSHA256BOOTKEY_BSECC608		5
#define BROM_BOOTOPT_BOCORHMAC_BSECC608				    6


def add_boot_hash_LS(idauIdauProt,idauBnscSize,pageCopy,bootopt):
    if bootopt >= 4: # handled externally
        return

    idauBsSize = idauIdauProt

    bootHashAddr = (idauBsSize - idauBnscSize) - SHA_HASHSIZE_IN_BYTES
    rowStartAddr = bootHashAddr & 0xFFFFFF00
    content=bytearray(idauBsSize)
    # Read boot area
    dev.Read(0, content, 0, idauBsSize)

    if bootopt == 1 or bootopt == 2: # SHA256 or SHA256BOOTKEY    
        utils.sha256_reset()
        if bootopt == 2:
            utils.sha256_update(pageCopy, FUSES_BOOTROM_BOOTKEY, FUSES_BOOTROM_BOOTKEYSIZE)
            utils.sha256_update(pageCopy, FUSES_BOOTROM_BOOTKEY, FUSES_BOOTROM_BOOTKEYSIZE)

        utils.sha256_update(content, 0, idauBsSize - idauBnscSize - SHA_HASHSIZE_IN_BYTES)
        if idauBnscSize > 0:
            utils.sha256_update(content, idauBsSize - idauBnscSize , idauBnscSize)
        utils.sha256_compute(content, bootHashAddr)
    elif bootopt == 3 :  # HMAC on bocor key and bootloader content
        for i in range(idauBnscSize): # compact message by removing the hashkey "hole"
            content[bootHashAddr+i]=content[idauBsSize-idauBnscSize+i]
        hmac_sha256(pageCopy, FUSES_BOOTROM_BOOTKEY, FUSES_BOOTROM_BOOTKEYSIZE,
            content, 0, idauBsSize - SHA_HASHSIZE_IN_BYTES, 
            content, bootHashAddr)
    elif bootopt >= 4:
        SIGN_SIZE = 64
        utils.sha256_reset()        
        utils.sha256_update(content, 0, idauBsSize - idauBnscSize - SIGN_SIZE)
        if idauBnscSize > 0:
            utils.sha256_update(content, idauBsSize - idauBnscSize , idauBnscSize)
        utils.computeHmacSignatureFromHash(content, idauBsSize - idauBnscSize) # compute signature inplace
        
    # Write Hash at proper location
    program_row(rowStartAddr,rowStartAddr,content)

def add_boot_hash_L11(idauBsSize,idauBnscSize,pageCopy,bootopt):
    utils.sha256_reset()
    if bootopt != 1:
        utils.sha256_update(pageCopy, FUSES_BOOTROM_BOOTKEY,FUSES_BOOTROM_BOOTKEYSIZE)
        utils.sha256_update(pageCopy, FUSES_BOOTROM_BOOTKEY,FUSES_BOOTROM_BOOTKEYSIZE)

    content=bytearray(idauBsSize)
    # Read boot area
    dev.Read(0, content, 0, idauBsSize)
    utils.sha256_update(content, 0, idauBsSize - idauBnscSize - SHA_HASHSIZE_IN_BYTES)
    if idauBnscSize > 0:
        utils.sha256_update(content, idauBsSize - idauBnscSize , idauBnscSize)

    # Write Hash at proper location
    bootHashAddr = (idauBsSize - idauBnscSize) - SHA_HASHSIZE_IN_BYTES
    rowStartAddr = bootHashAddr &0xFFFFFF00
    utils.sha256_compute(content, bootHashAddr)
    
    program_row(rowStartAddr,rowStartAddr,content)


def hmac_sha256(ptrkey,  ofsKey, keySizeInBytes, ptrmsg, ofsMsg, msgSizeInBytes, hash_in_out, out_ofs):
    # inner : H(key + message))
    
    datatmp = bytearray(SHA_CHUNKSIZE_IN_BYTES)
    utils.sha256_reset()
    # key + padding
    for i in range(SHA_CHUNKSIZE_IN_BYTES):
        datatmp[i] = ptrkey[i+ofsKey] ^ 0x36 if i<keySizeInBytes else 0x36
        
      
    utils.sha256_update(datatmp, 0, SHA_CHUNKSIZE_IN_BYTES)
    utils.sha256_update(ptrmsg, ofsMsg, msgSizeInBytes);

    # Finalize inner SHA computation
    # Save the inner hash output
    hmac_inner_hash = bytearray(SHA_HASHSIZE_IN_BYTES)
    utils.sha256_compute(hmac_inner_hash, 0)
    # Second (outer) SHA : H(key + innerSHA)
    utils.sha256_reset()
    #key + padding
    for i in range(SHA_CHUNKSIZE_IN_BYTES):
        datatmp[i] = ptrkey[i+ofsKey] ^ 0x5C if i<keySizeInBytes else 0x5c
        
    utils.sha256_update(datatmp, 0, SHA_CHUNKSIZE_IN_BYTES)
    utils.sha256_update(hmac_inner_hash, 0, SHA_HASHSIZE_IN_BYTES)
    utils.sha256_compute(hash_in_out, out_ofs)

def get_fuse_16(i, bit0, bit1):
    val = i[bit0/8] + 256*i[bit1/8]
    mask = [ 1,3,7,15,31,63,127,255,511,1023,2047,4095,8191 , 16383, 32767,65535 ]
    return mask[bit1 - bit0] & (val >> (bit0 & 7))

def get_fuse(i, bit0, bit1):
    if bit0 / 8 != bit1 / 8 :
        raise Exception("prog error")
    mask = [ 1,3,7,15,31,63,127,255 ]
    return mask[bit1 - bit0] & (i[bit0 / 8] >> (bit0 & 7))

def write_bocor_ls(pageCopy):
    pageCopy[7] = pageCopy[7] | 1  # force BCWEN to 1 to allow BOCOR rewrites
    ERASEKEYOFFSET = 0
    if ERASETYPE == L11CHIPERASE0:
        ERASEKEYOFFSET = 0x10
    elif ERASETYPE == L11CHIPERASE1:
        ERASEKEYOFFSET = 0x20
    elif ERASETYPE == L11CHIPERASE2:
        ERASEKEYOFFSET = 0x30
    if ERASEKEYOFFSET != 0:
        for i in range(16):
            if pageCopy[ERASEKEYOFFSET + i] != 255 & (ERASEKEY[i/4] >> (8*(i & 3))):
                log.error("Chip erase key does not match project settings. Forcing CE key for erase type " + str(ERASETYPE) + " to the one specified in project settings" + str(ERASEKEY))
            pageCopy[ERASEKEYOFFSET + i] = 255 & (ERASEKEY[i/4] >> (8*(i & 3)))
            # log.info("ce - key %d %02x" % (i, pageCopy[ERASEKEYOFFSET + i]))

    # Handle changes in the BOCOR row, computing CRC and hash and boothash if needed
    # BOCOR first doubleword CRC area

    bootprot = get_fuse_16(pageCopy, 40, 50) * BP_GRANULARITY
    bootopt = get_fuse(pageCopy, 32, 39)
    bnsc = get_fuse_16(pageCopy, 19, 27)*BNSC_GRANULARITY
    log.info("Boot configuration : bootprot=0x%x, bnsc=0x%x , bootopt=%x\n" % (bootprot,  bnsc, bootopt))

    if settings.getBool("x.tz_computecrc",True):
        crc = utils.crc32(pageCopy, 0, 8)
        crc = crc ^ 0xFFFFFFFF

        pageCopy[8 + 0] = (crc >> 0) & 255
        pageCopy[8 + 1] = (crc >> 8) & 255
        pageCopy[8 + 2] = (crc >> 16) & 255
        pageCopy[8 + 3] = (crc >> 24) & 255
        log.info("Computed and inserted BOCOR.CRC = 0x%08x" % crc)
        if "LS" in device:
            bootlck = get_fuse(pageCopy, 51, 51) 
            if bootlck == 0:
                log.error("The SECCFGLOCK bit is configured to lock the deviceat DAL = 0. Debug will not be possible without a chip erase")
        # Perform SHA/HMAC on DW0, [DW8 .. DW19] and place the computed hash at BOCORHASH addr
      
        if bootopt == 3 or bootopt >= 6: # 3 and >=6 use HMAC with BOOTKEY
            hmac_sha256(pageCopy,FUSES_BOOTROM_BOOTKEY,FUSES_BOOTROM_BOOTKEYSIZE, 
                        pageCopy, 0, 0x100-SHA_HASHSIZE_IN_BYTES, 
                        pageCopy, 0x100-SHA_HASHSIZE_IN_BYTES)
        elif bootopt == 0:
            pass
        else:
            # bootopt 1,2,4,5
            # Check whether bootkey is part of hash
            utils.sha256_reset() 
            if bootopt == 2 or bootopt == 5:
                # If SHA-256 with BOOTKEY is specified, the SHA hash calculation begins with a
                # virtual 512-bit chunk, consisting of BOOTKEY from BOCOR replicated twice
                utils.sha256_update(pageCopy, FUSES_BOOTROM_BOOTKEY,FUSES_BOOTROM_BOOTKEYSIZE)
                utils.sha256_update(pageCopy, FUSES_BOOTROM_BOOTKEY,FUSES_BOOTROM_BOOTKEYSIZE)
            # add the BOCOR data minus 32 bytes at the end
            utils.sha256_update(pageCopy, 0, 0x100 - 0x20)
            # finalize sha and store it in pageCopy
            utils.sha256_compute(pageCopy, FUSES_BOOTROM_BOCORHASH)

        
    erase_row(0x80c000)
    write_row(0x80c000, 0, pageCopy)
    dev.Read(0x80c000 + 1152/8,  1152/8, 16) # ioprotkey
    dev.Read(0x80c000 + FUSES_BOOTROM_BOCORHASH,  FUSES_BOOTROM_BOCORHASH, 16) # Martin
    dev.Read(0x80c000 + FUSES_BOOTROM_BOCORHASH + 16,  FUSES_BOOTROM_BOCORHASH + 16, 16)# Martin

    if bootopt == 0:
        return

    if not settings.getBool("x.tz_computesign",True):
        return

    if (bootprot >= 0):
        add_boot_hash_LS(bootprot, bnsc, pageCopy, bootopt)
    else:
        raise Exception("BOOTPROT region too small or BNSC too small")

def write_cfg_page(address, data, ofs):
    pageCopy = bytearray(256)

    if len(data) < 256:
        log.error("write_cfg_page should be called with 256 bytes of data")
        return

    dev.Read(address, pageCopy, 0, 256)
    if "L11" in device:
        urwen = get_fuse(pageCopy, 96, 96) 
        if urwen == 0:
            raise Exception("The URWEN bit is 0. Writing to user page is disabled until the device is chip erased.")
    if "LS" in device:
        bootlck = get_fuse(pageCopy, 106, 106) 
        if bootlck == 0:
            raise Exception("The URWEN bit is 0. Writing to user page is disabled until the device is chip erased.")

    if "LS" in device:
        USERCRC = 0x20
        UROWCRCLEN = 0x18
    else:
        USERCRC = 0x1C
        UROWCRCLEN = 0x14

    for i in range(0, 256):
        if pageCopy[i] != data[ofs+i]:
            if address == UROW and (i< USERCRC or i>USERCRC+3):
                log.info("Application user page byte at 0x%x changed from 0x%02x to 0x%02x" % (address+i, pageCopy[i], data[ofs+i]))
            if address == BOCOR and (i<8 or i>11):
                log.info("Application bocor page byte at 0x%x changed from 0x%02x to 0x%02x" % (address+i, pageCopy[i], data[ofs+i]))
            pageCopy[i] = data[ofs+i]

    # dev.Read(address,pageCopy,0,256)

    if address == UROW:		# USER1+USER2+USER3/2 CRC area (part of USER)
        if settings.getBool("x.tz_computecrc",True):
            crc = utils.crc32(pageCopy, 8, UROWCRCLEN)
            crc = crc ^ 0xFFFFFFFF

            pageCopy[USERCRC + 0] = crc & 255
            pageCopy[USERCRC + 1] = (crc >> 8) & 255
            pageCopy[USERCRC + 2] = (crc >> 16) & 255
            pageCopy[USERCRC + 3] = (crc >> 24) & 255
            log.info("Computed and inserted UROW.CRC = 0x%08x" % crc)
        erase_row(address)
        write_row(address, 0, pageCopy)
        return

    if address != BOCOR:
        return

    if not "L11" in device:
        write_bocor_ls(pageCopy)
        return

    pageCopy[6] = pageCopy[6] | 1  # force BCWEN to 1 to allow BOCOR rewrites
    ERASEKEYOFFSET = 0
    if ERASETYPE == L11CHIPERASE0:
        ERASEKEYOFFSET = 0x10
    elif ERASETYPE == L11CHIPERASE1:
        ERASEKEYOFFSET = 0x20
    elif ERASETYPE == L11CHIPERASE2:
        ERASEKEYOFFSET = 0x30
    if ERASEKEYOFFSET != 0:
        for i in range(16):
            if pageCopy[ERASEKEYOFFSET + i] != 255 & (ERASEKEY[i/4] >> (8*(i & 3))):
                log.error("Chip erase key does not match project settings. Forcing CE key for erase type " + str(ERASETYPE) + " to the one specified in project settings" + str(ERASEKEY))
            pageCopy[ERASEKEYOFFSET + i] = 255 & (ERASEKEY[i/4] >> (8*(i & 3)))
            log.info("ce - key %d %02x" % (i, pageCopy[ERASEKEYOFFSET + i]))
    # return
    # Writing the BOCOR row

    # Handle changes in the BOCOR row, computing CRC and hash and boothash if needed
    # BOCOR first doubleword CRC area
    FUSES_BOOTROM_BOOTOPT = 24
    sec_boot = (pageCopy[FUSES_BOOTROM_BOOTOPT / 8] & 0x0F) & 0x03
    BNSC_GRANULARITY = 0x20   # Boot Flash Non-Secure Callable region granularity
    BP_GRANULARITY = 0x100    # BOOTPROT region granularity
    BS_GRANULARITY = 0x100    # Boot Flash Secure region granularity

    boot_prot = get_fuse(pageCopy, 32, 39)*BP_GRANULARITY
    bs = get_fuse(pageCopy, 8, 15)*BS_GRANULARITY
    bnsc = get_fuse(pageCopy, 16, 21)*BNSC_GRANULARITY

    log.info("Boot configuration: bootprot=0x%x, bs=0x%x, bnsc=0x%x , bootopt=%x\n" % (boot_prot, bs, bnsc, sec_boot))


    if settings.getBool("x.tz_computecrc",True):
        crc = utils.crc32(pageCopy, 0, 8)
        crc = crc ^ 0xFFFFFFFF

        pageCopy[8 + 0] = (crc >> 0) & 255
        pageCopy[8 + 1] = (crc >> 8) & 255
        pageCopy[8 + 2] = (crc >> 16) & 255
        pageCopy[8 + 3] = (crc >> 24) & 255
        log.info("Computed and inserted BOCOR.CRC = 0x%08x" % crc)
        # Perform SHA on DW0, [DW8 .. DW19] and place the computed hash at BOCORHASH addr
        
        utils.sha256_reset()
        # Check whether bootkey is part of hash
        if sec_boot > 1:
            # If SHA-256 with BOOTKEY is specified, the SHA hash calculation begins with a
            # virtual 512-bit chunk, consisting of BOOTKEY from BOCOR replicated twice
            
            utils.sha256_update(pageCopy, FUSES_BOOTROM_BOOTKEY,FUSES_BOOTROM_BOOTKEYSIZE)
            utils.sha256_update(pageCopy, FUSES_BOOTROM_BOOTKEY,FUSES_BOOTROM_BOOTKEYSIZE)

        # add the BOCOR data
        utils.sha256_update(pageCopy, 0, 0x100 - 0x20)

        # finalize sha and store it in pageCopy
        utils.sha256_compute(pageCopy, FUSES_BOOTROM_BOCORHASH)

    erase_row(address)
    write_row(address, 0, pageCopy)

    if sec_boot == 0:
        return

    if not settings.getBool("x.tz_computesign",True):
        return

    if (boot_prot >= bs and bs-bnsc >= 0x100):
        add_boot_hash_L11(bs, bnsc, pageCopy,sec_boot)
    else:
        raise Exception("BOOTPROT region too small or BNSC too small")

def set_sw_bp(address, instruction, flags):  # mplab
    return set_sw_bp_gen(address, erase_size, instruction, flags)

def begin_communication_session(): #mplab
    log.info("Begin comm session")
    _begin_communication_session()

def end_communication_session(): #mplab
    log.info("End comm session")
    _end_communication_session()

def begin_programming_operation(): #mplab
    log.info("Begin operations")
    _begin_programming_operation()

def read_device_id():#mplab
    log.info("Read device ID")
    return _read_device_id()

def erase(): #mplab
    log.info("Erase")
    _erase()

def prog_write(type_of_mem, address, length, data): #mplab
    log.info("Writing %08x bytes to address 0x%08x of %s memory" % (length, address, type_of_mem))
    _prog_write(type_of_mem, address, length, data)

def prog_read(type_of_mem, address, length, data): #mplab
    log.info("Reading %08x bytes from address 0x%08x of %s memory" % (length, address, type_of_mem))
    _prog_read(type_of_mem, address, length, data)

def end_of_operations():#mplab
    log.info("End of operations")
    _end_of_operations()

def begin_debug_session():  #mplab
    log.info("Debug: Init debug session")
    _begin_debug_session()

def debug_read(mt, start, length, data):  #mplab
    log.info("Debug: Reading %08x bytes at start address 0x%08x (%s)" % (length, start, mt))
    _debug_read(mt, start, length, data)

def debug_write(mt, start, length, data):  #mplab
    log.info("Debug: Writing %08x bytes at start address 0x%08x (%s)" % (length, start, mt))
    _debug_write(mt, start, length, data)

def set_pc(pc):  #mplab
    log.info("Debug: set pc to 0x%08x" % pc)
    _set_pc(pc)

def get_pc():  #mplab
    pc = _get_pc()
    log.info("Debug: get_pc PC=0x%08x" % pc)
    return pc

def run_target():#mplab
    log.info("Debug: run target")
    _run_target()

_stealth_runstate = 2
def halt_target():  #mplab
    global _stealth_runstate    
    log.info("Debug: halt target")
    _stealth_runstate = 2  # cancels stealth mode
    _halt_target()

def step_target():  #mplab
    log.info("Debug: stepping at pc 0x%08x" % get_pc())
    _step_target()

def reset_target(): #mplab
    log.info("Debug: reset")
    _reset_target()
    on_after_reset() # call autoload hook

def is_target_running():#mplab
    global _stealth_runstate
    if _stealth_runstate == 2:
        return _is_target_running()
    return _stealth_runstate != 0

def on_after_reset(): 
    if not settings.getBool("arm.use_vtor", False):
        return
    vtor_name  = settings.getString("arm.vtor_adr", "0")

    vtor = -1
    try:
        vtor = int(vtor_name,0)
    except:
        try:
            vtor=deb.GetSymbolAddress(vtor_name)
        except:
            log.error("Debug: failed to compute location of VTOR")
            return
    load_vtor(vtor) 
    pass

def load_vtor(adr):
    try:
        pc = dev.Read32(adr + 4)
        sp = dev.Read32(adr)
        set_pc(arm.PC,pc)
        dev.WriteReg64(arm.SP,sp)
        log.info("Setting pc=%08x and sp=%08x" % (pc, sp))
    except:
        log.error("Debug: failed to set PC and SP to contents of exception_table")

def on_program_done():
    on_after_reset()

def end_debug_session():  #mplab
    log.info("Debug: End debug session")
    _end_debug_session()

def verify_transfer(type_of_mem, address, data, length):  #mplab
    log.error("Not-implemented Verifying %08x bytes to address 0x%0x of %s memory" % (length, address, type_of_mem))
    return True

def blank_check():  #mplab
    log.info("Blank check")

def hold_in_reset():  #mplab
    log.info("Hold in reset")
    _hold_in_reset()

def release_from_reset():  #mplab
    log.info("Release from reset")
    _release_from_reset()
    
