# This file is autogenerated
comm_speed=2000000
erase_as_needed = True  # used in prog_write
reset_delay = 0
has_reset = True
show_output = False
log_level = 0
has_connected = False
comm_iface = True # default to swd

def _begin_debug_session():
    ensure_connect()
    reset_and_halt()
    cache_onDebugStart()

def _begin_communication_session(): 
    global log_level,show_output,reset_delay, target_was_reset, has_reset, _stealth_runstate    , has_connected
    log_level    = settings.getNumeric("script.log_level",log_level)
    show_output  = settings.getBool("script.show_output",show_output)
    has_reset  = settings.getBool("script.has_reset",has_reset)
    reset_delay = settings.getNumeric("script.reset_delay",reset_delay)
    has_connected = False
    target_was_reset = False
    _stealth_runstate = 2
    dev.SetApiLogging(log_level)
    log.setShowOutput(show_output)

    global comm_iface, comm_speed, erase_as_needed
    comm_iface = settings.getString("communication.interface", "swd") == "swd"
    comm_speed = settings.getNumeric("communication.frequency", comm_speed)
    erase_as_needed = True  # used in prog_write

    init_mem_handlers()

def _end_communication_session(): 
    global has_connected
    dev.Disconnect()
    has_connected = False


def onShowPropsDFP2(t):
    ide.addBooleanProperty(t,"arm.use_vtor" , "*|programoptions|programoptions.eraseb4program","Set PC and SP to VTOR","After reset, force PC and SP to the entries defined by the VTOR", False)
    ide.addTextProperty(t,"arm.vtor_adr" , "*|programoptions|programoptions.eraseb4program","VTOR table or numerical address", "Enter address of vector table", "exception_table")
    ide.addPropCategory(t,"diagnostics" , "*|toolpack", "Diagnostics")
    ide.addBooleanProperty(t,"script.show_output" , "*|diagnostics|*","Output diagnostic logging","Show diagnostic text in the Output window", False)
    ide.addTextProperty(t,"script.log_level" , "*|diagnostics|*","Diagnostic log level","Set diagnostic level (usually 0 1 or 3)", "1")
    ide.addTextProperty(t,"script.reset_delay" , "*|diagnostics|*","Additional delay after reset","Enter additional RST settling delay in msec", "0")
    ide.addBooleanProperty(t,"script.has_reset" , "*|diagnostics|*","Uncheck if RESET line is not wired","Normally checked. Uncheck if the target does not have RST connected to the debugger", True)
    ide.addTextProperty(t, "loader.board_file", "*|programoptions|**","Board file path","Set the path of board file", "${ProjectDir}/board.xboard")

def print_dhcsr_v(t, d):
    log.info(t + arm.getDHCSRString(d))

def print_dhcsr(text):
    try:
        d = dev.Read32(arm.DHCSR)
        print_dhcsr_v(text, d)
        return d
    except:
        log.log("DHCSR is unreadable")
        return 0

def _debug_read(mt, start, length, data):
    cache_onDataRead(start, length)
    try:
        dev.Read(start, data, 0, length)
    except:
        for i in range(len(data)):
            try:
                dev.Read(start, data[i], 0, 1)
            except:
                data[i] = 0x3F
        log.info("Debug: an error occurred while reading address 0x%x length 0x%0x" % (start, length))

def _debug_write(mt, start, length, data):
    if str(mt) == "Pgm":
        cache_invalidateInstrCache()
        try:
            _flash_write(start, length, data, True)
        except:
            for i in range(len(data)):
                try:
                    _flash_write(start + i * 4, 1, data[i], True)
                except:
                    pass
            log.info("Debug: an error occurred while writing address 0x%x length 0x%0x" % (start, length))
        return

    cache_onDataWrite(start, length)
    try:
        dev.Write(start, data, 0, length)
    except:
        for i in range(len(data)):
            try:
                dev.Write(start, data[i], 0, 1)
            except:
                pass
        log.info("Debug: an error occurred while writing address 0x%x length 0x%0x" % (start, length))

def debug_write_supports_flash():
    return 1

def _get_pc():
    try:
        pc = dev.ReadReg64(15)
    except:
        log.error("get_pc returned error")
        return 0
    return pc
    
def _mem_read(start, length, data):
    dev.Read(start, data, 0, length)

def _mem_write(start, length, data):
    dev.Write(start, data, 0, length)

def _run_target():
    cache_onRun()
    wdt_onRun()
    dev.Write32(arm.DHCSR, 0xa05f0001)  # DBGKEY | C_DEBUGEN | C_HALT

def _halt_target():
    dev.Write32(arm.DHCSR, 0xa05f0003)  # DBGKEY | C_DEBUGEN | C_HALT

def _step_target():
    cache_onRun()
    wdt_onRun()
    dev.Write32(arm.DHCSR, 0xa05f000b)  # DBGKEY | C_DEBUGEN | C_HALT | C_MASKINTS
    dev.Write32(arm.DHCSR, 0xa05f000d)  # DBGKEY | C_DEBUGEN | C_STEP | C_MASKINTS
    dev.Write32(arm.DHCSR, 0xa05f0003)  # DBGKEY | C_DEBUGEN | C_HALT
    cache_onStop()
    wdt_onHalt()

def _set_pc(pc):
    dev.WriteReg64(15, pc)

def print_byte_array(text, array, index, size):
    string = text
    for i in range(size):
        string += " %x" % array[i+index]
    log.info(string)

g_is_running = True
def _is_target_running():
    global g_is_running
    dhcsr = dev.Read32(arm.DHCSR)
    state = 0 == (dhcsr & 0x20000)
    if state != g_is_running:
        log.info("Debug: target is now running" if state else "Debug: target has halted")
        g_is_running = state 
    if not g_is_running:
        cache_onStop()
        wdt_onHalt()
    return g_is_running

def _reset_target(): 
    reset_and_halt()

def ensure_connect():
    global has_connected
    if has_connected:
        return
    dev.Connect(comm_iface, comm_speed)
    has_connected = True

def _end_debug_session(): 
    #disable hw bp
    fpb = dev.Read32(0xe0002000)
    if 0 != (fpb & 1):
        dev.Write32(0xe0002000,2|(fpb&0xFFFFfffe))
    run_target()


def set_sw_bp_gen(address, erase_size, instruction, flags):  #mplab
    global erase_as_needed
    log.debug("Debug: set/reset bp at address 0x%0x, store instructions 0x%0x, flags = 0x%0x" % (address, instruction, flags))
    if address >= 0x20000000:
        erase_size = 4 
    else:
        clear_and_report_flash_error()


    erase_page_start = address & ~(erase_size-1)
    address_in_erase_page = address & (erase_size-1)

    data = bytearray(erase_size)
    cache_invalidateInstrCache()
    dev.Read(erase_page_start, data, 0, erase_size)
    return_value = data[address_in_erase_page] | (data[address_in_erase_page+1] << 8)

    # Insert software breakpoint instruction in the data
    data[address_in_erase_page] = instruction & 0xFF
    data[address_in_erase_page+1] = (instruction >> 8) & 0xFF

    if erase_size == 4:
        dev.Write(erase_page_start, data, 0, erase_size)
    else:
        erase_as_needed = True
        prog_write("Pgm", erase_page_start, erase_size, data)
    return return_value

# device specific functions


def dap_Read8(adr):
    return dev.Read8(adr)

def dap_Write8(adr,val):
    return dev.Write8(adr,val)

def dap_Read16(adr):
    return dev.Read16(adr)

def dap_Write16(adr,val):
    return dev.Write16(adr,val)

def dap_Read32(adr):
    return dev.Read32(adr)

def dap_Write32(adr,val):
    return dev.Write32(adr,val)

def dap_Read(adr,b,o,l):
    return dev.Read(adr,b,o,l)

no_device = False

def set_globals(dev_copy, utils_copy, settings_copy, device_copy, log_copy):
    global dev, utils, settings, device, log, no_device
    dev = dev_copy
    utils = utils_copy
    settings = settings_copy
    device = device_copy
    log = log_copy
    no_device = True

def _hold_in_reset(): 
    global has_reset
    if not has_reset:
        alt_hold_in_reset()
        return
    log.info("Prog: Hold in reset")
    dev.Pins(0, dev.RESET, 1000)
    #  The debugger needs to stay connected to actively keep the reset line low.

def alt_hold_in_reset(): 
    # Alternative if RESET pin is not connected to debugger
    log.info("Prog: Hold in reset , no reset line")
    reset_and_halt()

def _release_from_reset():
    global reset_delay
    global has_reset
    if not has_reset:
        log.info("Prog: Release from reset (soft reset)")
        reset_and_halt()
        run_target()
        return
    log.info("Prog: Release from reset (float reset line)")
    dev.Pins(0, dev.RESET, 1000)
    dev.Delay(reset_delay)
    dev.Pins(dev.RESET, dev.RESET, 1000)  # now float reset back
    dev.Delay(reset_delay)

def alt_release_from_reset():
    log.info("Prog: Release from reset, no reset line")
    dev.Write32(dev.AIRCR, 0x05fa0004)  # VECTKEY | SYSRESETREQ
erase_as_needed = True

def cache_onDebugStart():
    pass
def cache_onStop():
    pass
def cache_onRun():
    pass
def cache_onDataRead(adr,size):
    pass
def cache_onDataWrite(adr,size):
    pass
def cache_invalidateInstrCache():
    pass

def wdt_onRun():
    pass
def wdt_onHalt():
    pass

erase_size = 0x100

def _begin_programming_operation():
    global erase_as_needed
    erase_as_needed = True
    try:
        reset_to_park(False)  # may fail if locked
    except:
        pass

def reconnectAfterExtension():
    global has_connected
    has_connected = False # reset extension kills the OCD connection
    ensure_connect()

def _read_device_id():
    return dev.Read32(0x41002118) # DSU-DID register

prevCfgReg = 0
prevCfgReg2 = 0
OFFSET_CTRLB_2802 = 4
OFFSET_CTRLC_2802 = 8

def reset_and_halt():
    log.info("Debug: Reset target")
    reset_to_park(False)
# set a dwt breakpoint to halt on flash entry
    dev.Write32(arm.DEMCR, 0x01000000)  # enable TRCENA
    dev.Write32(0xe0001028, 0x00000412)
    dev.Write32(0xe0001020, 0x00000000)
    dev.Write32(0xe0001030, 0x00400000)
    dev.Write32(0xe0001038, 0x00000413)
    run_target()
    release_brext()
    dev.Delay(1000)
    t = 10
    while t > 0:
        try:
            if not is_target_running():
                dev.Write32(arm.DEMCR, 0x000000)  # disable TRCENA
                return
        except:
            pass  #during BOOTROM execution there may be errors reading DHCSR
        dev.Delay(100000)  # bootloader validation can take up to 0.5 sec
        t = t - 1
    if t == 0:
        log.error("Device did not halt")
    dev.Write32(arm.DEMCR, 0x000000)  # disable TRCENA

def cfg_nvmctrl():
    global prevCfgReg, prevCfgReg2
    set_nvmctrl_baseaddr()
    prevCfgReg2 = dev.Read8(nvmCtrl+OFFSET_CTRLC_2802)
    newCfgReg2 = prevCfgReg2 & 0x00fe  # use automatic writes
    if newCfgReg2 != prevCfgReg2:
        dev.Write8(nvmCtrl+OFFSET_CTRLC_2802, newCfgReg2)

    # CTRLB size = 4
    #global prevCfgReg
    if 0 == prevCfgReg:
        prevCfgReg = dev.Read32(nvmCtrl+OFFSET_CTRLB_2802)
    wait_states = 15
    newCfgReg = (prevCfgReg & ~0x1e) | (wait_states << 1)  # wait states 15
    if newCfgReg != prevCfgReg:
        dev.Write32(nvmCtrl+OFFSET_CTRLB_2802, newCfgReg)


def restore_nvmctrl():
    dev.Write8(nvmCtrl + OFFSET_CTRLC_2802, prevCfgReg2)
    dev.Write32(nvmCtrl + OFFSET_CTRLB_2802, prevCfgReg)


def erase_row(addr):
    # write a few bytes to the page buffer to set address register
    dev.Write32(addr, 0xFFFFFFFF)
    CMD_ERASE_ROW = 0xA502  # works on all flash sections on L10
    nvm_cmd(CMD_ERASE_ROW, 20)


def write_row(adr, ofs, data):
    page_size = 64
    written = 0

    while written < erase_size:
        dev.Write(adr, data, ofs + written, page_size)
        nvm_cmd(0xA504, 20)  # writePage
        adr += page_size
        written += page_size

def _prog_write_internal(type_of_mem, address, length, data): 
    global erase_as_needed        
    if _handle_security_flags(address,length,data):
        return
    if dal == 0:
        raise Exception("Device is protected. A chip erase is needed to remove the protection.")
    if str(type_of_mem) != "Pgm" and  str(type_of_mem) != "Cfg" and  str(type_of_mem) != "UserID":
        dev.Write(address, data, 0, length)
        return
    _flash_write(address,length,data,erase_as_needed)
    erase_as_needed = True  # only the first Prg write is allowed without an erase

def _flash_write(address, length, data,doerase):
    cfg_nvmctrl()
    # assumes flash is pre erased, so no row erase
    if address == UROW or address == BOCOR:
        if "L10" in device or "LE" in device:
            erase_row(address)
            write_row(address, 0, data)
        else:
            write_cfg_page(address, data,  0)
            if length > 0xc000-0x4000:
                write_cfg_page(BOCOR, data, 0xc000-0x4000)
    else:
        written = 0
        while written < length:
            if doerase:
                erase_row(address)
            write_row(address, written, data)
            written += erase_size
            address += erase_size
        
    restore_nvmctrl()


def _prog_read_internal(type_of_mem, address, length, data):    
    dev.Read(address, data, 0, length)


def program_row(adr, ofs, buf):
    erase_row(adr)
    write_row(adr, ofs, buf)

def clear_and_report_flash_error():
    try:
        is_nvm_ready()
    except:
        log.error("NVM controller is in an error state while setting a swbp. Clearing the error")



def set_sw_bp(address, instruction, flags):  # mplab
    return set_sw_bp_gen(address, erase_size, instruction, flags)


def _erase_internal():
    erase_with_chiperase()
target_was_reset = False
debug_session  = True

def begin_communication_session(): #mplab
    log.info("Begin comm session")
    _begin_communication_session()

def end_communication_session(): #mplab
    log.info("End comm session")
    _end_communication_session()

def begin_programming_operation(): #mplab
    global debug_session
    log.info("Begin operations")
    debug_session = False
    _begin_programming_operation()

def erase(): #mplab
    log.info("Erase")
    _erase()

def prog_write(type_of_mem, address, length, data): #mplab
    log.info("Writing %08x bytes to address 0x%08x of %s memory" % (length, address, type_of_mem))
    _prog_write(type_of_mem, address, length, data)

def prog_read(type_of_mem, address, length, data): #mplab
    log.info("Reading %08x bytes from address 0x%08x of %s memory" % (length, address, type_of_mem))
    _prog_read(type_of_mem, address, length, data)

def end_of_operations():#mplab
    log.info("End of operations")
    _end_of_operations()

def begin_debug_session():  #mplab
    log.info("Debug: Init debug session")
    global debug_session
    debug_session = True
    _begin_debug_session()

def debug_read(mt, start, length, data):  #mplab
    log.info("Debug: Reading %08x bytes at start address 0x%08x (%s)" % (length, start, mt))
    _debug_read(mt, start, length, data)

def debug_write(mt, start, length, data):  #mplab
    log.info("Debug: Writing %08x bytes at start address 0x%08x (%s)" % (length, start, mt))
    _debug_write(mt, start, length, data)

def set_pc(pc):  #mplab
    log.info("Debug: set pc to 0x%08x" % pc)
    _set_pc(pc)

def get_pc():  #mplab
    pc = _get_pc()
    log.info("Debug: get_pc PC=0x%08x" % pc)
    return pc

def run_target():#mplab
    log.info("Debug: run target")
    _run_target()

_stealth_runstate = 2
def halt_target():  #mplab
    global _stealth_runstate    
    log.info("Debug: halt target")
    _stealth_runstate = 2  # cancels stealth mode
    _halt_target()

def step_target():  #mplab
    log.info("Debug: stepping at pc 0x%08x" % get_pc())
    _step_target()

def reset_target(): #mplab
    log.info("Debug: reset")
    _reset_target()
    on_after_reset() # call autoload hook

def is_target_running():#mplab
    global _stealth_runstate
    if _stealth_runstate == 2:
        return _is_target_running()
    return _stealth_runstate != 0

def on_after_reset(): 
    if not debug_session:
        return
    if not settings.getBool("arm.use_vtor", False):
        return
    vtor_name  = settings.getString("arm.vtor_adr", "0")

    vtor = -1
    try:
        vtor = int(vtor_name,0)
    except:
        try:
            vtor=deb.GetSymbolAddress(vtor_name)
        except:
            log.error("Debug: failed to compute location of VTOR")
            return
    load_vtor(vtor) 
    pass

def load_vtor(adr):
    try:
        pc = dev.Read32(adr + 4)
        sp = dev.Read32(adr)
        set_pc(pc)
        dev.WriteReg64(arm.SP,sp)
        log.info("Setting pc=%08x and sp=%08x" % (pc, sp))
    except:
        log.error("Debug: failed to set PC and SP to contents of exception_table")

def on_program_done():
    on_after_reset()

def end_debug_session():  #mplab
    log.info("Debug: End debug session")
    _end_debug_session()

def verify_transfer(type_of_mem, address, data, length):  #mplab
    log.info("Verifying %08x bytes to address 0x%0x of %s memory" % (length, address, type_of_mem))
    _verify_transfer(type_of_mem, address, data, length)

    

def _verify_transfer(type_of_mem, address, data, length):
    if len(data) != length:
        raise Exception("The given data and length mismatch")
    d = bytearray(length)
    prog_read(type_of_mem, address, length, d)
    if str(type_of_mem) == "Cfg":
        verify_config(address, data, d, "verify")
    else:
        for i in range(length):
            if data[i] != d[i]:
                raise Exception("Verify failed for mem type {}, at address 0x{:X}".format(str(type_of_mem), address + i))

global dev_cfg_masks_bytearray
dev_cfg_masks_bytearray = None

def init_masks_as_bytearray():
    global dev_cfg_masks_bytearray
    if dev_cfg_masks_bytearray:
        return
    dev_cfg_masks_bytearray = {}
    for address, val in dev_cfg_masks.items():
        dev_cfg_masks_bytearray[address    ] = int(val      ) & 0xFF
        dev_cfg_masks_bytearray[address + 1] = int(val >> 8 ) & 0xFF
        dev_cfg_masks_bytearray[address + 2] = int(val >> 16) & 0xFF
        dev_cfg_masks_bytearray[address + 3] = int(val >> 24) & 0xFF

def verify_config(address, expected, actual, error_string_prefix):
    try:
        # older versions of MPLAB X (<=v5.45) did not pass dev_cfg_masks
        # so very_config cannot be executed
        dev_cfg_masks 
    except:
        raise Exception("{} config is not implemented".format(error_string_prefix))
    init_masks_as_bytearray()

    for index, actual_val in enumerate(actual):
        current_address = address + index
        if current_address in dev_cfg_masks_bytearray:
            mask = dev_cfg_masks_bytearray[current_address]
            expected_val = expected[index] & mask
            actual_val &= mask
            if actual_val != expected_val:
                error_string = "{} failed at address 0x{:0X}, expected 0x{:0X}, got 0x{:0X}".format(error_string_prefix, current_address, expected_val, actual_val)
                raise Exception(error_string)

def is_memory_blank_all_ffs(type_of_mem):
    return str(type_of_mem) == "Pgm" or str(type_of_mem) == "UserID"
        
def blank_check():  #mplab
    log.info("Blank check")

def blank_check_mem(type_of_mem, address, length):  #mplab
    msg.print("Blank checking %08x bytes to address 0x%0x of %s memory" % (length, address, type_of_mem))
    _blank_check_mem(type_of_mem, address, length)

def _blank_check_mem(type_of_mem, address, length):
    data = bytearray(length)
    prog_read(type_of_mem, address, length, data)
    if str(type_of_mem) == "Cfg":
        prog_read(type_of_mem, address, length, data)
        verify_config(address, data, data, "blank check")
    elif is_memory_blank_all_ffs(type_of_mem):
        for index, x in enumerate(data):
            if x != 255:
                raise Exception("Blank failed for mem type {}, at address 0x{:X}".format(str(type_of_mem), address + index))
    else:
        log.error("Blank check, ignoring {}".format(str(type_of_mem)))

def hold_in_reset():  #mplab
    log.info("Hold in reset")
    _hold_in_reset()

def release_from_reset():  #mplab
    log.info("Release from reset")
    _release_from_reset()
    
def read_device_id():#mplab
    log.info("Read device ID")
    return _read_device_id()
CRSTEXTBIT = 2  # CRSTEXT bit in STATUSA
BREXTBIT = 0x20  # BREXT bit in STATUSA
dal = -1
STATUSA = 1
STATUSB = 2

DEBUGGER_CMD_INIT = 0x44424755  # Initiate communication to enter trap functions
DEBUGGER_CMD_EXIT = 0x444247AA  # Goto exit function
nvmCtrl = 0
UROW = 0x00804000
BOCOR = 0x0080C000
DSU = 0x41002100  # external address range to bypass security filter
DSU_STATUSB_BCCD0 = 1 << 6
BCC = 0x20               # bootrom communication channel

SDAL0 = 100
SDAL1 = 101
CHIPERASE0 = 0xE0
CHIPERASE1 = 0xE1
CHIPERASE2 = 0xE2
CHIPERASE3 = 0xE3
CHIPERASE4 = 0xE4
NSCHIPERASE = 0xE3
ERASETYPE = None
ERASEKEY = []

def onloadDFP(ide):
    if ("L11" in device) or ("LS" in device) :
        ide.addCommand("Device actions|Set DAL 0", "set_dal_0")
        ide.addCommand("Device actions|Set DAL 1", "set_dal_1")
        ide.addCommand("Device actions|ChipErase_NS CE0", "chip_erase_0")
        ide.addCommand("Device actions|ChipErase_S CE1", "chip_erase_1")
        ide.addCommand("Device actions|ChipErase_ALL CE2", "chip_erase_2")
    elif "L10" in device:
        ide.addCommand("Device actions|Set DAL 0", "set_dal_0")
        ide.addCommand("Device actions|Chip Erase", "chip_erase_l10")
    elif "LE00" in device:
        ide.addCommand("Device actions|Set DAL 0", "set_dal_0")
        ide.addCommand("Device actions|Chip Erase", "chip_erase_3")
        ide.addCommand("Device actions|Chip Erase All", "chip_erase_4")


def special_action(kofs, cmd):
    global dal,ERASEKEY
    if deb.Connected():
        r = msg.msg("Debugger is in use. Stop debugging and retry", "Busy")
        return
    deb.Connect() #sets tool

    try:
        #dev.Connect(comm_iface, comm_speed) # sets device name
        if kofs == 0:
            dal = 3 & dap_Read8(DSU + 2)
            if dal == 0:
                raise Exception("Device is protected at DAL = 0. A chip erase is needed to remove the protection.")
            if dal == 1 and cmd == SDAL1:
                raise Exception("Device is protected at DAL = 1. A chip erase is needed to remove the protection.")
            
        cvt_erase_key() # set erase key

        if kofs != 0 and dal == 2:
            try :
                b = bytearray(16)
                reset_to_park(False)
                dap_Read(BOCOR + kofs, b, 0, 16)
                ERASEKEY[0] = byte_to_dword(b,0)
                ERASEKEY[1] = byte_to_dword(b,4)
                ERASEKEY[2] = byte_to_dword(b,8)
                ERASEKEY[3] = byte_to_dword(b,12)
                msg.printError("Using erase key from BOCOR 0x%08x,0x%08x,0x%08x,0x%08x" % (k[0],k[1],k[2],k[3]))
            except Exception as e:
                log.error("Failed to read key from bocor, using hardcoded key values from scripts")
        ERASETYPE = cmd
        
        special_nvm_op(ERASEKEY, ERASETYPE)

        dev.Disconnect()        #make sure
    except Exception as e:
        msg.msg(str(e),"Error")
        raise e
    except:
        msg.msg("Error performing action, check output window","Error")
        raise 
    finally:
        deb.Disconnect()

def set_dal_0():
    global dal
    special_action(0, SDAL0)
    msg.msg("DAL is now " + str(dal), "Set DAL 0")


def set_dal_1():
    global dal
    special_action(0, SDAL1)
    msg.msg("DAL is now " + str(dal), "Set DAL 1")

def byte_to_dword(b,o):
    return b[o+0] + 256*(b[o+1] + 256*(b[o+2] + 256*(b[o+3])))

def ce_with_dlg(kofs, t):
    global dal
    special_action(kofs, t)
    msg.msg("Chip erase done. DAL is now " + str(dal), "Chip Erase")

def chip_erase_2():
    ce_with_dlg(0x30, CHIPERASE2)

def chip_erase_1():
    ce_with_dlg(0x20, CHIPERASE1)


def chip_erase_0():
    ce_with_dlg(0x10, CHIPERASE0)

def chip_erase_3():
    ce_with_dlg(0, CHIPERASE3)

def chip_erase_4():
    ce_with_dlg(0, CHIPERASE4)


def chip_erase_l10():
    ce_with_dlg(0, NSCHIPERASE)

def reset_extension():
    global reset_delay # additional delay for reset line if needed
    global has_reset
    if not has_reset:
        return

    dev.SetInterface(dev.SWD) # benign even if already connected
    delay=1000  # time to  wait for analog RESET/SWCLK pins to become digitally high/low
    dev.Pins(0,dev.RESET,delay)  # 1 msec with reset high 
    if reset_delay > 0:
        dev.Delay(reset_delay)
    dev.Pins(dev.RESET,dev.RESET,delay) # 1 msec with floating reset 
    if reset_delay > 0:
        dev.Delay(reset_delay)
    dev.Pins(0,dev.RESET | dev.SWCLK,delay); # 1 msec with reset and clock low 
    if reset_delay > 0:
        dev.Delay(reset_delay)
    dev.Pins(dev.RESET,dev.RESET,delay); # now float reset back
    if reset_delay > 0:
        dev.Delay(reset_delay)
    dev.Delay(10000)
    reconnectAfterExtension()

def reset_to_park(brext):
    global has_reset
    reset_extension()
    
    if not has_reset:
        reset_and_halt()
        dal = 3 & dap_Read8(DSU + 2)
        log.info("Programming may not work without a connected RESET line")
        return
    exit_reset_extension(brext)

def erase_with_chiperase():
    global ERASEKEY, ERASETYPE
    global set_dal_val

    set_dal_val = 10  # reset DAL variable

    if "L10" in device:
        ERASETYPE = NSCHIPERASE
    elif "LE" in device:
        et = settings.getString("x.erase.type", "ChipEraseAll")

        if et == "ChipEraseAll":
            ERASETYPE = CHIPERASE4
        elif et == "ChipErase":
            ERASETYPE = CHIPERASE3
    else:
        et = settings.getString("x.erase.type", "ChipEraseAll")

        if et == "ChipEraseS":
            ERASETYPE = CHIPERASE1
        elif et == "ChipEraseNS":
            ERASETYPE = CHIPERASE0
        elif et == "ChipEraseAll":
            ERASETYPE = CHIPERASE2
        else:
            return    # do not erase

    cvt_erase_key()
    special_nvm_op(ERASEKEY, ERASETYPE)

def cvt_erase_key():
    global ERASEKEY
    keys = settings.getString("x.erase.key", "0xffffffff,0xffffffff,0xffffffff,0xffffffff").split(",")
    ERASEKEY = [0, 0, 0, 0]
    for i in range(0, 4):
        ERASEKEY[i] = long(keys[i], 16)

set_dal_val = 10
def _handle_security_flags(address, length, data): 
    if address == 0x41004000:
        if length < 1:
            return False
        global set_dal_val
        set_dal_val = data[0] - 0x4B
        return True
    return False

def _end_of_operations():
    global set_dal_val, erase_as_needed
    erase_as_needed = True
    if set_dal_val < 2:
        log.info("Setting DAL " + str(set_dal_val))
        special_nvm_op([], (SDAL0 if set_dal_val == 0 else SDAL1))
        set_dal_val = 10

def brom_read_status():
    return dap_Read32(DSU + BCC + 4)

def exit_reset_extension(brext):
    global dal
    reply = 0
    
    statusa = dap_Read8(DSU + STATUSA)  # debug
    dal = 3 & dap_Read8(DSU + 2)
    if 0 == (statusa & CRSTEXTBIT):
        log.error(device + " could not enter reset extension")
        return False

    dap_Write8(DSU + STATUSA, CRSTEXTBIT)  # clear crstext
    #  ROM starts running after clearing reset extension
    dev.Delay(5000)
    reply = 0
    if (dap_Read8(DSU+STATUSB) & 0x80):
        reply = brom_read_status()
    if reply != 0:
        log.error("User page validation failed with error code 0x%08x" % reply)
        raise Exception(device + " user page validation failed.")

    dap_Write32(DSU + BCC, DEBUGGER_CMD_EXIT)  # exit to park mode

    # after cmdexit , BOOTROM does boot validation, which may take up to 500msec
    # after which it enters the park loop and can be halted, if bootldr verify ok
    n = 0
    r = 0
    ellapsed = 0
    wkup_time = 10000 if "LS60" in device or "LS00" in device else 2000
    wkup_time = settings.getNumeric("wkup_time",wkup_time)
    while ellapsed < wkup_time:
        if 0 != (dap_Read8(DSU + STATUSB) & 0x80):   # if new data on BCCD1 , read it
            reply = brom_read_status()
            if reply == 0xEC000022:
                raise Exception("Chip is locked")
            if reply != 0xEC000039:
                log.error("Boot validation failed with error code 0x%02x" % (reply & 0xff))
                raise Exception("Boot validation failed")
            break
        dev.Delay(50000 * n)
        ellapsed = ellapsed + 50*n
        n = n+1
    if ellapsed > wkup_time:
        log.error("The Bootrom did not confirm the CPU park mode")
        raise Exception("Timed out entering park mode")
    # we can now halt the target if at DAL 2
    dap_Write32(arm.DHCSR, 0xa05f0003)  # DBGKEY | C_DEBUGEN | C_HALT
    dal = 3 & dap_Read8(DSU + 2)
    if brext:
        release_brext()
    return True


def release_brext():
    dap_Write8(DSU + STATUSA, BREXTBIT)

def brom_send_key(data, timeout):
    for wrd in data:
        dap_Write32(DSU + BCC, wrd)
        while timeout > 0:
            u8regval = dap_Read8(DSU + STATUSB)  # read statusb
            if 0 == (u8regval & DSU_STATUSB_BCCD0):  # break if BCC was read
                break
            dev.Delay(1000)
            timeout = timeout - 1
        if timeout == 0:
            return 1
    return 0

def special_nvm_op(key, ceMode):
    global dal
    SIG_COMM = 0xec000020
    SIG_CMD_SUCCESS = 0xec000021
    SIG_CMD_VALID = 0xec000024
    SIG_CMD_INVALID = 0xec000025
    SIG_BOOT_OK = 0xEC000039

    if (ceMode == SDAL0) or (ceMode == SDAL1):
        reset_to_park(False)
        CMD_SDAL0 = 0xA54B
        CMD_SDAL1 = 0xA54C
        set_nvmctrl_baseaddr()
        nvm_cmd(CMD_SDAL0 if (ceMode == SDAL0) else CMD_SDAL1, 100)
        try:
            # at DAL 0 the device will not exit to park mode
            reset_to_park(True)
        except:
            pass
        return

    if "LS60" in device and ceMode == CHIPERASE2:
        try:
            read_and_print_iokey("BOCOR.IOKEY before ChipErase_All is ")
        except:
            log.info("Could not read BOCOR.IOKEY from device")
        
    reset_extension()

    statusa = dap_Read8(DSU + STATUSA)
    if 0 == (statusa & CRSTEXTBIT):
        raise Exception(device + " could not enter reset extension. Please check the reset line is connected to debugger.")

    dap_Write8(DSU + STATUSA, CRSTEXTBIT)
    dev.Delay(5000)  # // wait for device validation
    errCode = 0
    if 0 != (dap_Read8(DSU + STATUSB) & 0x80):
        errCode = brom_read_status()

    if errCode != 0:
        log.error(device + " failed to boot. Error code {}".format(errCode)) # log the error, but proceed with chip erase

    dap_Write32(DSU + BCC, DEBUGGER_CMD_INIT)
    reply = brom_read_status()
    if (errCode == 0 and reply != SIG_COMM):
        raise Exception(device + " chip erase failed to enter command loop.") # shouldnt happen

    if (ceMode != NSCHIPERASE and (ceMode < CHIPERASE0 or ceMode > CHIPERASE4)):
        raise Exception(device + " chip erase failed (invalid mode).")
    dap_Write32(DSU + BCC, 0x44424700 | ceMode)
    reply = brom_read_status()
    if reply != SIG_CMD_VALID:
        log.error(device + " chip erase failed because bootrom did not accept chip erase command")
        raise Exception(device + " chip erase failed (cmd error)")

    if ceMode != NSCHIPERASE and ceMode != CHIPERASE4:
        brom_send_key(key, 100)

    for j in range(0, 20):
        reply = brom_read_status()
        if reply != SIG_CMD_VALID and reply != 0:
            break
        dev.Delay(1000000)
    if reply != SIG_CMD_SUCCESS:
        log.error(device + " chip erase failed : error code 0x%X" % reply)
        reset_to_park(False) # so we can read the BOCOR
        try:
            b = bytearray(16)
            dap_Read(BOCOR + 0x10, b, 0, 16)
            print_ce_key("CEKEY0" , b)
            dap_Read(BOCOR + 0x20, b, 0, 16)
            print_ce_key("CEKEY1" , b)
            dap_Read(BOCOR + 0x30, b, 0, 16)
            print_ce_key("CEKEY2" , b)
        except:
            log.error(device + " error reading bocor")
        raise Exception(device + " chip erase failed : error code 0x%X" % reply)
    else:
        log.info(device + " chip erase done")
    reset_to_park(True)
    pass

def set_nvmctrl_baseaddr():
    global nvmCtrl, dal
    nvmCtrl = 0x41004000
    if "L10" in device or "LE" in device:
        return
    dal = 3 & dap_Read8(DSU + 2)
    if dal != 1:
        nvmCtrl = 0x41005000
    return

def nvm_cmd(command, t):
    if no_device:
        return
    dap_Write16(nvmCtrl + 0, command)
    while t > 0:
        if is_nvm_ready():
            return
        dev.Delay(1000)
        t = t - 1
    if t == 0:
        raise Exception("Timeout executing NVM command")

FUSES_BOOTROM_BOOTKEY = 80      # 640/8
FUSES_BOOTROM_BOOTKEYSIZE = 32 # (896-640)/8
FUSES_BOOTROM_BOCORHASH = 224  # 1792/8

SHA_HASHSIZE_IN_BYTES       = 32
SHA_CHUNKSIZE_IN_BYTES      = 64
BNSC_GRANULARITY = 0x20   # Boot Flash Non-Secure Callable region granularity
BP_GRANULARITY = 0x100    # BOOTPROT region granularity

#define BROM_BOOTOPT_NONE					            0
#define BROM_BOOTOPT_SHA256					            1
#define BROM_BOOTOPT_SHA256BOOTKEY			            2
#define BROM_BOOTOPT_HMAC					            3
#define BROM_BOOTOPT_BOCORSHA256_BSECC608				4
#define BROM_BOOTOPT_BOCORSHA256BOOTKEY_BSECC608		5
#define BROM_BOOTOPT_BOCORHMAC_BSECC608				    6


def add_boot_hash_LS(idauIdauProt,idauBnscSize,pageCopy,bootopt):
    idauBsSize = idauIdauProt

    log.info("Computing signature")
    bootHashAddr = (idauBsSize - idauBnscSize) - SHA_HASHSIZE_IN_BYTES
    rowStartAddr = bootHashAddr & 0xFFFFFF00
    content=bytearray(idauBsSize)
    # Read boot area
    dev.Read(0, content, 0, idauBsSize)

    if bootopt == 1 or bootopt == 2: # SHA256 or SHA256BOOTKEY    
        utils.sha256_reset()
        if bootopt == 2:
            utils.sha256_update(pageCopy, FUSES_BOOTROM_BOOTKEY, FUSES_BOOTROM_BOOTKEYSIZE)
            utils.sha256_update(pageCopy, FUSES_BOOTROM_BOOTKEY, FUSES_BOOTROM_BOOTKEYSIZE)

        utils.sha256_update(content, 0, idauBsSize - idauBnscSize - SHA_HASHSIZE_IN_BYTES)
        if idauBnscSize > 0:
            utils.sha256_update(content, idauBsSize - idauBnscSize , idauBnscSize)
        utils.sha256_compute(content, bootHashAddr)
    elif bootopt == 3 :  # HMAC on bocor key and bootloader content
        for i in range(idauBnscSize): # compact message by removing the hashkey "hole"
            content[bootHashAddr+i]=content[idauBsSize-idauBnscSize+i]
        hmac_sha256(pageCopy, FUSES_BOOTROM_BOOTKEY, FUSES_BOOTROM_BOOTKEYSIZE,
            content, 0, idauBsSize - SHA_HASHSIZE_IN_BYTES, 
            content, bootHashAddr)
    elif bootopt >= 4:
        SIGN_SIZE = 64
        utils.sha256_reset()        
        utils.sha256_update(content, 0, idauBsSize - idauBnscSize - SIGN_SIZE)
        if idauBnscSize > 0:
            utils.sha256_update(content, idauBsSize - idauBnscSize , idauBnscSize)
        digest = bytearray(32)
        utils.sha256_compute(digest, 0)

        # The keys must be in the "right" format to be usable by Java
        # This may help :
        # openssl pkcs8 -topk8 -inform pem -in file.key -outform pem -nocrypt -out file.pem        
        sign_offset = idauBsSize - idauBnscSize - SIGN_SIZE 
        try:
            pr = utils.readPrivateKey("EC", settings.getString("x.prk.path", "")) 
            pu = utils.readPublicKey("EC",  settings.getString("x.puk.path", "")) 
            if not os.path.isfile(pu):
                pu = None
            sign = utils.computeSignature(digest, "NONEwithECDSA", pr, pu)
            # extract raw signature, 64 bytes
            r_offset = sign[3]-32+4
            s_offset = sign[r_offset+32+1]-32+(r_offset+32+2)
            rawSignature = bytearray(64)
            for  i in range(32):
                rawSignature[i] = sign[r_offset+i]
                rawSignature[0x20 + i]= sign[s_offset + i]
            # copy raw signature in place
            for i in range(SIGN_SIZE):
                content[sign_offset + i]=rawSignature[i]
        except:
            has_non_zero = False
            for i in range(SIGN_SIZE):
                if content[sign_offset + i] != 0 and content[sign_offset + i] != 0xff:
                    has_non_zero = True
            if not has_non_zero:
                log.error("Bootloader signature must be computed and inserted into the bootloader using the Microchip Trust Platform")
            return

    # Write Hash at proper location
    program_row(rowStartAddr,rowStartAddr,content)

def add_boot_hash_L11(idauBsSize,idauBnscSize,pageCopy,bootopt):
    utils.sha256_reset()
    if bootopt != 1:
        utils.sha256_update(pageCopy, FUSES_BOOTROM_BOOTKEY,FUSES_BOOTROM_BOOTKEYSIZE)
        utils.sha256_update(pageCopy, FUSES_BOOTROM_BOOTKEY,FUSES_BOOTROM_BOOTKEYSIZE)

    content=bytearray(idauBsSize)
    # Read boot area
    dev.Read(0, content, 0, idauBsSize)
    utils.sha256_update(content, 0, idauBsSize - idauBnscSize - SHA_HASHSIZE_IN_BYTES)
    if idauBnscSize > 0:
        utils.sha256_update(content, idauBsSize - idauBnscSize , idauBnscSize)

    # Write Hash at proper location
    bootHashAddr = (idauBsSize - idauBnscSize) - SHA_HASHSIZE_IN_BYTES
    rowStartAddr = bootHashAddr &0xFFFFFF00
    utils.sha256_compute(content, bootHashAddr)
    
    program_row(rowStartAddr,rowStartAddr,content)


def hmac_sha256(ptrkey,  ofsKey, keySizeInBytes, ptrmsg, ofsMsg, msgSizeInBytes, hash_in_out, out_ofs):
    # inner : H(key + message))
    
    datatmp = bytearray(SHA_CHUNKSIZE_IN_BYTES)
    utils.sha256_reset()
    # key + padding
    for i in range(SHA_CHUNKSIZE_IN_BYTES):
        datatmp[i] = ptrkey[i+ofsKey] ^ 0x36 if i<keySizeInBytes else 0x36
        
      
    utils.sha256_update(datatmp, 0, SHA_CHUNKSIZE_IN_BYTES)
    utils.sha256_update(ptrmsg, ofsMsg, msgSizeInBytes);

    # Finalize inner SHA computation
    # Save the inner hash output
    hmac_inner_hash = bytearray(SHA_HASHSIZE_IN_BYTES)
    utils.sha256_compute(hmac_inner_hash, 0)
    # Second (outer) SHA : H(key + innerSHA)
    utils.sha256_reset()
    #key + padding
    for i in range(SHA_CHUNKSIZE_IN_BYTES):
        datatmp[i] = ptrkey[i+ofsKey] ^ 0x5C if i<keySizeInBytes else 0x5c
        
    utils.sha256_update(datatmp, 0, SHA_CHUNKSIZE_IN_BYTES)
    utils.sha256_update(hmac_inner_hash, 0, SHA_HASHSIZE_IN_BYTES)
    utils.sha256_compute(hash_in_out, out_ofs)

def get_fuse_16(i, bit0, bit1):
    val = i[bit0 >> 3] + 256*i[bit1 >> 3]
    mask = [ 1,3,7,15,31,63,127,255,511,1023,2047,4095,8191 , 16383, 32767,65535 ]
    return mask[bit1 - bit0] & (val >> (bit0 & 7))

def get_fuse(i, bit0, bit1):
    mask = [ 1,3,7,15,31,63,127,255 ]
    return mask[bit1 - bit0] & (i[bit0 >> 3] >> (bit0 & 7))

def write_bocor_ls(pageCopy):
    pageCopy[7] = pageCopy[7] | 1  # force BCWEN to 1 to allow BOCOR rewrites
    ERASEKEYOFFSET = 0
    if ERASETYPE == CHIPERASE0:
        ERASEKEYOFFSET = 0x10
    elif ERASETYPE == CHIPERASE1:
        ERASEKEYOFFSET = 0x20
    elif ERASETYPE == CHIPERASE2:
        ERASEKEYOFFSET = 0x30
    if ERASEKEYOFFSET != 0:
        for i in range(16):
            if pageCopy[ERASEKEYOFFSET + i] != 255 & (ERASEKEY[i/4] >> (8*(i & 3))):
                log.error("Chip erase key does not match project settings. Forcing CE key for erase type " + str(ERASETYPE) + " to the one specified in project settings" + str(ERASEKEY))
            pageCopy[ERASEKEYOFFSET + i] = 255 & (ERASEKEY[i/4] >> (8*(i & 3)))
            # log.info("ce - key %d %02x" % (i, pageCopy[ERASEKEYOFFSET + i]))

    # Handle changes in the BOCOR row, computing CRC and hash and boothash if needed
    # BOCOR first doubleword CRC area

    bootprot = get_fuse_16(pageCopy, 40, 50) * BP_GRANULARITY
    bootopt = get_fuse(pageCopy, 32, 39)
    bnsc = get_fuse_16(pageCopy, 19, 27)*BNSC_GRANULARITY
    log.info("Boot configuration : bootprot=0x%x, bnsc=0x%x , bootopt=%x\n" % (bootprot,  bnsc, bootopt))

    if settings.getBool("x.tz_computecrc",True):
        crc = utils.crc32(pageCopy, 0, 8)
        crc = crc ^ 0xFFFFFFFF

        pageCopy[8 + 0] = (crc >> 0) & 255
        pageCopy[8 + 1] = (crc >> 8) & 255
        pageCopy[8 + 2] = (crc >> 16) & 255
        pageCopy[8 + 3] = (crc >> 24) & 255
        log.info("Computed and inserted BOCOR.CRC = 0x%08x" % crc)
        if "LS" in device:
            bootlck = get_fuse(pageCopy, 51, 51) 
            if bootlck == 0:
                log.error("The SECCFGLOCK bit is configured to lock the deviceat DAL = 0. Debug will not be possible without a chip erase")
        # Perform SHA/HMAC on DW0, [DW8 .. DW19] and place the computed hash at BOCORHASH addr
      
        if bootopt == 3 or bootopt >= 6: # 3 and >=6 use HMAC with BOOTKEY
            hmac_sha256(pageCopy,FUSES_BOOTROM_BOOTKEY,FUSES_BOOTROM_BOOTKEYSIZE, 
                        pageCopy, 0, 0x100-SHA_HASHSIZE_IN_BYTES, 
                        pageCopy, 0x100-SHA_HASHSIZE_IN_BYTES)
        elif bootopt == 0:
            pass
        else:
            # bootopt 1,2,4,5
            # Check whether bootkey is part of hash
            utils.sha256_reset() 
            if bootopt == 2 or bootopt == 5:
                # If SHA-256 with BOOTKEY is specified, the SHA hash calculation begins with a
                # virtual 512-bit chunk, consisting of BOOTKEY from BOCOR replicated twice
                utils.sha256_update(pageCopy, FUSES_BOOTROM_BOOTKEY,FUSES_BOOTROM_BOOTKEYSIZE)
                utils.sha256_update(pageCopy, FUSES_BOOTROM_BOOTKEY,FUSES_BOOTROM_BOOTKEYSIZE)
            # add the BOCOR data minus 32 bytes at the end
            utils.sha256_update(pageCopy, 0, 0x100 - 0x20)
            # finalize sha and store it in pageCopy
            utils.sha256_compute(pageCopy, FUSES_BOOTROM_BOCORHASH)

        
    erase_row(0x80c000)
    write_row(0x80c000, 0, pageCopy)
    # uncomment to debug contents of bocor
    # dev.Read(0x80c000 + 1152/8,  pageCopy, 0, 16) # ioprotkey
    # dev.Read(0x80c000 + FUSES_BOOTROM_BOCORHASH, pageCopy, 0, 16) 
    # dev.Read(0x80c000 + FUSES_BOOTROM_BOCORHASH + 16,  pageCopy, 0, 16)

    if bootopt == 0:
        return

    if not settings.getBool("x.tz_computesign",True):
        return

    if (bootprot >= 0):
        add_boot_hash_LS(bootprot, bnsc, pageCopy, bootopt)
    else:
        raise Exception("BOOTPROT region is too small")

def read_and_print_iokey(warningText):
    reset_to_park(False) # so we can read the BOCOR
    b = bytearray(16)
    dap_Read(0x80c000 + 144,  b, 0, 16) # ioprotkey
    keyString = " 0x" + (',0x'.join(format(x, '02x') for x in b) )
    msg.printError(warningText + keyString)
    try:
        project_dir = ide.expandProjectMacros("${ProjectName}", "${ProjectDir}")
        f = open(project_dir + "/bocor_iokeys.txt", "a")
        f.write("const unsigned char __attribute__((space(prog),address (0x0080c090 ))) bocor_iokey [] = {" + keyString + "}; // xc32 only \n")
        f.close()
    except:
        pass


def print_ce_key(k,b):
    msg.printError(k + " is 0x" + 
        ("".join(format(x, '02x') for x in b[0:4]) ) + ",0x" +
        ("".join(format(x, '02x') for x in b[4:8]) ) + ",0x" +
        ("".join(format(x, '02x') for x in b[8:12]) ) + ",0x" +
        ("".join(format(x, '02x') for x in b[12:16]) )
        )


def write_cfg_page(address, data, ofs):
    pageCopy = bytearray(256)

    if len(data) < 256:
        log.error("write_cfg_page should be called with 256 bytes of data")
        return

    dev.Read(address, pageCopy, 0, 256)
    if "L11" in device:
        urwen = get_fuse(pageCopy, 96, 96) 
        if urwen == 0:
            raise Exception("The URWEN bit is 0. Writing to user page is disabled until the device is chip erased.")
    if "LS" in device:
        bootlck = get_fuse(pageCopy, 106, 106) 
        if bootlck == 0:
            raise Exception("The URWEN bit is 0. Writing to user page is disabled until the device is chip erased.")

    if "LS" in device:
        USERCRC = 0x20
        UROWCRCLEN = 0x18
    else:
        USERCRC = 0x1C
        UROWCRCLEN = 0x14

    for i in range(0, 256):
        if pageCopy[i] != data[ofs+i]:
            if address == UROW and (i< USERCRC or i>USERCRC+3):
                log.info("Application user page byte at 0x%x changed from 0x%02x to 0x%02x" % (address+i, pageCopy[i], data[ofs+i]))
            if address == BOCOR and (i<8 or i>11):
                log.info("Application bocor page byte at 0x%x changed from 0x%02x to 0x%02x" % (address+i, pageCopy[i], data[ofs+i]))
            pageCopy[i] = data[ofs+i]

    # dev.Read(address,pageCopy,0,256)

    if address == UROW:		# USER1+USER2+USER3/2 CRC area (part of USER)
        if settings.getBool("x.tz_computecrc",True):
            crc = utils.crc32(pageCopy, 8, UROWCRCLEN)
            crc = crc ^ 0xFFFFFFFF

            pageCopy[USERCRC + 0] = crc & 255
            pageCopy[USERCRC + 1] = (crc >> 8) & 255
            pageCopy[USERCRC + 2] = (crc >> 16) & 255
            pageCopy[USERCRC + 3] = (crc >> 24) & 255
            log.info("Computed and inserted UROW.CRC = 0x%08x" % crc)
        erase_row(address)
        write_row(address, 0, pageCopy)
        return

    if address != BOCOR:
        return

    if "LS" in device:
        write_bocor_ls(pageCopy)
        return

    pageCopy[6] = pageCopy[6] | 1  # force BCWEN to 1 to allow BOCOR rewrites
    ERASEKEYOFFSET = 0
    if ERASETYPE == CHIPERASE0:
        ERASEKEYOFFSET = 0x10
    elif ERASETYPE == CHIPERASE1:
        ERASEKEYOFFSET = 0x20
    elif ERASETYPE == CHIPERASE2:
        ERASEKEYOFFSET = 0x30
    if ERASEKEYOFFSET != 0:
        for i in range(16):
            if pageCopy[ERASEKEYOFFSET + i] != 255 & (ERASEKEY[i/4] >> (8*(i & 3))):
                log.error("Chip erase key does not match project settings. Forcing CE key for erase type " + str(ERASETYPE) + " to the one specified in project settings" + str(ERASEKEY))
            pageCopy[ERASEKEYOFFSET + i] = 255 & (ERASEKEY[i/4] >> (8*(i & 3)))
            log.info("ce - key %d %02x" % (i, pageCopy[ERASEKEYOFFSET + i]))
    # return
    # Writing the BOCOR row

    # Handle changes in the BOCOR row, computing CRC and hash and boothash if needed
    # BOCOR first doubleword CRC area
    # BOOTOPT is at offset 3 (FUSES_BOOTROM_BOOTOPT = 24 / 8)
    sec_boot = (pageCopy[3] & 0x0F) & 0x03
    BS_GRANULARITY = 0x100    # Boot Flash Secure region granularity

    boot_prot = get_fuse(pageCopy, 32, 39)*BP_GRANULARITY
    bs = get_fuse(pageCopy, 8, 15)*BS_GRANULARITY
    bnsc = get_fuse(pageCopy, 16, 21)*BNSC_GRANULARITY

    log.info("Boot configuration: bootprot=0x%x, bs=0x%x, bnsc=0x%x , bootopt=%x\n" % (boot_prot, bs, bnsc, sec_boot))


    if settings.getBool("x.tz_computecrc",True):
        crc = utils.crc32(pageCopy, 0, 8)
        crc = crc ^ 0xFFFFFFFF

        pageCopy[8 + 0] = (crc >> 0) & 255
        pageCopy[8 + 1] = (crc >> 8) & 255
        pageCopy[8 + 2] = (crc >> 16) & 255
        pageCopy[8 + 3] = (crc >> 24) & 255
        log.info("Computed and inserted BOCOR.CRC = 0x%08x" % crc)
        # Perform SHA on DW0, [DW8 .. DW19] and place the computed hash at BOCORHASH addr
        
        utils.sha256_reset()
        # Check whether bootkey is part of hash
        if sec_boot > 1:
            # If SHA-256 with BOOTKEY is specified, the SHA hash calculation begins with a
            # virtual 512-bit chunk, consisting of BOOTKEY from BOCOR replicated twice
            
            utils.sha256_update(pageCopy, FUSES_BOOTROM_BOOTKEY,FUSES_BOOTROM_BOOTKEYSIZE)
            utils.sha256_update(pageCopy, FUSES_BOOTROM_BOOTKEY,FUSES_BOOTROM_BOOTKEYSIZE)

        # add the BOCOR data
        utils.sha256_update(pageCopy, 0, 0x100 - 0x20)

        # finalize sha and store it in pageCopy
        utils.sha256_compute(pageCopy, FUSES_BOOTROM_BOCORHASH)

    erase_row(address)
    write_row(address, 0, pageCopy)

    if sec_boot == 0:
        return

    if not settings.getBool("x.tz_computesign",True):
        return

    if (boot_prot >= bs and bs-bnsc >= 0x100):
        add_boot_hash_L11(bs, bnsc, pageCopy,sec_boot)
    else:
        raise Exception("BOOTPROT or BNSC regions are too small")

def write_config(address, len, data):
    if address == UROW or address == BOCOR:
        if "L10" in device or "LE" in device:
            erase_row(address)
            write_row(address, 0, data)
        else:
            write_cfg_page(address, data,  0)
            if len > 0xc000-0x4000:
                write_cfg_page(BOCOR, data, 0xc000-0x4000)

def read_config(address, length, data):
    dev.Read(address, data, 0, length)

def is_nvm_ready():
    OFFSET_INTFLAG_2802 = 0x14
    intReg = dap_Read8(nvmCtrl + OFFSET_INTFLAG_2802)
    isReady = 0 != (intReg & 1)
    if not (intReg & 0xfe):  # if no ERROR bit is set
        return isReady
    # clear error bits in INTFLAG
    dap_Write8(nvmCtrl + OFFSET_INTFLAG_2802, 2 | 4 | 8 | 16)
    err = " error"
    if intReg & 2:
        err = " PROGE" + err
    if intReg & 4:
        err = " LOCKE" + err
    if intReg & 8:
        err = " NVME" + err
    if intReg & 16:
        err = " KEYE" + err
    raise Exception("The NVM controller reports an" + err)

def _read_device_id():
    return dev.Read32(0x41002118) # DSU-DID register


import os
has_samba = os.path.isfile(os.path.join("samba.py"))
if has_samba:
    import samba
from xml.dom import minidom


class MemHandlers():
    def __init__(self, board_file):
        if has_samba:
            samba.log = log
            samba.msg = msg
            samba.dev = dev
            samba.is_target_running = is_target_running
            samba.run_target = run_target
            samba.architecture = architecture
            samba.arm = arm
        self.parse_board_file(board_file)

    def parse_board_file(self, board_file):
        self.handlers = []
        xmldoc = minidom.parse(board_file)
        rangeNodes = xmldoc.getElementsByTagName("range")
        for rangeNode in rangeNodes:
            start = int(rangeNode.getAttribute("start"), 0)
            end = int(rangeNode.getAttribute("end"), 0)
            type = rangeNode.getAttribute("type")
            config = {}
            for configNode in rangeNode.childNodes:
                if configNode.nodeType == configNode.ELEMENT_NODE:
                    try:
                        config[configNode.tagName] = int(configNode.firstChild.nodeValue, 0)
                    except:
                        config[configNode.tagName] = ide.expandProjectMacros("${ProjectName}", configNode.firstChild.nodeValue).replace("\\", os.path.sep)
            if type == "samba" and has_samba:
                self.handlers.append(samba.Samba(start, end, config))
            elif type == "user":
                self.handlers.append(UserHandler(start, end, config))

    def prog_write(self, type_of_mem, address, length, data):
        log.info("Prog: Writing %d bytes to address 0x%0x of %s memory" % (length, address, type_of_mem))
        global erase_as_needed
        remainings = [[address, address + length]]
        for handler in self.handlers:
            write_start = max(address, handler.range_start)
            write_end = min(address + length, handler.range_end)
            if write_start < write_end:
                # chop the data buffer and pass it to handler and run
                if erase_as_needed:
                    handler.erase(write_start - handler.range_start, write_end - write_start)
                handler.write(write_start - handler.range_start, data[write_start - address: write_end - address])
            new_remainings = []
            for remaining in remainings:
                write_start = max(remaining[0], handler.range_start)
                write_end = min(remaining[1], handler.range_end)
                if remaining[0] < write_start < remaining[1]:
                    new_remainings.append([remaining[0], write_start])
                if remaining[0] < write_end < remaining[1]:
                    new_remainings.append([write_end, remaining[1]])
                elif write_start < write_end < remaining[0] or remaining[1] < write_start < write_end or write_start > write_end:
                    new_remainings.append(remaining)
            remainings = new_remainings
        # now write to memory ranges that are not covered by handlers
        for remaining in remainings:
            _prog_write_internal(type_of_mem, remaining[0], remaining[1] - remaining[0], data[remaining[0] - address: remaining[1] - address])

    def prog_read(self, type_of_mem, address, length, data):
        log.info("Prog: Reading %d bytes to address 0x%0x of %s memory" % (length, address, type_of_mem))
        remainings = [[address, address + length]]
        for handler in self.handlers:
            read_start = max(address, handler.range_start)
            read_end = min(address + length, handler.range_end)
            if read_start < read_end:
                # chop the data buffer and pass it to handler and run
                buffer = bytearray(read_end - read_start)
                handler.read(read_start - handler.range_start, buffer)
                data[read_start - address: read_end - address] = buffer
            new_remainings = []
            for remaining in remainings:
                read_start = max(remaining[0], handler.range_start)
                read_end = min(remaining[1], handler.range_end)
                if remaining[0] < read_start < remaining[1]:
                    new_remainings.append([remaining[0], read_start])
                if remaining[0] < read_end < remaining[1]:
                    new_remainings.append([read_end, remaining[1]])
                elif read_start < read_end < remaining[0] or remaining[1] < read_start < read_end or read_start > read_end:
                    new_remainings.append(remaining)
            remainings = new_remainings
        # now write to memory ranges that are not covered by handlers
        for remaining in remainings:
            _prog_read_internal(type_of_mem, remaining[0], remaining[1] - remaining[0], data[remaining[0] - address: remaining[1] - address])

    def erase(self):
        log.info("Prog: Erasing memory")
        for handler in self.handlers:
            if handler.range_start < handler.range_end:
                handler.erase(0, handler.range_end - handler.range_start)


class UserHandler():
    def __init__(self, range_start, range_end, config):
        self.range_start = range_start
        self.range_end = range_end
        self.config = config

    def call(self, address=0, data=None):
        if "handler_name" in self.config.keys():
            eval(self.config["handler_name"])()
        else:
            log.info("The name of handler function is missing")


def _prog_write(type_of_mem, address, length, data):
    global mem_handlers
    if mem_handlers is None:
        _prog_write_internal(type_of_mem, address, length, data)
    else:
        mem_handlers.prog_write(type_of_mem, address, length, data)


def _prog_read(type_of_mem, address, length, data):
    global mem_handlers
    if mem_handlers is None:
        _prog_read_internal(type_of_mem, address, length, data)
    else:
        mem_handlers.prog_read(type_of_mem, address, length, data)


def _erase():
    global mem_handlers, erase_as_needed
    if mem_handlers is not None:
        mem_handlers.erase()
    _erase_internal()
    erase_as_needed = False  # tell prog_write not to erase rows prior to write


def init_mem_handlers():
    global mem_handlers
    mem_handlers = None
    try:
        board_file = ide.expandProjectMacros("${ProjectName}", settings.getString("loader.board_file", "${ProjectDir}/board.xboard"))
    except:
        board_file = "./board.xboard"
    if os.path.isfile(board_file):
        mem_handlers = MemHandlers(board_file)
